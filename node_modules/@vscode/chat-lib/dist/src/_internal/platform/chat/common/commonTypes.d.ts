import type { ChatErrorDetails, ChatResult } from 'vscode';
import { IChatEndpoint } from '../../networking/common/networking';
import { APIErrorResponse, APIUsage, FilterReason } from '../../networking/common/openai';
/**
 * The location of a chat request.
 */
export declare enum ChatLocation {
    /**
     * The chat panel
     */
    Panel = 1,
    /**
     * Terminal inline chat
     */
    Terminal = 2,
    /**
     * Notebook inline chat
     */
    Notebook = 3,
    /**
     * Code editor inline chat
     */
    Editor = 4,
    /**
     * Chat is happening in an editing session.
     * This location doesn't exist in vscode API, but is still used to compute the location sent for some intents.
     */
    EditingSession = 5,
    /**
     * The chat request does not correspond directly to a user chat request.
     */
    Other = 6,
    /**
     * The chat is an agent mode edit session.
     */
    Agent = 7,
    /**
     * A request coming through the OpenAILanguageModelServer
     */
    ResponsesProxy = 8
}
export declare namespace ChatLocation {
    /**
     * Use this for passing uiKind to github telemetry, which we don't want to impact.
     * Also known as UIKind in the telemetry data.
     */
    function toString(chatLocation: ChatLocation): string;
    /**
     * This goes to logs and msft telemetry and is ok to change
     */
    function toStringShorter(chatLocation: ChatLocation): string;
}
export declare enum ChatFetchResponseType {
    OffTopic = "offTopic",
    Canceled = "canceled",
    Filtered = "filtered",
    FilteredRetry = "filteredRetry",
    PromptFiltered = "promptFiltered",
    Length = "length",
    RateLimited = "rateLimited",
    QuotaExceeded = "quotaExceeded",
    ExtensionBlocked = "extensionBlocked",
    BadRequest = "badRequest",
    NotFound = "notFound",
    Failed = "failed",
    Unknown = "unknown",
    NetworkError = "networkError",
    AgentUnauthorized = "agent_unauthorized",
    AgentFailedDependency = "agent_failed_dependency",
    InvalidStatefulMarker = "invalid_stateful_marker",
    Success = "success"
}
export type ChatFetchError = 
/**
 * We requested conversation, but the message was deemed off topic by the intent classifier.
 */
{
    type: ChatFetchResponseType.OffTopic;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
}
/**
 * Communication with a third party agent failed.
 * The error message provides further details, usually indicating either an invocation timeout or an improper response.
 */
 | {
    type: ChatFetchResponseType.AgentFailedDependency;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
}
/**
 * User authorization is required to proceed.
 */
 | {
    type: ChatFetchResponseType.AgentUnauthorized;
    reason: string;
    reasonDetail?: string;
    authorizationUrl: string;
    requestId: string;
    serverRequestId: string | undefined;
}
/**
 * We requested conversation, but we decided to cancel mid-way, for example because the
 * user requested cancelation.
 */
 | {
    type: ChatFetchResponseType.Canceled;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
}
/**
 * We requested conversation, but the response was filtered by RAI.
 */
 | {
    type: ChatFetchResponseType.Filtered;
    reason: string;
    reasonDetail?: string;
    category: FilterReason;
    requestId: string;
    serverRequestId: string | undefined;
}
/**
 * We requested conversation, but the prompt was filtered by RAI.
 */
 | {
    type: ChatFetchResponseType.PromptFiltered;
    reason: string;
    reasonDetail?: string;
    category: FilterReason;
    requestId: string;
    serverRequestId: string | undefined;
}
/**
 * We requested conversation, but the response was too long.
 */
 | {
    type: ChatFetchResponseType.Length;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
    truncatedValue: string;
}
/**
 * We requested conversation, but didn't come up with any results because the rate limit was exceeded.
 */
 | {
    type: ChatFetchResponseType.RateLimited;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
    retryAfter: number | undefined;
    rateLimitKey: string;
    capiError?: {
        code?: string;
        message?: string;
    };
}
/**
 * We requested conversation, but didn't come up with any results because the free tier quota was exceeded.
 */
 | {
    type: ChatFetchResponseType.QuotaExceeded;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
    retryAfter: Date;
    capiError?: {
        code?: string;
        message?: string;
    };
}
/**
 * We requested conversation, but the extension is blocked
 */
 | {
    type: ChatFetchResponseType.ExtensionBlocked;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
    retryAfter: number;
    learnMoreLink: string;
}
/**
 * We requested conversation, but didn't come up with any results because of a bad request
 */
 | {
    type: ChatFetchResponseType.BadRequest;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
} | {
    type: ChatFetchResponseType.NotFound;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
}
/**
 * We requested conversation, but didn't come up with any results because something
 * unexpected went wrong.
 */
 | {
    type: ChatFetchResponseType.Failed;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
    streamError?: APIErrorResponse;
}
/**
 * We requested conversation, but didn't come up with any results because of a network error
 */
 | {
    type: ChatFetchResponseType.NetworkError;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
    streamError?: APIErrorResponse;
}
/**
 * We requested conversation, but didn't come up with any results for some "unknown"
 * reason, such as slur redaction or snippy.
 */
 | {
    type: ChatFetchResponseType.Unknown;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
}
/**
 * The `statefulMarker` present in the request was invalid or expired. The
 * request may be retried without that marker to resubmit it anew.
 */
 | {
    type: ChatFetchResponseType.InvalidStatefulMarker;
    reason: string;
    reasonDetail?: string;
    requestId: string;
    serverRequestId: string | undefined;
};
export type ChatFetchRetriableError<T> = 
/**
 * We requested conversation, the response was filtered by RAI, but we want to retry.
 */
{
    type: ChatFetchResponseType.FilteredRetry;
    reason: string;
    category: FilterReason;
    value: T;
    requestId: string;
    serverRequestId: string | undefined;
};
export type FetchSuccess<T> = {
    type: ChatFetchResponseType.Success;
    value: T;
    requestId: string;
    serverRequestId: string | undefined;
    usage: APIUsage | undefined;
    resolvedModel: string;
};
export type FetchResponse<T> = FetchSuccess<T> | ChatFetchError;
export type ChatResponse = FetchResponse<string>;
export type ChatResponses = FetchResponse<string[]>;
export declare function getErrorDetailsFromChatFetchError(fetchResult: ChatFetchError, fallbackModel: IChatEndpoint, copilotPlan: string, hideRateLimitTimeEstimate?: boolean): ChatErrorDetails;
export declare function getFilteredMessage(category: FilterReason, supportsMarkdown?: boolean): string;
/**
 * Not localized because it's used in the same way that the CancellationError name is used.
 */
export declare const CanceledMessage: {
    message: string;
};
export declare const CanceledResult: ChatResult;
//# sourceMappingURL=commonTypes.d.ts.map