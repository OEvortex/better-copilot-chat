import type { CancellationToken } from 'vscode';
import { AsyncIterableObject } from '../../../util/vs/base/common/async';
import { Event } from '../../../util/vs/base/common/event';
import { FinishedCallback, IResponseDelta, OptionalChatRequestParams } from '../../networking/common/fetch';
import { IChatEndpoint, IMakeChatRequestOptions } from '../../networking/common/networking';
import { ChatResponse, ChatResponses } from './commonTypes';
export interface Source {
    readonly extensionId?: string;
}
export interface IResponsePart {
    readonly delta: IResponseDelta;
}
export interface IFetchMLOptions extends IMakeChatRequestOptions {
    endpoint: IChatEndpoint;
    requestOptions: OptionalChatRequestParams;
}
export declare const IChatMLFetcher: import("../../../util/common/services").ServiceIdentifier<IChatMLFetcher>;
export interface IChatMLFetcher {
    readonly _serviceBrand: undefined;
    readonly onDidMakeChatMLRequest: Event<{
        readonly model: string;
        readonly source?: Source;
        readonly tokenCount?: number;
    }>;
    fetchOne(options: IFetchMLOptions, token: CancellationToken): Promise<ChatResponse>;
    /**
     * Note: the returned array of strings may be less than `n` (e.g., in case there were errors during streaming)
     */
    fetchMany(options: IFetchMLOptions, token: CancellationToken): Promise<ChatResponses>;
}
export declare class FetchStreamSource {
    private _stream;
    private _paused?;
    private _seenAnnotationTypes;
    get stream(): AsyncIterableObject<IResponsePart>;
    constructor();
    pause(): void;
    unpause(): void;
    update(text: string, delta: IResponseDelta): void;
    resolve(): void;
}
export declare class FetchStreamRecorder {
    readonly callback: FinishedCallback;
    readonly deltas: IResponseDelta[];
    private _firstTokenEmittedTime;
    get firstTokenEmittedTime(): number | undefined;
    constructor(callback: FinishedCallback | undefined);
}
//# sourceMappingURL=chatMLFetcher.d.ts.map