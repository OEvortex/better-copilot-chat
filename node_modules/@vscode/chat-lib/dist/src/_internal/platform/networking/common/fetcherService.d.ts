export declare const IFetcherService: import("../../../util/common/services").ServiceIdentifier<IFetcherService>;
export interface IFetcherService {
    readonly _serviceBrand: undefined;
    getUserAgentLibrary(): string;
    fetch(url: string, options: FetchOptions): Promise<Response>;
    disconnectAll(): Promise<unknown>;
    makeAbortController(): IAbortController;
    isAbortError(e: any): boolean;
    isInternetDisconnectedError(e: any): boolean;
    isFetcherError(e: any): boolean;
    getUserMessageForFetcherError(err: any): string;
    fetchWithPagination<T>(baseUrl: string, options: PaginationOptions<T>): Promise<T[]>;
}
/** A basic version of http://developer.mozilla.org/en-US/docs/Web/API/Response */
export declare class Response {
    readonly status: number;
    readonly statusText: string;
    readonly headers: IHeaders;
    private readonly getText;
    private readonly getJson;
    private readonly getBody;
    readonly fetcher: FetcherId;
    ok: boolean;
    constructor(status: number, statusText: string, headers: IHeaders, getText: () => Promise<string>, getJson: () => Promise<any>, getBody: () => Promise<unknown | null>, fetcher: FetcherId);
    text(): Promise<string>;
    json(): Promise<any>;
    /** Async version of the standard .body field. */
    body(): Promise<unknown | null>;
}
export type FetcherId = 'electron-fetch' | 'node-fetch' | 'node-http' | 'test-stub' | 'helix-fetch';
/** These are the options we currently use, for ease of reference. */
export interface FetchOptions {
    headers?: {
        [name: string]: string;
    };
    body?: string;
    timeout?: number;
    json?: any;
    method?: 'GET' | 'POST';
    signal?: IAbortSignal;
    retryFallbacks?: boolean;
    expectJSON?: boolean;
    useFetcher?: FetcherId;
    suppressIntegrationId?: boolean;
}
export interface PaginationOptions<T> extends FetchOptions {
    pageSize?: number;
    startPage?: number;
    getItemsFromResponse: (data: any) => T[];
    buildUrl: (baseUrl: string, pageSize: number, page: number) => string;
}
export interface IAbortSignal {
    readonly aborted: boolean;
    addEventListener(type: 'abort', listener: (this: AbortSignal) => void): void;
    removeEventListener(type: 'abort', listener: (this: AbortSignal) => void): void;
}
export interface IAbortController {
    readonly signal: IAbortSignal;
    abort(): void;
}
export interface IHeaders extends Iterable<[string, string]> {
    get(name: string): string | null;
}
export declare function jsonVerboseError(resp: Response): Promise<any>;
//# sourceMappingURL=fetcherService.d.ts.map