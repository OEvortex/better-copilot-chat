import type { CancellationToken } from 'vscode';
import { ILogService } from '../../log/common/logService';
import { ITelemetryService } from '../../telemetry/common/telemetry';
import { RawThinkingDelta } from '../../thinking/common/thinking';
import { FinishedCallback, ICodeVulnerabilityAnnotation, IIPCodeCitation, RequestId } from '../common/fetch';
import { Response } from '../common/fetcherService';
import { APIErrorResponse, APIJsonData, APIUsage, ChoiceLogProbs, FilterReason, FinishedCompletionReason, IToolCall } from '../common/openai';
/** Gathers together many chunks of a single completion choice. */
declare class APIJsonDataStreaming {
    readonly model: string;
    constructor(model: string);
    get text(): readonly string[];
    private _text;
    private _newText;
    append(choice: ExtendedChoiceJSON): void;
    flush(): string;
    private static _removeCR;
    toJSON(): {
        text: string[];
        newText: string[];
    };
}
export declare function splitChunk(chunk: string): [string[], string];
/**
 * A single finished completion returned from the model or proxy, along with
 * some metadata.
 */
export interface FinishedCompletion {
    solution: APIJsonDataStreaming;
    /** An optional offset into `solution.text.join('')` where the completion finishes. */
    finishOffset: number | undefined;
    /** A copilot-specific human-readable reason for the completion finishing. */
    reason: FinishedCompletionReason;
    /** A copilot-specific reason for filtering the response. Only returns when reason === FinishedCompletionReason.ContentFilter */
    filterReason?: FilterReason;
    error?: APIErrorResponse;
    /** The token usage reported from CAPI */
    usage?: APIUsage;
    requestId: RequestId;
    index: number;
}
/** What comes back from the OpenAI API for a single choice in an SSE chunk. */
interface ChoiceJSON {
    index: number;
    /**
     * The text attribute as defined in completions streaming.
     * See https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#event_stream_format
     */
    text?: string;
    /**
     * The delta attribute as defined in chat streaming.
     * See https://github.com/openai/openai-cookbook/blob/main/examples/How_to_stream_completions.ipynb
     */
    delta?: {
        content: string | null;
    };
    finish_reason?: FinishedCompletionReason.Stop | FinishedCompletionReason.Length | FinishedCompletionReason.FunctionCall | FinishedCompletionReason.ContentFilter | FinishedCompletionReason.ServerError | FinishedCompletionReason.ToolCalls | null;
    logprobs?: ChoiceLogProbs;
}
/**
 * Extensions to the OpenAI stream format
 */
interface ExtendedChoiceJSON extends ChoiceJSON {
    content_filter_results?: Record<Exclude<FilterReason, FilterReason.Copyright>, {
        filtered: boolean;
        severity: string;
    }>;
    message?: RawThinkingDelta;
    delta?: {
        content: string | null;
        copilot_annotations?: {
            CodeVulnerability: ICodeVulnerabilityAnnotation[];
            IPCodeCitations: IIPCodeCitation[];
            TextCopyright: boolean | undefined;
            Sexual: boolean | undefined;
            SexualPattern: boolean | undefined;
            Violence: boolean | undefined;
            HateSpeech: boolean | undefined;
            HateSpeechPattern: boolean | undefined;
            SelfHarm: boolean | undefined;
            PromptPromBlockList: boolean | undefined;
        };
        function_call?: {
            name: string;
            arguments: string;
        };
        tool_calls?: IToolCall[];
        role?: string;
        name?: string;
    } & RawThinkingDelta;
}
/**
 * Processes an HTTP request containing what is assumed to be an SSE stream of
 * OpenAI API data. Yields a stream of `FinishedCompletion` objects, each as
 * soon as it's finished.
 */
export declare class SSEProcessor {
    private readonly logService;
    private readonly telemetryService;
    private readonly expectedNumChoices;
    private readonly response;
    private readonly body;
    private readonly cancellationToken?;
    private requestId;
    /**
     * A key & value being here means at least one chunk with that choice index
     * has been received. A null value means we've already finished the given
     * solution and should not process incoming tokens further.
     */
    private readonly solutions;
    private readonly completedFunctionCallIdxs;
    private readonly functionCalls;
    private readonly toolCalls;
    private functionCallName;
    private constructor();
    static create(logService: ILogService, telemetryService: ITelemetryService, expectedNumChoices: number, response: Response, cancellationToken?: CancellationToken): Promise<SSEProcessor>;
    /**
     * Yields finished completions as soon as they are available. The finishedCb
     * is used to determine when a completion is done and should be truncated.
     * It is called on the whole of the received solution text, once at the end
     * of the completion (if it stops by itself) and also on any chunk that has
     * a newline in it.
     *
     * Closes the server request stream when all choices are finished/truncated
     * (as long as fastCancellation is true).
     *
     * Note that for this to work, the caller must consume the entire stream.
     * This happens automatically when using a `for await` loop, but when
     * iterating manually this needs to be done by calling `.next()` until it
     * returns an item with done = true (or calling `.return()`).
     */
    processSSE(finishedCb?: FinishedCallback): AsyncIterable<FinishedCompletion>;
    private processSSEInner;
    /** Yields the solutions that weren't yet finished, with a 'DONE' reason. */
    private finishSolutions;
    /**
     * Returns whether the cancellation token was cancelled and closes the
     * stream if it was.
     */
    private maybeCancel;
    private cancel;
    private logChoice;
}
export declare function convertToAPIJsonData(streamingData: APIJsonDataStreaming): APIJsonData;
export declare function sendCommunicationErrorTelemetry(telemetryService: ITelemetryService, message: string, extra?: any): void;
export {};
//# sourceMappingURL=stream.d.ts.map