import { BaseEdit } from '../../../../util/vs/editor/common/core/edits/edit';
import { LineEdit } from '../../../../util/vs/editor/common/core/edits/lineEdit';
import { BaseStringEdit, BaseStringReplacement, StringEdit } from '../../../../util/vs/editor/common/core/edits/stringEdit';
import { StringText } from '../../../../util/vs/editor/common/core/text/abstractText';
import { SerializedEdit } from './editUtils';
export declare class RootedEdit<TEdit extends BaseStringEdit<BaseStringReplacement<any>, any> = StringEdit> {
    readonly base: StringText;
    readonly edit: TEdit;
    static toLineEdit(edit: RootedEdit<BaseStringEdit<BaseStringReplacement<any>, any>>): LineEdit;
    constructor(base: StringText, edit: TEdit);
    getEditedState(): StringText;
    /**
     * Creates a rooted edit `r`, such that
     * * `r.initialState.equals(this.initialState.apply(onto))`
     * * `(r.initialState.apply(r.edit)).equals(this.initialState.apply(onto).apply(this.edit))`
    */
    rebase(onto: StringEdit): RootedEdit;
    toString(): string;
    /**
     * If `r.base.equals(this.base)` and `r.getEditedState().equals(this.getEditedState())`, then `r.normalize().equals(this.normalize())`.
    */
    normalize(): RootedEdit;
    equals(other: RootedEdit): boolean;
}
export type TReplacement<TEdit> = TEdit extends BaseEdit<infer TReplacement, any> ? TReplacement : never;
/**
 * Represents a sequence of single edits.
*/
export declare class SingleEdits<TEdit extends BaseStringEdit<BaseStringReplacement<any>, any> = StringEdit> {
    /**
     * The edits are applied in order and don't have to be sorted.
    */
    readonly edits: readonly TEdit['TReplacement'][];
    constructor(
    /**
     * The edits are applied in order and don't have to be sorted.
    */
    edits: readonly TEdit['TReplacement'][]);
    compose(): StringEdit;
    apply(value: string): string;
    isEmpty(): boolean;
    toEdits(): Edits<StringEdit>;
}
/**
 * Represents a sequence of edits.
*/
export declare class Edits<T extends BaseStringEdit<BaseStringReplacement<any>, any> = StringEdit> {
    private readonly _editType;
    /**
     * The edits are applied in given order and don't have to be sorted.
     * Least to most recent.
     */
    readonly edits: readonly T[];
    static single(edit: StringEdit): Edits;
    constructor(_editType: new (replacements: readonly TReplacement<T>[]) => T, 
    /**
     * The edits are applied in given order and don't have to be sorted.
     * Least to most recent.
     */
    edits: readonly T[]);
    compose(): T;
    add(edit: T): Edits<T>;
    apply(value: string): string;
    isEmpty(): boolean;
    swap(editFirst: StringEdit): {
        edits: Edits;
        editLast: StringEdit;
    } | undefined;
    serialize(): SerializedEdit[];
    static deserialize(v: SerializedEdit[]): Edits;
    toHumanReadablePatch(base: StringText): string;
}
//# sourceMappingURL=edit.d.ts.map