export declare class EditReason {
    readonly metadata: ITextModelEditReasonMetadata;
    static create(metadata: ITextModelEditReasonMetadata | undefined): EditReason;
    private constructor();
    static readonly unknown: EditReason;
    toKey(level: number): string;
}
declare const privateSymbol: unique symbol;
export declare class TextModelEditReason {
    readonly metadata: ITextModelEditReasonMetadata;
    constructor(metadata: ITextModelEditReasonMetadata, _privateCtorGuard: typeof privateSymbol);
    toString(): string;
    getType(): string;
    /**
     * Converts the metadata to a key string.
     * Only includes properties/values that have `level` many `$` prefixes or less.
    */
    toKey(level: number): string;
}
type TextModelEditReasonT<T> = TextModelEditReason & {
    metadataT: T;
};
export declare const EditReasons: {
    unknown(data: {
        name?: string | null;
    }): TextModelEditReasonT<{
        readonly source: "unknown";
        readonly name: string | null | undefined;
    }>;
    chatApplyEdits(data: {
        modelId: string | undefined;
    }): TextModelEditReasonT<{
        readonly source: "Chat.applyEdits";
        readonly $modelId: string | undefined;
    }>;
    inlineCompletionAccept(data: {
        nes: boolean;
        requestUuid: string;
        extensionId: string;
    }): TextModelEditReasonT<{
        readonly source: "inlineCompletionAccept";
        readonly $nes: boolean;
        readonly $extensionId: string;
        readonly $$requestUuid: string;
    }>;
    inlineCompletionPartialAccept(data: {
        nes: boolean;
        requestUuid: string;
        extensionId: string;
        type: "word" | "line";
    }): TextModelEditReasonT<{
        readonly source: "inlineCompletionPartialAccept";
        readonly type: "line" | "word";
        readonly $extensionId: string;
        readonly $$requestUuid: string;
    }>;
    inlineChatApplyEdit(data: {
        modelId: string | undefined;
    }): TextModelEditReasonT<{
        readonly source: "inlineChat.applyEdits";
        readonly $modelId: string | undefined;
    }>;
    reloadFromDisk: () => TextModelEditReasonT<{
        readonly source: "reloadFromDisk";
    }>;
    cursor(data: {
        kind: "compositionType" | "compositionEnd" | "type" | "paste" | "cut" | "executeCommands" | "executeCommand";
        detailedSource?: string | null;
    }): TextModelEditReasonT<{
        readonly source: "cursor";
        readonly kind: "type" | "compositionType" | "compositionEnd" | "paste" | "cut" | "executeCommands" | "executeCommand";
        readonly detailedSource: string | null | undefined;
    }>;
    setValue: () => TextModelEditReasonT<{
        readonly source: "setValue";
    }>;
    eolChange: () => TextModelEditReasonT<{
        readonly source: "eolChange";
    }>;
    applyEdits: () => TextModelEditReasonT<{
        readonly source: "applyEdits";
    }>;
    snippet: () => TextModelEditReasonT<{
        readonly source: "snippet";
    }>;
    suggest: (data: {
        extensionId: string | undefined;
    }) => TextModelEditReasonT<{
        readonly source: "suggest";
        readonly $extensionId: string | undefined;
    }>;
};
type Values<T> = T[keyof T];
type ITextModelEditReasonMetadata = Values<{
    [TKey in keyof typeof EditReasons]: ReturnType<typeof EditReasons[TKey]>['metadataT'];
}>;
export {};
//# sourceMappingURL=editReason.d.ts.map