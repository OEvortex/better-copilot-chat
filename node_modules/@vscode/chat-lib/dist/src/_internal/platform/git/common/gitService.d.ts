import { IDisposable } from 'monaco-editor';
import { Event } from '../../../util/vs/base/common/event';
import { IObservable } from '../../../util/vs/base/common/observableInternal';
import { URI } from '../../../util/vs/base/common/uri';
import { Change, Commit, CommitShortStat, LogOptions } from '../vscode/git';
export interface RepoContext {
    readonly rootUri: URI;
    readonly headBranchName: string | undefined;
    readonly headCommitHash: string | undefined;
    readonly upstreamBranchName: string | undefined;
    readonly upstreamRemote: string | undefined;
    readonly isRebasing: boolean;
    readonly remoteFetchUrls?: Array<string | undefined>;
    readonly remotes: string[];
    readonly changes: {
        mergeChanges: Change[];
        indexChanges: Change[];
        workingTree: Change[];
        untrackedChanges: Change[];
    } | undefined;
    readonly headBranchNameObs: IObservable<string | undefined>;
    readonly headCommitHashObs: IObservable<string | undefined>;
    readonly upstreamBranchNameObs: IObservable<string | undefined>;
    readonly upstreamRemoteObs: IObservable<string | undefined>;
    readonly isRebasingObs: IObservable<boolean>;
    isIgnored(uri: URI): Promise<boolean>;
}
export declare const IGitService: import("../../../util/common/services").ServiceIdentifier<IGitService>;
export interface IGitService extends IDisposable {
    readonly _serviceBrand: undefined;
    readonly onDidOpenRepository: Event<RepoContext>;
    readonly onDidCloseRepository: Event<RepoContext>;
    readonly onDidFinishInitialization: Event<void>;
    readonly activeRepository: IObservable<RepoContext | undefined>;
    readonly repositories: Array<RepoContext>;
    readonly isInitialized: boolean;
    getRepository(uri: URI, forceOpen?: boolean): Promise<RepoContext | undefined>;
    getRepositoryFetchUrls(uri: URI): Promise<Pick<RepoContext, 'rootUri' | 'remoteFetchUrls'> | undefined>;
    initialize(): Promise<void>;
    add(uri: URI, paths: string[]): Promise<void>;
    log(uri: URI, options?: LogOptions): Promise<Commit[] | undefined>;
    diffBetween(uri: URI, ref1: string, ref2: string): Promise<Change[] | undefined>;
    diffWith(uri: URI, ref: string): Promise<Change[] | undefined>;
    diffIndexWithHEADShortStats(uri: URI): Promise<CommitShortStat | undefined>;
    fetch(uri: URI, remote?: string, ref?: string, depth?: number): Promise<void>;
    getMergeBase(uri: URI, ref1: string, ref2: string): Promise<string | undefined>;
    createWorktree(uri: URI, options?: {
        path?: string;
        commitish?: string;
        branch?: string;
    }): Promise<string | undefined>;
    deleteWorktree(uri: URI, path: string, options?: {
        force?: boolean;
    }): Promise<void>;
    migrateChanges(uri: URI, sourceRepositoryUri: URI, options?: {
        confirmation?: boolean;
        deleteFromSource?: boolean;
        untracked?: boolean;
    }): Promise<void>;
}
/**
 * Gets the best repo github repo id from the repo context.
 */
export declare function getGitHubRepoInfoFromContext(repoContext: RepoContext): {
    id: GithubRepoId;
    remoteUrl: string;
} | undefined;
export interface ResolvedRepoRemoteInfo {
    readonly fetchUrl: string | undefined;
    readonly repoId: ResolvedRepoId;
}
export type ResolvedRepoId = GithubRepoId | AdoRepoId;
/**
 * Gets the repo info for any type of repo from the repo context.
 */
export declare function getOrderedRepoInfosFromContext(repoContext: RepoContext): Iterable<ResolvedRepoRemoteInfo>;
/**
 * Returns the remote URLs from repo context, starting with the best first.
 */
export declare function getOrderedRemoteUrlsFromContext(repoContext: RepoContext): Iterable<string>;
export declare function parseRemoteUrl(fetchUrl: string): {
    host: string;
    path: string;
} | undefined;
export declare class GithubRepoId {
    readonly org: string;
    readonly repo: string;
    readonly type = "github";
    static parse(nwo: string): GithubRepoId | undefined;
    constructor(org: string, repo: string);
    toString(): string;
}
export declare function toGithubNwo(id: GithubRepoId): string;
/**
 * Extracts the GitHub repository name from a git fetch URL.
 * @param fetchUrl The git fetch URL to extract the repository name from.
 * @returns The repository name if the fetch URL is a valid GitHub URL, otherwise undefined.
 */
export declare function getGithubRepoIdFromFetchUrl(fetchUrl: string): GithubRepoId | undefined;
export declare class AdoRepoId {
    readonly org: string;
    readonly project: string;
    readonly repo: string;
    readonly type = "ado";
    constructor(org: string, project: string, repo: string);
    toString(): string;
}
/**
 * Extracts the ADO repository name from a git fetch URL.
 * @param fetchUrl The Git fetch URL to extract the repository name from.
 * @returns The repository name if the fetch URL is a valid ADO URL, otherwise undefined.
 */
export declare function getAdoRepoIdFromFetchUrl(fetchUrl: string): AdoRepoId | undefined;
/**
 * Normalizes a remote repo fetch url into a standardized format
 * @param fetchUrl A remote repo fetch url in the form of http, https, or ssh.
 * @returns The normalized fetch url. Sanitized of any credentials, stripped of query params, and using https
 */
export declare function normalizeFetchUrl(fetchUrl: string): string;
//# sourceMappingURL=gitService.d.ts.map