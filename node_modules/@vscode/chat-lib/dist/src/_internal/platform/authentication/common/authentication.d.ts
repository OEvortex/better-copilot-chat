import type { AuthenticationGetSessionOptions, AuthenticationSession } from 'vscode';
import { Emitter, Event } from '../../../util/vs/base/common/event';
import { Disposable } from '../../../util/vs/base/common/lifecycle';
import { AuthProviderId, IConfigurationService } from '../../configuration/common/configurationService';
import { ILogService } from '../../log/common/logService';
import { CopilotToken } from './copilotToken';
import { ICopilotTokenManager } from './copilotTokenManager';
import { ICopilotTokenStore } from './copilotTokenStore';
export declare const GITHUB_SCOPE_USER_EMAIL: string[];
export declare const GITHUB_SCOPE_READ_USER: string[];
export declare const GITHUB_SCOPE_ALIGNED: string[];
export declare class MinimalModeError extends Error {
    constructor();
}
export declare const IAuthenticationService: import("../../../util/common/services").ServiceIdentifier<IAuthenticationService>;
export interface IAuthenticationService {
    readonly _serviceBrand: undefined;
    /**
     * Whether the authentication service is in minimal mode. If true, the authentication service will not attempt to
     * fetch the permissive token. This means that:
     * * {@link getPermissiveGitHubSession} interactive flows will always throw an error
     * * {@link getPermissiveGitHubSession} silent flows and {@link permissiveGitHubSession} will always return undefined
     */
    readonly isMinimalMode: boolean;
    /**
     * Event emitter that will fire an event every time the authentication status changes. This is used for example to detect when the user
     * logs out of GitHub or when they log in with a more permissive token.
     *
     * @note For best practice of handling of the user's authentication state, you should react to this event.
     */
    readonly onDidAuthenticationChange: Event<void>;
    /**
     * @deprecated Use {@link onDidAuthenticationChange} instead. This event fires when the access token changes and not the copilot token.
     */
    readonly onDidAccessTokenChange: Event<void>;
    /**
     * Checks if there is currently any session available in the cache. Does not make any network requests and does not
     * call out to the underlying authentication provider.
     *
     * @note See {@link getAnyGitHubToken} for more information and for an async version by calling {@link getAnyGitHubSession} with `{ silent: true }`.
     * @note For best practice of handling of the user's authentication state, you should react to {@link onDidAuthenticationChange}.
     * @note This token will have at least the `user:email` scope to be able to access the minimum Copilot API.
     */
    readonly anyGitHubSession: AuthenticationSession | undefined;
    /**
     * Returns a currently valid GitHub session, also known as session or auth session. Skips the cache and calls
     * the underlying authentication provider using the options passed in.
     *
     * @note You should typically use the synchronous version {@link anyGitHubToken} if you are fetching a session silently.
     * @note For best practice of handling of the user's authentication state, you should react to {@link onDidAuthenticationChange}.
     * @note This token will have at least the `user:email` scope to be able to access the minimum Copilot API.
     * @returns an auth session or undefined if none is found.
     */
    getAnyGitHubSession(options?: AuthenticationGetSessionOptions): Promise<AuthenticationSession | undefined>;
    /**
     * Checks if there is currently a permissive session available in the cache. Does not make any network requests and does not
     * call out to the underlying authentication provider.
     *
     * @note See {@link getPermissiveGitHubToken} for more information and for an async version by calling {@link getPermissiveGitHubSession} with `{ silent: true }`.
     * @note For best practice of handling of the user's authentication state, you should react to {@link onDidAuthenticationChange}.
     * @returns undefined if no auth session is available or Minimal Mode is enabled. Otherwise, returns an auth session with the `repo` scope.
     */
    readonly permissiveGitHubSession: AuthenticationSession | undefined;
    /**
     * Returns a currently valid permissive GitHub session, also known as session or auth session. Skips the cache and calls
     * the underlying authentication provider using the options passed in.
     *
     * @note We have the {@link IAuthenticationChatUpgradeService} to upgrade the session to a permissive one. Use this for confirmation in Chat/Edits instead of showing the modal.
     * @note You should typically use the synchronous version {@link getPermissiveGitHubToken} if you are fetching a session silently.
     * @note For best practice of handling of the user's authentication state, you should react to {@link onDidAuthenticationChange}.
     * @note This token will have at least the `repo` scope to be able to access the extended features of the Copilot API.
     * @returns an auth session or undefined if none is found.
     * @throws MinimalModeError {@link MinimalModeError} if the authentication service is in minimal mode.
     */
    getPermissiveGitHubSession(options: AuthenticationGetSessionOptions): Promise<AuthenticationSession | undefined>;
    /**
     * Checks if there is currently a Copilot token available in the cache. Does not make any network requests.
     * See {@link getCopilotToken} for more information and for an async version.
     *
     * @note we omit token here because it is possibly expired. If you need it, use {@link getCopilotToken} instead as it includes a refresh mechanism.
     * @note For best practice of handling of the user's authentication state, you should react to {@link onDidAuthenticationChange}.
     */
    readonly copilotToken: Omit<CopilotToken, 'token'> | undefined;
    /**
     * Return the token needed to authenticate with the speculative decoding endpoint.
     * This token is public as it is set via a request to the ChatMLFetcher and reset either via expiration or a 403 response from the SD endpoint.
     * @note There is no guarantee this is a valid token and it can still reject due to 403 with the SD endpoint
     */
    speculativeDecodingEndpointToken: string | undefined;
    /**
     * Return a currently valid Copilot token, retrieving a fresh one if
     * necessary.
     *
     * @param force will force a refresh of the token, even if not expired
     * @returns a Copilot token or throws an error if none is found.
     * @note For best practice of handling of the user's authentication state, you should react to {@link onDidAuthenticationChange}.
     */
    getCopilotToken(force?: boolean): Promise<CopilotToken>;
    /**
     * Drop the current Copilot token as we received an HTTP error while trying
     * to use it that indicates it's no longer valid.
     */
    resetCopilotToken(httpError?: number): void;
    /**
     * Fired when the authentication state changes for ado.
     */
    readonly onDidAdoAuthenticationChange: Event<void>;
    /**
     * Returns a valid Azure DevOps session for the user
     */
    getAdoAccessTokenBase64(options?: AuthenticationGetSessionOptions): Promise<string | undefined>;
}
export declare abstract class BaseAuthenticationService extends Disposable implements IAuthenticationService {
    protected readonly _logService: ILogService;
    protected readonly _tokenStore: ICopilotTokenStore;
    private readonly _tokenManager;
    protected readonly _configurationService: IConfigurationService;
    readonly _serviceBrand: undefined;
    protected readonly _onDidAuthenticationChange: Emitter<void>;
    readonly onDidAuthenticationChange: Event<void>;
    protected readonly _onDidAccessTokenChange: Emitter<void>;
    readonly onDidAccessTokenChange: Event<void>;
    protected readonly _onDidAdoAuthenticationChange: Emitter<void>;
    readonly onDidAdoAuthenticationChange: Event<void>;
    constructor(_logService: ILogService, _tokenStore: ICopilotTokenStore, _tokenManager: ICopilotTokenManager, _configurationService: IConfigurationService);
    protected _isMinimalMode: import("../../../util/vs/base/common/observableInternal").IObservableWithChange<boolean, void>;
    get isMinimalMode(): boolean;
    protected _anyGitHubSession: AuthenticationSession | undefined;
    get anyGitHubSession(): AuthenticationSession | undefined;
    abstract getAnyGitHubSession(options?: AuthenticationGetSessionOptions): Promise<AuthenticationSession | undefined>;
    protected _permissiveGitHubSession: AuthenticationSession | undefined;
    get permissiveGitHubSession(): AuthenticationSession | undefined;
    abstract getPermissiveGitHubSession(options: AuthenticationGetSessionOptions): Promise<AuthenticationSession | undefined>;
    protected _anyAdoSession: AuthenticationSession | undefined;
    get anyAdoSession(): AuthenticationSession | undefined;
    protected abstract getAnyAdoSession(options?: AuthenticationGetSessionOptions): Promise<AuthenticationSession | undefined>;
    private _copilotTokenError;
    get copilotToken(): CopilotToken | undefined;
    getCopilotToken(force?: boolean): Promise<CopilotToken>;
    resetCopilotToken(httpError?: number): void;
    speculativeDecodingEndpointToken: string | undefined;
    abstract getAdoAccessTokenBase64(options?: AuthenticationGetSessionOptions): Promise<string | undefined>;
    protected _handleAuthChangeEvent(): Promise<void>;
}
export declare function authProviderId(configurationService: IConfigurationService): AuthProviderId;
//# sourceMappingURL=authentication.d.ts.map