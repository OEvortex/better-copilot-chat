import { CopilotUserQuotaInfo } from '../../chat/common/chatQuotaService';
/**
 * A function used to determine if the org list contains an internal organization
 * @param orgList The list of organizations the user is a member of
 * Whether or not it contains an internal org
 */
export declare function containsInternalOrg(orgList: string[]): boolean;
export declare class CopilotToken {
    private readonly _info;
    private readonly tokenMap;
    constructor(_info: ExtendedTokenInfo);
    private parseToken;
    get token(): string;
    get sku(): string | undefined;
    /**
     * Evaluates `has_cfi_access?` which is defined as `!has_cfb_access? && !has_cfe_access?`
     * (cfb = copilot for business, cfe = copilot for enterprise).
     * So it's also true for copilot free users.
     */
    get isIndividual(): boolean;
    get organizationList(): string[];
    get enterpriseList(): number[];
    get endpoints(): {
        api: string;
        telemetry: string;
        proxy: string;
        'origin-tracker'?: string;
    } | undefined;
    get isInternal(): boolean;
    get isMicrosoftInternal(): boolean;
    get isGitHubInternal(): boolean;
    get isFreeUser(): boolean;
    get isNoAuthUser(): boolean;
    get isChatQuotaExceeded(): boolean;
    get isCompletionsQuotaExceeded(): boolean;
    get codeQuoteEnabled(): boolean;
    get isVscodeTeamMember(): boolean;
    get codexAgentEnabled(): boolean;
    get copilotPlan(): 'free' | 'individual' | 'individual_pro' | 'business' | 'enterprise';
    get quotaInfo(): {
        quota_snapshots: {
            chat: {
                quota_id: string;
                entitlement: number;
                remaining: number;
                unlimited: boolean;
                overage_count: number;
                overage_permitted: boolean;
                percent_remaining: number;
            };
            completions: {
                quota_id: string;
                entitlement: number;
                remaining: number;
                unlimited: boolean;
                overage_count: number;
                overage_permitted: boolean;
                percent_remaining: number;
            };
            premium_interactions: {
                quota_id: string;
                entitlement: number;
                remaining: number;
                unlimited: boolean;
                overage_count: number;
                overage_permitted: boolean;
                percent_remaining: number;
            };
        } | undefined;
        quota_reset_date: string | undefined;
    };
    get username(): string;
    private _isTelemetryEnabled;
    isTelemetryEnabled(): boolean;
    private _isPublicSuggestionsEnabled;
    isPublicSuggestionsEnabled(): boolean;
    isChatEnabled(): boolean;
    isCopilotIgnoreEnabled(): boolean;
    get isCopilotCodeReviewEnabled(): boolean;
    isEditorPreviewFeaturesEnabled(): boolean;
    isMcpEnabled(): boolean;
    getTokenValue(key: string): string | undefined;
    isExpandedClientSideIndexingEnabled(): boolean;
    isFcv1(): boolean;
}
/**
 * Details of the user's telemetry consent status we get from the server during token retrieval.
 *
 * `unconfigured` is a transitional state for pre-GA that indicates the user is in the Technical Preview
 * and needs to be asked about telemetry consent client-side. It can be removed post-GA as the server
 * will never return it again.
 *
 * `enabled` indicates that they agreed to full telemetry.
 *
 * `disabled` indicates that they opted out of full telemetry so we can only send the core messages
 * that users cannot opt-out of.
 *
 */
export type UserTelemetryChoice = 'enabled' | 'disabled';
/**
 * A notification we get from the server during token retrieval. Needs to be presented to the user.
 */
type ServerSideNotification = {
    message: string;
    url: string;
    title: string;
};
/**
 * A notification that warns the user about upcoming problems.
 */
type WarningNotification = ServerSideNotification & {
    notification_id: string;
};
/**
 * A notification in case of an error.
 */
type ErrorNotification = ServerSideNotification;
/**
 * A server response containing a Copilot token and metadata associated with it.
 */
export interface TokenInfo {
    token: string;
    expires_at: number;
    refresh_in: number;
    user_notification?: WarningNotification;
    error_details?: ErrorNotification;
    organization_list?: string[];
    code_quote_enabled?: boolean;
    public_suggestions?: string;
    telemetry?: string;
    copilotignore_enabled?: boolean;
    endpoints?: {
        api: string;
        telemetry: string;
        proxy: string;
        'origin-tracker'?: string;
    };
    chat_enabled?: boolean;
    limited_user_quotas?: {
        chat: number;
        completions: number;
    };
    enterprise_list?: number[];
    individual?: boolean;
    sku?: string;
    message?: string;
}
/**
 * A server response containing the user info for the copilot user from the /copilot_internal/user endpoint
 */
export interface CopilotUserInfo extends CopilotUserQuotaInfo {
    access_type_sku: string;
    analytics_tracking_id: string;
    assigned_date: string;
    can_signup_for_limited: boolean;
    chat_enabled: boolean;
    copilot_plan: string;
    organization_login_list: string[];
    organization_list: Array<{
        login: string;
        name: string | null;
    }>;
    codex_agent_enabled?: boolean;
}
export type ExtendedTokenInfo = TokenInfo & {
    username: string;
    isVscodeTeamMember: boolean;
    blackbird_clientside_indexing?: boolean;
} & Pick<CopilotUserInfo, 'copilot_plan' | 'quota_snapshots' | 'quota_reset_date' | 'codex_agent_enabled'>;
export type TokenEnvelope = Omit<TokenInfo, 'token' | 'organization_list'>;
export type TokenErrorReason = 'NotAuthorized' | 'FailedToGetToken' | 'TokenInvalid' | 'GitHubLoginFailed' | 'HTTP401' | 'RateLimited';
export declare enum TokenErrorNotificationId {
    EnterPriseManagedUserAccount = "enterprise_managed_user_account",
    NotSignedUp = "not_signed_up",
    NoCopilotAccess = "no_copilot_access",
    SubscriptionEnded = "subscription_ended",
    ServerError = "server_error",
    FeatureFlagBlocked = "feature_flag_blocked",
    SpammyUser = "spammy_user",
    CodespacesDemoInactive = "codespaces_demo_inactive",//TODO: Handle this if this is still applicable
    SnippyNotConfigured = "snippy_not_configured"
}
export type TokenError = {
    reason: TokenErrorReason;
    notification_id?: TokenErrorNotificationId;
    message?: string;
};
export type TokenInfoOrError = ({
    kind: 'success';
} & ExtendedTokenInfo) | ({
    kind: 'failure';
} & TokenError);
export {};
//# sourceMappingURL=copilotToken.d.ts.map