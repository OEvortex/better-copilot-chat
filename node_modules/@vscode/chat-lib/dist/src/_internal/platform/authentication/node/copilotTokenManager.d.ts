import { Disposable } from '../../../util/vs/base/common/lifecycle';
import { SyncDescriptor } from '../../../util/vs/platform/instantiation/common/descriptors';
import { IConfigurationService } from '../../configuration/common/configurationService';
import { ICAPIClientService } from '../../endpoint/common/capiClient';
import { IDomainService } from '../../endpoint/common/domainService';
import { IEnvService } from '../../env/common/envService';
import { BaseOctoKitService } from '../../github/common/githubService';
import { ILogService } from '../../log/common/logService';
import { IFetcherService } from '../../networking/common/fetcherService';
import { ITelemetryService } from '../../telemetry/common/telemetry';
import { CopilotToken, ExtendedTokenInfo, TokenInfoOrError } from '../common/copilotToken';
import { CheckCopilotToken, ICopilotTokenManager, NotGitHubLoginFailed } from '../common/copilotTokenManager';
export declare const tokenErrorString = "Tests: either GITHUB_PAT, GITHUB_OAUTH_TOKEN, or GITHUB_OAUTH_TOKEN+VSCODE_COPILOT_CHAT_TOKEN must be set unless running from an IS_SCENARIO_AUTOMATION environment. Run \"npm run get_token\" to get credentials.";
export declare function createStaticGitHubTokenProvider(): (() => string) | undefined;
export declare function getOrCreateTestingCopilotTokenManager(deviceId: string): SyncDescriptor<ICopilotTokenManager & CheckCopilotToken>;
export declare abstract class BaseCopilotTokenManager extends Disposable implements ICopilotTokenManager {
    protected readonly _baseOctokitservice: BaseOctoKitService;
    protected readonly _logService: ILogService;
    protected readonly _telemetryService: ITelemetryService;
    protected readonly _domainService: IDomainService;
    protected readonly _capiClientService: ICAPIClientService;
    protected readonly _fetcherService: IFetcherService;
    protected readonly _envService: IEnvService;
    readonly _serviceBrand: undefined;
    protected _isDisposed: boolean;
    private readonly _copilotTokenRefreshEmitter;
    readonly onDidCopilotTokenRefresh: import("../../../util/vs/base/common/event").Event<void>;
    constructor(_baseOctokitservice: BaseOctoKitService, _logService: ILogService, _telemetryService: ITelemetryService, _domainService: IDomainService, _capiClientService: ICAPIClientService, _fetcherService: IFetcherService, _envService: IEnvService);
    private _copilotToken;
    get copilotToken(): ExtendedTokenInfo | undefined;
    set copilotToken(token: ExtendedTokenInfo | undefined);
    abstract getCopilotToken(force?: boolean): Promise<CopilotToken>;
    resetCopilotToken(httpError?: number): void;
    /**
     * Fetches a Copilot token from the GitHub token.
     * @param githubToken A GitHub token to mint a Copilot token from.
     * @returns A Copilot token info or an error.
     * @todo this should be not be public, but it is for now to allow testing.
     */
    authFromGitHubToken(githubToken: string, ghUsername: string): Promise<TokenInfoOrError & NotGitHubLoginFailed>;
    /**
     * Fetches a Copilot token from the devDeviceId.
     * @param devDeviceId A device ID to mint a Copilot token from.
     * @returns A Copilot token info or an error.
     * @todo this should be not be public, but it is for now to allow testing.
     */
    authFromDevDeviceId(devDeviceId: string): Promise<TokenInfoOrError & NotGitHubLoginFailed>;
    private doAuthFromGitHubTokenOrDevDeviceId;
    private fetchCopilotTokenFromGitHubToken;
    private fetchCopilotTokenFromDevDeviceId;
    private fetchCopilotUserInfo;
}
/**
 * A `CopilotTokenManager` that always returns the same token.
 * Mostly only useful for short periods, e.g. tests or single completion requests,
 * as these tokens typically expire after a few hours.
 * @todo Move this to a test layer
 */
export declare class FixedCopilotTokenManager extends BaseCopilotTokenManager implements CheckCopilotToken {
    private _completionsToken;
    constructor(_completionsToken: string, logService: ILogService, telemetryService: ITelemetryService, capiClientService: ICAPIClientService, domainService: IDomainService, fetcherService: IFetcherService, envService: IEnvService);
    set completionsToken(token: string);
    get completionsToken(): string;
    getCopilotToken(): Promise<CopilotToken>;
    checkCopilotToken(): Promise<{
        status: 'OK';
    }>;
}
/**
 * Use the `StaticExtendedTokenInfoCopilotTokenManager` when you have a base64, JSON-encoded `ExtendedTokenInfo`
 * in an automation scenario.
 */
export declare class StaticExtendedTokenInfoCopilotTokenManager extends BaseCopilotTokenManager implements CheckCopilotToken {
    private readonly _initialToken;
    constructor(serializedToken: string, logService: ILogService, telemetryService: ITelemetryService, capiClientService: ICAPIClientService, domainService: IDomainService, fetcherService: IFetcherService, envService: IEnvService);
    getCopilotToken(): Promise<CopilotToken>;
    checkCopilotToken(): Promise<{
        status: 'OK';
    }>;
}
/**
 * Generic token manager that handles token caching and refresh logic.
 * Takes an authentication function to fetch new tokens.
 */
export declare abstract class RefreshableCopilotTokenManager extends BaseCopilotTokenManager implements CheckCopilotToken {
    protected abstract authenticateAndGetToken(): Promise<TokenInfoOrError & NotGitHubLoginFailed>;
    getCopilotToken(force?: boolean): Promise<CopilotToken>;
    checkCopilotToken(): Promise<({
        kind: "failure";
    } & import("../common/copilotToken").TokenError & {
        kind: "failure";
        reason: Exclude<import("../common/copilotToken").TokenErrorReason, "GitHubLoginFailed">;
    }) | {
        status: "OK";
    }>;
}
export declare class CopilotTokenManagerFromDeviceId extends RefreshableCopilotTokenManager {
    private readonly deviceId;
    protected readonly configurationService: IConfigurationService;
    constructor(deviceId: string, logService: ILogService, telemetryService: ITelemetryService, domainService: IDomainService, capiClientService: ICAPIClientService, fetcherService: IFetcherService, envService: IEnvService, configurationService: IConfigurationService);
    protected authenticateAndGetToken(): Promise<TokenInfoOrError & NotGitHubLoginFailed>;
}
/**
 * Given a GitHub token, return a Copilot token, refreshing it as needed.
 * The caller that initializes the object is responsible for checking telemetry consent before
 * using the object.
 */
export declare class CopilotTokenManagerFromGitHubToken extends RefreshableCopilotTokenManager {
    private readonly githubToken;
    private readonly githubUsername;
    protected readonly configurationService: IConfigurationService;
    constructor(githubToken: string, githubUsername: string, logService: ILogService, telemetryService: ITelemetryService, domainService: IDomainService, capiClientService: ICAPIClientService, fetcherService: IFetcherService, envService: IEnvService, configurationService: IConfigurationService);
    protected authenticateAndGetToken(): Promise<TokenInfoOrError & NotGitHubLoginFailed>;
}
//# sourceMappingURL=copilotTokenManager.d.ts.map