/**
 * This implements the Map interface. Note that in all methods that iterate or return an iterator, a copy of the underlying data is
 * returned so that if you call `get`, `set`, or `delete` while iterating, the iterator will not be invalidated.
 */
export declare class LRUCacheMap<K, T> implements Map<K, T> {
    private valueMap;
    private sizeLimit;
    constructor(size?: number);
    set(key: K, value: T): this;
    /**
     * Warning this method makes the key the most recently used. To avoid this, use `peek` instead.
     * @param key
     * @returns
     */
    get(key: K): T | undefined;
    delete(key: K): boolean;
    clear(): void;
    get size(): number;
    keys(): IterableIterator<K>;
    values(): IterableIterator<T>;
    entries(): IterableIterator<[K, T]>;
    [Symbol.iterator](): IterableIterator<[K, T]>;
    has(key: K): boolean;
    forEach(callbackfn: (value: T, key: K, map: Map<K, T>) => void, thisArg?: unknown): void;
    get [Symbol.toStringTag](): string;
    peek(key: K): T | undefined;
}
//# sourceMappingURL=cache.d.ts.map