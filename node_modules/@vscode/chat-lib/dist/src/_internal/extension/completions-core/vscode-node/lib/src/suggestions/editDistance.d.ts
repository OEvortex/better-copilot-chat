interface Alignment {
    distance: number;
    startOffset: number;
    endOffset: number;
}
/**
 * Computes the best alignment, under edit-distance, of placing `needle` within
 * `haystack`. These may be strings or arrays.
 *
 * In other words, the entirety of `needle` will count towards the distance,
 * while only the sub-range within `haystack` corresponding to the best match
 * will be included. This means `editDistance(a, b) !== editDistance(b, a)` in
 * general.
 *
 * If `needle` and `haystack` are strings, the distance is in UTF-16 code units.
 * For instance, an emoji inserted in `needle` will increase the distance by 2,
 * while an ASCII character will increase it only by one.
 *
 * @param haystack The big string or array within which the needle should match
 * @param needle The small string or array to match
 * @param compare An optional comparison operator for the elements of `haystack`
 * and `needle`. It should return a "cost" for substituting a given element of
 * `haystack` with a given element of `needle`. If these elements are equal then
 * `compare` should return 0. The indices of these elements are also given to
 * compare.
 *
 * @returns An alignment of the best match possible, with offsets within
 * `haystack`.
 */
export declare function editDistance<E, T extends string | E[]>(haystack: T, needle: T, compare?: (haystackElem: (typeof haystack)[number], needleElem: (typeof needle)[number], haystackIndex: number, needleIndex: number) => number): Alignment;
type LexDictionary = Map<string, number>;
interface LexGenerator {
    (s: string): Generator<string, void, unknown>;
}
export declare function emptyLexDictionary(): LexDictionary;
export declare function reverseLexDictionary(d: LexDictionary): string[];
/**
 * A simple lex generator.
 * A lexeme is one of the following three:
 *  1. A sequence of letters, numbers, _ and -
 *  2. A sequence of spaces
 *  3. Any other single Unicode code point
 */
export declare function lexGeneratorWords(s: string): Generator<string, void, unknown>;
/**
 * Convert a string into an array of lexeme ids, as defined by a lexeme dictionary.
 *
 * Lexemes not already in the dictionary will be added with a fresh key. Hence,
 * this function can be called with an `emptyLexDictionary()`.
 *
 * @param s The string to convert
 * @param lexDictionary The dictionary to begin with
 * @param lexGenerator The generator to use to convert `s` into a stream of
 * substring lexemes
 * @param lexFilter Keep only lexemes satisfying this conditional
 *
 * @returns Pair containing:
 *   - an array of (lexeme ids, lexeme starting offset within `s`),
 *   - the updated dictionary.
 */
export declare function lexicalAnalyzer(s: string, d: LexDictionary, lexGenerator: LexGenerator, lexFilter: (lexeme: string) => boolean): [[number, number][], LexDictionary];
interface LexAlignment {
    lexDistance: number;
    startOffset: number;
    endOffset: number;
    haystackLexLength: number;
    needleLexLength: number;
}
/**
 * Computes the best alignment, under edit-distance, of placing the lexemes of
 * `needle` within those of `haystack`.
 *
 * More precisely, we compute the lex tokens of `needle` and `haystack` under
 * the same dictionary, and then align these by their edit distance using
 * `editDistance`. We then translate the offsets in the lex-match-alignment back
 * to character offsets.
 *
 * @param haystack The big string within which the needle should match
 * @param needle The small string to match
 * @param lexGenerator Generator which chops up a string into lexemes
 * @param lexFilter Keep only lexemes that return true on this function
 *
 * @returns An alignment of the best match possible, with offsets within
 * `haystack`.
 */
export declare function lexEditDistance(haystack: string, needle: string, lexGenerator?: LexGenerator): LexAlignment;
export {};
//# sourceMappingURL=editDistance.d.ts.map