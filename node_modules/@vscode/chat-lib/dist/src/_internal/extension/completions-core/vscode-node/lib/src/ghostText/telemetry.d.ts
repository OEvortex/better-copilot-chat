import { ServicesAccessor } from '../../../../../../util/vs/platform/instantiation/common/instantiation';
import { Logger } from '../logger';
import { PromptResponse } from '../prompt/prompt';
import { TelemetryData, TelemetryWithExp } from '../telemetry';
import { CopilotCompletion } from './copilotCompletion';
import { ResultType } from './ghostText';
export type PostInsertionCategory = 'ghostText' | 'solution';
export declare const logger: Logger;
/** Send `.shown` event */
export declare function telemetryShown(accessor: ServicesAccessor, insertionCategory: PostInsertionCategory, completion: CopilotCompletion): void;
/** Send `.accepted` event */
export declare function telemetryAccepted(accessor: ServicesAccessor, insertionCategory: PostInsertionCategory, telemetryData: TelemetryData): void;
/** Send `.rejected` event */
export declare function telemetryRejected(accessor: ServicesAccessor, insertionCategory: PostInsertionCategory, telemetryData: TelemetryData): void;
/** Cut down telemetry type for "result" telemetry, to avoid too much data load on Azure Monitor.
 *
 */
type BasicResultTelemetry = {
    headerRequestId: string;
    copilot_trackingId: string;
    opportunityId?: string;
    sku?: string;
    organizations_list?: string;
    enterprise_list?: string;
    clientCompletionId?: string;
};
/**
 * For `ghostText.canceled` we include all fields for backwards compatibility, as this event had it initially,
 * Note that we now send the event from more places, but it still makes sense to be consistent.
 */
type CanceledResultTelemetry = {
    telemetryBlob: TelemetryData;
    cancelledNetworkRequest?: boolean;
};
/**
 * When we request ghost text, we also send a `ghostText.issued` telemetry event. To measure
 * Copilot's overall reliability, we want to make sure we consistently send a matching "result" event.
 *
 * This type allows us to keep track of what happened during the pipeline that produces ghost text results,
 * and use the TypeScript type system to reduce the chances of accidentally forgetting to send the result event.
 *
 * At the end of that pipeline, we will either have a final ghost text result and we can send a `ghostText.produced`
 * message, or something will have prevented us producing a result and we can send an alternative mesages.
 */
export type GhostTextResultWithTelemetry<T> = 
/**
 * A result was produced successfully. If this is the final ghost text result,
 * we should send the result message `ghostText.produced`.
 */
{
    type: 'success';
    value: T;
    telemetryData: BasicResultTelemetry;
    telemetryBlob: TelemetryWithExp;
    resultType: ResultType;
    performanceMetrics?: [string, number][];
}
/**
 * We decided not to request ghost text this time. No `ghostText.issued` message
 * was sent so there is no need send any result telemetry.
 */
 | {
    type: 'abortedBeforeIssued';
    reason: string;
    telemetryData: BasicResultTelemetry;
}
/**
 * We requested ghost text, but we decided to cancel mid-way, for example because the
 * user kept typing. This will turn into a `ghostText.canceled` result message.
 * Note: this uses the preferred American spelling "canceled" rather than "cancelled",
 * because the telemetry message has always done that, even though it may be inconsistent
 * with log messages and code comments etc.
 */
 | {
    type: 'canceled';
    reason: string;
    telemetryData: CanceledResultTelemetry;
}
/**
 * We requested ghost text, but didn't come up with any results for some "expected"
 * reason, such as slur redaction or snippy. This will turn into a `ghostText.empty`
 * result message.
 */
 | {
    type: 'empty';
    reason: string;
    telemetryData: BasicResultTelemetry;
}
/**
 * We requested ghost text, but didn't come up with any results because something
 * unexpected went wrong. This will turn into a `ghostText.failed` result message.
 */
 | {
    type: 'failed';
    reason: string;
    telemetryData: BasicResultTelemetry;
}
/**
 * The promptOnly parameter was set to true in the request. We only need the prompt
 * that was about to be sent to the model. This is for experimentation purposes, so
 * there is not any need for telemetry in this case.
 */
 | {
    type: 'promptOnly';
    reason: string;
    prompt: PromptResponse;
};
export declare function mkCanceledResultTelemetry(telemetryBlob: TelemetryData, extraFlags?: {
    cancelledNetworkRequest?: boolean;
}): CanceledResultTelemetry;
export declare function mkBasicResultTelemetry(telemetryBlob: TelemetryWithExp): BasicResultTelemetry;
/**
 * Given a ghost text result, send the appropriate "result" telemetry, if any, and return the
 * result value if one was produced.
 * @param start Milliseconds (since process start) when the completion request was by the editor.
 */
export declare function handleGhostTextResultTelemetry<T>(accessor: ServicesAccessor, result: GhostTextResultWithTelemetry<T>): T | undefined;
export declare function resultTypeToString(resultType: ResultType): string;
export {};
//# sourceMappingURL=telemetry.d.ts.map