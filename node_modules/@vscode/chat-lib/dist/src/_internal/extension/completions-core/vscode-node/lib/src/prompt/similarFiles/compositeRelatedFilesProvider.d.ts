import { IIgnoreService } from '../../../../../../../platform/ignore/common/ignoreService';
import { IInstantiationService } from '../../../../../../../util/vs/platform/instantiation/common/instantiation';
import { CancellationToken as ICancellationToken } from '../../../../types/src';
import { ICompletionsFeaturesService } from '../../experiments/featuresService';
import { ICompletionsFileSystemService } from '../../fileSystem';
import { ICompletionsLogTargetService } from '../../logger';
import { TelemetryWithExp } from '../../telemetry';
import { RelatedFilesDocumentInfo, RelatedFilesProvider, RelatedFilesResponse } from './relatedFiles';
export type ProviderCallback = (uri: string, context: {
    flags: Record<string, unknown>;
}, cancellationToken: ICancellationToken) => Promise<RelatedFilesResponse | undefined>;
type Provider = {
    languageId: string;
    extensionId: string;
    callback: ProviderCallback;
};
export declare class CompositeRelatedFilesProvider extends RelatedFilesProvider {
    private featuresService;
    protected providers: Map<string, Map<string, Provider>>;
    protected telemetrySent: boolean;
    private reportedUnknownProviders;
    constructor(instantiationService: IInstantiationService, ignoreService: IIgnoreService, featuresService: ICompletionsFeaturesService, logTarget: ICompletionsLogTargetService, fileSystemService: ICompletionsFileSystemService);
    getRelatedFilesResponse(docInfo: RelatedFilesDocumentInfo, telemetryData: TelemetryWithExp, cancellationToken: ICancellationToken | undefined): Promise<RelatedFilesResponse | undefined>;
    convert(uri: string, providers: Map<string, Provider>, startTime: number, telemetryData: TelemetryWithExp, token: ICancellationToken | undefined): Promise<RelatedFilesResponse | undefined>;
    registerRelatedFilesProvider(extensionId: string, languageId: string, provider: ProviderCallback): void;
    unregisterRelatedFilesProvider(extensionId: string, languageId: string, callback: ProviderCallback): void;
    /**
     * Providers should manage their own telemetry.
     * These four methods are for backward compatibility with the C++ provider.
     */
    isActive(languageId: string, telemetryData: TelemetryWithExp): boolean;
    relatedFilesTelemetry(telemetryData: TelemetryWithExp): void;
    relatedFileNonresponseTelemetry(language: string, telemetryData: TelemetryWithExp): void;
    performanceTelemetry(duration: number, telemetryData: TelemetryWithExp): void;
}
export {};
//# sourceMappingURL=compositeRelatedFilesProvider.d.ts.map