import { ServicesAccessor } from '../../../../../../util/vs/platform/instantiation/common/instantiation';
import { CancellationToken as ICancellationToken } from '../../../types/src';
import { CompletionState } from '../completionState';
import { APIChoice } from '../openai/openai';
import { CopilotNamedAnnotationList } from '../openai/stream';
import { ExtractPromptOptions } from '../prompt/prompt';
import { TelemetryWithExp } from '../telemetry';
import { GhostTextResultWithTelemetry } from './telemetry';
export interface GhostCompletion {
    completionIndex: number;
    completionText: string;
    displayText: string;
    displayNeedsWsOffset: boolean;
}
export interface CompletionResult {
    completion: GhostCompletion;
    telemetry: TelemetryWithExp;
    isMiddleOfTheLine: boolean;
    suffixCoverage: number;
    copilotAnnotations?: CopilotNamedAnnotationList;
    clientCompletionId: string;
}
export declare enum ResultType {
    Network = 0,
    Cache = 1,
    TypingAsSuggested = 2,
    Cycling = 3,
    Async = 4
}
export type GetNetworkCompletionsType = GhostTextResultWithTelemetry<[APIChoice, Promise<void>]>;
export type GetGhostTextOptions = ExtractPromptOptions & {
    /** Indicates if this is a cycling request. */
    isCycling: boolean;
    /** Whether to stop the ghost text request after computing the prompt (used in the simulator)
     */
    promptOnly: boolean;
    /**
     * Indicates if this is a speculative request generated assuming that the completion was accepted,
     */
    isSpeculative: boolean;
    /**
     * Opportunity ID is a unique ID generated by the client relating to a
     * single "opportunity" to provide some kind of suggestion to the user.
     */
    opportunityId?: string;
    /**
     * An optional debounce time in milliseconds before requesting a completion.
     * Overridable via config or exp variable: `copilotvscodedebouncethreshold`.
     */
    debounceMs?: number;
};
export declare function getGhostText(accessor: ServicesAccessor, completionState: CompletionState, token?: ICancellationToken, options?: Partial<GetGhostTextOptions>): Promise<GhostTextResultWithTelemetry<[CompletionResult[], ResultType]>>;
export declare class ForceMultiLine {
    readonly requestMultilineOverride: boolean;
    static readonly default: ForceMultiLine;
    constructor(requestMultilineOverride?: boolean);
}
//# sourceMappingURL=ghostText.d.ts.map