import { IAuthenticationService } from '../../../../../../platform/authentication/common/authentication';
import { ICompletionModelInformation, IEndpointProvider } from '../../../../../../platform/endpoint/common/endpointProvider';
import { Disposable } from '../../../../../../util/vs/base/common/lifecycle';
import { IInstantiationService } from '../../../../../../util/vs/platform/instantiation/common/instantiation';
import { TokenizerName } from '../../../prompt/src/tokenization';
import { ICompletionsFeaturesService } from '../experiments/featuresService';
import { TelemetryWithExp } from '../telemetry';
import { CompletionHeaders } from './fetch';
export declare const ICompletionsModelManagerService: import("../../../../../../util/common/services").ServiceIdentifier<ICompletionsModelManagerService>;
export interface ICompletionsModelManagerService {
    readonly _serviceBrand: undefined;
    getGenericCompletionModels(): ModelItem[];
    getDefaultModelId(): string;
    getTokenizerForModel(modelId: string): TokenizerName;
    getCurrentModelRequestInfo(featureSettings?: TelemetryWithExp): ModelRequestInfo;
}
export declare class AvailableModelsManager extends Disposable implements ICompletionsModelManagerService {
    private readonly _instantiationService;
    private readonly _featuresService;
    private readonly _endpointProvider;
    _serviceBrand: undefined;
    fetchedModelData: ICompletionModelInformation[];
    customModels: string[];
    editorPreviewFeaturesDisabled: boolean;
    constructor(shouldFetch: boolean | undefined, _instantiationService: IInstantiationService, _featuresService: ICompletionsFeaturesService, _endpointProvider: IEndpointProvider, authenticationService: IAuthenticationService);
    private refreshAvailableModels;
    /**
     * Returns the default model, determined by the order returned from the API
     * Note: this does NOT fetch models to avoid side effects
     */
    getDefaultModelId(): string;
    refreshModels(): Promise<void>;
    /**
     * Returns a list of models that are available for generic completions.
     * Calls to CAPI to retrieve the list.
     */
    getGenericCompletionModels(): ModelItem[];
    getTokenizerForModel(modelId: string): TokenizerName;
    static filterCompletionModels(data: ICompletionModelInformation[], editorPreviewFeaturesDisabled: boolean): ICompletionModelInformation[];
    static filterModelsWithEditorPreviewFeatures(data: ICompletionModelInformation[], editorPreviewFeaturesDisabled: boolean): ICompletionModelInformation[];
    static mapCompletionModels(data: ICompletionModelInformation[]): ModelItem[];
    getCurrentModelRequestInfo(featureSettings?: TelemetryWithExp | undefined): ModelRequestInfo;
}
export interface ModelItem {
    modelId: string;
    label: string;
    preview: boolean;
    tokenizer: string;
}
export type ModelChoiceSourceTelemetryValue = 'override' | 'modelpicker' | 'exp' | 'default' | 'custommodel' | 'prerelease';
declare class ModelRequestInfo {
    readonly modelId: string;
    readonly modelChoiceSource: ModelChoiceSourceTelemetryValue;
    constructor(modelId: string, modelChoiceSource: ModelChoiceSourceTelemetryValue);
    get headers(): CompletionHeaders;
}
export {};
//# sourceMappingURL=model.d.ts.map