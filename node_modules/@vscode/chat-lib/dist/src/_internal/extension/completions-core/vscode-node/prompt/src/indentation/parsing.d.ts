import { IndentationTree } from './classes';
/**
 * Perform a raw indentation-tree parse of a string. This is completely
 * language-agnostic and the returned tree is unlabeled.
 *
 *  - Blank lines pertain to the top-most node that they may, as restricted
 *    by next non-blank line. So e.g.
 *
 *         E
 *           e1
 *             e2
 *
 *           e3
 *
 *     Then e1.subs = [e2], and E.subs = [ e1, blank, e3 ].
 *
 */
export declare function parseRaw(source: string): IndentationTree<never>;
type LineMatcher = (sourceLine: string) => boolean;
export interface LabelRule<L> {
    matches: LineMatcher;
    label: L | undefined;
}
/** Labels the line elements of the tree in-place according to rules */
export declare function labelLines<L>(tree: IndentationTree<L>, labelRules: LabelRule<L>[]): void;
/**
 * For each virtual node, if the node has only one non-blank sub, then label
 * the virtual node as that sub.
 */
export declare function labelVirtualInherited<L>(tree: IndentationTree<L>): void;
/**
 * Function to convert a mapped object to a list of rules.
 * This allows some type magic for extracting a label type from a mapping of rules.
 */
export declare function buildLabelRules<L extends {
    [key: string]: RegExp | LineMatcher;
}>(ruleMap: L): LabelRule<keyof L>[];
/**
 * Fills the opener and closer indentation spec
 * 1. Openers alone in a line whose older sibling is a line are moved to be the first of that sibling's children,
 *    and their children integrated as subsequent children of their new parent.
 * 2. Closers following an older sibling (maybe with blanks in between) are moved to be the last of that sibling.
 * 3. If the closer in 2 has children themselves, their older siblings are wrapped in a virtual node
 */
export declare function combineClosersAndOpeners<L>(tree: IndentationTree<L | 'opener' | 'closer'>): IndentationTree<L | 'opener' | 'closer'>;
/**
 * If there are more than 1 consecutive sibling separated from others by delimiters,
 * combine them into a virtual node.
 * The possibly several consecutive delimiters will be put with the preceding siblings into the virtual node.
 * Note that offside groupings should be done before this.
 */
export declare function groupBlocks<L>(tree: IndentationTree<L>, isDelimiter?: (node: IndentationTree<L>) => boolean, label?: L): IndentationTree<L>;
/**
 * Remove unlabeled virtual nodes which either:
 *  - Have one or no children
 *  - Are the only child of their parent
 * In either case, it is replaced by their children.
 */
export declare function flattenVirtual<L>(tree: IndentationTree<L>): IndentationTree<L>;
/**
 * Register a language-specific parser for a language.
 * This should normally be called in index.ts.
 */
export declare function registerLanguageSpecificParser(language: string, parser: (raw: IndentationTree<never>) => IndentationTree<string>): void;
export declare function parseTree(source: string, languageId?: string): IndentationTree<string>;
export {};
//# sourceMappingURL=parsing.d.ts.map