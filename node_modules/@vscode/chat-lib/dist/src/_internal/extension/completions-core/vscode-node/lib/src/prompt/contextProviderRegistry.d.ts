import { CancellationToken, DocumentSelector } from 'vscode-languageserver-protocol';
import { ILanguageContextProviderService } from '../../../../../../platform/languageContextProvider/common/languageContextProviderService';
import { IInstantiationService, ServicesAccessor } from '../../../../../../util/vs/platform/instantiation/common/instantiation';
import { ContextItemUsageDetails, ContextProvider, DocumentContext, ResolutionStatus, SupportedContextItem, UsageStatus } from '../../../types/src';
import { ICompletionsLogTargetService } from '../logger';
import { TelemetryWithExp } from '../telemetry';
import { ICompletionsRuntimeModeService } from '../util/runtimeMode';
import { SupportedContextItemWithId } from './contextProviders/contextItemSchemas';
import { ICompletionsContextProviderService } from './contextProviderStatistics';
export interface ResolvedContextItem<T extends SupportedContextItemWithId = SupportedContextItemWithId> {
    providerId: string;
    matchScore: number;
    resolution: ResolutionStatus;
    resolutionTimeMs: number;
    data: T[];
}
export interface ContextProviderTelemetry {
    providerId: string;
    matched: boolean;
    resolution: ResolutionStatus;
    resolutionTimeMs: number;
    usage: UsageStatus;
    usageDetails?: ContextItemUsageDetails[];
    numResolvedItems: number;
    numUsedItems?: number;
    numPartiallyUsedItems?: number;
}
export declare const ICompletionsContextProviderRegistryService: import("../../../../../../util/common/services").ServiceIdentifier<ICompletionsContextProviderRegistryService>;
export interface ICompletionsContextProviderRegistryService {
    readonly _serviceBrand: undefined;
    registerContextProvider<T extends SupportedContextItem>(provider: ContextProvider<T>): void;
    unregisterContextProvider(providerId: string): void;
    providers: ContextProvider<SupportedContextItem>[];
    resolveAllProviders(completionId: string, opportunityId: string, documentContext: DocumentContext, telemetryData: TelemetryWithExp, completionToken?: CancellationToken, data?: unknown): Promise<ResolvedContextItem[]>;
}
export type ActiveExperiments = Map<string, string | number | boolean | string[]>;
export declare const ICompletionsDefaultContextProviders: import("../../../../../../util/common/services").ServiceIdentifier<ICompletionsDefaultContextProviders>;
export interface ICompletionsDefaultContextProviders {
    readonly _serviceBrand: undefined;
    getIds(): string[];
    add(id: string): void;
}
export declare class DefaultContextProvidersContainer implements ICompletionsDefaultContextProviders {
    _serviceBrand: undefined;
    private ids;
    add(id: string): void;
    getIds(): string[];
}
type ContextProviderMatchFunction = (instantiationService: IInstantiationService, documentSelector: DocumentSelector, documentContext: DocumentContext) => Promise<number> | number;
export declare class CoreContextProviderRegistry implements ICompletionsContextProviderRegistryService {
    private match;
    private registryService;
    private runtimeMode;
    protected instantiationService: IInstantiationService;
    protected logTarget: ICompletionsLogTargetService;
    protected contextProviderStatistics: ICompletionsContextProviderService;
    _serviceBrand: undefined;
    constructor(match: ContextProviderMatchFunction, registryService: ILanguageContextProviderService, runtimeMode: ICompletionsRuntimeModeService, instantiationService: IInstantiationService, logTarget: ICompletionsLogTargetService, contextProviderStatistics: ICompletionsContextProviderService);
    registerContextProvider<T extends SupportedContextItem>(_provider: ContextProvider<T>): void;
    unregisterContextProvider(_providerId: string): void;
    get providers(): ContextProvider<SupportedContextItem>[];
    /**
     * Resolves all context providers for the given context.
     * Items returned will need to be filtered by schema.
     */
    resolveAllProviders(completionId: string, opportunityId: string, documentContext: DocumentContext, telemetryData: TelemetryWithExp, completionCancellationToken?: CancellationToken, data?: unknown): Promise<ResolvedContextItem[]>;
    private matchProviders;
}
export declare class MutableContextProviderRegistry extends CoreContextProviderRegistry {
    private _providers;
    constructor(match: ContextProviderMatchFunction, registryService: ILanguageContextProviderService, runtimeMode: ICompletionsRuntimeModeService, instantiationService: IInstantiationService, logTarget: ICompletionsLogTargetService, contextProviderStatistics: ICompletionsContextProviderService);
    registerContextProvider<T extends SupportedContextItem>(provider: ContextProvider<T>): void;
    unregisterContextProvider(providerId: string): void;
    get providers(): ContextProvider<SupportedContextItem>[];
}
export declare class CachedContextProviderRegistry implements ICompletionsContextProviderRegistryService {
    _serviceBrand: undefined;
    private _cachedContextItems;
    private readonly delegate;
    constructor(registry: new (match: ContextProviderMatchFunction) => CoreContextProviderRegistry, match: ContextProviderMatchFunction, instantiationService: IInstantiationService);
    registerContextProvider<T extends SupportedContextItem>(provider: ContextProvider<T>): void;
    unregisterContextProvider(providerId: string): void;
    get providers(): ContextProvider<SupportedContextItem>[];
    resolveAllProviders(completionId: string, opportunityId: string, documentContext: DocumentContext, telemetryData: TelemetryWithExp, completionToken?: CancellationToken, data?: unknown): Promise<ResolvedContextItem[]>;
}
export declare function telemetrizeContextItems(contextProvider: ICompletionsContextProviderService, completionId: string, resolvedContextItems: ResolvedContextItem[]): ContextProviderTelemetry[];
export declare function matchContextItems(resolvedContextItem: ResolvedContextItem): boolean;
export declare function useContextProviderAPI(accessor: ServicesAccessor, languageId: string, telemetryData: TelemetryWithExp): boolean;
export {};
//# sourceMappingURL=contextProviderRegistry.d.ts.map