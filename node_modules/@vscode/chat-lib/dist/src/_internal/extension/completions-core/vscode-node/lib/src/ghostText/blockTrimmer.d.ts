import { StatementNode, StatementTree } from './statementTree';
import { IPosition, TextDocumentContents } from '../textDocument';
/**
 * BlockTrimmer base class.
 */
export declare abstract class BlockTrimmer {
    protected readonly languageId: string;
    protected readonly prefix: string;
    protected readonly completion: string;
    static isSupported(languageId: string): boolean;
    /** Tests for the subset of supported languages that are trimmed by default */
    static isTrimmedByDefault(languageId: string): boolean;
    constructor(languageId: string, prefix: string, completion: string);
    abstract getCompletionTrimOffset(): Promise<number | undefined>;
    protected withParsedStatementTree<T>(fn: (tree: StatementTree) => Promise<T> | T): Promise<T>;
    protected trimmedCompletion(offset: number | undefined): string;
    /**
     * Gets the statement at the cursor position.
     * If the cursor is not within a statement (e.g. it's on an error node),
     * returns the first statement from the tree (if any).
     */
    protected getStatementAtCursor(tree: StatementTree): StatementNode | undefined;
    protected getContainingBlockOffset(stmt: StatementNode | undefined): number | undefined;
    protected hasNonStatementContentAfter(stmt: StatementNode | undefined): boolean;
    protected asCompletionOffset(offset: number | undefined): number | undefined;
    protected isCompoundStatement(stmt: StatementNode): boolean;
}
/**
 * A block trimmer that tries to obtain the longest reasonable completion
 * within its line limit. This results in a more verbose completion.
 *
 * Don't delete it is used in tests.
 */
export declare class VerboseBlockTrimmer extends BlockTrimmer {
    private readonly lineLimit;
    private readonly offsetLimit;
    constructor(languageId: string, prefix: string, completion: string, lineLimit?: number);
    getCompletionTrimOffset(): Promise<number | undefined>;
    private isWithinLimit;
    private trimToBlankLine;
    private trimToStatement;
}
/**
 * A block trimmer that stops when it's likely the end of a logical section has
 * been reached, such as the start of a new compound statement. This results in
 * a more terse completion.
 */
export declare class TerseBlockTrimmer extends BlockTrimmer {
    private readonly lineLimit;
    private readonly lookAhead;
    private readonly limitOffset;
    private readonly lookAheadOffset;
    constructor(languageId: string, prefix: string, completion: string, lineLimit?: number, lookAhead?: number);
    getCompletionTrimOffset(): Promise<number | undefined>;
    /**
     * Return the position of the first non-whitespace character to the right
     * of the cursor, or the start of the completion if it is blank.
     */
    private stmtStartPos;
    private trimAtFirstBlankLine;
    private trimAtStatementChange;
}
export declare enum BlockPositionType {
    NonBlock = "non-block",
    EmptyBlock = "empty-block",
    BlockEnd = "block-end",
    MidBlock = "mid-block"
}
export declare function getBlockPositionType(document: TextDocumentContents, position: IPosition): Promise<BlockPositionType>;
//# sourceMappingURL=blockTrimmer.d.ts.map