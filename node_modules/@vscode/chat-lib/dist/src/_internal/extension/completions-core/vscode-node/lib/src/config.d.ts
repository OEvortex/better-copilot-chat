import { packageJson } from '../../../../../platform/env/common/packagejson';
import { ServicesAccessor } from '../../../../../util/vs/platform/instantiation/common/instantiation';
import { Filter } from './experiments/filters';
import { Emitter, Event } from './util/event';
export { packageJson };
export declare const ConfigKey: {
    Enable: string;
    UserSelectedCompletionModel: string;
    ShowEditorCompletions: string;
    EnableAutoCompletions: string;
    DelayCompletions: string;
    FilterCompletions: string;
    CompletionsDelay: string;
    CompletionsDebounce: string;
    RelatedFilesVSCodeCSharp: string;
    RelatedFilesVSCodeTypeScript: string;
    RelatedFilesVSCode: string;
    ContextProviders: string;
    DebugFilterLogCategories: string;
    DebugSnippyOverrideUrl: string;
    UseSubsetMatching: string;
    ContextProviderTimeBudget: string;
    DebugOverrideCapiUrl: string;
    DebugOverrideCapiUrlLegacy: string;
    DebugTestOverrideCapiUrl: string;
    DebugTestOverrideCapiUrlLegacy: string;
    DebugOverrideProxyUrl: string;
    DebugOverrideProxyUrlLegacy: string;
    DebugTestOverrideProxyUrl: string;
    DebugTestOverrideProxyUrlLegacy: string;
    DebugOverrideEngine: string;
    DebugOverrideEngineLegacy: string;
    /**
     * Internal experiment for always requesting multiline completions.
     * This might not result always in a multiline suggestion, but most often will.
     */
    AlwaysRequestMultiline: string;
    /**
     * Let the model terminate single line completions when AlwaysRequestMultiline is enabled.
     */
    ModelAlwaysTerminatesSingleline: string;
    /**
     * Overrides whether to use the Workspace Context Coordinator to coordinate workspace context.
     * This setting takes precedence over the value from ExP.
     */
    UseWorkspaceContextCoordinator: string;
    /**
     * Overrides whether to include neighboring files in the prompt
     * alongside context providers.
     * This setting takes precedence over the value from ExP.
     */
    IncludeNeighboringFiles: string;
    ExcludeRelatedFiles: string;
    DebugOverrideCppHeadersEnableSwitch: string;
    /**
     * Internal config for using the completions prompt with split context.
     * https://github.com/github/copilot/issues/19286
     */
    UseSplitContextPrompt: string;
};
export type ConfigKeyType = string;
export declare enum BlockMode {
    /**
     * Parse the context + completion on the client using treesitter to
     * determine blocks.
     */
    Parsing = "parsing",
    /**
     * Let the server parse out blocks and assume that the completion terminates
     * at the end of a block.
     */
    Server = "server",
    /**
     * Runs both the treesitter parsing on the client plus indentation-based
     * truncation on the proxy.
     */
    ParsingAndServer = "parsingandserver",
    /**
     * Client-based heuristic to display more multiline completions.
     * It almost always requests a multiline completion from the server and tries to break it up to something useful on the client.
     *
     * This should not be rolled out at the moment (latency impact is high, UX needs further fine-tuning),
     * but can  be used for internal experimentation.
     */
    MoreMultiline = "moremultiline"
}
export declare function shouldDoServerTrimming(blockMode: BlockMode): boolean;
export declare enum BuildType {
    DEV = "dev",
    PROD = "prod",
    NIGHTLY = "nightly"
}
export declare const ICompletionsConfigProvider: import("../../../../../util/common/services").ServiceIdentifier<ICompletionsConfigProvider>;
export interface ICompletionsConfigProvider {
    readonly _serviceBrand: undefined;
    getConfig<T>(key: ConfigKeyType): T;
    getOptionalConfig<T>(key: ConfigKeyType): T | undefined;
    dumpForTelemetry(): {
        [key: string]: string;
    };
    onDidChangeCopilotSettings: Event<ConfigProvider>;
}
export declare abstract class ConfigProvider implements ICompletionsConfigProvider {
    _serviceBrand: undefined;
    abstract getConfig<T>(key: ConfigKeyType): T;
    abstract getOptionalConfig<T>(key: ConfigKeyType): T | undefined;
    abstract dumpForTelemetry(): {
        [key: string]: string;
    };
    abstract onDidChangeCopilotSettings: Event<ConfigProvider>;
    requireReady(): Promise<void>;
}
/** Provides only the default values, ignoring the user's settings.
 * @public KEEPING FOR TESTS
*/
export declare class DefaultsOnlyConfigProvider extends ConfigProvider {
    getConfig<T>(key: ConfigKeyType): T;
    getOptionalConfig<T>(key: ConfigKeyType): T | undefined;
    dumpForTelemetry(): {
        [key: string]: string;
    };
    onDidChangeCopilotSettings: () => {
        dispose: () => void;
    };
}
/**
 * A ConfigProvider that allows overriding of config values.
 * @public KEEPING FOR TESTS
*/
export declare class InMemoryConfigProvider extends ConfigProvider {
    private readonly baseConfigProvider;
    protected readonly copilotEmitter: Emitter<this>;
    readonly onDidChangeCopilotSettings: Event<this>;
    private overrides;
    constructor(baseConfigProvider: ConfigProvider);
    setOverrides(overrides: Map<ConfigKeyType, unknown>): void;
    clearOverrides(): void;
    protected getOptionalOverride<T>(key: ConfigKeyType): T | undefined;
    getConfig<T>(key: ConfigKeyType): T;
    getOptionalConfig<T>(key: ConfigKeyType): T | undefined;
    setConfig(key: ConfigKeyType, value: unknown): void;
    setCopilotSettings(settings: Record<ConfigKeyType, unknown>): void;
    dumpForTelemetry(): {
        [key: string]: string;
    };
}
export declare function getConfigKeyRecursively<T>(config: Record<string, unknown>, key: string): T | undefined;
export declare function getConfigDefaultForKey<T>(key: string): T;
export declare function getOptionalConfigDefaultForKey<T>(key: string): T | undefined;
export declare function getConfig<T>(accessor: ServicesAccessor, key: ConfigKeyType): T;
export declare function dumpForTelemetry(accessor: ServicesAccessor): {
    [key: string]: string;
};
export declare class BuildInfo {
    static isPreRelease(): boolean;
    static isProduction(): boolean;
    static getBuildType(): BuildType;
    static getVersion(): string;
    static getBuild(): string;
}
type NameAndVersion = {
    name: string;
    version: string;
};
export type EditorInfo = NameAndVersion & {
    root?: string;
    devName?: string;
};
export type EditorPluginInfo = NameAndVersion;
export type EditorPluginFilter = {
    filter: Filter;
    value: string;
    isVersion?: boolean;
};
export declare function formatNameAndVersion({ name, version }: NameAndVersion): string;
export declare const ICompletionsEditorAndPluginInfo: import("../../../../../util/common/services").ServiceIdentifier<ICompletionsEditorAndPluginInfo>;
export interface ICompletionsEditorAndPluginInfo {
    readonly _serviceBrand: undefined;
    getEditorInfo(): EditorInfo;
    getEditorPluginInfo(): EditorPluginInfo;
    getRelatedPluginInfo(): EditorPluginInfo[];
}
/**
 * Do not use this in new code.  Every endpoint has its own unique versioning.
 * Centralizing in a single constant was a mistake.
 * @deprecated
 */
export declare const apiVersion = "2025-05-01";
export declare function editorVersionHeaders(accessor: ServicesAccessor): {
    [key: string]: string;
};
//# sourceMappingURL=config.d.ts.map