import { PromptSnapshotNodeStatistics } from '../../../../prompt/src/components/components';
import { Tokenizer } from '../../../../prompt/src/tokenization';
export interface WeightedBlock {
    /**
     * Paths use a syntax similar to JSON path, but with a few differences:
     * - Fragments, string and number components are ignored
     * - The same identifier can exist at the same level, and is represented as an array index ([i])
     *   For example this prompts:
     *     <>
     *      <ComponentA />
     *      <ComponentB />
     *      <ComponentA />
     *     </>
     *  Would have the following paths:
     *    $.ComponentA[0]
     *    $.ComponentB
     *    $.ComponentA[1]
     */
    componentPath: string;
    type: 'prefix' | 'suffix' | 'context';
    value: string;
    weight: number;
    index?: number;
    nodeStatistics: PromptSnapshotNodeStatistics;
    chunks?: Set<string>;
    source?: unknown;
}
export interface ElidedBlock extends WeightedBlock {
    tokens: number;
    elidedValue: string;
    elidedTokens: number;
}
interface ElisionStrategy {
    elide(prefixBlocks: WeightedBlock[], prefixTokenLimit: number, suffixBlock: WeightedBlock, suffixTokenLimit: number, tokenizer: Tokenizer): {
        blocks: ElidedBlock[];
        cycles: number;
    };
}
/**
 * The wishlist strategy does a two-pass elision, based on prompt/src/wishlist.ts
 * - Removes blocks (of lines) with the lowest weight, ignoring blocks with a weight of 1.
 * - Adjust the total token count to fit within the limit line by line, top to bottom.
 *
 * Notice the extra `suffix*` arguments in the constructor and elide method.
 */
export declare class WishlistElision implements ElisionStrategy {
    elide(prefixBlocks: WeightedBlock[], prefixTokenLimit: number, suffixBlock: WeightedBlock, suffixTokenLimit: number, tokenizer: Tokenizer): {
        blocks: ElidedBlock[];
        cycles: number;
    };
    private preparePrefixBlocks;
    /**
     * Special handling for the suffix, adapted from PromptWishlist.fulfill
     * Some behaviors are different from the original implementation:
     * - If the token limit is less than the edit distance, we don't error but just return the first tokens of the new suffix.
     * - When using the cached suffix, we check and enforce the limit.
     * - Remaining tokens are returned and handled by the caller, so we don't need to check the prefix nor modify limits in place.
     */
    private elideSuffix;
    private elidePrefix;
    /**
     * Marks blocks for removal based on their weight and the total token limit.
     * If a block has a chunk identifier, all blocks with the same chunk will be removed together.
     * Blocks with a weight of 1 are protected from removal.
     */
    private removeLowWeightPrefixBlocks;
    private trimPrefixLinesToFit;
}
export declare function makePrompt(elidedBlocks: ElidedBlock[]): string;
export declare function makePrefixPrompt(elidedBlocks: ElidedBlock[]): string;
/**
 * Return context items grouped in blocks reflecting the prompt structure.
 */
export declare function makeContextPrompt(elidedBlocks: ElidedBlock[]): string[];
export {};
//# sourceMappingURL=elision.d.ts.map