import { RecentEditsConfig } from './recentEditsProvider';
/** The shape of one unified-diff hunk, independent of formatting. */
export interface DiffHunk {
    file: string;
    pre: number;
    post: number;
    before: string[];
    removed: string[];
    added: string[];
    after: string[];
}
export interface RecentEdit {
    file: string;
    startLine: number;
    endLine: number;
    diff: DiffHunk;
    timestamp: number;
}
export type RecentEditMap = Record<string, {
    originalContent: string;
    currentContent: string;
    edits: RecentEdit[];
}>;
/**
 * Flatten all edits from a RecentEditMap into a single array,
 * sorted by timestamp (oldest first).
 */
export declare function getAllRecentEditsByTimestamp(map: RecentEditMap): RecentEdit[];
/**
 * Find the first/last differing line indices.
 * Returns null if the two are identical.
 */
export declare function findChangeSpan(prevLines: string[], newLines: string[]): {
    start: number;
    endPrev: number;
    endNew: number;
} | null;
/**
 * Collect everything needed to render a single diff in any format.
 */
export declare function getDiff(file: string, prevLines: string[], newLines: string[], start: number, endPrev: number, endNew: number, context: number): DiffHunk;
/**
 * Turn a DiffHunk into a standard unified diff string.
 */
export declare function unifiedDiff(hunk: DiffHunk, removeDeletedLines?: boolean, insertionsBeforeDeletions?: boolean, appendNoReplyMarker?: boolean): string;
/**
 * Turn a DiffHunk into a plain english find/replace string
 */
export declare function findReplaceDiff(hunk: DiffHunk, removeDeletedLines?: boolean): string;
/**
 * Determines whether two edits overlap or are close enough to be considered adjacent.
 *
 * @param incoming - The new edit being evaluated, represented as a `RecentEdit` object.
 * @param last - The most recent edit already processed, represented as a `RecentEdit` object.
 * @param editMergeLineDistance - The maximum number of lines between edits to consider them adjacent.
 * @returns `true` if the edits overlap or are within the specified line distance; otherwise, `false`.
 */
export declare function editsOverlap(incoming: RecentEdit, last: RecentEdit, editMergeLineDistance: number): boolean;
/**
 * Add an incoming hunk, coalesce overlaps, and immediately trim+rebase if needed.
 */
export declare function updateEdits(originalContent: string, existing: RecentEdit[], incoming: RecentEdit, currentFileLines: string[], config: RecentEditsConfig): {
    originalContent: string;
    edits: RecentEdit[];
};
/** Build the incoming edit object */
export declare function buildIncomingEdit(file: string, prevLines: string[], nextLines: string[], span: {
    start: number;
    endPrev: number;
    endNew: number;
}, config: RecentEditsConfig): RecentEdit;
/**
 * Trim old files from the state.
 */
export declare function trimOldFilesFromState(state: RecentEditMap, maxFiles: number): RecentEditMap;
/**
 * Reducer that takes a file and its new contents,
 * merging them into a clean structure of recent edits.
 */
export declare function recentEditsReducer(state: RecentEditMap | undefined, file: string, newContents: string, config: RecentEditsConfig): RecentEditMap;
/**
 * Summarizes a single recent edit for the prompt.
 * @param edit
 * @param config RecentEditsPromptConfig
 * @returns a string summarizing the edit for the prompt, or null if the edit should be left out
 */
export declare function summarizeEdit(edit: RecentEdit, config: RecentEditsConfig): string | null;
//# sourceMappingURL=recentEditsReducer.d.ts.map