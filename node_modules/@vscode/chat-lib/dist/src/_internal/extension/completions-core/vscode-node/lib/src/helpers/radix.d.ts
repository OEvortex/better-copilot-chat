/** A data structure for efficiently finding all values that are indexed by a key
 * that is a prefix of a given key, using a radix trie representation.
 *
 * An overarching goal of the implementation is to minimize storing and handling
 * the full keys since in the case of completions, the keys are the full text of
 * the document before the cursor which can be large.
 */
export declare class LRURadixTrie<T> {
    private readonly maxSize;
    /** Singular, empty root node for the the trie. */
    private readonly root;
    /** Set of all leaf nodes with values, tracked for evicting LRU values. */
    private readonly leafNodes;
    constructor(maxSize: number);
    /**
     * Traverses the trie to insert a new value. If an existing exact match is
     * found the value is added to a list of values at that node. Otherwise a
     * new node is created.
     *
     * As a side effect, the least recently used node is evicted if the max size
     * is exceeded.
     */
    set(key: string, value: T): void;
    /** Traverses the trie and returns all values whose keys are a prefix of the
     * given key. Returns them in order of longest prefix first.
     */
    findAll(key: string): Array<{
        remainingKey: string;
        value: T;
    }>;
    /** Removes the value at a given key if any from the trie. */
    delete(key: string): void;
    /** Traverses the trie to find the node with the closest prefix to a given key. */
    private findClosestNode;
    /** Deletes a node from the trie and resolves relationships with surrounding nodes.
     * - If the node has no children, remove it from its parent.
     * - If the node has one child, replace it with its child in the parent,
     *   concatenating the edges together.
     * - If the node has multiple children, the node is left in place as an
     *   intermediary node.
     * - In all cases, the value at the node is removed and the node is removed
     *   from the flatNodes set of leaf nodes.
     */
    private deleteNode;
    /** Walks the trie to find and evict the least recently used node. This is
     * intentionally optimized for read performance over write performance.
     */
    private evictLeastRecentlyUsed;
    /** Iterate through the set of leaf nodes to find the least recently used.
     *
     * Note, this could be done more efficiently with a heap or even just
     * keeping the list sorted. Currently, this is mirroring the LRUCacheMap
     * implementation to optimize for read performance over write performance.
     * Though this may be worth revisiting since both reading and writing are on
     * the critical path for completions.
     */
    private findLeastRecentlyUsed;
}
//# sourceMappingURL=radix.d.ts.map