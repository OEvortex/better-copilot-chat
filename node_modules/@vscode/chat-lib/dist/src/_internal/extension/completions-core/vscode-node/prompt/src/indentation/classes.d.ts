export type IndentationTree<L> = TopNode<L> | VirtualNode<L> | LineNode<L> | BlankNode<L>;
export type IndentationSubTree<L> = Exclude<IndentationTree<L>, TopNode<L>>;
interface NodeBase<L> {
    label?: L;
    subs: IndentationSubTree<L>[];
}
/**
 * Virtual nodes represent groupings are not directly visible in indentation.
 **/
export interface VirtualNode<L> extends NodeBase<L> {
    type: 'virtual';
    indentation: number;
}
export interface TopNode<L> extends NodeBase<L> {
    type: 'top';
    indentation: -1;
}
/**
 * A line of source code and its sub-nodes
 * */
export interface LineNode<L> extends NodeBase<L> {
    type: 'line';
    indentation: number;
    lineNumber: number;
    sourceLine: string;
}
/**
 * A blank line
 */
interface BlankNode<L> extends NodeBase<L> {
    type: 'blank';
    lineNumber: number;
    subs: never[];
}
/** Construct a virtual node */
export declare function virtualNode<L>(indentation: number, subs: IndentationSubTree<L>[], label?: L): VirtualNode<L>;
/** Construct a line node */
export declare function lineNode<L>(indentation: number, lineNumber: number, sourceLine: string, subs: IndentationSubTree<L>[], label?: L): LineNode<L>;
/** Return a blank node */
export declare function blankNode(line: number): BlankNode<never>;
/** Return a node representing the top node */
export declare function topNode<L>(subs?: IndentationSubTree<L>[]): TopNode<L>;
export declare function isBlank<L>(tree: IndentationTree<L>): tree is BlankNode<L>;
export declare function isLine<L>(tree: IndentationTree<L>): tree is LineNode<L>;
export declare function isVirtual<L>(tree: IndentationTree<L>): tree is VirtualNode<L>;
export declare function isTop<L>(tree: IndentationTree<L>): tree is TopNode<L>;
/**
 * Return the tree which consists of everything up to the line node with the
 * given number. All later siblings of that line node, recursively, are removed.
 *
 * This function does not assume the line numbers appear contiguously, but will
 * return anything before the numbered line, whether its line number is greater
 * or not.
 *
 * This is destructive and modifies the tree.
 */
export declare function cutTreeAfterLine(tree: IndentationTree<unknown>, lineNumber: number): void;
/**
 * A type expressing that JSON.parse(JSON.stringify(x)) === x.
 */
export type JsonStable = string | number | JsonStable[] | {
    [key: string]: JsonStable;
};
/**
 * Return a deep duplicate of the tree -- this will only work if the labels can be stringified to parseable JSON.
 */
export declare function duplicateTree<L extends JsonStable>(tree: IndentationTree<L>): IndentationTree<L>;
export {};
//# sourceMappingURL=classes.d.ts.map