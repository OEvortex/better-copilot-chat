import { CancellationToken } from '../../types/src';
/**
 * CIRCULAR DEPENDENCY FIX - PROGRESSIVE REFACTORING
 *
 * This module was refactored to resolve a circular dependency that caused runtime errors:
 *
 * Previous circular dependency chain:
 * networking.ts â†’ config.ts â†’ features.ts â†’ copilotTokenManager.ts â†’ copilotToken.ts â†’ github.ts â†’ networking.ts
 *
 * The issue:
 * - networking.ts defined FetchResponseError and other error classes
 * - network/github.ts needed FetchResponseError, so imported from networking.ts
 * - But networking.ts indirectly depended on github.ts through the config chain
 * - This caused "Cannot access 'FetchResponseError' before initialization" runtime error
 *
 * Solution - Module Separation:
 * 1. Extracted all error classes and types to '#lib/networking/networkingTypes'
 * 2. github.ts now imports FetchResponseError directly from the types module
 * 3. This breaks the circular dependency while preserving functionality
 * 4. No more dynamic imports needed since errors and types are in the same module
 *
 * Progressive Refactoring Strategy:
 * - Re-export everything from the new module to maintain API compatibility
 * - 22+ files across the codebase import from './networking' and expect these exports
 * - This approach allows internal restructuring without breaking existing imports
 * - Future: Could gradually migrate files to import directly from networkingTypes module
 */
export * from './networkingTypes';
import { IConfigurationService } from '../../../../../platform/configuration/common/configurationService';
import { IFetcherService } from '../../../../../platform/networking/common/fetcherService';
import { IExperimentationService } from '../../../../../platform/telemetry/common/nullExperimentationService';
import { ServicesAccessor } from '../../../../../util/vs/platform/instantiation/common/instantiation';
import { FetchOptions, Response } from './networkingTypes';
export declare const ICompletionsFetcherService: import("../../../../../util/common/services").ServiceIdentifier<ICompletionsFetcherService>;
export interface ICompletionsFetcherService {
    readonly _serviceBrand: undefined;
    getImplementation(): ICompletionsFetcherService | Promise<ICompletionsFetcherService>;
    fetch(url: string, options: FetchOptions): Promise<Response>;
    disconnectAll(): Promise<unknown>;
}
export declare class CompletionsFetcher implements ICompletionsFetcherService {
    private readonly configurationService;
    private readonly fetcherService;
    private readonly experimentationService;
    _serviceBrand: undefined;
    constructor(configurationService: IConfigurationService, fetcherService: IFetcherService, experimentationService: IExperimentationService);
    getImplementation(): ICompletionsFetcherService | Promise<ICompletionsFetcherService>;
    fetch(url: string, options: FetchOptions): Promise<Response>;
    disconnectAll(): Promise<unknown>;
}
/**
 * Encapsulates all the functionality related to making GET/POST/DELETE requests using
 * different libraries (and in the future, different environments like web vs
 * node).
 */
export declare abstract class Fetcher {
    abstract readonly name: string;
    /**
     * Returns the real implementation, not a delegator.  Used by diagnostics to ensure the fetcher name and all
     * reachability checks are aligned.
     */
    getImplementation(): Fetcher | Promise<Fetcher>;
    abstract fetch(url: string, options: FetchOptions): Promise<Response>;
    abstract disconnectAll(): Promise<unknown>;
}
export declare function postRequest(accessor: ServicesAccessor, url: string, secretKey: string, intent: string | undefined, // Must be passed in, even if explicitly `undefined`
requestId: string, body?: Record<string, unknown>, cancelToken?: CancellationToken, extraHeaders?: Record<string, string>, timeout?: number, modelProviderName?: string): Promise<Response>;
//# sourceMappingURL=networking.d.ts.map