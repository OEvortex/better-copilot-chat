import { CancellationTokenSource } from '../../../types/src';
import { ICompletionsFeaturesService } from '../experiments/featuresService';
import { ICompletionsLogTargetService } from '../logger';
import { APIChoice } from '../openai/openai';
import { Prompt } from '../prompt/prompt';
import { TelemetryWithExp } from '../telemetry';
import { GetNetworkCompletionsType } from './ghostText';
export declare const ICompletionsAsyncManagerService: import("../../../../../../util/common/services").ServiceIdentifier<ICompletionsAsyncManagerService>;
export interface ICompletionsAsyncManagerService {
    readonly _serviceBrand: undefined;
    clear(): void;
    shouldWaitForAsyncCompletions(prefix: string, prompt: Prompt): boolean;
    updateCompletion(headerRequestId: string, text: string): void;
    queueCompletionRequest(headerRequestId: string, prefix: string, prompt: Prompt, cancellationTokenSource: CancellationTokenSource, resultPromise: Promise<GetNetworkCompletionsType>): Promise<void>;
    getFirstMatchingRequestWithTimeout(headerRequestId: string, prefix: string, prompt: Prompt, isSpeculative: boolean, telemetryWithExp: TelemetryWithExp): Promise<[APIChoice, Promise<void>] | undefined>;
    getFirstMatchingRequest(headerRequestId: string, prefix: string, prompt: Prompt, isSpeculative: boolean): Promise<[APIChoice, Promise<void>] | undefined>;
}
export declare class AsyncCompletionManager implements ICompletionsAsyncManagerService {
    #private;
    private readonly featuresService;
    private readonly logTarget;
    _serviceBrand: undefined;
    /** Mapping of headerRequestId to completion request */
    private readonly requests;
    /** The most recently requested (either via getFirstMatchingRequest or
     * getFirstMatchingRequestWithTimeout) header request ID. Serves as a lock
     * for cancellation. Since we only want to cancel requests that don't match
     * the most recent request prefix. */
    private mostRecentRequestId;
    constructor(featuresService: ICompletionsFeaturesService, logTarget: ICompletionsLogTargetService);
    clear(): void;
    /**
     * Check if there are any candidate completions for the current position.
     * We need to strike the right balance between queuing completions as the
     * user types, without queuing one per keystroke. This method should return
     * true if we don't have any completions that match the current position.
     * This method should return false if we have reasonable candidates that
     * match the current position.
     */
    shouldWaitForAsyncCompletions(prefix: string, prompt: Prompt): boolean;
    /**
     * Called from a FinishedCallback to report partial results as a completion
     * is streamed back from the server.
     */
    updateCompletion(headerRequestId: string, text: string): void;
    /**
     * Adds an in-flight completion request to the requests map for tracking.
     * Once the request is completed it is removed from the requests map.
     */
    queueCompletionRequest(headerRequestId: string, prefix: string, prompt: Prompt, cancellationTokenSource: CancellationTokenSource, resultPromise: Promise<GetNetworkCompletionsType>): Promise<void>;
    /** Returns the first matching completion or times out. */
    getFirstMatchingRequestWithTimeout(headerRequestId: string, prefix: string, prompt: Prompt, isSpeculative: boolean, telemetryWithExp: TelemetryWithExp): Promise<[APIChoice, Promise<void>] | undefined>;
    /**
     * Returns the first resolved matching completion request. Modifies the
     * returned APIChoice to match the current prompt.
     */
    getFirstMatchingRequest(headerRequestId: string, prefix: string, prompt: Prompt, isSpeculative: boolean): Promise<[APIChoice, Promise<void>] | undefined>;
    /**
     * Attempts to cancel a request if it is still pending and the request
     * attempting the cancellation (that it no longer matches) is the most
     * recent request.
     *
     * @param headerRequestId The request id for the call to
     * getFirstMatchingRequest that the `request` no longer matches.
     * @param request The request to cancel
     */
    private cancelRequest;
}
//# sourceMappingURL=asyncCompletions.d.ts.map