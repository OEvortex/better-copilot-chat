import { ServicesAccessor } from '../../../../../../../util/vs/platform/instantiation/common/instantiation';
import { SimilarFileInfo } from '../../../../prompt/src/prompt';
import { CancellationToken as ICancellationToken } from '../../../../types/src';
import { TelemetryWithExp } from '../../telemetry';
import { RelatedFileTrait } from './relatedFiles';
export declare enum NeighboringFileType {
    None = "none",// Do not add neighbor files.
    OpenTabs = "opentabs",// Add open files.
    CursorMostRecent = "cursormostrecent",// Add the most recent cursor focused files.
    CursorMostCount = "cursormostcount",// Add the most cursor focused files.
    WorkspaceSharingSameFolder = "workspacesharingsamefolder",// Add the workspace files sharing the same folder with the target file.
    WorkspaceSmallestPathDist = "workspacesmallestpathdist",// Add the workspace files according to their path distance toward the target file
    OpenTabsAndCocommitted = "opentabsandcocommitted",// Add open files and the co-committed files.
    RelatedCSharp = "related/csharp",// The Semantic Code Context says this file is related.
    RelatedCSharpRoslyn = "related/csharproslyn",// The C# language service says this file is related.
    RelatedCpp = "related/cpp",// The C++ language service says this file is related.
    RelatedTypeScript = "related/typescript",// The Typescript language service says this file is related.
    RelatedCppSemanticCodeContext = "related/cppsemanticcodecontext",// The Semantic Code Context says this file is related.
    RelatedOther = "related/other"
}
/**
 * We found out that considering
 * all **open** neighbor files (independent of the language) was not helpful. However, some
 * specific languages (e.g. frontend frameworks) benefit from this approach. Leaving this
 * function here for future reference, in case we want to experiment this approach again for
 * specific languages that always use cross-language files.
 *
 * @param languageId Language ID of the current file
 * @param neighborLanguageId Language ID of the neighbor file
 * @returns Boolean value indicating whether the neighbor file should be considered
 *          (currently matching the current file's language with neighbors')
 */
export declare function considerNeighborFile(languageId: string, neighborLanguageId: string): boolean;
export type NeighborsCollection = Map<string, SimilarFileInfo>;
export interface INeighborSource {
    getNeighborFiles(uri: string, languageId: string, maxNumNeighborFiles: number): Promise<{
        docs: NeighborsCollection;
        neighborSource: Map<NeighboringFileType, string[]>;
    }>;
}
export declare class NeighborSource {
    static MAX_NEIGHBOR_AGGREGATE_LENGTH: number;
    static MAX_NEIGHBOR_FILES: number;
    static EXCLUDED_NEIGHBORS: string[];
    static defaultEmptyResult(): {
        docs: Map<string, SimilarFileInfo>;
        neighborSource: Map<NeighboringFileType, string[]>;
        traits: RelatedFileTrait[];
    };
    private static instance;
    /** Reset the singleton instance for unit test only */
    static reset(): void;
    static getNeighborFilesAndTraits(accessor: ServicesAccessor, uri: string, fileType: string, telemetryData: TelemetryWithExp, cancellationToken?: ICancellationToken, data?: unknown, forceRelatedFilesComputation?: boolean): Promise<{
        docs: NeighborsCollection;
        neighborSource: Map<NeighboringFileType, string[]>;
        traits: RelatedFileTrait[];
    }>;
    static basename(uri: string): string;
    /**
     * Get the fileUri relative to the provided basePath
     * or its basename if basePath is not its ancestor.
     */
    static getRelativePath(fileUri: string, baseUri: string): string | undefined;
}
export declare function isIncludeNeighborFilesActive(accessor: ServicesAccessor, languageId: string, telemetryData: TelemetryWithExp): boolean;
//# sourceMappingURL=neighborFiles.d.ts.map