import { IExperimentationService } from '../../../../../../platform/telemetry/common/nullExperimentationService';
import { IInstantiationService } from '../../../../../../util/vs/platform/instantiation/common/instantiation';
import { ICompletionsCopilotTokenManager } from '../auth/copilotTokenManager';
import { BlockMode } from '../config';
import { TelemetryData, TelemetryWithExp } from '../telemetry';
import { ExpConfig } from './expConfig';
import { CompletionsFiltersInfo, ContextProviderExpSettings, ICompletionsFeaturesService } from './featuresService';
import { FilterSettings } from './filters';
/** General-purpose API for accessing ExP variable values. */
export declare class Features implements ICompletionsFeaturesService {
    private readonly instantiationService;
    private readonly experimentationService;
    private readonly copilotTokenManager;
    _serviceBrand: undefined;
    constructor(instantiationService: IInstantiationService, experimentationService: IExperimentationService, copilotTokenManager: ICompletionsCopilotTokenManager);
    /**
     * Central logic for obtaining the assignments of treatment groups
     * for a given set of filters (i.e. descriptors of who is getting the treatment).
     * Also gets the values of variables controlled by experiment.
     *
     * This function should be called **exactly once** at the start of every
     * 'completion request' in the client (e.g. ghostText, panel request or chat conversation).
     *
     * It is called with an initial set of filters, (FeaturesFilterArgs)
     * but it adds many of its own.
     * At first the general background filters like extension version.
     * Then it will check ExP assignments for the first time, to find out
     * whether there are any assignments of a special granularity
     * (i.e. the concept that we want to redraw assignments based on
     * time bucket, or checksum of time, etc).
     *
     * On most calls to this function, the assignment fetches will be the
     * assignments from previously used filters, so they will be cached and return fast.
     *
     * @param telemetryData The base telemetry object to which the experimental filters, ExP
     * variable values, and experimental assignments will be added. All properties and measurements
     * of the input telemetryData will be present in the output TelemetryWithExp object.
     * Every telemetry data used to generate ExP scorecards (e.g. ghostText events) must
     * include the correct experiment assignments in order to properly create those
     * scorecards.
     */
    updateExPValuesAndAssignments(filtersInfo?: CompletionsFiltersInfo, telemetryData?: TelemetryData): Promise<TelemetryWithExp>;
    /**
     * Request a Copilot token and use that token to call updateExPValuesAndAssignments. Do NOT call this at startup.
     * Instead, register a onCopilotToken handler and use that token with updateExPValuesAndAssignments directly.
     */
    fetchTokenAndUpdateExPValuesAndAssignments(filtersInfo?: CompletionsFiltersInfo, telemetryData?: TelemetryData): Promise<TelemetryWithExp>;
    private createExpConfigAndFilters;
    /** Get the entries from this.assignments corresponding to given settings. */
    getFallbackExpAndFilters(): Promise<{
        filters: FilterSettings;
        exp: ExpConfig;
    }>;
    /** Override for BlockMode to send in the request. */
    overrideBlockMode(telemetryWithExp: TelemetryWithExp): BlockMode | undefined;
    /** Functions with arguments, passed via object destructuring */
    /** @returns the string for copilotcustomengine, or "" if none is set. */
    customEngine(telemetryWithExp: TelemetryWithExp): string;
    /** @returns the string for copilotcustomenginetargetengine, or undefined if none is set. */
    customEngineTargetEngine(telemetryWithExp: TelemetryWithExp): string | undefined;
    /** @returns the percent of prompt tokens to be allocated to the suffix */
    suffixPercent(telemetryWithExp: TelemetryWithExp): number;
    /** @returns the percentage match threshold for using the cached suffix */
    suffixMatchThreshold(telemetryWithExp: TelemetryWithExp): number;
    /** @returns whether to enable the inclusion of C++ headers as neighbor files. */
    cppHeadersEnableSwitch(telemetryWithExp: TelemetryWithExp): boolean;
    /** @returns whether to use included related files as neighbor files for C# (vscode experiment). */
    relatedFilesVSCodeCSharp(telemetryWithExp: TelemetryWithExp): boolean;
    /** @returns whether to use included related files as neighbor files for TS/JS (vscode experiment). */
    relatedFilesVSCodeTypeScript(telemetryWithExp: TelemetryWithExp): boolean;
    /** @returns whether to use included related files as neighbor files (vscode experiment). */
    relatedFilesVSCode(telemetryWithExp: TelemetryWithExp): boolean;
    /** @returns the list of context providers IDs to enable. The special value `*` enables all context providers. */
    contextProviders(telemetryWithExp: TelemetryWithExp): string[];
    contextProviderTimeBudget(languageId: string, telemetryWithExp: TelemetryWithExp): number;
    includeNeighboringFiles(languageId: string, telemetryWithExp: TelemetryWithExp): boolean;
    excludeRelatedFiles(languageId: string, telemetryWithExp: TelemetryWithExp): boolean;
    getContextProviderExpSettings(languageId: string): ContextProviderExpSettings | undefined;
    private getProviderIDs;
    /** @returns the maximal number of tokens of prompt AND completion */
    maxPromptCompletionTokens(telemetryWithExp: TelemetryWithExp): number;
    stableContextPercent(telemetryWithExp: TelemetryWithExp): number;
    volatileContextPercent(telemetryWithExp: TelemetryWithExp): number;
    /** Custom parameters for language specific Context Providers. */
    cppContextProviderParams(telemetryWithExp: TelemetryWithExp): string | undefined;
    csharpContextProviderParams(telemetryWithExp: TelemetryWithExp): string | undefined;
    javaContextProviderParams(telemetryWithExp: TelemetryWithExp): string | undefined;
    multiLanguageContextProviderParams(telemetryWithExp: TelemetryWithExp): string | undefined;
    tsContextProviderParams(telemetryWithExp: TelemetryWithExp): string | undefined;
    completionsDebounce(telemetryWithExp: TelemetryWithExp): number | undefined;
    enableElectronFetcher(telemetryWithExp: TelemetryWithExp): boolean;
    enableFetchFetcher(telemetryWithExp: TelemetryWithExp): boolean;
    asyncCompletionsTimeout(telemetryWithExp: TelemetryWithExp): number;
    enableProgressiveReveal(telemetryWithExp: TelemetryWithExp): boolean;
    modelAlwaysTerminatesSingleline(telemetryWithExp: TelemetryWithExp): boolean;
    longLookaheadSize(telemetryWithExp: TelemetryWithExp): number;
    shortLookaheadSize(telemetryWithExp: TelemetryWithExp): number;
    maxMultilineTokens(telemetryWithExp: TelemetryWithExp): number;
    multilineAfterAcceptLines(telemetryWithExp: TelemetryWithExp): number;
    completionsDelay(telemetryWithExp: TelemetryWithExp): number;
    singleLineUnlessAccepted(telemetryWithExp: TelemetryWithExp): boolean;
}
//# sourceMappingURL=features.d.ts.map