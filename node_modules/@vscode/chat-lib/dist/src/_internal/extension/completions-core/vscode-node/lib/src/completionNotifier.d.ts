import { ICompletionsTelemetryService } from '../../bridge/src/completionsTelemetryServiceBridge';
import { CancellationToken, Disposable } from '../../types/src';
import { CompletionState } from './completionState';
import { GetGhostTextOptions } from './ghostText/ghostText';
import { TelemetryWithExp } from './telemetry';
import { ICompletionsPromiseQueueService } from './util/promiseQueue';
export type CompletionRequestedEvent = {
    completionId: string;
    completionState: CompletionState;
    telemetryData: TelemetryWithExp;
    cancellationToken?: CancellationToken;
    options?: Partial<GetGhostTextOptions>;
};
export declare const ICompletionsNotifierService: import("../../../../../util/common/services").ServiceIdentifier<ICompletionsNotifierService>;
export interface ICompletionsNotifierService {
    readonly _serviceBrand: undefined;
    notifyRequest(completionState: CompletionState, completionId: string, telemetryData: TelemetryWithExp, cancellationToken?: CancellationToken, options?: Partial<GetGhostTextOptions>): void;
    onRequest(listener: (event: CompletionRequestedEvent) => void): Disposable;
}
export declare class CompletionNotifier implements ICompletionsNotifierService {
    #private;
    protected completionsPromiseQueue: ICompletionsPromiseQueueService;
    protected completionsTelemetryService: ICompletionsTelemetryService;
    _serviceBrand: undefined;
    constructor(completionsPromiseQueue: ICompletionsPromiseQueueService, completionsTelemetryService: ICompletionsTelemetryService);
    notifyRequest(completionState: CompletionState, completionId: string, telemetryData: TelemetryWithExp, cancellationToken?: CancellationToken, options?: Partial<GetGhostTextOptions>): boolean;
    onRequest(listener: (event: CompletionRequestedEvent) => void): Disposable;
}
//# sourceMappingURL=completionNotifier.d.ts.map