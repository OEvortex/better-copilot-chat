import { IndentationSubTree, IndentationTree, TopNode } from './classes';
/**
 * Clear all labels (and their types) from the tree.
 * This will modify the tree in place, or return a retyped tree.
 */
export declare function clearLabels<L>(tree: IndentationTree<L>): IndentationTree<never>;
/** clear labels if condition is true */
export declare function clearLabelsIf<L, S>(tree: IndentationTree<L | S>, condition: (arg: L | S) => arg is S): IndentationTree<L>;
export declare function mapLabels<L1, L2>(tree: IndentationSubTree<L1>, map: (arg: L1) => L2 | undefined): IndentationSubTree<L2>;
export declare function mapLabels<L1, L2>(tree: TopNode<L1>, map: (arg: L1) => L2 | undefined): TopNode<L2>;
export declare function mapLabels<L1, L2>(tree: IndentationTree<L1>, map: (arg: L1) => L2 | undefined): IndentationTree<L2>;
/**
 * Renumber the line numbers of the tree contiguously from 0 and up.
 */
export declare function resetLineNumbers<L>(tree: IndentationTree<L>): void;
/**
 * Visit the tree with a function that is called on each node.
 *
 * If direction is topDown, then parents are visited before their children.
 * If direction is bottomUp, children are visited in order before their parents,
 * so that leaf nodes are visited first.
 */
export declare function visitTree<L>(tree: IndentationTree<L>, visitor: (tree: IndentationTree<L>) => void, direction: 'topDown' | 'bottomUp'): void;
/**
 * Visit the tree with a function that is called on each node --
 * if it returns false, children are not visited (in case of topDown),
 * or the parent is not visited anymore (in case of bottomUp).
 *
 * If direction is topDown, then parents are visited before their children.
 * If direction is bottomUp, children are visited in order before their parents,
 * so that leaf nodes are visited first.
 */
export declare function visitTreeConditionally<L>(tree: IndentationTree<L>, visitor: (tree: IndentationTree<L>) => boolean, direction: 'topDown' | 'bottomUp'): void;
/**
 * Fold an accumulator function over the tree.
 *
 * If direction is topDown, then parents are visited before their children.
 * If direction is bottomUp, children are visited in order before their parents,
 * so that leaf nodes are visited first.
 */
export declare function foldTree<T, L>(tree: IndentationTree<L>, init: T, accumulator: (tree: IndentationTree<L>, acc: T) => T, direction: 'topDown' | 'bottomUp'): T;
export type Rebuilder<L> = (tree: IndentationTree<L>) => IndentationTree<L> | undefined;
/**
 * Rebuild the tree from the bottom up by applying a function to each node.
 * The visitor function takes a node whose children have already been rebuilt,
 * and returns a new node to replace it (or undefined if it should be deleted).
 * Optionally, a function can be provided to skip nodes that should just be kept
 * without visiting them or their sub-nodes.
 */
export declare function rebuildTree<L>(tree: IndentationTree<L>, visitor: Rebuilder<L>, skip?: (tree: IndentationTree<L>) => boolean): IndentationTree<L>;
//# sourceMappingURL=manipulation.d.ts.map