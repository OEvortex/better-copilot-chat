import Parser, { SyntaxNode } from 'web-tree-sitter';
export declare abstract class StatementNode {
    readonly node: SyntaxNode;
    readonly children: StatementNode[];
    parent: StatementNode | undefined;
    nextSibling: StatementNode | undefined;
    protected collapsed: boolean;
    constructor(node: SyntaxNode);
    addChild(child: StatementNode): void;
    /**
     * Called after the last child is added to this node when the tree is being
     * constructed. This is a callback derived classes can use to do any additional
     * processing once this branch of the tree is complete. The default behavior
     * is to do nothing.
     */
    childrenFinished(): void;
    containsStatement(stmt: StatementNode): boolean;
    statementAt(offset: number): StatementNode | undefined;
    abstract get isCompoundStatementType(): boolean;
    /** Treat this node and its children as a single statement */
    protected collapse(): void;
    get description(): string;
    dump(prefix1?: string, prefix2?: string): string;
    dumpPath(prefix1?: string, prefix2?: string, forChild?: boolean): string;
}
/**
 * A simplified view of a syntax tree.
 *
 * It contains only nodes which represent complete statements. Because statements may
 * be compound, a single statement may contain other statements within it.
 *
 * "Statement" refers to a syntactic unit of the language. It represents the smallest
 * division of a code completion we would consider when truncating. It may be a simple
 * statement such as:
 *
 *   `x = 1;`
 *
 * or a compound statement such as:
 *
 *   `if (x > 0) { x = 2; }`
 *
 * where the entire string comprises the parent statement, and `x = 2;` is
 * a child statement of the parent. Note that `x > 0` is not a statement, but
 * an expression.
 *
 * The view is further constrained to a portion of the overall document (the start and
 * end offsets). This view contains all statements which intersect that region, so
 * containing statements are included in the view, even though they may extend
 * beyond the region.
 */
export declare abstract class StatementTree implements Disposable {
    private readonly languageId;
    private readonly text;
    private readonly startOffset;
    private readonly endOffset;
    protected tree: Parser.Tree | undefined;
    readonly statements: StatementNode[];
    static isSupported(languageId: string): boolean;
    static isTrimmedByDefault(languageId: string): boolean;
    static create(languageId: string, text: string, startOffset: number, endOffset: number): StatementTree;
    constructor(languageId: string, text: string, startOffset: number, endOffset: number);
    [Symbol.dispose](): void;
    clear(): void;
    statementAt(offset: number): StatementNode | undefined;
    build(): Promise<void>;
    protected abstract createNode(node: SyntaxNode): StatementNode;
    protected abstract getStatementQueryText(): string;
    protected addStatement(stmt: StatementNode): void;
    protected parse(): Promise<Parser.Tree>;
    protected getStatementQuery(tree: Parser.Tree): Parser.Query;
    protected getQuery(language: Parser.Language, queryText: string): Parser.Query;
    protected offsetToPosition(offset: number): Parser.Point;
    dump(prefix?: string): string;
}
//# sourceMappingURL=statementTree.d.ts.map