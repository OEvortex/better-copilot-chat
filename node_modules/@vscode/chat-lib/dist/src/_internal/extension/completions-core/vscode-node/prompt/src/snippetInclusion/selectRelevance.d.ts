import { DocumentInfo, DocumentInfoWithOffset, SimilarFileInfo } from '../prompt';
import { CursorContextInfo } from './cursorContext';
import { SnippetWithProviderInfo } from './snippets';
export interface ScoredSnippetMarker {
    score: number;
    startLine: number;
    endLine: number;
}
/**
 * A snippet of code together with a relevance score.
 *
 * The scoring system assumes that a snippet with a **bigger** score is **more** relevant.
 */
export interface ScoredSnippet extends ScoredSnippetMarker {
    snippet: string;
    relativePath?: string;
}
export declare enum SortOptions {
    Ascending = "ascending",
    Descending = "descending",
    None = "none"
}
declare class Tokenizer {
    private readonly stopsForLanguage;
    constructor(doc: DocumentInfo);
    tokenize(a: string): Set<string>;
}
/**
 * For a given document, extracts the best matching snippets from other documents
 * by comparing all of a set of windows in the object doc.
 */
export declare abstract class WindowedMatcher {
    protected referenceDoc: DocumentInfoWithOffset;
    protected tokenizer: Tokenizer;
    protected abstract id(): string;
    protected abstract similarityScore(a: Set<string>, b: Set<string>): number;
    /**
     * Given an array of lines, returns an array of pairs <startLine, endLine> of indices,
     * such that each pair is a window of lines to consider adding.
     * startLine is inclusive, endLine is exclusive.
     * @param lines Lines of a source text, in order
     */
    protected abstract getWindowsDelineations(lines: string[]): [number, number][];
    /**
     * Subclasses should implement this method to return the desired context info for tokenization
     * from the reference document. Will only be called after constructor is finished.
     * The tokenizer used in WindowedMatcher is a simple tokenizer for Jaccard similarity, NOT an
     * OpenAI model tokenizer.
     */
    protected abstract _getCursorContextInfo(referenceDoc: DocumentInfoWithOffset): CursorContextInfo;
    protected constructor(referenceDoc: DocumentInfoWithOffset);
    /**
     * Lazy getter for referenceTokens since it relies on properties
     * that are not initialized in the constructor of WindowedMatcher
     * but in the constructor of its subclasses.
     */
    protected referenceTokensCache: Set<string> | undefined;
    get referenceTokens(): Promise<Set<string>>;
    private createReferenceTokens;
    /**
     * Returns a sorted array of snippets with their scores according to the sort option.
     * @param snippets ScoredSnippet[]
     *
     */
    sortScoredSnippets(snippets: ScoredSnippetMarker[], sortOption?: SortOptions): ScoredSnippetMarker[];
    /**
     * Returns all snippet markers with their scores.
     * @param objectDoc
     *
     */
    retrieveAllSnippets(objectDoc: SimilarFileInfo, sortOption?: SortOptions): Promise<ScoredSnippetMarker[]>;
    findMatches(objectDoc: SimilarFileInfo, maxSnippetsPerFile: number): Promise<SnippetWithProviderInfo[]>;
    /**
     * Returns the snippet from the object document
     * that is most similar to the reference Document
     * together with its Jaccard score
     *
     * @param objectDoc
     */
    findBestMatch(objectDoc: SimilarFileInfo, maxSnippetsPerFile: number): Promise<SnippetWithProviderInfo[]>;
}
/**
 * Split by non-alphanumeric characters
 */
export declare function splitIntoWords(a: string): string[];
export {};
//# sourceMappingURL=selectRelevance.d.ts.map