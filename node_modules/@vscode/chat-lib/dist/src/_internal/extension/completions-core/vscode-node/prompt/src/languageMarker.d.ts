import { DocumentInfo } from './prompt';
/**
 * Interface for writing single-line comments in a given language.
 * Does not include the terminal new-line character (i.e. for many languages,
 * `end` will just be the empty string).
 */
interface CommentMarker {
    start: string;
    end: string;
}
interface ILanguageInfo {
    readonly lineComment: CommentMarker;
    /**
     * if not set, defaults to the language id
     */
    readonly markdownLanguageIds?: string[];
}
interface ILanguage extends ILanguageInfo {
    readonly languageId: string;
}
/**
 * Language files in VSCode:
 * https://code.visualstudio.com/docs/languages/identifiers#_known-language-identifiers
 *
 * Missing below from this list are:
 * Diff diff
 * Git git-commit and git-rebase
 * JSON json
 * ShaderLab shaderlab
 * Additional to that list are:
 * Erlang
 * Haskell
 * Kotlin
 * QL
 * Scala
 * Verilog
 *
 * Markdown ids from https://raw.githubusercontent.com/highlightjs/highlight.js/refs/heads/main/SUPPORTED_LANGUAGES.md
 * Also refer to [vscode-copilot-chat](https://github.com/microsoft/vscode-copilot-chat/blob/main/src/util/common/languages.ts)
 */
export declare const languageMarkers: {
    [language: string]: ILanguageInfo;
};
export declare function mdCodeBlockLangToLanguageId(mdLanguageId: string): string | undefined;
/**
 * Determine if a line is a shebang line for a known language
 * @param line The line to check
 * @returns The language if it is a known shebang line, otherwise undefined
 */
export declare function isShebangLine(line: string): boolean;
/**
 * Best-effort determining whether the top of the source already contains a
 * discernible language marker, in particular a shebang line
 * @param languageId The string name of the language
 * @returns True iff we determined a recognisable language marker
 */
export declare function hasLanguageMarker({ source }: DocumentInfo): boolean;
/**
 * Comment a single line of text in a given language.
 * E.g. for python, turn "hello there" into "# hello there"
 *
 * Note: This will not behave as you expect if `text` has multiple lines. In
 * that case, use {@link commentBlockAsSingles} instead.
 */
export declare function comment(text: string, languageId: string): string;
/**
 * Comment a block of text using single-line comments.
 *
 * The returned comment block will have a trailing newline exactly when the
 * input does.
 */
export declare function commentBlockAsSingles(text: string, languageId: string): string;
/**
 * Return a one-line comment or text which describes the language of a
 * document, e.g. a shebang line or a comment.
 *
 * @param doc The document we want the marker for.
 * @returns A one-line string that describes the language.
 */
export declare function getLanguageMarker(doc: DocumentInfo): string;
/**
 * Return a one-line comment containing the relative path of the document, if known.
 *
 * @param doc The document we want the marker for.
 * @param defaultCommentMarker The comment marker to use if the language does not have one.
 * @returns A one-line comment that contains the relative path of the document.
 */
export declare function getPathMarker(doc: DocumentInfo): string;
/**
 * Appends a new line to a string if it does not already end with one.
 *
 * @param str String to append
 *
 * @returns A string with a new line escape character at the end.
 */
export declare function newLineEnded(str: string): string;
/**
 * Retrieves the language for a given language identifier.
 *
 * @param languageId - The identifier of the language. If undefined, defaults to 'plaintext'.
 * @returns The language associated with the specified language identifier.
 */
export declare function getLanguage(languageId: string | undefined): ILanguage;
export {};
//# sourceMappingURL=languageMarker.d.ts.map