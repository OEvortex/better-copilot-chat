import { IConfigurationService } from '../../../platform/configuration/common/configurationService';
import { DocumentId } from '../../../platform/inlineEdits/common/dataTypes/documentId';
import { ObservableWorkspace } from '../../../platform/inlineEdits/common/observableWorkspace';
import { ILogService } from '../../../platform/log/common/logService';
import { IExperimentationService } from '../../../platform/telemetry/common/nullExperimentationService';
import { Disposable } from '../../../util/vs/base/common/lifecycle';
import { AnnotatedStringReplacement, StringEdit, StringReplacement } from '../../../util/vs/editor/common/core/edits/stringEdit';
import { OffsetRange } from '../../../util/vs/editor/common/core/ranges/offsetRange';
import { StringText } from '../../../util/vs/editor/common/core/text/abstractText';
import { EditDataWithIndex } from '../common/editRebase';
import { INesConfigs } from './nesConfigs';
import { NextEditFetchRequest } from './nextEditProvider';
export interface CachedEdit {
    docId: DocumentId;
    documentBeforeEdit: StringText;
    editWindow?: OffsetRange;
    edit?: StringReplacement;
    edits?: StringReplacement[];
    detailedEdits: AnnotatedStringReplacement<EditDataWithIndex>[][];
    userEditSince?: StringEdit;
    rebaseFailed?: boolean;
    rejected?: boolean;
    /**
     * When caching multiple edits, this is the order in which they were applied.
     */
    subsequentN?: number;
    source: NextEditFetchRequest;
    cacheTime: number;
}
export type CachedOrRebasedEdit = CachedEdit & {
    rebasedEdit?: StringReplacement;
    rebasedEditIndex?: number;
};
export declare class NextEditCache extends Disposable {
    readonly workspace: ObservableWorkspace;
    private readonly _logService;
    private readonly _documentCaches;
    private readonly _sharedCache;
    constructor(workspace: ObservableWorkspace, _logService: ILogService, configService: IConfigurationService, expService: IExperimentationService);
    setKthNextEdit(docId: DocumentId, documentContents: StringText, editWindow: OffsetRange | undefined, nextEdit: StringReplacement, subsequentN: number, nextEdits: StringReplacement[] | undefined, userEditSince: StringEdit | undefined, source: NextEditFetchRequest): CachedEdit | undefined;
    setNoNextEdit(docId: DocumentId, documentContents: StringText, editWindow: OffsetRange | undefined, source: NextEditFetchRequest): void;
    lookupNextEdit(docId: DocumentId, currentDocumentContents: StringText, currentSelection: readonly OffsetRange[], nesConfigs: INesConfigs): CachedOrRebasedEdit | undefined;
    tryRebaseCacheEntry(cachedEdit: CachedEdit, currentDocumentContents: StringText, currentSelection: readonly OffsetRange[], nesConfigs: INesConfigs): CachedOrRebasedEdit | undefined;
    rejectedNextEdit(requestId: string): void;
    isRejectedNextEdit(docId: DocumentId, currentDocumentContents: StringText, edit: StringReplacement, nesConfigs: INesConfigs): boolean;
    evictedCachedEdit(cachedEdit: CachedEdit): void;
    clear(): void;
}
//# sourceMappingURL=nextEditCache.d.ts.map