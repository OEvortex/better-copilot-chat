"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
var UserInteractionMonitor_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UserInteractionMonitor = void 0;
const configurationService_1 = require("../../../platform/configuration/common/configurationService");
const xtabPromptOptions_1 = require("../../../platform/inlineEdits/common/dataTypes/xtabPromptOptions");
const nullExperimentationService_1 = require("../../../platform/telemetry/common/nullExperimentationService");
const delay_1 = require("./delay");
let UserInteractionMonitor = class UserInteractionMonitor {
    static { UserInteractionMonitor_1 = this; }
    static { this.MAX_INTERACTIONS_CONSIDERED = 10; }
    constructor(_configurationService, _experimentationService) {
        this._configurationService = _configurationService;
        this._experimentationService = _experimentationService;
        this._recentUserActions = [];
    }
    // Capture user interactions
    handleAcceptance() {
        this._recordUserAction('accepted');
    }
    handleRejection() {
        this._recordUserAction('rejected');
    }
    _recordUserAction(kind) {
        this._recentUserActions.push({ time: Date.now(), kind });
        // keep at most 10 user actions
        this._recentUserActions = this._recentUserActions.slice(-UserInteractionMonitor_1.MAX_INTERACTIONS_CONSIDERED);
    }
    // Creates a DelaySession based on recent user interactions
    createDelaySession(requestTime) {
        const baseDebounceTime = this._configurationService.getExperimentBasedConfig(configurationService_1.ConfigKey.TeamInternal.InlineEditsDebounce, this._experimentationService);
        const backoffDebounceEnabled = this._configurationService.getExperimentBasedConfig(configurationService_1.ConfigKey.TeamInternal.InlineEditsBackoffDebounceEnabled, this._experimentationService);
        const expectedTotalTime = backoffDebounceEnabled ? this._getExpectedTotalTime(baseDebounceTime) : undefined;
        return new delay_1.DelaySession(baseDebounceTime, expectedTotalTime, requestTime);
    }
    _getExpectedTotalTime(baseDebounceTime) {
        const DEBOUNCE_DECAY_TIME_MS = 10 * 60 * 1000; // 10 minutes
        const MAX_DEBOUNCE_TIME = 3000; // 3 seconds
        const MIN_DEBOUNCE_TIME = 50; // 50 ms
        const REJECTION_WEIGHT = 1.5;
        const ACCEPTANCE_WEIGHT = 0.8;
        const now = Date.now();
        let multiplier = 1;
        // Calculate impact of each action with time decay
        for (const action of this._recentUserActions) {
            const timeSinceAction = now - action.time;
            if (timeSinceAction > DEBOUNCE_DECAY_TIME_MS) {
                continue;
            }
            // Exponential decay: impact decreases as time passes
            const decayFactor = Math.exp(-timeSinceAction / DEBOUNCE_DECAY_TIME_MS);
            const actionWeight = action.kind === 'rejected' ? REJECTION_WEIGHT : ACCEPTANCE_WEIGHT;
            multiplier *= 1 + ((actionWeight - 1) * decayFactor);
        }
        let debounceTime = baseDebounceTime * multiplier;
        // Clamp the debounce time to reasonable bounds
        debounceTime = Math.min(MAX_DEBOUNCE_TIME, Math.max(MIN_DEBOUNCE_TIME, debounceTime));
        return debounceTime;
    }
    // Determine aggressiveness level based on user interactions
    getAggressivenessLevel() {
        const configuredAggressivenessLevel = this._configurationService.getExperimentBasedConfig(configurationService_1.ConfigKey.TeamInternal.InlineEditsXtabAggressivenessLevel, this._experimentationService);
        if (configuredAggressivenessLevel !== undefined) {
            return configuredAggressivenessLevel;
        }
        const userHappinessScore = this._getUserHappinessScore();
        if (userHappinessScore >= 0.7) {
            return xtabPromptOptions_1.AggressivenessLevel.High;
        }
        else if (userHappinessScore >= 0.4) {
            return xtabPromptOptions_1.AggressivenessLevel.Medium;
        }
        else {
            return xtabPromptOptions_1.AggressivenessLevel.Low;
        }
    }
    /**
     * Value between 0 and 1 indicating user happiness.
     * 1 means very happy, 0 means very unhappy.
     */
    _getUserHappinessScore() {
        if (this._recentUserActions.length === 0) {
            return 0.5; // neutral score when no data
        }
        let weightedScore = 0;
        let totalWeight = 0;
        for (let i = 0; i < this._recentUserActions.length; i++) {
            const action = this._recentUserActions[i];
            // Calculate weight based on position (more recent = higher weight)
            // Position 0 (oldest) has lowest weight, last position has highest weight
            const weight = i + 1;
            // Accepted = 1, Rejected = 0
            const score = action.kind === 'accepted' ? 1 : 0;
            weightedScore += score * weight;
            totalWeight += weight;
        }
        const rawScore = totalWeight > 0 ? weightedScore / totalWeight : 0.5;
        // Adjust score towards neutral (0.5) when we have fewer data points
        // This prevents extreme scores with limited data
        const dataConfidence = this._recentUserActions.length / UserInteractionMonitor_1.MAX_INTERACTIONS_CONSIDERED;
        return 0.5 + (rawScore - 0.5) * dataConfidence;
    }
};
exports.UserInteractionMonitor = UserInteractionMonitor;
exports.UserInteractionMonitor = UserInteractionMonitor = UserInteractionMonitor_1 = __decorate([
    __param(0, configurationService_1.IConfigurationService),
    __param(1, nullExperimentationService_1.IExperimentationService)
], UserInteractionMonitor);
//# sourceMappingURL=userInteractionMonitor.js.map