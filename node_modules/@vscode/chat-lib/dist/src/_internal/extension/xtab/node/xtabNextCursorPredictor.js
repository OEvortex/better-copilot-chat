"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __param = (this && this.__param) || function (paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.XtabNextCursorPredictor = void 0;
const copilot_api_1 = require("@vscode/copilot-api");
const commonTypes_1 = require("../../../platform/chat/common/commonTypes");
const configurationService_1 = require("../../../platform/configuration/common/configurationService");
const chatEndpoint_1 = require("../../../platform/endpoint/node/chatEndpoint");
const nextCursorLinePrediction_1 = require("../../../platform/inlineEdits/common/dataTypes/nextCursorLinePrediction");
const nullExperimentationService_1 = require("../../../platform/telemetry/common/nullExperimentationService");
const errors_1 = require("../../../util/common/errors");
const result_1 = require("../../../util/common/result");
const tokenizer_1 = require("../../../util/common/tokenizer");
const assert_1 = require("../../../util/vs/base/common/assert");
const cancellation_1 = require("../../../util/vs/base/common/cancellation");
const instantiation_1 = require("../../../util/vs/platform/instantiation/common/instantiation");
const promptCrafting_1 = require("../common/promptCrafting");
const xtabUtils_1 = require("./xtabUtils");
let XtabNextCursorPredictor = class XtabNextCursorPredictor {
    constructor(computeTokens, instaService, configService, expService) {
        this.computeTokens = computeTokens;
        this.instaService = instaService;
        this.configService = configService;
        this.expService = expService;
        this.isDisabled = false;
    }
    determineEnablement() {
        if (this.isDisabled) {
            return undefined;
        }
        const originalNextCursorLinePrediction = this.configService.getExperimentBasedConfig(configurationService_1.ConfigKey.TeamInternal.InlineEditsNextCursorPredictionEnabled, this.expService);
        switch (originalNextCursorLinePrediction) {
            case nextCursorLinePrediction_1.NextCursorLinePrediction.OnlyWithEdit:
            case nextCursorLinePrediction_1.NextCursorLinePrediction.Jump:
            case undefined:
                return originalNextCursorLinePrediction;
            // remove support for LabelOnlyWithEdit
            case nextCursorLinePrediction_1.NextCursorLinePrediction.LabelOnlyWithEdit:
                return nextCursorLinePrediction_1.NextCursorLinePrediction.OnlyWithEdit;
            // for backward compatibility
            case true:
                return nextCursorLinePrediction_1.NextCursorLinePrediction.OnlyWithEdit;
            case false:
                return undefined;
            default:
                (0, assert_1.assertNever)(originalNextCursorLinePrediction);
        }
    }
    async predictNextCursorPosition(promptPieces, parentTracer) {
        const tracer = parentTracer.sub('predictNextCursorPosition');
        const systemMessage = `Your task is to predict the next line number in the current file where the developer is most likely to make their next edit, using the provided context. If you don't think anywhere is a good next line jump target, just output the current line number of the cursor. Make sure to just output the line number and nothing else (no explanation, reasoning, etc.).`;
        const maxTokens = this.configService.getExperimentBasedConfig(configurationService_1.ConfigKey.Advanced.InlineEditsNextCursorPredictionCurrentFileMaxTokens, this.expService);
        const currentFileContentR = (0, promptCrafting_1.constructTaggedFile)(promptPieces.currentDocument, promptPieces.editWindowLinesRange, promptPieces.areaAroundEditWindowLinesRange, {
            ...promptPieces.opts,
            currentFile: {
                ...promptPieces.opts.currentFile,
                maxTokens,
                includeTags: false,
            }
        }, this.computeTokens, { includeLineNumbers: { areaAroundCodeToEdit: false, currentFileContent: true } });
        if (currentFileContentR.isError()) {
            tracer.trace(`Failed to construct tagged file: ${currentFileContentR.err}`);
            return result_1.Result.fromString(currentFileContentR.err);
        }
        const { taggedCurrentDocLines, areaAroundCodeToEdit } = currentFileContentR.val;
        const newPromptPieces = new promptCrafting_1.PromptPieces(promptPieces.currentDocument, promptPieces.editWindowLinesRange, promptPieces.areaAroundEditWindowLinesRange, promptPieces.activeDoc, promptPieces.xtabHistory, taggedCurrentDocLines, areaAroundCodeToEdit, promptPieces.langCtx, promptPieces.aggressivenessLevel, this.computeTokens, {
            ...promptPieces.opts,
            includePostScript: false,
        });
        const userMessage = (0, promptCrafting_1.getUserPrompt)(newPromptPieces);
        const messages = (0, xtabUtils_1.constructMessages)({
            systemMsg: systemMessage,
            userMsg: userMessage
        });
        const modelName = this.configService.getExperimentBasedConfig(configurationService_1.ConfigKey.TeamInternal.InlineEditsNextCursorPredictionModelName, this.expService);
        if (modelName === undefined) {
            tracer.trace('Model name for cursor prediction is not defined; skipping prediction');
            return result_1.Result.fromString('modelNameNotDefined');
        }
        const url = this.configService.getConfig(configurationService_1.ConfigKey.TeamInternal.InlineEditsNextCursorPredictionUrl);
        const secretKey = this.configService.getConfig(configurationService_1.ConfigKey.TeamInternal.InlineEditsNextCursorPredictionApiKey);
        const endpoint = this.instaService.createInstance(chatEndpoint_1.ChatEndpoint, {
            id: modelName,
            name: 'nes.nextCursorPosition',
            urlOrRequestMetadata: url ? url : { type: copilot_api_1.RequestType.ProxyChatCompletions },
            model_picker_enabled: false,
            is_chat_default: false,
            is_chat_fallback: false,
            version: '',
            capabilities: {
                type: 'chat',
                family: '',
                tokenizer: tokenizer_1.TokenizerType.CL100K,
                limits: undefined,
                supports: {
                    parallel_tool_calls: false,
                    tool_calls: false,
                    streaming: true,
                    vision: false,
                    prediction: false,
                    thinking: false
                }
            },
        });
        const maxResponseTokens = this.configService.getExperimentBasedConfig(configurationService_1.ConfigKey.TeamInternal.InlineEditsNextCursorPredictionMaxResponseTokens, this.expService);
        let requestOptions = {
            max_tokens: maxResponseTokens,
        };
        if (secretKey) {
            requestOptions = { ...requestOptions, secretKey };
        }
        const response = await endpoint.makeChatRequest2({
            messages,
            debugName: 'nes.nextCursorPosition',
            finishedCb: undefined,
            location: commonTypes_1.ChatLocation.Other,
            requestOptions,
        }, cancellation_1.CancellationToken.None);
        if (response.type !== commonTypes_1.ChatFetchResponseType.Success) {
            if (response.type === commonTypes_1.ChatFetchResponseType.NotFound) {
                tracer.trace('Next cursor position prediction endpoint not found; disabling predictor for current session.');
                this.isDisabled = true;
            }
            return result_1.Result.fromString(`fetchError:${response.type}`);
        }
        try {
            const trimmed = response.value.trim();
            const lineNumber = parseInt(trimmed, 10);
            if (isNaN(lineNumber)) {
                return result_1.Result.fromString(`gotNaN`);
            }
            if (lineNumber < 0) {
                return result_1.Result.fromString(`negativeLineNumber`);
            }
            return result_1.Result.ok(lineNumber);
        }
        catch (err) {
            tracer.trace(`Failed to parse predicted line number from response '${response.value}': ${err}`);
            return result_1.Result.fromString(`failedToParseLine:"${response.value}". Error ${(0, errors_1.fromUnknown)(err).message}`);
        }
    }
};
exports.XtabNextCursorPredictor = XtabNextCursorPredictor;
exports.XtabNextCursorPredictor = XtabNextCursorPredictor = __decorate([
    __param(1, instantiation_1.IInstantiationService),
    __param(2, configurationService_1.IConfigurationService),
    __param(3, nullExperimentationService_1.IExperimentationService)
], XtabNextCursorPredictor);
//# sourceMappingURL=xtabNextCursorPredictor.js.map