export type Task<T = void> = () => (Promise<T> | T);
/**
 * Processes tasks in the order they were scheduled.
*/
export declare class TaskQueue {
    private _runningTask;
    private _pendingTasks;
    /**
     * Waits for the current and pending tasks to finish, then runs and awaits the given task.
     * If the task is skipped because of clearPending, the promise is rejected with a CancellationError.
    */
    schedule<T>(task: Task<T>): Promise<T>;
    /**
     * Waits for the current and pending tasks to finish, then runs and awaits the given task.
     * If the task is skipped because of clearPending, the promise is resolved with undefined.
    */
    scheduleSkipIfCleared<T>(task: Task<T>): Promise<T | undefined>;
    private _runIfNotRunning;
    private _processQueue;
    /**
     * Clears all pending tasks. Does not cancel the currently running task.
    */
    clearPending(): void;
}
export declare class BatchedProcessor<TArg, TResult> {
    private readonly _fn;
    private readonly _waitingTimeMs;
    private _queue;
    private _timeout;
    constructor(_fn: (args: TArg[]) => Promise<TResult[]>, _waitingTimeMs: number);
    request(arg: TArg): Promise<TResult>;
    private _flush;
}
export declare function raceFilter<T>(promises: Promise<T>[], filter: (result: T) => boolean): Promise<T | undefined>;
//# sourceMappingURL=async.d.ts.map