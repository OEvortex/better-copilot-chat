"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
exports.Tracer = void 0;
exports.createTracer = createTracer;
class Tracer {
    constructor(section, logFn) {
        this.section = section;
        this.logFn = logFn;
    }
    trace(message, ...payload) {
        this.logFn(this.argsToString(message, payload));
    }
    argsToString(message, payload) {
        const payloadStr = payload.length ? ` ${this.stringify(payload)}` : '';
        return `[${this.sectionStr}] ${message}${payloadStr}`;
    }
    sub(name, opts) {
        const sub = this.subNoEntry(name, opts);
        sub.trace('created');
        return sub;
    }
    subNoEntry(name, opts) {
        const subSection = this.createSubSection(name);
        const extraLog = opts?.extraLog;
        const logFn = (extraLog === undefined
            ? this.logFn
            : (message) => {
                this.logFn(message);
                extraLog(message);
            });
        const sub = new Tracer(subSection, logFn);
        return sub;
    }
    throws(message, ...payload) {
        const payloadStr = payload.length ? ` ${this.stringify(payload)}` : '';
        this.logFn(`[${this.sectionStr}] Throw: ${message ? message : 'void'}${payloadStr}`);
    }
    returns(message, ...payload) {
        const payloadStr = payload.length ? ` ${this.stringify(payload)}` : '';
        this.logFn(`[${this.sectionStr}] Return: ${message ? message : 'void'}${payloadStr}`);
    }
    get sectionStr() {
        return Array.isArray(this.section) ? this.section.join('][') : this.section;
    }
    createSubSection(name) {
        return Array.isArray(this.section) ? this.section.concat(name) : [this.section, ...(Array.isArray(name) ? name : [name])];
    }
    stringify(value) {
        function stringifyObj(obj) {
            const toStringValue = obj.toString();
            if (toStringValue && toStringValue !== '[object Object]') {
                return toStringValue;
            }
            if (obj instanceof Error) {
                return obj.stack || obj.message;
            }
            return JSON.stringify(obj, null, 2);
        }
        if (!value) {
            return JSON.stringify(value, null, 2);
        }
        if (typeof value === 'string') {
            return value;
        }
        if (typeof value === 'function') {
            return value.name ? `[Function: ${value.name}]` : '[Function]';
        }
        if (Array.isArray(value)) {
            return `[${value.map(v => this.stringify(v)).join(', ')}]`;
        }
        if (typeof value === 'object') {
            return stringifyObj(value);
        }
        const valueToString = value.toString();
        if (valueToString && valueToString !== '[object Object]') {
            return valueToString;
        }
        return stringifyObj(value);
    }
}
exports.Tracer = Tracer;
function createTracer(section, logFn) {
    return new Tracer(section, logFn);
}
//# sourceMappingURL=tracing.js.map