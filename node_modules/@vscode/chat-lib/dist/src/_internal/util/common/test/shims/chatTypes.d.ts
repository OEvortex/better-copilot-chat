import type * as vscode from 'vscode';
export declare class ChatResponseMarkdownPart {
    value: vscode.MarkdownString;
    constructor(value: string | vscode.MarkdownString);
}
export declare class ChatResponseCodeblockUriPart {
    isEdit?: boolean;
    value: vscode.Uri;
    undoStopId?: string;
    constructor(value: vscode.Uri, isEdit?: boolean, undoStopId?: string);
}
export declare class ChatResponseFileTreePart {
    value: vscode.ChatResponseFileTree[];
    baseUri: vscode.Uri;
    constructor(value: vscode.ChatResponseFileTree[], baseUri: vscode.Uri);
}
export declare class ChatResponseAnchorPart {
    value: vscode.Uri | vscode.Location;
    value2: any;
    title?: string;
    constructor(value: vscode.Uri | vscode.Location, title?: string);
}
export declare class ChatResponseProgressPart {
    value: string;
    constructor(value: string);
}
export declare class ChatResponseThinkingProgressPart {
    value: string | string[];
    id?: string;
    metadata?: {
        readonly [key: string]: any;
    };
    constructor(value: string | string[], id?: string, metadata?: {
        readonly [key: string]: any;
    });
}
export declare class ChatResponseExternalEditPart {
    uris: vscode.Uri[];
    callback: () => Thenable<unknown>;
    applied: Thenable<string>;
    didGetApplied: (value: string) => void;
    constructor(uris: vscode.Uri[], callback: () => Thenable<unknown>);
}
export declare class ChatResponseProgressPart2 {
    value: string;
    task?: (progress: vscode.Progress<vscode.ChatResponseWarningPart>) => Thenable<string | void>;
    constructor(value: string, task?: (progress: vscode.Progress<vscode.ChatResponseWarningPart>) => Thenable<string | void>);
}
export declare class ChatResponseWarningPart {
    value: vscode.MarkdownString;
    constructor(value: string | vscode.MarkdownString);
}
export declare class ChatResponseReferencePart {
    value: vscode.Uri | vscode.Location;
    constructor(value: vscode.Uri | vscode.Location);
}
export declare class ChatResponseReferencePart2 {
    value: vscode.Uri | vscode.Location | {
        variableName: string;
        value?: vscode.Uri | vscode.Location;
    };
    iconPath?: vscode.Uri | vscode.ThemeIcon | {
        light: vscode.Uri;
        dark: vscode.Uri;
    };
    options?: {
        status?: {
            description: string;
            kind: vscode.ChatResponseReferencePartStatusKind;
        };
    };
    constructor(value: vscode.Uri | vscode.Location | {
        variableName: string;
        value?: vscode.Uri | vscode.Location;
    }, iconPath?: vscode.Uri | vscode.ThemeIcon | {
        light: vscode.Uri;
        dark: vscode.Uri;
    }, options?: {
        status?: {
            description: string;
            kind: vscode.ChatResponseReferencePartStatusKind;
        };
    });
}
export declare class ChatResponseMovePart {
    readonly uri: vscode.Uri;
    readonly range: vscode.Range;
    constructor(uri: vscode.Uri, range: vscode.Range);
}
export declare class ChatResponseExtensionsPart {
    readonly extensions: string[];
    constructor(extensions: string[]);
}
export declare class ChatResponsePullRequestPart {
    readonly uri: vscode.Uri;
    readonly linkTag: string;
    readonly title: string;
    readonly description: string;
    readonly author: string;
    constructor(uri: vscode.Uri, title: string, description: string, author: string, linkTag: string);
}
export declare class ChatResponseCodeCitationPart {
    value: vscode.Uri;
    license: string;
    snippet: string;
    constructor(value: vscode.Uri, license: string, snippet: string);
}
export declare class ChatResponseCommandButtonPart {
    value: vscode.Command;
    constructor(value: vscode.Command);
}
export declare class ChatResponseMarkdownWithVulnerabilitiesPart {
    value: vscode.MarkdownString;
    vulnerabilities: vscode.ChatVulnerability[];
    constructor(value: string | vscode.MarkdownString, vulnerabilities: vscode.ChatVulnerability[]);
}
export declare class ChatResponseTextEditPart {
    uri: vscode.Uri;
    edits: vscode.TextEdit[];
    isDone?: boolean;
    constructor(uri: vscode.Uri, editsOrDone: vscode.TextEdit | vscode.TextEdit[] | true);
}
export declare class ChatResponseNotebookEditPart implements vscode.ChatResponseNotebookEditPart {
    uri: vscode.Uri;
    edits: vscode.NotebookEdit[];
    isDone?: boolean;
    constructor(uri: vscode.Uri, editsOrDone: vscode.NotebookEdit | vscode.NotebookEdit[] | true);
}
export declare class ChatResponseConfirmationPart {
    title: string;
    message: string;
    data: any;
    buttons: string[] | undefined;
    constructor(title: string, message: string, data: any, buttons?: string[]);
}
export declare class ChatPrepareToolInvocationPart {
    toolName: string;
    /**
     * @param toolName The name of the tool being prepared for invocation.
     */
    constructor(toolName: string);
}
export declare class ChatRequestTurn implements vscode.ChatRequestTurn {
    readonly prompt: string;
    readonly command: string | undefined;
    readonly references: vscode.ChatPromptReference[];
    readonly participant: string;
    readonly toolReferences: vscode.ChatLanguageModelToolReference[];
    constructor(prompt: string, command: string | undefined, references: vscode.ChatPromptReference[], participant: string, toolReferences: vscode.ChatLanguageModelToolReference[]);
}
export declare class ChatResponseTurn implements vscode.ChatResponseTurn {
    readonly response: ReadonlyArray<ChatResponseMarkdownPart | ChatResponseFileTreePart | ChatResponseAnchorPart | ChatResponseCommandButtonPart>;
    readonly result: vscode.ChatResult;
    readonly participant: string;
    readonly command?: string | undefined;
    constructor(response: ReadonlyArray<ChatResponseMarkdownPart | ChatResponseFileTreePart | ChatResponseAnchorPart | ChatResponseCommandButtonPart>, result: vscode.ChatResult, participant: string, command?: string | undefined);
}
export declare class ChatRequestEditorData {
    readonly document: vscode.TextDocument;
    readonly selection: vscode.Selection;
    readonly wholeRange: vscode.Range;
    constructor(document: vscode.TextDocument, selection: vscode.Selection, wholeRange: vscode.Range);
}
export declare class ChatRequestNotebookData {
    readonly cell: vscode.TextDocument;
    constructor(cell: vscode.TextDocument);
}
export declare class ChatReferenceDiagnostic {
    readonly diagnostics: [vscode.Uri, vscode.Diagnostic[]][];
    constructor(diagnostics: [vscode.Uri, vscode.Diagnostic[]][]);
}
export declare class ChatReferenceBinaryData {
    readonly mimeType: string;
    readonly data: () => Thenable<Uint8Array>;
    constructor(mimeType: string, data: () => Thenable<Uint8Array>);
}
export declare class LanguageModelToolResult {
    content: (LanguageModelTextPart | LanguageModelPromptTsxPart | unknown)[];
    constructor(content: (LanguageModelTextPart | LanguageModelPromptTsxPart | unknown)[]);
}
export declare class LanguageModelToolResult2 {
    content: (LanguageModelTextPart | LanguageModelPromptTsxPart | LanguageModelDataPart | unknown)[];
    constructor(content: (LanguageModelTextPart | LanguageModelPromptTsxPart | LanguageModelDataPart | unknown)[]);
}
export declare class LanguageModelTextPart implements vscode.LanguageModelTextPart {
    value: string;
    constructor(value: string);
}
export declare enum LanguageModelPartAudience {
    Assistant = 0,
    User = 1,
    Extension = 2
}
export declare class LanguageModelTextPart2 extends LanguageModelTextPart {
    audience: LanguageModelPartAudience[] | undefined;
    constructor(value: string, audience?: LanguageModelPartAudience[]);
}
export declare class LanguageModelThinkingPart implements vscode.LanguageModelThinkingPart {
    value: string | string[];
    id?: string;
    metadata?: {
        readonly [key: string]: any;
    };
    constructor(value: string | string[], id?: string, metadata?: {
        readonly [key: string]: any;
    });
}
export declare class LanguageModelDataPart implements vscode.LanguageModelDataPart {
    mimeType: string;
    data: Uint8Array<ArrayBufferLike>;
    constructor(data: Uint8Array, mimeType: string);
    static image(data: Uint8Array<ArrayBufferLike>, mimeType: string): vscode.LanguageModelDataPart;
    static json(value: object): vscode.LanguageModelDataPart;
    static text(value: string): vscode.LanguageModelDataPart;
}
export declare class LanguageModelDataPart2 extends LanguageModelDataPart {
    audience: LanguageModelPartAudience[] | undefined;
    constructor(data: Uint8Array, mimeType: string, audience?: LanguageModelPartAudience[]);
}
export declare enum ChatImageMimeType {
    PNG = "image/png",
    JPEG = "image/jpeg",
    GIF = "image/gif",
    WEBP = "image/webp",
    BMP = "image/bmp"
}
export declare class LanguageModelPromptTsxPart {
    value: unknown;
    constructor(value: unknown);
}
export declare enum ExcludeSettingOptions {
    None = 1,
    FilesExclude = 2,
    SearchAndFilesExclude = 3
}
export declare class TextSearchMatch2 {
    uri: vscode.Uri;
    ranges: {
        sourceRange: vscode.Range;
        previewRange: vscode.Range;
    }[];
    previewText: string;
    constructor(uri: vscode.Uri, ranges: {
        sourceRange: vscode.Range;
        previewRange: vscode.Range;
    }[], previewText: string);
}
export declare class AISearchKeyword {
    keyword: string;
    constructor(keyword: string);
}
export declare enum ChatErrorLevel {
    Info = 0,
    Warning = 1,
    Error = 2
}
export declare enum ChatRequestEditedFileEventKind {
    Keep = 1,
    Undo = 2,
    UserModification = 3
}
export declare enum ChatResponseClearToPreviousToolInvocationReason {
    NoReason = 0,
    FilteredContentRetry = 1,
    CopyrightContentRetry = 2
}
export declare class LanguageModelToolExtensionSource implements vscode.LanguageModelToolExtensionSource {
    readonly id: string;
    readonly label: string;
    constructor(id: string, label: string);
}
export declare class LanguageModelToolMCPSource implements vscode.LanguageModelToolMCPSource {
    readonly label: string;
    readonly name: string;
    readonly instructions: string | undefined;
    constructor(label: string, name: string, instructions: string | undefined);
}
export declare class LanguageModelToolCallPart implements vscode.LanguageModelToolCallPart {
    callId: string;
    name: string;
    input: object;
    constructor(callId: string, name: string, input: object);
}
export declare class LanguageModelToolResultPart implements vscode.LanguageModelToolResultPart {
    callId: string;
    content: (LanguageModelTextPart | LanguageModelPromptTsxPart | unknown)[];
    isError: boolean;
    constructor(callId: string, content: (LanguageModelTextPart | LanguageModelPromptTsxPart | unknown)[], isError?: boolean);
}
export declare class LanguageModelToolResultPart2 implements vscode.LanguageModelToolResultPart2 {
    callId: string;
    content: (LanguageModelTextPart | LanguageModelPromptTsxPart | LanguageModelDataPart | unknown)[];
    isError: boolean;
    constructor(callId: string, content: (LanguageModelTextPart | LanguageModelPromptTsxPart | LanguageModelDataPart | unknown)[], isError?: boolean);
}
export declare enum LanguageModelChatMessageRole {
    User = 1,
    Assistant = 2,
    System = 3
}
export declare enum LanguageModelChatToolMode {
    Auto = 1,
    Required = 2
}
export declare class LanguageModelChatMessage implements vscode.LanguageModelChatMessage {
    role: LanguageModelChatMessageRole;
    content: Array<any>;
    name: string | undefined;
    constructor(role: LanguageModelChatMessageRole, content: string | Array<any>, name?: string);
    static User(content: string | Array<any>, name?: string): LanguageModelChatMessage;
    static Assistant(content: string | Array<any>, name?: string): LanguageModelChatMessage;
}
export declare class ChatToolInvocationPart {
    toolName: string;
    toolCallId: string;
    isError?: boolean;
    invocationMessage?: string | vscode.MarkdownString;
    originMessage?: string | vscode.MarkdownString;
    pastTenseMessage?: string | vscode.MarkdownString;
    isConfirmed?: boolean;
    isComplete?: boolean;
    toolSpecificData?: vscode.ChatTerminalToolInvocationData;
    constructor(toolName: string, toolCallId: string, isError?: boolean);
}
export declare class ChatResponseTurn2 implements vscode.ChatResponseTurn2 {
    readonly response: ReadonlyArray<ChatResponseMarkdownPart | ChatResponseFileTreePart | ChatResponseAnchorPart | ChatResponseCommandButtonPart | ChatResponseExtensionsPart | ChatToolInvocationPart>;
    readonly result: vscode.ChatResult;
    readonly participant: string;
    readonly command?: string | undefined;
    constructor(response: ReadonlyArray<ChatResponseMarkdownPart | ChatResponseFileTreePart | ChatResponseAnchorPart | ChatResponseCommandButtonPart | ChatResponseExtensionsPart | ChatToolInvocationPart>, result: vscode.ChatResult, participant: string, command?: string | undefined);
}
export declare enum ChatSessionStatus {
    Failed = 0,
    Completed = 1,
    InProgress = 2
}
export declare class LanguageModelError extends Error {
    #private;
    static NotFound(message?: string): LanguageModelError;
    static NoPermissions(message?: string): LanguageModelError;
    static Blocked(message?: string): LanguageModelError;
    readonly code: string;
    constructor(message?: string, code?: string, cause?: Error);
}
//# sourceMappingURL=chatTypes.d.ts.map