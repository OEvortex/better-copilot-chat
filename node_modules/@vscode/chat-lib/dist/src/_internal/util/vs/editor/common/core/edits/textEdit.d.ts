import { ISingleEditOperation } from '../editOperation';
import { BaseStringEdit, StringReplacement } from './stringEdit';
import { Position } from '../position';
import { Range } from '../range';
import { AbstractText } from '../text/abstractText';
export declare class TextEdit {
    readonly replacements: readonly TextReplacement[];
    static fromStringEdit(edit: BaseStringEdit, initialState: AbstractText): TextEdit;
    static replace(originalRange: Range, newText: string): TextEdit;
    static delete(range: Range): TextEdit;
    static insert(position: Position, newText: string): TextEdit;
    static fromParallelReplacementsUnsorted(replacements: readonly TextReplacement[]): TextEdit;
    constructor(replacements: readonly TextReplacement[]);
    /**
     * Joins touching edits and removes empty edits.
     */
    normalize(): TextEdit;
    mapPosition(position: Position): Position | Range;
    mapRange(range: Range): Range;
    inverseMapPosition(positionAfterEdit: Position, doc: AbstractText): Position | Range;
    inverseMapRange(range: Range, doc: AbstractText): Range;
    apply(text: AbstractText): string;
    applyToString(str: string): string;
    inverse(doc: AbstractText): TextEdit;
    getNewRanges(): Range[];
    toReplacement(text: AbstractText): TextReplacement;
    equals(other: TextEdit): boolean;
    toString(text: AbstractText | string | undefined): string;
}
export declare class TextReplacement {
    readonly range: Range;
    readonly text: string;
    static joinReplacements(replacements: TextReplacement[], initialValue: AbstractText): TextReplacement;
    static fromStringReplacement(replacement: StringReplacement, initialState: AbstractText): TextReplacement;
    static delete(range: Range): TextReplacement;
    constructor(range: Range, text: string);
    get isEmpty(): boolean;
    static equals(first: TextReplacement, second: TextReplacement): boolean;
    toSingleEditOperation(): ISingleEditOperation;
    toEdit(): TextEdit;
    equals(other: TextReplacement): boolean;
    extendToCoverRange(range: Range, initialValue: AbstractText): TextReplacement;
    extendToFullLine(initialValue: AbstractText): TextReplacement;
    removeCommonPrefixAndSuffix(text: AbstractText): TextReplacement;
    removeCommonPrefix(text: AbstractText): TextReplacement;
    removeCommonSuffix(text: AbstractText): TextReplacement;
    isEffectiveDeletion(text: AbstractText): boolean;
    toString(): string;
}
//# sourceMappingURL=textEdit.d.ts.map