import { WorkerOptions } from 'worker_threads';
export type RpcRequest = {
    id: number;
    fn: string;
    args: any[];
};
export type RpcResponse = {
    id: number;
    res?: any;
    err?: Error;
};
/**
 * Holds promises for RPC requests and resolves them when the call completes.
 */
export declare class RcpResponseHandler {
    private nextId;
    private readonly handlers;
    createHandler<T>(): {
        id: number;
        result: Promise<T>;
    };
    handleResponse(response: RpcResponse): void;
    /**
     * Handle an unexpected error by logging it and rejecting all handlers.
     */
    handleError(err: Error): void;
    clear(): void;
}
export type RpcProxy<ProxyType> = {
    [K in keyof ProxyType]: ProxyType[K] extends ((...args: infer Args) => infer R) ? (...args: Args) => Promise<Awaited<R>> : never;
};
export declare function createRpcProxy<ProxyType>(remoteCall: (name: string, args: any[]) => Promise<any>): RpcProxy<ProxyType>;
export declare class WorkerWithRpcProxy<WorkerProxyType, HostProxyType = {}> {
    private readonly worker;
    private readonly responseHandler;
    readonly proxy: RpcProxy<WorkerProxyType>;
    constructor(workerPath: string, workerOptions?: WorkerOptions, host?: HostProxyType);
    terminate(): void;
    /**
     * Handle an unexpected error by logging it and rejecting all handlers.
     */
    private handleError;
}
//# sourceMappingURL=worker.d.ts.map