import type * as vscode from 'vscode';
import { DocumentSelector, Position } from 'vscode-languageserver-protocol';
import { IPCitationDetail, IPDocumentCitation } from './_internal/extension/completions-core/vscode-node/lib/src/citationManager';
import { EditorInfo, EditorPluginInfo } from './_internal/extension/completions-core/vscode-node/lib/src/config';
import { CopilotCompletion } from './_internal/extension/completions-core/vscode-node/lib/src/ghostText/copilotCompletion';
import { GetGhostTextOptions } from './_internal/extension/completions-core/vscode-node/lib/src/ghostText/ghostText';
import { ITextEditorOptions } from './_internal/extension/completions-core/vscode-node/lib/src/ghostText/normalizeIndent';
import { ActionItem } from './_internal/extension/completions-core/vscode-node/lib/src/notificationSender';
import { StatusChangedEvent } from './_internal/extension/completions-core/vscode-node/lib/src/progress';
import { INotebookDocument, ITextDocument, TextDocumentIdentifier } from './_internal/extension/completions-core/vscode-node/lib/src/textDocument';
import { TextDocumentChangeEvent, TextDocumentCloseEvent, TextDocumentFocusedEvent, TextDocumentOpenEvent, WorkspaceFoldersChangeEvent } from './_internal/extension/completions-core/vscode-node/lib/src/textDocumentManager';
import { Event } from './_internal/extension/completions-core/vscode-node/lib/src/util/event';
import { DocumentContext, WorkspaceFolder } from './_internal/extension/completions-core/vscode-node/types/src';
import { IAuthenticationService } from './_internal/platform/authentication/common/authentication';
import { ICopilotTokenManager } from './_internal/platform/authentication/common/copilotTokenManager';
import { IConfigurationService } from './_internal/platform/configuration/common/configurationService';
import { ICAPIClientService } from './_internal/platform/endpoint/common/capiClient';
import { IEndpointProvider } from './_internal/platform/endpoint/common/endpointProvider';
import { IIgnoreService } from './_internal/platform/ignore/common/ignoreService';
import { IUndesiredModelsManager } from './_internal/platform/inlineEdits/common/inlineEditsModelService';
import { ObservableWorkspace } from './_internal/platform/inlineEdits/common/observableWorkspace';
import { ILanguageContextProviderService } from './_internal/platform/languageContextProvider/common/languageContextProviderService';
import { IFetcher } from './_internal/platform/networking/common/networking';
import { IExperimentationService, TreatmentsChangeEvent } from './_internal/platform/telemetry/common/nullExperimentationService';
import { CancellationToken } from './_internal/util/vs/base/common/cancellation';
import { Disposable } from './_internal/util/vs/base/common/lifecycle';
export { IAuthenticationService, ICAPIClientService, IEndpointProvider, IExperimentationService, IIgnoreService, ILanguageContextProviderService };
/**
 * Log levels (taken from vscode.d.ts)
 */
export declare enum LogLevel {
    /**
     * No messages are logged with this level.
     */
    Off = 0,
    /**
     * All messages are logged with this level.
     */
    Trace = 1,
    /**
     * Messages with debug and higher log level are logged with this level.
     */
    Debug = 2,
    /**
     * Messages with info and higher log level are logged with this level.
     */
    Info = 3,
    /**
     * Messages with warning and higher log level are logged with this level.
     */
    Warning = 4,
    /**
     * Only error messages are logged with this level.
     */
    Error = 5
}
export interface ILogTarget {
    logIt(level: LogLevel, metadataStr: string, ...extra: any[]): void;
    show?(preserveFocus?: boolean): void;
}
export interface ITelemetrySender {
    sendTelemetryEvent(eventName: string, properties?: Record<string, string | undefined>, measurements?: Record<string, number | undefined>): void;
    sendEnhancedTelemetryEvent?(eventName: string, properties?: Record<string, string | undefined>, measurements?: Record<string, number | undefined>): void;
}
export interface INESProviderOptions {
    readonly workspace: ObservableWorkspace;
    readonly fetcher: IFetcher;
    readonly copilotTokenManager: ICopilotTokenManager;
    readonly telemetrySender: ITelemetrySender;
    readonly logTarget?: ILogTarget;
    /**
     * If true, the provider will wait for treatment variables to be set.
     * INESProvider.updateTreatmentVariables() must be called to unblock.
     */
    readonly waitForTreatmentVariables?: boolean;
    readonly undesiredModelsManager?: IUndesiredModelsManager;
}
export interface INESResult {
    readonly result?: {
        readonly newText: string;
        readonly range: {
            readonly start: number;
            readonly endExclusive: number;
        };
    };
}
export interface INESProvider<T extends INESResult = INESResult> {
    getId(): string;
    getNextEdit(documentUri: vscode.Uri, cancellationToken: CancellationToken): Promise<T>;
    handleShown(suggestion: T): void;
    handleAcceptance(suggestion: T): void;
    handleRejection(suggestion: T): void;
    handleIgnored(suggestion: T, supersededByRequestUuid: T | undefined): void;
    updateTreatmentVariables(variables: Record<string, boolean | number | string>): void;
    dispose(): void;
}
export declare function createNESProvider(options: INESProviderOptions): INESProvider<INESResult>;
export declare class SimpleExperimentationService extends Disposable implements IExperimentationService {
    private readonly _configurationService;
    readonly _serviceBrand: undefined;
    private readonly variables;
    private readonly _onDidTreatmentsChange;
    readonly onDidTreatmentsChange: import("./_internal/util/vs/base/common/event").Event<TreatmentsChangeEvent>;
    private readonly waitFor;
    private readonly resolveWaitFor;
    constructor(waitForTreatmentVariables: boolean | undefined, _configurationService: IConfigurationService);
    hasTreatments(): Promise<void>;
    getTreatmentVariable<T extends boolean | number | string>(name: string): T | undefined;
    setCompletionsFilters(_filters: Map<string, string>): Promise<void>;
    updateTreatmentVariables(variables: Record<string, boolean | number | string>): void;
}
export type IDocumentContext = DocumentContext;
export type CompletionsContextProviderMatchFunction = (documentSelector: DocumentSelector, documentContext: IDocumentContext) => Promise<number>;
export type ICompletionsStatusChangedEvent = StatusChangedEvent;
export interface ICompletionsStatusHandler {
    didChange(event: ICompletionsStatusChangedEvent): void;
}
export type ICompletionsTextDocumentChangeEvent = Event<TextDocumentChangeEvent>;
export type ICompletionsTextDocumentOpenEvent = Event<TextDocumentOpenEvent>;
export type ICompletionsTextDocumentCloseEvent = Event<TextDocumentCloseEvent>;
export type ICompletionsTextDocumentFocusedEvent = Event<TextDocumentFocusedEvent>;
export type ICompletionsWorkspaceFoldersChangeEvent = Event<WorkspaceFoldersChangeEvent>;
export type ICompletionsTextDocumentIdentifier = TextDocumentIdentifier;
export type ICompletionsNotebookDocument = INotebookDocument;
export type ICompletionsWorkspaceFolder = WorkspaceFolder;
export interface ICompletionsTextDocumentManager {
    onDidChangeTextDocument: ICompletionsTextDocumentChangeEvent;
    onDidOpenTextDocument: ICompletionsTextDocumentOpenEvent;
    onDidCloseTextDocument: ICompletionsTextDocumentCloseEvent;
    onDidFocusTextDocument: ICompletionsTextDocumentFocusedEvent;
    onDidChangeWorkspaceFolders: ICompletionsWorkspaceFoldersChangeEvent;
    /**
     * Get all open text documents, skipping content exclusions and other validations.
     */
    getTextDocumentsUnsafe(): ITextDocument[];
    /**
     * If `TextDocument` represents notebook returns `INotebookDocument` instance, otherwise returns `undefined`
     */
    findNotebook(doc: TextDocumentIdentifier): ICompletionsNotebookDocument | undefined;
    getWorkspaceFolders(): WorkspaceFolder[];
}
export interface IURLOpener {
    open(url: string): Promise<void>;
}
export type IEditorInfo = EditorInfo;
export type IEditorPluginInfo = EditorPluginInfo;
export interface IEditorSession {
    readonly sessionId: string;
    readonly machineId: string;
    readonly remoteName?: string;
    readonly uiKind?: string;
}
export type IActionItem = ActionItem;
export interface INotificationSender {
    showWarningMessage(message: string, ...actions: IActionItem[]): Promise<IActionItem | undefined>;
}
export type IIPCitationDetail = IPCitationDetail;
export type IIPDocumentCitation = IPDocumentCitation;
export interface IInlineCompletionsCitationHandler {
    handleIPCodeCitation(citation: IIPDocumentCitation): Promise<void>;
}
export interface IInlineCompletionsProviderOptions {
    readonly fetcher: IFetcher;
    readonly authService: IAuthenticationService;
    readonly telemetrySender: ITelemetrySender;
    readonly logTarget?: ILogTarget;
    readonly isRunningInTest?: boolean;
    readonly contextProviderMatch: CompletionsContextProviderMatchFunction;
    readonly languageContextProvider?: ILanguageContextProviderService;
    readonly statusHandler: ICompletionsStatusHandler;
    readonly documentManager: ICompletionsTextDocumentManager;
    readonly workspace: ObservableWorkspace;
    readonly urlOpener: IURLOpener;
    readonly editorInfo: IEditorInfo;
    readonly editorPluginInfo: IEditorPluginInfo;
    readonly relatedPluginInfo: IEditorPluginInfo[];
    readonly editorSession: IEditorSession;
    readonly notificationSender: INotificationSender;
    readonly ignoreService?: IIgnoreService;
    readonly waitForTreatmentVariables?: boolean;
    readonly endpointProvider: IEndpointProvider;
    readonly capiClientService?: ICAPIClientService;
    readonly citationHandler?: IInlineCompletionsCitationHandler;
}
export type IGetInlineCompletionsOptions = Exclude<Partial<GetGhostTextOptions>, 'promptOnly'> & {
    formattingOptions?: ITextEditorOptions;
};
export interface IInlineCompletionsProvider {
    updateTreatmentVariables(variables: Record<string, boolean | number | string>): void;
    getInlineCompletions(textDocument: ITextDocument, position: Position, token?: CancellationToken, options?: IGetInlineCompletionsOptions): Promise<CopilotCompletion[] | undefined>;
    inlineCompletionShown(completionId: string): Promise<void>;
    dispose(): void;
}
export declare function createInlineCompletionsProvider(options: IInlineCompletionsProviderOptions): IInlineCompletionsProvider;
//# sourceMappingURL=main.d.ts.map