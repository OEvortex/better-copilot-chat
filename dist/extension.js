"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/types/providerKeys.ts
var ProviderKey;
var init_providerKeys = __esm({
  "src/types/providerKeys.ts"() {
    "use strict";
    ProviderKey = /* @__PURE__ */ ((ProviderKey2) => {
      ProviderKey2["Antigravity"] = "antigravity";
      ProviderKey2["Chutes"] = "chutes";
      ProviderKey2["DeepInfra"] = "deepinfra";
      ProviderKey2["DeepSeek"] = "deepseek";
      ProviderKey2["GeminiCli"] = "geminicli";
      ProviderKey2["Huggingface"] = "huggingface";
      ProviderKey2["LightningAI"] = "lightningai";
      ProviderKey2["Kimi"] = "kimi";
      ProviderKey2["Mistral"] = "mistral";
      ProviderKey2["MiniMax"] = "minimax";
      ProviderKey2["MiniMaxCoding"] = "minimax-coding";
      ProviderKey2["Moonshot"] = "moonshot";
      ProviderKey2["Ollama"] = "ollama";
      ProviderKey2["OpenCode"] = "opencode";
      ProviderKey2["OpenAI"] = "openai";
      ProviderKey2["QwenCli"] = "qwencli";
      ProviderKey2["Zenmux"] = "zenmux";
      ProviderKey2["Zhipu"] = "zhipu";
      ProviderKey2["Compatible"] = "compatible";
      return ProviderKey2;
    })(ProviderKey || {});
  }
});

// src/utils/logger.ts
var vscode, Logger;
var init_logger = __esm({
  "src/utils/logger.ts"() {
    "use strict";
    vscode = __toESM(require("vscode"));
    Logger = class _Logger {
      static outputChannel;
      /**
       * Initialize logger manager
       */
      static initialize(channelName = "Copilot ++") {
        _Logger.outputChannel = vscode.window.createOutputChannel(channelName, {
          log: true
        });
      }
      /**
       * Check and prompt VS Code log level settings
       */
      static checkAndPromptLogLevel() {
        if (!_Logger.outputChannel) {
          return;
        }
        const channelLevel = _Logger.outputChannel.logLevel;
        const envLevel = vscode.env.logLevel;
        _Logger.info("VS Code log level status:");
        _Logger.info(
          `  - Output channel level: ${vscode.LogLevel[channelLevel]} (${channelLevel})`
        );
        _Logger.info(
          `  - Editor environment level: ${vscode.LogLevel[envLevel]} (${envLevel})`
        );
        if (channelLevel > vscode.LogLevel.Debug) {
          _Logger.warn(
            `Current VS Code log level is ${vscode.LogLevel[channelLevel]}, detailed debug information may not be displayed`
          );
          _Logger.info(
            'To view detailed debug logs, please execute command: "Developer: Set Log Level" \u2192 select "Debug"'
          );
          vscode.window.showInformationMessage(
            `Copilot ++: Current VS Code log level is ${vscode.LogLevel[channelLevel]}`,
            "Set Log Level",
            "Ignore"
          ).then((selection) => {
            if (selection === "Set Log Level") {
              vscode.commands.executeCommand("workbench.action.setLogLevel");
            }
          });
        } else {
          _Logger.info(
            `VS Code log level is set to ${vscode.LogLevel[channelLevel]}, detailed debug information can be viewed`
          );
        }
      }
      /**
       * Trace level log (VS Code LogLevel.Trace = 1)
       */
      static trace(message, ...args) {
        if (_Logger.outputChannel) {
          _Logger.outputChannel.trace(message, ...args);
        }
      }
      /**
       * Debug level log (VS Code LogLevel.Debug = 2)
       */
      static debug(message, ...args) {
        if (_Logger.outputChannel) {
          _Logger.outputChannel.debug(message, ...args);
        }
      }
      /**
       * Info level log (VS Code LogLevel.Info = 3)
       */
      static info(message, ...args) {
        if (_Logger.outputChannel) {
          _Logger.outputChannel.info(message, ...args);
        }
      }
      /**
       * Warning level log (VS Code LogLevel.Warning = 4)
       */
      static warn(message, ...args) {
        if (_Logger.outputChannel) {
          _Logger.outputChannel.warn(message, ...args);
        }
      }
      /**
       * Error level log (VS Code LogLevel.Error = 5)
       */
      static error(message, ...args) {
        if (_Logger.outputChannel) {
          _Logger.outputChannel.error(message, ...args);
        }
      }
      /**
       * Dispose logger manager
       */
      static dispose() {
        if (_Logger.outputChannel) {
          _Logger.outputChannel.dispose();
        }
      }
    };
  }
});

// src/accounts/accountQuotaCache.ts
var vscode2, STORAGE_KEY, STORAGE_VERSION, AccountQuotaCache;
var init_accountQuotaCache = __esm({
  "src/accounts/accountQuotaCache.ts"() {
    "use strict";
    vscode2 = __toESM(require("vscode"));
    init_logger();
    STORAGE_KEY = "chp.accountQuotaCache";
    STORAGE_VERSION = 1;
    AccountQuotaCache = class _AccountQuotaCache {
      static instance;
      context;
      cache = /* @__PURE__ */ new Map();
      _onQuotaStateChange = new vscode2.EventEmitter();
      /** Event when quota state changes */
      onQuotaStateChange = this._onQuotaStateChange.event;
      constructor() {
      }
      /**
       * Initialize with extension context
       */
      static initialize(context) {
        if (!_AccountQuotaCache.instance) {
          _AccountQuotaCache.instance = new _AccountQuotaCache();
        }
        _AccountQuotaCache.instance.context = context;
        _AccountQuotaCache.instance.loadFromStorage();
        Logger.info("AccountQuotaCache initialized");
        return _AccountQuotaCache.instance;
      }
      /**
       * Get instance
       */
      static getInstance() {
        if (!_AccountQuotaCache.instance) {
          _AccountQuotaCache.instance = new _AccountQuotaCache();
        }
        return _AccountQuotaCache.instance;
      }
      /**
       * Load cache from storage
       */
      loadFromStorage() {
        if (!this.context) {
          return;
        }
        try {
          const data = this.context.globalState.get(STORAGE_KEY);
          if (data && data.version === STORAGE_VERSION) {
            this.cache.clear();
            for (const state of data.accounts) {
              if (state.quotaExceeded && state.quotaResetAt && Date.now() >= state.quotaResetAt) {
                state.quotaExceeded = false;
                state.quotaResetAt = void 0;
                state.backoffLevel = 0;
                state.lastError = void 0;
              }
              this.cache.set(state.accountId, state);
            }
            Logger.debug(
              `Loaded ${this.cache.size} account quota states from storage`
            );
          }
        } catch (error2) {
          Logger.error("Failed to load quota cache from storage:", error2);
        }
      }
      /**
       * Save cache to storage
       */
      async saveToStorage() {
        if (!this.context) {
          return;
        }
        try {
          const data = {
            version: STORAGE_VERSION,
            accounts: Array.from(this.cache.values()),
            updatedAt: Date.now()
          };
          await this.context.globalState.update(STORAGE_KEY, data);
          Logger.debug("Quota cache saved to storage");
        } catch (error2) {
          Logger.error("Failed to save quota cache to storage:", error2);
        }
      }
      /**
       * Get or create state for account
       */
      getOrCreateState(accountId, provider, accountName) {
        if (!accountId) {
          Logger.warn(
            `[AccountQuotaCache] getOrCreateState called with empty accountId! provider: ${provider}, accountName: ${accountName}`
          );
          Logger.warn("[AccountQuotaCache] Stack trace:", new Error().stack);
        }
        let state = this.cache.get(accountId);
        if (!state) {
          Logger.debug(
            `[AccountQuotaCache] Creating new state for accountId: ${accountId}, provider: ${provider}`
          );
          state = {
            accountId,
            accountName,
            provider,
            quotaExceeded: false,
            backoffLevel: 0,
            updatedAt: Date.now(),
            successCount: 0,
            failureCount: 0
          };
          this.cache.set(accountId, state);
        } else if (accountName && state.accountName !== accountName) {
          state.accountName = accountName;
        }
        return state;
      }
      /**
       * Mark quota exceeded for account
       */
      async markQuotaExceeded(accountId, provider, options) {
        if (!accountId || accountId === "undefined") {
          Logger.error(
            `[AccountQuotaCache] markQuotaExceeded called with invalid accountId: "${accountId}", provider: ${provider}, accountName: ${options?.accountName}`
          );
          Logger.error("[AccountQuotaCache] Stack trace:", new Error().stack);
          return;
        }
        Logger.debug(
          `[AccountQuotaCache] markQuotaExceeded - accountId: ${accountId}, provider: ${provider}, accountName: ${options?.accountName}`
        );
        const state = this.getOrCreateState(
          accountId,
          provider,
          options?.accountName
        );
        const { cooldown, newLevel } = this.calculateCooldown(
          state.backoffLevel,
          options?.resetDelayMs
        );
        state.quotaExceeded = true;
        state.quotaResetAt = Date.now() + cooldown;
        state.backoffLevel = newLevel;
        state.affectedModel = options?.affectedModel;
        state.lastError = options?.error || `Quota exceeded, retry after ${Math.round(cooldown / 1e3)}s`;
        state.updatedAt = Date.now();
        state.failureCount++;
        state.lastFailureAt = Date.now();
        Logger.debug(
          `[AccountQuotaCache] Updated state for ${accountId}: failureCount=${state.failureCount}, quotaResetAt=${state.quotaResetAt}`
        );
        await this.saveToStorage();
        this._onQuotaStateChange.fire({ accountId, provider, state });
        Logger.debug(
          `[AccountQuotaCache] Account ${accountId} quota exceeded, cooldown ${Math.round(cooldown / 1e3)}s (level ${newLevel})`
        );
      }
      /**
       * Clear quota exceeded state for account
       */
      async clearQuotaExceeded(accountId) {
        const state = this.cache.get(accountId);
        if (state) {
          state.quotaExceeded = false;
          state.quotaResetAt = void 0;
          state.backoffLevel = 0;
          state.lastError = void 0;
          state.updatedAt = Date.now();
          await this.saveToStorage();
          this._onQuotaStateChange.fire({
            accountId,
            provider: state.provider,
            state
          });
        }
      }
      /**
       * Record a successful request
       */
      async recordSuccess(accountId, provider, accountName) {
        if (!accountId || accountId === "undefined") {
          Logger.error(
            `[AccountQuotaCache] recordSuccess called with invalid accountId: "${accountId}", provider: ${provider}, accountName: ${accountName}`
          );
          Logger.error("[AccountQuotaCache] Stack trace:", new Error().stack);
          return;
        }
        Logger.debug(
          `[AccountQuotaCache] recordSuccess - accountId: ${accountId}, provider: ${provider}, accountName: ${accountName}`
        );
        const state = this.getOrCreateState(accountId, provider, accountName);
        Logger.debug(
          `[AccountQuotaCache] Current state for ${accountId}: successCount=${state.successCount}, failureCount=${state.failureCount}`
        );
        if (state.quotaExceeded) {
          state.quotaExceeded = false;
          state.quotaResetAt = void 0;
          state.backoffLevel = 0;
          state.lastError = void 0;
        }
        state.successCount++;
        state.lastSuccessAt = Date.now();
        state.updatedAt = Date.now();
        Logger.debug(
          `[AccountQuotaCache] Updated state for ${accountId}: successCount=${state.successCount}`
        );
        await this.saveToStorage();
        this._onQuotaStateChange.fire({ accountId, provider, state });
      }
      /**
       * Record failed request (non-quota)
       */
      async recordFailure(accountId, provider, error2, accountName) {
        const state = this.getOrCreateState(accountId, provider, accountName);
        state.failureCount++;
        state.lastFailureAt = Date.now();
        state.lastError = error2;
        state.updatedAt = Date.now();
        await this.saveToStorage();
        this._onQuotaStateChange.fire({ accountId, provider, state });
      }
      /**
       * Check whether account is in cooldown
       */
      isInCooldown(accountId) {
        const state = this.cache.get(accountId);
        if (!state || !state.quotaExceeded) {
          return false;
        }
        if (state.quotaResetAt && Date.now() >= state.quotaResetAt) {
          void this.clearQuotaExceeded(accountId);
          return false;
        }
        return true;
      }
      /**
       * Get remaining cooldown time (ms)
       */
      getRemainingCooldown(accountId) {
        const state = this.cache.get(accountId);
        if (!state || !state.quotaExceeded || !state.quotaResetAt) {
          return 0;
        }
        const remaining = state.quotaResetAt - Date.now();
        return remaining > 0 ? remaining : 0;
      }
      /**
       * Get state of account
       */
      getState(accountId) {
        return this.cache.get(accountId);
      }
      /**
       * Get all states
       */
      getAllStates() {
        const states = Array.from(this.cache.values());
        Logger.debug(
          `[AccountQuotaCache] getAllStates returning ${states.length} states:`,
          states.map((s) => ({
            accountId: s.accountId,
            provider: s.provider,
            successCount: s.successCount,
            failureCount: s.failureCount
          }))
        );
        return states;
      }
      /**
       * Get states by provider
       */
      getStatesByProvider(provider) {
        return Array.from(this.cache.values()).filter(
          (s) => s.provider === provider
        );
      }
      /**
       * Get available accounts (not in cooldown)
       */
      getAvailableAccounts(provider) {
        return Array.from(this.cache.values()).filter((s) => s.provider === provider && !this.isInCooldown(s.accountId)).map((s) => s.accountId);
      }
      /**
       * Get account with the shortest cooldown (to prefer when all are limited)
       */
      getAccountWithShortestCooldown(provider) {
        const states = this.getStatesByProvider(provider).filter((s) => s.quotaExceeded && s.quotaResetAt).sort((a, b) => (a.quotaResetAt || 0) - (b.quotaResetAt || 0));
        return states[0]?.accountId;
      }
      /**
       * Calculate cooldown with exponential backoff
       */
      calculateCooldown(prevLevel, serverDelayMs) {
        const QUOTA_BACKOFF_BASE_MS3 = 1e3;
        const QUOTA_BACKOFF_MAX_MS3 = 30 * 60 * 1e3;
        if (prevLevel < 0) {
          prevLevel = 0;
        }
        let cooldown = QUOTA_BACKOFF_BASE_MS3 * 2 ** prevLevel;
        if (cooldown < QUOTA_BACKOFF_BASE_MS3) {
          cooldown = QUOTA_BACKOFF_BASE_MS3;
        }
        if (serverDelayMs && serverDelayMs > cooldown) {
          cooldown = serverDelayMs;
        }
        if (cooldown >= QUOTA_BACKOFF_MAX_MS3) {
          return { cooldown: QUOTA_BACKOFF_MAX_MS3, newLevel: prevLevel };
        }
        return { cooldown, newLevel: prevLevel + 1 };
      }
      /**
       * Remove account state (when account is deleted)
       */
      async removeAccount(accountId) {
        if (this.cache.has(accountId)) {
          this.cache.delete(accountId);
          await this.saveToStorage();
        }
      }
      /**
       * Clear all cache
       */
      async clearAll() {
        this.cache.clear();
        await this.saveToStorage();
      }
      /**
       * Dispose
       */
      dispose() {
        this._onQuotaStateChange.dispose();
      }
    };
  }
});

// src/accounts/accountManager.ts
var accountManager_exports = {};
__export(accountManager_exports, {
  AccountManager: () => AccountManager
});
var vscode3, STORAGE_KEY2, STORAGE_VERSION2, AccountManager;
var init_accountManager = __esm({
  "src/accounts/accountManager.ts"() {
    "use strict";
    vscode3 = __toESM(require("vscode"));
    init_providerKeys();
    init_logger();
    init_accountQuotaCache();
    STORAGE_KEY2 = "chp.accounts";
    STORAGE_VERSION2 = 1;
    AccountManager = class _AccountManager {
      static instance;
      context;
      accounts = /* @__PURE__ */ new Map();
      activeAccounts = {};
      routingConfig = {};
      _onAccountChange = new vscode3.EventEmitter();
      /** Event fired when accounts change */
      onAccountChange = this._onAccountChange.event;
      /** Provider configuration */
      static providerConfigs = /* @__PURE__ */ new Map([
        [
          "antigravity" /* Antigravity */,
          {
            supportsMultiAccount: true,
            supportsOAuth: true,
            supportsApiKey: false
          }
        ],
        [
          "zhipu" /* Zhipu */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        [
          "moonshot" /* Moonshot */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        [
          "minimax" /* MiniMax */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        [
          "compatible" /* Compatible */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        [
          "deepseek" /* DeepSeek */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        [
          "deepinfra" /* DeepInfra */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        [
          "chutes" /* Chutes */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        [
          "opencode" /* OpenCode */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        [
          "huggingface" /* Huggingface */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        [
          "mistral" /* Mistral */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        [
          "openai" /* OpenAI */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        [
          "kimi" /* Kimi */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        [
          "minimax-coding" /* MiniMaxCoding */,
          {
            supportsMultiAccount: true,
            supportsOAuth: false,
            supportsApiKey: true
          }
        ],
        // Register CLI OAuth providers so they can be managed via AccountManager
        [
          "qwencli" /* QwenCli */,
          {
            supportsMultiAccount: true,
            supportsOAuth: true,
            supportsApiKey: false
          }
        ],
        [
          "geminicli" /* GeminiCli */,
          {
            supportsMultiAccount: true,
            supportsOAuth: true,
            supportsApiKey: false
          }
        ]
      ]);
      constructor(context) {
        this.context = context;
      }
      /**
       * Initialize AccountManager
       */
      static initialize(context) {
        if (!_AccountManager.instance) {
          _AccountManager.instance = new _AccountManager(context);
          _AccountManager.instance.loadFromStorage();
          Logger.info("AccountManager initialized");
        }
        return _AccountManager.instance;
      }
      /**
       * Get instance
       */
      static getInstance() {
        if (!_AccountManager.instance) {
          throw new Error(
            "AccountManager not initialized. Call initialize() first."
          );
        }
        return _AccountManager.instance;
      }
      /**
       * Generate unique account ID
       */
      generateAccountId() {
        const timestamp = Date.now().toString(36);
        const random2 = Math.random().toString(36).substring(2, 8);
        return `acc_${timestamp}_${random2}`;
      }
      /**
       * Load data from storage
       */
      async loadFromStorage() {
        try {
          const data = this.context.globalState.get(STORAGE_KEY2);
          if (data && data.version === STORAGE_VERSION2) {
            this.accounts.clear();
            for (const account of data.accounts) {
              this.accounts.set(account.id, account);
            }
            this.activeAccounts = data.activeAccounts || {};
            this.routingConfig = data.routingConfig || {};
            this.syncIsDefaultWithActiveAccounts();
            Logger.debug(`Loaded ${this.accounts.size} accounts from storage`);
          }
        } catch (error2) {
          Logger.error("Failed to load accounts from storage:", error2);
        }
      }
      /**
       * Sync isDefault flag with activeAccounts to ensure consistency
       * Fix: switching model could pick the first account instead of the default account
       */
      syncIsDefaultWithActiveAccounts() {
        for (const account of this.accounts.values()) {
          account.isDefault = false;
        }
        for (const [provider, accountId] of Object.entries(this.activeAccounts)) {
          const account = this.accounts.get(accountId);
          if (account && account.provider === provider) {
            account.isDefault = true;
          }
        }
      }
      /**
       * Save data to storage
       */
      async saveToStorage() {
        try {
          const data = {
            version: STORAGE_VERSION2,
            accounts: Array.from(this.accounts.values()),
            activeAccounts: this.activeAccounts,
            routingConfig: this.routingConfig
          };
          await this.context.globalState.update(STORAGE_KEY2, data);
          Logger.debug("Accounts saved to storage");
        } catch (error2) {
          Logger.error("Failed to save accounts to storage:", error2);
        }
      }
      /**
       * Save credentials to SecretStorage
       */
      async saveCredentials(accountId, credentials) {
        const key = `chp.account.${accountId}.credentials`;
        await this.context.secrets.store(key, JSON.stringify(credentials));
      }
      /**
       * Get credentials from SecretStorage
       */
      async getCredentials(accountId) {
        const key = `chp.account.${accountId}.credentials`;
        const data = await this.context.secrets.get(key);
        if (data) {
          try {
            return JSON.parse(data);
          } catch {
            return void 0;
          }
        }
        return void 0;
      }
      /**
       * Delete credentials from SecretStorage
       */
      async deleteCredentials(accountId) {
        const key = `chp.account.${accountId}.credentials`;
        await this.context.secrets.delete(key);
      }
      /**
       * Add new account with API Key
       */
      async addApiKeyAccount(provider, displayName, apiKey, options) {
        try {
          const accountId = this.generateAccountId();
          const now = (/* @__PURE__ */ new Date()).toISOString();
          const account = {
            id: accountId,
            displayName,
            provider,
            authType: "apiKey",
            status: "active",
            createdAt: now,
            updatedAt: now,
            metadata: options?.metadata,
            isDefault: this.getAccountsByProvider(provider).length === 0
          };
          const credentials = {
            apiKey,
            endpoint: options?.endpoint,
            customHeaders: options?.customHeaders
          };
          this.accounts.set(accountId, account);
          await this.saveCredentials(accountId, credentials);
          await this.saveToStorage();
          if (account.isDefault) {
            this.activeAccounts[provider] = accountId;
          }
          this._onAccountChange.fire({ type: "added", account, provider });
          Logger.info(`Added API Key account: ${displayName} for ${provider}`);
          return { success: true, account };
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          Logger.error("Failed to add API Key account:", error2);
          return { success: false, error: errorMessage };
        }
      }
      /**
       * Add OAuth account
       */
      async addOAuthAccount(provider, displayName, email2, oauthCredentials, metadata) {
        try {
          const accountId = this.generateAccountId();
          const now = (/* @__PURE__ */ new Date()).toISOString();
          const account = {
            id: accountId,
            displayName,
            provider,
            authType: "oauth",
            email: email2,
            status: "active",
            createdAt: now,
            updatedAt: now,
            expiresAt: oauthCredentials.expiresAt,
            metadata,
            isDefault: this.getAccountsByProvider(provider).length === 0
          };
          this.accounts.set(accountId, account);
          await this.saveCredentials(accountId, oauthCredentials);
          await this.saveToStorage();
          if (account.isDefault) {
            this.activeAccounts[provider] = accountId;
          }
          this._onAccountChange.fire({ type: "added", account, provider });
          Logger.info(
            `Added OAuth account: ${displayName} (${email2}) for ${provider}`
          );
          return { success: true, account };
        } catch (error2) {
          const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
          Logger.error("Failed to add OAuth account:", error2);
          return { success: false, error: errorMessage };
        }
      }
      /**
       * Delete account
       */
      async removeAccount(accountId) {
        const account = this.accounts.get(accountId);
        if (!account) {
          Logger.warn(`Account not found: ${accountId}`);
          return false;
        }
        try {
          await this.deleteCredentials(accountId);
          this.accounts.delete(accountId);
          if (this.activeAccounts[account.provider] === accountId) {
            const remainingAccounts = this.getAccountsByProvider(account.provider);
            if (remainingAccounts.length > 0) {
              this.activeAccounts[account.provider] = remainingAccounts[0].id;
            } else {
              delete this.activeAccounts[account.provider];
            }
          }
          const routing = this.routingConfig[account.provider];
          if (routing?.modelAssignments) {
            for (const [modelId, mappedAccountId] of Object.entries(
              routing.modelAssignments
            )) {
              if (mappedAccountId === accountId) {
                delete routing.modelAssignments[modelId];
              }
            }
          }
          try {
            const quotaCache = AccountQuotaCache.getInstance();
            await quotaCache.removeAccount(accountId);
          } catch {
          }
          await this.saveToStorage();
          this._onAccountChange.fire({
            type: "removed",
            account,
            provider: account.provider
          });
          Logger.info(`Removed account: ${account.displayName}`);
          return true;
        } catch (error2) {
          Logger.error("Failed to remove account:", error2);
          return false;
        }
      }
      /**
       * Switch active account
       */
      async switchAccount(provider, accountId) {
        const account = this.accounts.get(accountId);
        if (!account || account.provider !== provider) {
          Logger.warn(`Account not found or provider mismatch: ${accountId}`);
          return false;
        }
        try {
          const oldActiveId = this.activeAccounts[provider];
          if (oldActiveId) {
            const oldAccount = this.accounts.get(oldActiveId);
            if (oldAccount) {
              oldAccount.isDefault = false;
            }
          }
          this.activeAccounts[provider] = accountId;
          account.isDefault = true;
          account.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
          await this.saveToStorage();
          this._onAccountChange.fire({ type: "switched", account, provider });
          Logger.info(
            `Switched to account: ${account.displayName} for ${provider}`
          );
          return true;
        } catch (error2) {
          Logger.error("Failed to switch account:", error2);
          return false;
        }
      }
      /**
       * Get the active account for a provider
       */
      getActiveAccount(provider) {
        const accountId = this.activeAccounts[provider];
        if (accountId) {
          return this.accounts.get(accountId);
        }
        return void 0;
      }
      /**
       * Get credentials of the active account
       */
      async getActiveCredentials(provider) {
        const account = this.getActiveAccount(provider);
        if (account) {
          return this.getCredentials(account.id);
        }
        return void 0;
      }
      /**
       * Get API Key of the active account (utility)
       */
      async getActiveApiKey(provider) {
        const credentials = await this.getActiveCredentials(provider);
        if (credentials && "apiKey" in credentials) {
          return credentials.apiKey;
        }
        return void 0;
      }
      /**
       * Get OAuth token of the active account (utility)
       */
      async getActiveOAuthToken(provider) {
        const credentials = await this.getActiveCredentials(provider);
        if (credentials && "accessToken" in credentials) {
          return credentials.accessToken;
        }
        return void 0;
      }
      /**
       * Get all accounts for a provider
       */
      getAccountsByProvider(provider) {
        return Array.from(this.accounts.values()).filter(
          (acc) => acc.provider === provider
        );
      }
      /**
       * Get all accounts
       */
      getAllAccounts() {
        return Array.from(this.accounts.values());
      }
      /**
       * Get account by ID
       */
      getAccount(accountId) {
        return this.accounts.get(accountId);
      }
      /**
       * Update account information
       */
      async updateAccount(accountId, updates) {
        const account = this.accounts.get(accountId);
        if (!account) {
          return false;
        }
        try {
          Object.assign(account, updates, { updatedAt: (/* @__PURE__ */ new Date()).toISOString() });
          await this.saveToStorage();
          this._onAccountChange.fire({
            type: "updated",
            account,
            provider: account.provider
          });
          return true;
        } catch (error2) {
          Logger.error("Failed to update account:", error2);
          return false;
        }
      }
      /**
       * Update credentials of account
       */
      async updateCredentials(accountId, credentials) {
        const account = this.accounts.get(accountId);
        if (!account) {
          return false;
        }
        try {
          await this.saveCredentials(accountId, credentials);
          account.updatedAt = (/* @__PURE__ */ new Date()).toISOString();
          if ("expiresAt" in credentials) {
            account.expiresAt = credentials.expiresAt;
          }
          await this.saveToStorage();
          return true;
        } catch (error2) {
          Logger.error("Failed to update credentials:", error2);
          return false;
        }
      }
      /**
       * Get model -> account mapping for the provider
       */
      getModelAccountAssignments(provider) {
        return { ...this.routingConfig[provider]?.modelAssignments || {} };
      }
      /**
       * Get assigned accountId for the model
       */
      getAccountIdForModel(provider, modelId) {
        return this.routingConfig[provider]?.modelAssignments?.[modelId];
      }
      /**
       * Assign model to account (or remove assignment if accountId not provided)
       */
      async setAccountForModel(provider, modelId, accountId) {
        const routing = this.ensureProviderRoutingConfig(provider);
        if (accountId) {
          routing.modelAssignments[modelId] = accountId;
        } else {
          delete routing.modelAssignments[modelId];
        }
        await this.saveToStorage();
      }
      /**
       * Get load balance enabled state for provider
       */
      getLoadBalanceEnabled(provider) {
        const defaultValue = provider === "antigravity" /* Antigravity */;
        return this.routingConfig[provider]?.loadBalanceEnabled ?? defaultValue;
      }
      /**
       * Update load balance state for provider
       */
      async setLoadBalanceEnabled(provider, enabled) {
        const routing = this.ensureProviderRoutingConfig(provider);
        routing.loadBalanceEnabled = enabled;
        await this.saveToStorage();
      }
      /**
       * Ensure provider routing config exists
       */
      ensureProviderRoutingConfig(provider) {
        if (!this.routingConfig[provider]) {
          this.routingConfig[provider] = {
            modelAssignments: {},
            loadBalanceEnabled: false
          };
        } else if (!this.routingConfig[provider].modelAssignments) {
          this.routingConfig[provider].modelAssignments = {};
        }
        return this.routingConfig[provider];
      }
      /**
       * Check whether provider supports multi-account
       */
      static supportsMultiAccount(provider) {
        const config2 = _AccountManager.providerConfigs.get(provider);
        return config2?.supportsMultiAccount ?? true;
      }
      /**
       * Get provider configuration
       */
      static getProviderConfig(provider) {
        return _AccountManager.providerConfigs.get(provider) ?? {
          supportsMultiAccount: true,
          supportsOAuth: false,
          supportsApiKey: true
        };
      }
      /**
       * Register new provider configuration
       */
      static registerProviderConfig(provider, config2) {
        _AccountManager.providerConfigs.set(provider, config2);
      }
      /**
       * Check whether account is expired
       */
      isAccountExpired(accountId) {
        const account = this.accounts.get(accountId);
        if (!account || !account.expiresAt) {
          return false;
        }
        return new Date(account.expiresAt) < /* @__PURE__ */ new Date();
      }
      /**
       * Mark account as expired
       */
      async markAccountExpired(accountId) {
        await this.updateAccount(accountId, { status: "expired" });
      }
      /**
       * Mark account as error
       */
      async markAccountError(accountId, error2) {
        await this.updateAccount(accountId, {
          status: "error",
          metadata: { ...this.accounts.get(accountId)?.metadata, lastError: error2 }
        });
      }
      /**
       * Check if account is currently quota-limited
       */
      isAccountQuotaLimited(accountId) {
        try {
          const quotaCache = AccountQuotaCache.getInstance();
          return quotaCache.isInCooldown(accountId);
        } catch {
          return false;
        }
      }
      /**
       * Get remaining quota cooldown time (ms)
       */
      getAccountQuotaCooldown(accountId) {
        try {
          const quotaCache = AccountQuotaCache.getInstance();
          return quotaCache.getRemainingCooldown(accountId);
        } catch {
          return 0;
        }
      }
      /**
       * Get list of available accounts (not quota-limited) for provider
       */
      getAvailableAccountsForProvider(provider) {
        const accounts = this.getAccountsByProvider(provider);
        return accounts.filter(
          (acc) => acc.status === "active" && !this.isAccountExpired(acc.id) && !this.isAccountQuotaLimited(acc.id)
        );
      }
      /**
       * Get next available account for provider (round-robin or priority)
       */
      getNextAvailableAccount(provider, currentAccountId) {
        const availableAccounts = this.getAvailableAccountsForProvider(provider);
        if (availableAccounts.length === 0) {
          try {
            const quotaCache = AccountQuotaCache.getInstance();
            const shortestCooldownId = quotaCache.getAccountWithShortestCooldown(provider);
            if (shortestCooldownId) {
              return this.accounts.get(shortestCooldownId);
            }
          } catch {
          }
          return void 0;
        }
        if (availableAccounts.length === 0) {
          try {
            const quotaCache = AccountQuotaCache.getInstance();
            const shortestCooldownId = quotaCache.getAccountWithShortestCooldown(provider);
            if (shortestCooldownId) {
              return this.accounts.get(shortestCooldownId);
            }
          } catch {
          }
          return void 0;
        }
        if (currentAccountId) {
          const currentIndex = availableAccounts.findIndex(
            (acc) => acc.id === currentAccountId
          );
          if (currentIndex >= 0 && currentIndex < availableAccounts.length - 1) {
            return availableAccounts[currentIndex + 1];
          }
        }
        return availableAccounts[0];
      }
      /**
       * Dispose
       */
      dispose() {
        this._onAccountChange.dispose();
      }
    };
  }
});

// raw-file:../ui/accountManager.css
var accountManager_default;
var init_accountManager2 = __esm({
  "raw-file:../ui/accountManager.css"() {
    accountManager_default = '/* Account Manager Page Styles */\n:root {\n	--vscode-font-family: var(\n		--vscode-editor-font-family,\n		-apple-system,\n		BlinkMacSystemFont,\n		"Segoe UI",\n		Roboto,\n		Oxygen,\n		Ubuntu,\n		Cantarell,\n		"Open Sans",\n		"Helvetica Neue",\n		sans-serif\n	);\n	--vscode-font-size: var(--vscode-editor-font-size, 13px);\n\n	--radius-lg: 16px;\n	--radius-md: 12px;\n	--radius-sm: 10px;\n	--shadow-soft: 0 10px 28px rgba(0, 0, 0, 0.12);\n}\n\n* {\n	box-sizing: border-box;\n	margin: 0;\n	padding: 0;\n}\n\nbody {\n	font-family: var(--vscode-font-family);\n	font-size: var(--vscode-font-size);\n	color: var(--vscode-foreground);\n	background-color: var(--vscode-editor-background);\n	padding: 16px 16px 24px;\n	line-height: 1.4;\n}\n\n.container {\n	max-width: 1100px;\n	margin: 0 auto;\n}\n\n.shell {\n	display: flex;\n	flex-direction: column;\n	gap: 14px;\n}\n\n.surface {\n	background: var(\n		--vscode-editorWidget-background,\n		var(--vscode-editor-background)\n	);\n	border: 1px solid var(--vscode-panel-border);\n	border-radius: var(--radius-lg);\n	box-shadow: 0 1px 0 rgba(0, 0, 0, 0.06);\n}\n\n/* Top bar */\n.topbar {\n	display: flex;\n	align-items: center;\n	justify-content: space-between;\n	gap: 12px;\n	padding: 14px 16px;\n}\n\n.topbar-title {\n	min-width: 0;\n}\n\n.topbar-title-text {\n	font-size: 18px;\n	font-weight: 700;\n	color: var(--vscode-foreground);\n}\n\n.topbar-subtitle {\n	margin-top: 2px;\n	font-size: 12px;\n	color: var(--vscode-descriptionForeground);\n}\n\n.topbar-actions {\n	display: flex;\n	gap: 10px;\n	align-items: center;\n	flex-shrink: 0;\n}\n\n/* Settings link */\n.settings-link {\n	display: flex;\n	align-items: center;\n	gap: 6px;\n	padding: 6px 12px;\n	border-radius: var(--radius-sm);\n	color: var(--vscode-textLink-foreground);\n	text-decoration: none;\n	font-size: 13px;\n	font-weight: 500;\n	transition:\n		background-color 0.15s ease,\n		color 0.15s ease;\n	cursor: pointer;\n}\n\n.settings-link:hover {\n	background-color: var(--vscode-toolbar-hoverBackground);\n	color: var(\n		--vscode-textLink-activeForeground,\n		var(--vscode-textLink-foreground)\n	);\n}\n\n.settings-icon {\n	font-size: 14px;\n}\n\n.settings-text {\n	white-space: nowrap;\n}\n\n/* Main layout */\n.layout {\n	display: grid;\n	grid-template-columns: 260px 1fr;\n	gap: 14px;\n	align-items: start;\n}\n\n.sidebar {\n	padding: 14px;\n	display: flex;\n	flex-direction: column;\n	gap: 12px;\n	position: sticky;\n	top: 16px;\n}\n\n.sidebar-header {\n	display: flex;\n	align-items: center;\n	justify-content: space-between;\n}\n\n.sidebar-title {\n	font-size: 12px;\n	font-weight: 700;\n	color: var(--vscode-descriptionForeground);\n	letter-spacing: 0.8px;\n	text-transform: uppercase;\n}\n\n.provider-list {\n	display: flex;\n	flex-direction: column;\n	gap: 6px;\n}\n\n.provider-item {\n	width: 100%;\n	display: grid;\n	grid-template-columns: 28px 1fr auto;\n	align-items: center;\n	gap: 10px;\n	padding: 10px 10px;\n	border-radius: var(--radius-md);\n	border: 1px solid transparent;\n	background: transparent;\n	color: var(--vscode-foreground);\n	cursor: pointer;\n	text-align: left;\n}\n\n.provider-item:hover {\n	background: var(--vscode-list-hoverBackground);\n}\n\n.provider-item.active {\n	background: var(--vscode-list-inactiveSelectionBackground);\n	border-color: var(--vscode-focusBorder);\n}\n\n.provider-item-icon {\n	display: inline-flex;\n	width: 28px;\n	height: 28px;\n	border-radius: var(--radius-sm);\n	align-items: center;\n	justify-content: center;\n	background: var(--vscode-badge-background);\n	color: var(--vscode-badge-foreground);\n	font-size: 14px;\n}\n\n.provider-icon-img {\n	width: 100%;\n	height: 100%;\n	object-fit: contain;\n	border-radius: var(--radius-sm);\n}\n\n.provider-item-name {\n	min-width: 0;\n	overflow: hidden;\n	text-overflow: ellipsis;\n	white-space: nowrap;\n	font-weight: 600;\n	font-size: 13px;\n}\n\n.provider-item-count {\n	font-variant-numeric: tabular-nums;\n	font-size: 12px;\n	color: var(--vscode-descriptionForeground);\n	padding: 2px 8px;\n	border-radius: 999px;\n	border: 1px solid var(--vscode-panel-border);\n}\n\n.sidebar-footer {\n	margin-top: 6px;\n}\n\n.btn-block {\n	width: 100%;\n	justify-content: center;\n}\n\n.content {\n	padding: 14px;\n}\n\n.content-header {\n	display: flex;\n	align-items: flex-start;\n	justify-content: space-between;\n	gap: 12px;\n	margin-bottom: 12px;\n}\n\n.content-title {\n	font-size: 16px;\n	font-weight: 700;\n}\n\n.content-subtitle {\n	margin-top: 2px;\n	font-size: 12px;\n	color: var(--vscode-descriptionForeground);\n}\n\n.content-actions {\n	flex-shrink: 0;\n}\n\n.account-cards {\n	display: flex;\n	flex-direction: column;\n	gap: 10px;\n}\n\n/* Notice */\n.notice {\n	padding: 12px 14px;\n	border-radius: var(--radius-lg);\n	border: 1px solid var(--vscode-panel-border);\n	background: var(\n		--vscode-editorWidget-background,\n		var(--vscode-editor-background)\n	);\n}\n\n.notice-warning {\n	border-color: var(--vscode-notificationsWarningBorder, #ffa500);\n	background: var(\n		--vscode-inputValidation-warningBackground,\n		rgba(255, 165, 0, 0.08)\n	);\n}\n\n.notice-title {\n	font-weight: 700;\n	font-size: 13px;\n	color: var(--vscode-notificationsWarningForeground, #ffa500);\n	margin-bottom: 4px;\n}\n\n.notice-body {\n	color: var(--vscode-foreground);\n	font-size: 12px;\n}\n\n.notice-meta {\n	margin-top: 4px;\n	color: var(--vscode-descriptionForeground);\n}\n\n.quota-countdown {\n	font-variant-numeric: tabular-nums;\n	font-weight: 700;\n	color: var(--vscode-foreground);\n}\n\n/* Codex Rate Limit Banner */\n.codex-rate-limit-banner {\n	display: flex;\n	flex-direction: column;\n	gap: 8px;\n	margin: 0 0 16px;\n	padding: 12px 16px;\n	border-radius: 4px;\n	border-left: 3px solid var(--vscode-charts-green, #4caf50);\n	background: var(--vscode-editor-background);\n	border: 1px solid var(--vscode-panel-border);\n}\n\n.codex-rate-limit-banner.warning {\n	border-left-color: var(--vscode-notificationsWarningBorder, #ffa500);\n	background: var(\n		--vscode-inputValidation-warningBackground,\n		rgba(255, 165, 0, 0.08)\n	);\n}\n\n.rate-limit-header {\n	display: flex;\n	align-items: center;\n	gap: 8px;\n}\n\n.rate-limit-icon {\n	font-size: 14px;\n}\n\n.rate-limit-title {\n	font-weight: 600;\n	font-size: 13px;\n	color: var(--vscode-foreground);\n}\n\n.rate-limit-updated {\n	margin-left: auto;\n	font-size: 11px;\n	color: var(--vscode-descriptionForeground);\n}\n\n.rate-limit-content {\n	display: flex;\n	flex-direction: column;\n	gap: 4px;\n}\n\n.rate-limit-row {\n	display: flex;\n	align-items: center;\n	gap: 8px;\n	font-size: 12px;\n}\n\n.rate-limit-label {\n	min-width: 60px;\n	color: var(--vscode-descriptionForeground);\n}\n\n.rate-limit-bar {\n	font-family: monospace;\n	font-size: 11px;\n	color: var(--vscode-foreground);\n	opacity: 0.8;\n}\n\n.rate-limit-value {\n	min-width: 35px;\n	text-align: right;\n	font-weight: 600;\n	color: var(--vscode-foreground);\n}\n\n.codex-rate-limit-banner.warning .rate-limit-value {\n	color: var(--vscode-notificationsWarningForeground, #ffa500);\n}\n\n/* Account-level Rate Limit (inline in account card) */\n.account-rate-limit {\n	margin-top: 8px;\n	padding: 8px 10px;\n	border-radius: 4px;\n	background: var(--vscode-editor-background);\n	border: 1px solid var(--vscode-panel-border);\n	font-size: 11px;\n}\n\n.account-rate-limit.warning {\n	border-color: var(--vscode-notificationsWarningBorder, #ffa500);\n	background: var(\n		--vscode-inputValidation-warningBackground,\n		rgba(255, 165, 0, 0.08)\n	);\n}\n\n.rate-limit-header-inline {\n	display: flex;\n	align-items: center;\n	gap: 6px;\n	margin-bottom: 4px;\n}\n\n.rate-limit-title-small {\n	font-weight: 600;\n	font-size: 11px;\n	color: var(--vscode-foreground);\n}\n\n.rate-limit-value.warning {\n	color: var(--vscode-notificationsWarningForeground, #ffa500);\n}\n\n/* Account Quota State (cached quota info) */\n.account-quota-state {\n	margin-top: 8px;\n	padding: 8px 10px;\n	border-radius: 4px;\n	background: var(--vscode-editor-background);\n	border: 1px solid var(--vscode-panel-border);\n	font-size: 11px;\n}\n\n.account-quota-state.success {\n	border-color: var(--vscode-notificationsInfoBorder, #3794ff);\n}\n\n.account-quota-state.warning {\n	border-color: var(--vscode-notificationsWarningBorder, #ffa500);\n	background: var(\n		--vscode-inputValidation-warningBackground,\n		rgba(255, 165, 0, 0.08)\n	);\n}\n\n.account-quota-state.error {\n	border-color: var(--vscode-notificationsErrorBorder, #f14c4c);\n	background: var(\n		--vscode-inputValidation-errorBackground,\n		rgba(241, 76, 76, 0.08)\n	);\n}\n\n.quota-state-header {\n	display: flex;\n	align-items: center;\n	gap: 6px;\n	margin-bottom: 6px;\n}\n\n.quota-state-icon {\n	font-size: 12px;\n}\n\n.quota-state-title {\n	font-weight: 600;\n	font-size: 11px;\n	color: var(--vscode-foreground);\n}\n\n.quota-state-content {\n	display: flex;\n	flex-direction: column;\n	gap: 2px;\n}\n\n.quota-state-row {\n	display: flex;\n	justify-content: space-between;\n	align-items: center;\n	gap: 8px;\n}\n\n.quota-state-row.warning {\n	color: var(--vscode-notificationsWarningForeground, #ffa500);\n}\n\n.quota-state-label {\n	color: var(--vscode-descriptionForeground);\n	font-size: 10px;\n}\n\n.quota-state-value {\n	font-family: var(--vscode-editor-font-family, monospace);\n	font-size: 10px;\n	color: var(--vscode-foreground);\n}\n\n.quota-state-value.success {\n	color: var(--vscode-notificationsInfoForeground, #3794ff);\n}\n\n.quota-state-value.warning {\n	color: var(--vscode-notificationsWarningForeground, #ffa500);\n}\n\n.quota-state-value.error {\n	color: var(--vscode-notificationsErrorForeground, #f14c4c);\n}\n\n/* Buttons */\n.btn {\n	display: inline-flex;\n	align-items: center;\n	gap: 6px;\n	padding: 8px 14px;\n	border: 1px solid transparent;\n	border-radius: 12px;\n	font-size: 12px;\n	font-weight: 600;\n	cursor: pointer;\n	transition: opacity 0.15s ease;\n}\n\n.btn:hover {\n	opacity: 0.85;\n}\n\n.btn-primary {\n	background-color: var(--vscode-button-background);\n	color: var(--vscode-button-foreground);\n}\n\n.btn-secondary {\n	background-color: var(--vscode-button-secondaryBackground);\n	color: var(--vscode-button-secondaryForeground);\n	border-color: transparent;\n}\n\n.btn-ghost {\n	background: transparent;\n	border-color: var(--vscode-panel-border);\n	color: var(--vscode-foreground);\n}\n\n.btn-ghost:hover {\n	background: var(--vscode-list-hoverBackground);\n}\n\n.btn-danger {\n	background-color: rgba(220, 53, 69, 0.15);\n	color: var(--vscode-errorForeground, #dc3545);\n	border: 1px solid rgba(220, 53, 69, 0.3);\n}\n\n.btn-icon {\n	padding: 8px 10px;\n	background: transparent;\n	border: 1px solid var(--vscode-panel-border);\n	min-width: 34px;\n	justify-content: center;\n}\n\n.btn-icon:hover {\n	background-color: var(--vscode-list-hoverBackground);\n}\n\n/* ===== SIMPLIFIED ACCOUNT CARD ===== */\n.account-card-simple {\n	display: flex;\n	align-items: center;\n	gap: 12px;\n	padding: 12px 14px;\n	border-radius: var(--radius-lg);\n	border: 1px solid var(--vscode-panel-border);\n	background: var(--vscode-editor-background);\n	transition: all 0.15s ease;\n}\n\n.account-card-simple:hover {\n	background: var(--vscode-list-hoverBackground);\n	border-color: var(--vscode-focusBorder);\n}\n\n.account-card-simple.active {\n	background: var(--vscode-list-inactiveSelectionBackground);\n	border-color: var(--vscode-focusBorder);\n}\n\n.account-card-simple.quota-limited {\n	border-color: var(--vscode-notificationsWarningBorder, #ffa500);\n	background: var(\n		--vscode-inputValidation-warningBackground,\n		rgba(255, 165, 0, 0.05)\n	);\n}\n\n.account-card-left {\n	display: flex;\n	align-items: center;\n	gap: 12px;\n	flex: 1;\n	min-width: 0;\n	cursor: pointer;\n}\n\n.account-info-compact {\n	flex: 1;\n	min-width: 0;\n}\n\n.account-name-row {\n	display: flex;\n	align-items: center;\n	gap: 8px;\n	flex-wrap: wrap;\n}\n\n.status-dot-inline {\n	width: 8px;\n	height: 8px;\n	border-radius: 50%;\n	background: var(--vscode-charts-green, #4caf50);\n	flex-shrink: 0;\n}\n\n.status-dot-inline.inactive,\n.status-dot-inline.error {\n	background: var(--vscode-charts-red, #f14c4c);\n}\n\n.status-dot-inline.pending {\n	background: var(--vscode-charts-yellow, #cca700);\n}\n\n.account-email-compact {\n	font-size: 11px;\n	color: var(--vscode-descriptionForeground);\n	margin-top: 2px;\n	overflow: hidden;\n	text-overflow: ellipsis;\n	white-space: nowrap;\n}\n\n.account-meta-compact {\n	display: flex;\n	gap: 12px;\n	margin-top: 4px;\n	font-size: 11px;\n	color: var(--vscode-descriptionForeground);\n}\n\n.account-stats {\n	font-family: var(--vscode-editor-font-family, monospace);\n}\n\n.quota-badge-compact {\n	padding: 4px 10px;\n	border-radius: 999px;\n	background: var(\n		--vscode-inputValidation-warningBackground,\n		rgba(255, 165, 0, 0.15)\n	);\n	border: 1px solid var(--vscode-notificationsWarningBorder, #ffa500);\n	font-size: 11px;\n	font-weight: 600;\n	color: var(--vscode-notificationsWarningForeground, #ffa500);\n	white-space: nowrap;\n}\n\n.quota-countdown-compact {\n	font-variant-numeric: tabular-nums;\n}\n\n/* Bigger, easier to click action buttons */\n.account-actions-compact {\n	display: flex;\n	gap: 8px;\n	flex-shrink: 0;\n}\n\n.btn-action {\n	display: flex;\n	align-items: center;\n	justify-content: center;\n	min-width: 44px;\n	height: 44px;\n	padding: 0 16px;\n	border-radius: 12px;\n	border: 1px solid var(--vscode-panel-border);\n	background: transparent;\n	color: var(--vscode-foreground);\n	font-size: 14px;\n	font-weight: 600;\n	cursor: pointer;\n	transition: all 0.15s ease;\n}\n\n.btn-action:hover {\n	background: var(--vscode-list-hoverBackground);\n}\n\n.btn-action.btn-use {\n	background: var(--vscode-button-background);\n	color: var(--vscode-button-foreground);\n	border-color: transparent;\n	padding: 0 20px;\n}\n\n.btn-action.btn-use:hover {\n	opacity: 0.9;\n}\n\n.btn-action.btn-info {\n	font-size: 16px;\n}\n\n.btn-action.btn-delete {\n	color: var(--vscode-errorForeground, #f14c4c);\n	font-size: 16px;\n}\n\n.btn-action.btn-delete:hover {\n	background: rgba(220, 53, 69, 0.15);\n	border-color: rgba(220, 53, 69, 0.3);\n}\n\n/* Legacy account-card styles (keep for compatibility) */\n.account-card {\n	display: flex;\n	align-items: flex-start;\n	justify-content: space-between;\n	gap: 12px;\n	padding: 12px 12px;\n	border-radius: var(--radius-lg);\n	border: 1px solid var(--vscode-panel-border);\n	background: var(--vscode-editor-background);\n	transition:\n		background-color 0.15s ease,\n		border-color 0.15s ease;\n	position: relative;\n}\n\n.account-card.clickable {\n	cursor: pointer;\n}\n\n.account-card.clickable::after {\n	content: "";\n	position: absolute;\n	inset: 0;\n	border-radius: var(--radius-lg);\n	box-shadow: inset 0 0 0 1px transparent;\n	pointer-events: none;\n	transition: box-shadow 0.15s ease;\n}\n\n.account-card.clickable:hover::after {\n	box-shadow: inset 0 0 0 1px var(--vscode-focusBorder);\n}\n\n.account-card:hover {\n	background: var(--vscode-list-hoverBackground);\n	border-color: var(--vscode-focusBorder);\n}\n\n.account-card.active {\n	background: var(--vscode-list-inactiveSelectionBackground);\n	border-color: var(--vscode-focusBorder);\n}\n\n/* Quota limited account card - Simplified */\n.account-card.quota-limited {\n	border-color: var(--vscode-notificationsWarningBorder, #ffa500);\n	background: var(\n		--vscode-inputValidation-warningBackground,\n		rgba(255, 165, 0, 0.05)\n	);\n}\n\n.account-card-main {\n	display: flex;\n	align-items: flex-start;\n	gap: 12px;\n	min-width: 0;\n	flex: 1;\n}\n\n.account-avatar {\n	display: flex;\n	align-items: center;\n	justify-content: center;\n	width: 32px;\n	height: 32px;\n	border-radius: 50%;\n	background: var(--vscode-textLink-foreground, #3794ff);\n	color: #fff;\n	font-size: 12px;\n	font-weight: 600;\n	flex-shrink: 0;\n	text-transform: uppercase;\n}\n\n.account-card-info {\n	min-width: 0;\n	flex: 1;\n}\n\n.account-card-title {\n	display: flex;\n	flex-wrap: wrap;\n	gap: 6px;\n	align-items: center;\n}\n\n.account-name {\n	font-size: 13px;\n	font-weight: 700;\n	color: var(--vscode-foreground);\n	margin-right: 2px;\n}\n\n.badge {\n	display: inline-flex;\n	align-items: center;\n	gap: 6px;\n	padding: 3px 8px;\n	border-radius: 999px;\n	font-size: 11px;\n	font-weight: 700;\n	border: 1px solid var(--vscode-panel-border);\n	background: transparent;\n	color: var(--vscode-foreground);\n}\n\n.badge-primary {\n	background: var(--vscode-badge-background);\n	border-color: transparent;\n	color: var(--vscode-badge-foreground);\n}\n\n.badge-muted {\n	color: var(--vscode-descriptionForeground);\n}\n\n.badge-warning {\n	border-color: var(--vscode-notificationsWarningBorder, #ffa500);\n	color: var(--vscode-notificationsWarningForeground, #ffa500);\n	background: var(\n		--vscode-inputValidation-warningBackground,\n		rgba(255, 165, 0, 0.08)\n	);\n}\n\n.badge-status {\n	color: var(--vscode-descriptionForeground);\n}\n\n.account-quota-inline {\n	margin-top: 8px;\n	display: inline-flex;\n	flex-wrap: wrap;\n	align-items: center;\n	gap: 8px;\n	padding: 6px 10px;\n	border-radius: 999px;\n	border: 1px solid var(--vscode-notificationsWarningBorder, #ffa500);\n	background: var(\n		--vscode-inputValidation-warningBackground,\n		rgba(255, 165, 0, 0.08)\n	);\n	font-size: 11px;\n}\n\n.quota-model {\n	color: var(--vscode-foreground);\n	font-weight: 600;\n}\n\n.quota-timer {\n	color: var(--vscode-descriptionForeground);\n	font-size: 11px;\n}\n\n.quota-timer .account-quota-countdown {\n	font-weight: 600;\n	color: var(--vscode-foreground);\n	font-variant-numeric: tabular-nums;\n	font-size: 12px;\n}\n\n.account-email {\n	font-size: 11px;\n	color: var(--vscode-descriptionForeground);\n	margin-top: 2px;\n}\n\n.account-meta {\n	display: flex;\n	gap: 10px;\n	margin-top: 4px;\n	font-size: 11px;\n	color: var(--vscode-descriptionForeground);\n}\n\n.account-meta-item {\n	display: flex;\n	align-items: center;\n	gap: 4px;\n}\n\n/* Legacy status pills (still used in details modal) */\n.account-status {\n	display: inline-flex;\n	align-items: center;\n	gap: 6px;\n	padding: 3px 10px;\n	border-radius: 999px;\n	font-size: 11px;\n	font-weight: 700;\n	border: 1px solid var(--vscode-panel-border);\n}\n\n.account-status.active {\n	background: rgba(40, 167, 69, 0.12);\n	border-color: rgba(40, 167, 69, 0.28);\n	color: #28a745;\n}\n\n.account-status.inactive {\n	background: rgba(108, 117, 125, 0.12);\n	border-color: rgba(108, 117, 125, 0.28);\n	color: #6c757d;\n}\n\n.account-status.expired {\n	background: rgba(255, 193, 7, 0.12);\n	border-color: rgba(255, 193, 7, 0.28);\n	color: #ffc107;\n}\n\n.account-status.error {\n	background: rgba(220, 53, 69, 0.12);\n	border-color: rgba(220, 53, 69, 0.28);\n	color: #dc3545;\n}\n\n.status-dot {\n	width: 6px;\n	height: 6px;\n	border-radius: 50%;\n}\n\n.status-dot.active {\n	background-color: #28a745;\n}\n\n.status-dot.inactive {\n	background-color: #6c757d;\n}\n\n.status-dot.expired {\n	background-color: #ffc107;\n}\n\n.status-dot.error {\n	background-color: #dc3545;\n}\n\n.account-card-actions {\n	display: flex;\n	gap: 8px;\n	align-items: center;\n	justify-content: flex-end;\n	flex-shrink: 0;\n}\n\n.btn-compact {\n	padding: 6px 12px;\n	font-size: 11px;\n	border-radius: 10px;\n}\n\n/* Empty State - Simplified */\n.empty-state {\n	text-align: center;\n	padding: 32px 16px;\n	color: var(--vscode-descriptionForeground);\n}\n\n.empty-state-title {\n	font-size: 15px;\n	font-weight: 600;\n	color: var(--vscode-foreground);\n	margin-bottom: 8px;\n}\n\n.empty-state-description {\n	font-size: 13px;\n	margin-bottom: 16px;\n	line-height: 1.5;\n}\n\n/* Modal - Simplified */\n.modal-overlay {\n	position: fixed;\n	top: 0;\n	left: 0;\n	right: 0;\n	bottom: 0;\n	background-color: rgba(0, 0, 0, 0.5);\n	display: flex;\n	align-items: center;\n	justify-content: center;\n	z-index: 1000;\n	animation: fadeIn 0.15s ease;\n}\n\n@keyframes fadeIn {\n	from {\n		opacity: 0;\n	}\n	to {\n		opacity: 1;\n	}\n}\n\n.modal {\n	background-color: var(--vscode-editor-background);\n	border-radius: var(--radius-lg);\n	border: 1px solid var(--vscode-panel-border);\n	max-width: 500px;\n	width: 90%;\n	max-height: 85vh;\n	overflow: hidden;\n	display: flex;\n	flex-direction: column;\n	animation: slideUp 0.15s ease;\n}\n\n@keyframes slideUp {\n	from {\n		opacity: 0;\n		transform: translateY(10px);\n	}\n	to {\n		opacity: 1;\n		transform: translateY(0);\n	}\n}\n\n.modal-header {\n	display: flex;\n	justify-content: space-between;\n	align-items: center;\n	padding: 14px 16px;\n	border-bottom: 1px solid var(--vscode-panel-border);\n	background: var(--vscode-editor-background);\n}\n\n.modal-title {\n	font-size: 16px;\n	font-weight: 600;\n}\n\n.modal-close {\n	background: none;\n	border: none;\n	font-size: 20px;\n	cursor: pointer;\n	color: var(--vscode-foreground);\n	opacity: 0.6;\n	transition: opacity 0.15s ease;\n	width: 28px;\n	height: 28px;\n	display: flex;\n	align-items: center;\n	justify-content: center;\n	border-radius: 10px;\n}\n\n.modal-close:hover {\n	opacity: 1;\n	background-color: var(--vscode-list-hoverBackground);\n}\n\n.modal-body {\n	padding: 16px;\n	overflow-y: auto;\n}\n\n.modal-footer {\n	display: flex;\n	justify-content: flex-end;\n	gap: 8px;\n	padding: 14px 16px;\n	border-top: 1px solid var(--vscode-panel-border);\n	background-color: var(--vscode-editor-background);\n}\n\n/* Form Elements - Simplified */\n.form-group {\n	margin-bottom: 16px;\n}\n\n.form-label {\n	display: block;\n	font-size: 12px;\n	font-weight: 600;\n	margin-bottom: 6px;\n	color: var(--vscode-foreground);\n}\n\n.form-input {\n	width: 100%;\n	padding: 8px 12px;\n	font-size: 12px;\n	border: 1px solid var(--vscode-input-border);\n	border-radius: 12px;\n	background-color: var(--vscode-input-background);\n	color: var(--vscode-input-foreground);\n	transition: border-color 0.15s ease;\n}\n\n.form-input:focus {\n	outline: none;\n	border-color: var(--vscode-focusBorder);\n}\n\n.form-input::placeholder {\n	color: var(--vscode-input-placeholderForeground);\n}\n\n.form-select {\n	width: 100%;\n	padding: 8px 12px;\n	font-size: 12px;\n	border: 1px solid var(--vscode-input-border);\n	border-radius: 12px;\n	background-color: var(--vscode-input-background);\n	color: var(--vscode-input-foreground);\n	cursor: pointer;\n	transition: border-color 0.15s ease;\n}\n\n.form-select:focus {\n	outline: none;\n	border-color: var(--vscode-focusBorder);\n}\n\n.form-hint {\n	font-size: 11px;\n	color: var(--vscode-descriptionForeground);\n	margin-top: 4px;\n	line-height: 1.4;\n}\n\n/* Provider Select Grid - Simplified */\n.provider-select-grid {\n	display: grid;\n	grid-template-columns: repeat(2, 1fr);\n	gap: 12px;\n	margin-bottom: 16px;\n}\n\n.provider-select-item {\n	display: flex;\n	align-items: center;\n	gap: 10px;\n	padding: 10px;\n	border: 1px solid var(--vscode-panel-border);\n	border-radius: 12px;\n	cursor: pointer;\n	transition:\n		border-color 0.15s ease,\n		background-color 0.15s ease;\n	background: var(--vscode-editor-background);\n}\n\n.provider-select-item:hover {\n	border-color: var(--vscode-focusBorder);\n	background: var(--vscode-list-hoverBackground);\n}\n\n.provider-select-item.selected {\n	border-color: var(--vscode-textLink-foreground);\n	background: var(--vscode-list-inactiveSelectionBackground);\n}\n\n.provider-select-icon {\n	display: inline-flex;\n	width: 32px;\n	height: 32px;\n	border-radius: var(--radius-sm);\n	align-items: center;\n	justify-content: center;\n	background: var(--vscode-badge-background);\n	color: var(--vscode-badge-foreground);\n	font-size: 16px;\n	flex-shrink: 0;\n}\n\n.provider-select-info {\n	flex: 1;\n}\n\n.provider-select-name {\n	font-weight: 600;\n	font-size: 13px;\n	margin-bottom: 2px;\n}\n\n.provider-select-type {\n	font-size: 10px;\n	color: var(--vscode-descriptionForeground);\n	text-transform: uppercase;\n	letter-spacing: 0.3px;\n}\n\n/* Toast Notifications - Simplified */\n.toast-container {\n	position: fixed;\n	top: 16px;\n	right: 16px;\n	z-index: 2000;\n	display: flex;\n	flex-direction: column;\n	gap: 8px;\n}\n\n.toast {\n	display: flex;\n	align-items: center;\n	gap: 10px;\n	padding: 10px 14px;\n	border-radius: 12px;\n	animation: slideIn 0.15s ease;\n	min-width: 250px;\n	font-size: 12px;\n}\n\n.toast.success {\n	background: rgba(40, 167, 69, 0.9);\n	color: white;\n}\n\n.toast.error {\n	background: rgba(220, 53, 69, 0.9);\n	color: white;\n}\n\n.toast.warning {\n	background: rgba(255, 193, 7, 0.9);\n	color: #000;\n}\n\n.toast.info {\n	background: var(--vscode-button-background);\n	color: var(--vscode-button-foreground);\n}\n\n@keyframes slideIn {\n	from {\n		transform: translateX(100%);\n		opacity: 0;\n	}\n	to {\n		transform: translateX(0);\n		opacity: 1;\n	}\n}\n\n/* Loading Spinner - Simplified */\n.loading-spinner {\n	display: inline-block;\n	width: 14px;\n	height: 14px;\n	border: 2px solid var(--vscode-foreground);\n	border-radius: 50%;\n	border-top-color: transparent;\n	animation: spin 0.7s linear infinite;\n}\n\n@keyframes spin {\n	to {\n		transform: rotate(360deg);\n	}\n}\n\n/* Responsive - Simplified */\n@media (max-width: 768px) {\n	.layout {\n		grid-template-columns: 1fr;\n	}\n\n	.sidebar {\n		position: static;\n		top: auto;\n	}\n\n	.provider-select-grid {\n		grid-template-columns: 1fr;\n	}\n\n	/* Simplified account card on mobile */\n	.account-card-simple {\n		flex-wrap: wrap;\n		gap: 10px;\n	}\n\n	.account-card-left {\n		width: 100%;\n	}\n\n	.account-actions-compact {\n		width: 100%;\n		justify-content: flex-end;\n	}\n\n	.btn-action {\n		min-width: 48px;\n		height: 48px;\n	}\n\n	.btn-action.btn-use {\n		flex: 1;\n		max-width: 120px;\n	}\n\n	.quota-badge-compact {\n		margin-left: auto;\n	}\n}\n\n/* Scrollbar - Simplified */\n::-webkit-scrollbar {\n	width: 6px;\n	height: 6px;\n}\n\n::-webkit-scrollbar-track {\n	background: transparent;\n}\n\n::-webkit-scrollbar-thumb {\n	background-color: var(--vscode-scrollbarSlider-background);\n	border-radius: 3px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n	background-color: var(--vscode-scrollbarSlider-hoverBackground);\n}\n';
  }
});

// raw-file:../ui/accountManager.js
var accountManager_default2;
var init_accountManager3 = __esm({
  "raw-file:../ui/accountManager.js"() {
    accountManager_default2 = '/**\r\n * Account Manager Page JavaScript\r\n * Handles all UI interactions for the Account Manager WebView\r\n */\r\n\r\n// VS Code API\r\nconst vscode = acquireVsCodeApi();\r\n\r\n// State\r\nlet accounts = [];\r\nlet providers = [];\r\nlet selectedProvider = null;\r\nlet antigravityQuota = null;\r\nlet antigravityQuotaTimer = null;\r\nlet codexRateLimits = [];\r\nlet accountQuotaStates = [];\r\nlet _providerImageUris = {};\r\n\r\n/**\r\n * Initialize the Account Manager\r\n */\r\nfunction _initializeAccountManager(\r\n    initialAccounts,\r\n    initialProviders,\r\n    initialAntigravityQuota,\r\n    initialCodexRateLimits,\r\n    initialAccountQuotaStates,\r\n    initialProviderImageUris,\r\n) {\r\n    accounts = initialAccounts || [];\r\n    providers = initialProviders || [];\r\n    antigravityQuota = normalizeAntigravityQuota(initialAntigravityQuota);\r\n    codexRateLimits = initialCodexRateLimits || [];\r\n    accountQuotaStates = initialAccountQuotaStates || [];\r\n    _providerImageUris = initialProviderImageUris || {};\r\n\r\n    // Restore selected provider from persisted state if possible\r\n    try {\r\n        const state = vscode.getState() || {};\r\n        if (typeof state.selectedProvider === "string") {\r\n            selectedProvider = state.selectedProvider;\r\n        }\r\n    } catch {\r\n        // Ignore state restore failures\r\n    }\r\n    ensureSelectedProvider();\r\n\r\n    renderPage();\r\n    setupEventListeners();\r\n}\r\n\r\n/**\r\n * Render the entire page\r\n */\r\nfunction renderPage() {\r\n    const app = document.getElementById("app");\r\n    if (!app) {\r\n        console.error("Account Manager: app element not found");\r\n        return;\r\n    }\r\n    ensureSelectedProvider();\r\n    app.innerHTML = `\r\n        <div class="shell">\r\n            ${renderHeader()}\r\n            ${renderQuotaBanner()}\r\n            ${renderMainLayout()}\r\n            <div id="modal-container"></div>\r\n            <div class="toast-container" id="toast-container"></div>\r\n        </div>\r\n    `;\r\n    startQuotaCountdown();\r\n}\r\n\r\n/**\r\n * Render header section\r\n */\r\nfunction renderHeader() {\r\n    const totalAccounts = accounts.length;\r\n    const providersWithAccounts = [...new Set(accounts.map((a) => a.provider))]\r\n        .length;\r\n    const subtitle = `${totalAccounts} account${totalAccounts !== 1 ? "s" : ""} \xB7 ${providersWithAccounts} provider${providersWithAccounts !== 1 ? "s" : ""}`;\r\n    return `\r\n        <div class="topbar">\r\n            <div class="topbar-title">\r\n                <div class="topbar-title-text">Account Manager</div>\r\n                <div class="topbar-subtitle">${escapeHtml(subtitle)}</div>\r\n            </div>\r\n            <div class="topbar-actions">\r\n                <a class="settings-link" href="#" onclick="openGCMPSettings(); return false;" title="Configure load balancing and advanced settings for AI Chat Models">\r\n                    <span class="settings-icon"></span>\r\n                    <span class="settings-text">GCMP Settings</span>\r\n                </a>\r\n                <button class="btn btn-primary" onclick="showAddAccountModal()">Add account</button>\r\n                <button class="btn btn-ghost" onclick="refreshAccounts()">Refresh</button>\r\n            </div>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Open GCMP Settings page\r\n */\r\nfunction _openGCMPSettings() {\r\n    vscode.postMessage({\r\n        command: "openSettings",\r\n    });\r\n}\r\n\r\n/**\r\n * Render Antigravity quota banner\r\n */\r\nfunction renderQuotaBanner() {\r\n    if (!antigravityQuota) {\r\n        return "";\r\n    }\r\n\r\n    const remaining = antigravityQuota.resetAt - Date.now();\r\n    if (remaining <= 0) {\r\n        return "";\r\n    }\r\n\r\n    const modelLabel = antigravityQuota.modelName\r\n        ? escapeHtml(antigravityQuota.modelName)\r\n        : "Unknown model";\r\n    const accountLabel = antigravityQuota.accountName\r\n        ? escapeHtml(antigravityQuota.accountName)\r\n        : "";\r\n\r\n    return `\r\n        <div class="notice notice-warning" id="quota-banner">\r\n            <div class="notice-title">Quota exceeded</div>\r\n            <div class="notice-body">\r\n                <div><strong>${modelLabel}</strong> ${accountLabel ? `\xB7 ${accountLabel}` : ""}</div>\r\n                <div class="notice-meta">Retry in <span class="quota-countdown" id="quota-countdown">${formatCountdown(remaining)}</span></div>\r\n            </div>\r\n        </div>\r\n    `;\r\n}\r\n\r\nfunction renderMainLayout() {\r\n    const providerSummary = getProviderSummary();\r\n    if (providerSummary.length === 0) {\r\n        return `\r\n            <div class="layout">\r\n                <div class="surface sidebar">\r\n                    <div class="sidebar-header">\r\n                        <div class="sidebar-title">Providers</div>\r\n                    </div>\r\n                    <div class="sidebar-empty">No providers</div>\r\n                </div>\r\n                <div class="surface content">\r\n                    ${renderEmptyState()}\r\n                </div>\r\n            </div>\r\n        `;\r\n    }\r\n\r\n    // Ensure selected provider exists\r\n    const selected =\r\n        providerSummary.find((p) => p.id === selectedProvider) ||\r\n        providerSummary[0];\r\n    if (selected && selected.id !== selectedProvider) {\r\n        setSelectedProvider(selected.id);\r\n    }\r\n\r\n    const providerAccounts = accounts.filter(\r\n        (a) => a.provider === selectedProvider,\r\n    );\r\n\r\n    return `\r\n        <div class="layout">\r\n            ${renderSidebar(providerSummary)}\r\n            ${renderContent(selected, providerAccounts)}\r\n        </div>\r\n    `;\r\n}\r\n\r\nfunction renderSidebar(providerSummary) {\r\n    return `\r\n        <div class="surface sidebar">\r\n            <div class="sidebar-header">\r\n                <div class="sidebar-title">Providers</div>\r\n            </div>\r\n            <div class="provider-list">\r\n                ${providerSummary\r\n            .map((p) => {\r\n                const isActive = p.id === selectedProvider;\r\n                return `\r\n                        <button class="provider-item ${isActive ? "active" : ""}" onclick="setSelectedProvider(\'${p.id}\')" title="${escapeHtml(p.name)}">\r\n                            <span class="provider-item-icon">${getProviderIcon(p.id)}</span>\r\n                            <span class="provider-item-name">${escapeHtml(p.name)}</span>\r\n                            <span class="provider-item-count">${p.count}</span>\r\n                        </button>\r\n                    `;\r\n            })\r\n            .join("")}\r\n            </div>\r\n            <div class="sidebar-footer">\r\n                <button class="btn btn-ghost btn-block" onclick="showAddAccountModal()">Add account</button>\r\n            </div>\r\n        </div>\r\n    `;\r\n}\r\n\r\nfunction renderContent(selectedProviderInfo, providerAccounts) {\r\n    if (!selectedProviderInfo) {\r\n        return `<div class="surface content">${renderEmptyState()}</div>`;\r\n    }\r\n\r\n    const title = escapeHtml(selectedProviderInfo.name);\r\n    const countLabel = `${providerAccounts.length} account${providerAccounts.length !== 1 ? "s" : ""}`;\r\n\r\n    return `\r\n        <div class="surface content">\r\n            <div class="content-header">\r\n                <div>\r\n                    <div class="content-title">${title}</div>\r\n                    <div class="content-subtitle">${escapeHtml(countLabel)}</div>\r\n                </div>\r\n                <div class="content-actions">\r\n                    <button class="btn btn-ghost" onclick="addAccountForProvider(\'${selectedProviderInfo.id}\')">Add</button>\r\n                </div>\r\n            </div>\r\n\r\n            ${providerAccounts.length > 0\r\n            ? `<div class="account-cards">${providerAccounts.map((account) => renderAccountCard(account)).join("")}</div>`\r\n            : renderProviderEmptyState(selectedProviderInfo.id)\r\n        }\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Get quota state for a specific account\r\n */\r\nfunction getAccountQuotaState(accountId) {\r\n    console.log("[DEBUG] getAccountQuotaState called with accountId:", accountId);\r\n    console.log(\r\n        "[DEBUG] Available accountQuotaStates:",\r\n        accountQuotaStates.map((qs) => ({\r\n            accountId: qs.accountId,\r\n            provider: qs.provider,\r\n            successCount: qs.successCount,\r\n        })),\r\n    );\r\n    const state = accountQuotaStates.find((qs) => qs.accountId === accountId);\r\n    console.log(\r\n        "[DEBUG] Found state for accountId",\r\n        accountId,\r\n        ":",\r\n        state\r\n            ? { successCount: state.successCount, failureCount: state.failureCount }\r\n            : null,\r\n    );\r\n    return state || null;\r\n}\r\n\r\n/**\r\n * Check if account is in quota cooldown\r\n */\r\nfunction isAccountInQuotaCooldown(accountId) {\r\n    const state = getAccountQuotaState(accountId);\r\n    if (!state || !state.quotaExceeded || !state.quotaResetAt) {\r\n        return false;\r\n    }\r\n    return Date.now() < state.quotaResetAt;\r\n}\r\n\r\n/**\r\n * Render quota state info for an account\r\n */\r\nfunction _renderAccountQuotaState(accountId) {\r\n    const state = getAccountQuotaState(accountId);\r\n    if (!state) {\r\n        return "";\r\n    }\r\n\r\n    const isInCooldown = isAccountInQuotaCooldown(accountId);\r\n    const remaining = isInCooldown ? state.quotaResetAt - Date.now() : 0;\r\n\r\n    // Calculate success rate\r\n    const totalRequests = state.successCount + state.failureCount;\r\n    const successRate =\r\n        totalRequests > 0\r\n            ? Math.round((state.successCount / totalRequests) * 100)\r\n            : 100;\r\n\r\n    let statusClass = "success";\r\n    if (isInCooldown) {\r\n        statusClass = "warning";\r\n    } else if (successRate < 50) {\r\n        statusClass = "error";\r\n    } else if (successRate < 80) {\r\n        statusClass = "warning";\r\n    }\r\n\r\n    return `\r\n        <div class="account-quota-state ${statusClass}">\r\n            <div class="quota-state-header">\r\n                <span class="quota-state-icon">${isInCooldown ? "WAIT" : "STATS"}</span>\r\n                <span class="quota-state-title">Quota Status</span>\r\n            </div>\r\n            <div class="quota-state-content">\r\n                ${isInCooldown\r\n            ? `\r\n                    <div class="quota-state-row warning">\r\n                        <span class="quota-state-label">Cooldown:</span>\r\n                        <span class="quota-state-value account-quota-countdown" data-reset-at="${state.quotaResetAt}">${formatCountdown(remaining)}</span>\r\n                    </div>\r\n                    ${state.affectedModel\r\n                ? `\r\n                        <div class="quota-state-row">\r\n                            <span class="quota-state-label">Model:</span>\r\n                            <span class="quota-state-value">${escapeHtml(state.affectedModel)}</span>\r\n                        </div>\r\n                    `\r\n                : ""\r\n            }\r\n                `\r\n            : ""\r\n        }\r\n                <div class="quota-state-row">\r\n                    <span class="quota-state-label">Success:</span>\r\n                    <span class="quota-state-value">${state.successCount} requests</span>\r\n                </div>\r\n                <div class="quota-state-row">\r\n                    <span class="quota-state-label">Failures:</span>\r\n                    <span class="quota-state-value">${state.failureCount} requests</span>\r\n                </div>\r\n                <div class="quota-state-row">\r\n                    <span class="quota-state-label">Rate:</span>\r\n                    <span class="quota-state-value ${statusClass}">${successRate}%</span>\r\n                </div>\r\n                ${state.lastSuccessAt\r\n            ? `\r\n                    <div class="quota-state-row">\r\n                        <span class="quota-state-label">Last success:</span>\r\n                        <span class="quota-state-value">${formatTimeAgo(state.lastSuccessAt)}</span>\r\n                    </div>\r\n                `\r\n            : ""\r\n        }\r\n                ${state.lastError\r\n            ? `\r\n                    <div class="quota-state-row error">\r\n                        <span class="quota-state-label">Last error:</span>\r\n                        <span class="quota-state-value">${escapeHtml(state.lastError)}</span>\r\n                    </div>\r\n                `\r\n            : ""\r\n        }\r\n            </div>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Format time ago\r\n */\r\nfunction formatTimeAgo(timestamp) {\r\n    const seconds = Math.floor((Date.now() - timestamp) / 1000);\r\n    if (seconds < 60) return "just now";\r\n    const minutes = Math.floor(seconds / 60);\r\n    if (minutes < 60) return `${minutes}m ago`;\r\n    const hours = Math.floor(minutes / 60);\r\n    if (hours < 24) return `${hours}h ago`;\r\n    const days = Math.floor(hours / 24);\r\n    return `${days}d ago`;\r\n}\r\n\r\n/**\r\n * Get rate limit for a specific account\r\n */\r\nfunction getCodexRateLimitForAccount(accountId) {\r\n    return codexRateLimits.find((rl) => rl.accountId === accountId) || null;\r\n}\r\n\r\n/**\r\n * Render rate limit info for a Codex account\r\n */\r\nfunction _renderAccountRateLimit(accountId) {\r\n    const rateLimit = getCodexRateLimitForAccount(accountId);\r\n    if (!rateLimit) {\r\n        return "";\r\n    }\r\n\r\n    const primaryRemaining = rateLimit.primary\r\n        ? 100 - rateLimit.primary.usedPercent\r\n        : null;\r\n    const secondaryRemaining = rateLimit.secondary\r\n        ? 100 - rateLimit.secondary.usedPercent\r\n        : null;\r\n    const minRemaining = Math.min(\r\n        primaryRemaining ?? 100,\r\n        secondaryRemaining ?? 100,\r\n    );\r\n    const isWarning = minRemaining < 30;\r\n\r\n    const formatWindowLabel = (minutes) => {\r\n        if (!minutes) {\r\n            return "5h";\r\n        }\r\n        if (minutes < 60) {\r\n            return `${minutes}m`;\r\n        }\r\n        const hours = Math.floor(minutes / 60);\r\n        if (hours < 24) {\r\n            return `${hours}h`;\r\n        }\r\n        const days = Math.floor(hours / 24);\r\n        if (days === 7) {\r\n            return "Weekly";\r\n        }\r\n        return `${days}d`;\r\n    };\r\n\r\n    const renderProgressBar = (percent) => {\r\n        const filled = Math.round((percent / 100) * 10);\r\n        const empty = 10 - filled;\r\n        return "\u2588".repeat(filled) + "\u2591".repeat(empty);\r\n    };\r\n\r\n    let content = "";\r\n    if (rateLimit.primary) {\r\n        const label = formatWindowLabel(rateLimit.primary.windowMinutes);\r\n        const remaining = (100 - rateLimit.primary.usedPercent).toFixed(0);\r\n        const bar = renderProgressBar(100 - rateLimit.primary.usedPercent);\r\n        content += `<div class="rate-limit-row"><span class="rate-limit-label">${label}:</span><span class="rate-limit-bar">[${bar}]</span><span class="rate-limit-value ${isWarning && remaining < 30 ? "warning" : ""}">${remaining}%</span></div>`;\r\n    }\r\n    if (rateLimit.secondary) {\r\n        const label = formatWindowLabel(rateLimit.secondary.windowMinutes);\r\n        const remaining = (100 - rateLimit.secondary.usedPercent).toFixed(0);\r\n        const bar = renderProgressBar(100 - rateLimit.secondary.usedPercent);\r\n        const rowWarning = remaining < 30;\r\n        content += `<div class="rate-limit-row"><span class="rate-limit-label">${label}:</span><span class="rate-limit-bar">[${bar}]</span><span class="rate-limit-value ${rowWarning ? "warning" : ""}">${remaining}%</span></div>`;\r\n    }\r\n\r\n    const updatedAt = rateLimit.capturedAt\r\n        ? new Date(rateLimit.capturedAt).toLocaleTimeString()\r\n        : "";\r\n\r\n    return `\r\n        <div class="account-rate-limit ${isWarning ? "warning" : ""}">\r\n            <div class="rate-limit-header-inline">\r\n                <span class="rate-limit-icon"></span>\r\n                <span class="rate-limit-title-small">Rate Limit</span>\r\n                ${updatedAt ? `<span class="rate-limit-updated">${updatedAt}</span>` : ""}\r\n            </div>\r\n            <div class="rate-limit-content">\r\n                ${content}\r\n            </div>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Render provider sections\r\n */\r\nfunction _renderProviderSections() {\r\n    // Group accounts by provider\r\n    const accountsByProvider = {};\r\n    for (const account of accounts) {\r\n        if (!accountsByProvider[account.provider]) {\r\n            accountsByProvider[account.provider] = [];\r\n        }\r\n        accountsByProvider[account.provider].push(account);\r\n    }\r\n\r\n    // Get all providers (including those without accounts)\r\n    const allProviders = [\r\n        ...new Set([\r\n            ...providers.map((p) => p.id),\r\n            ...Object.keys(accountsByProvider),\r\n        ]),\r\n    ];\r\n\r\n    if (allProviders.length === 0) {\r\n        return renderEmptyState();\r\n    }\r\n\r\n    return allProviders\r\n        .map((providerId) => {\r\n            const providerInfo = providers.find((p) => p.id === providerId) || {\r\n                id: providerId,\r\n                name: providerId,\r\n            };\r\n            const providerAccounts = accountsByProvider[providerId] || [];\r\n            const isCollapsed = collapsedProviders[providerId];\r\n\r\n            return `\r\n            <div class="provider-section" data-provider="${providerId}">\r\n                <div class="provider-header" onclick="toggleProvider(\'${providerId}\')">\r\n                    <div class="provider-title">\r\n                        <span class="provider-icon">${getProviderIcon(providerId)}</span>\r\n                        <span class="provider-name">${escapeHtml(providerInfo.name || providerId)}</span>\r\n                        <span class="provider-badge">${providerAccounts.length} account${providerAccounts.length !== 1 ? "s" : ""}</span>\r\n                    </div>\r\n                    <div class="provider-actions">\r\n                        <button class="btn btn-icon" onclick="event.stopPropagation(); addAccountForProvider(\'${providerId}\')" title="Add account">\r\n                            +\r\n                        </button>\r\n                        <span style="font-size: 12px; opacity: 0.6;">${isCollapsed ? "\u25B8" : "\u25BE"}</span>\r\n                    </div>\r\n                </div>\r\n                <div class="provider-content ${isCollapsed ? "collapsed" : ""}">\r\n                    ${providerAccounts.length > 0\r\n                    ? renderAccountList(providerAccounts)\r\n                    : renderProviderEmptyState(providerId)\r\n                }\r\n                </div>\r\n            </div>\r\n        `;\r\n        })\r\n        .join("");\r\n}\r\n\r\n/**\r\n * Render account list for a provider\r\n */\r\nfunction renderAccountList(providerAccounts) {\r\n    return `\r\n        <div class="account-list">\r\n            ${renderAccountListHeader()}\r\n            ${providerAccounts.map((account) => renderAccountCard(account)).join("")}\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Render account list header\r\n */\r\nfunction renderAccountListHeader() {\r\n    return `\r\n        <div class="account-list-header">\r\n            <div class="account-col account-col-name">\u{1F464} Account</div>\r\n            <div class="account-col account-col-status">Status</div>\r\n            <div class="account-col account-col-auth">Auth Type</div>\r\n            <div class="account-col account-col-created">Created</div>\r\n            <div class="account-col account-col-actions">Actions</div>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Render a single account card - Simplified UI\r\n */\r\nfunction renderAccountCard(account) {\r\n    const initials = getInitials(account.displayName);\r\n    const isDefault = account.isDefault;\r\n    const isQuotaLimited =\r\n        antigravityQuota &&\r\n        account.provider === "antigravity" &&\r\n        antigravityQuota.accountId === account.id;\r\n    const isCodexAccount = account.provider === "codex";\r\n    const _codexRateLimit = isCodexAccount\r\n        ? getCodexRateLimitForAccount(account.id)\r\n        : null;\r\n\r\n    // Check account quota state from cache\r\n    const quotaState = getAccountQuotaState(account.id);\r\n    const isInQuotaCooldown = isAccountInQuotaCooldown(account.id);\r\n\r\n    const statusClass = escapeHtml(account.status);\r\n    const authLabel = account.authType === "oauth" ? "OAuth" : "API Key";\r\n\r\n    // Calculate success rate for compact display\r\n    let statsText = "";\r\n    if (quotaState) {\r\n        const total = quotaState.successCount + quotaState.failureCount;\r\n        const _rate =\r\n            total > 0 ? Math.round((quotaState.successCount / total) * 100) : 100;\r\n        statsText = `${quotaState.successCount}/${quotaState.failureCount}`;\r\n    }\r\n\r\n    return `\r\n        <div class="account-card-simple ${isDefault ? "active" : ""} ${isQuotaLimited || isInQuotaCooldown ? "quota-limited" : ""}" data-account-id="${account.id}">\r\n            <div class="account-card-left" onclick="handleAccountCardClick(event, \'${account.id}\', ${isDefault})">\r\n                <div class="account-avatar">${initials}</div>\r\n                <div class="account-info-compact">\r\n                    <div class="account-name-row">\r\n                        <span class="account-name">${escapeHtml(account.displayName)}</span>\r\n                        ${isDefault ? \'<span class="badge badge-primary">Current</span>\' : ""}\r\n                        <span class="badge badge-muted">${escapeHtml(authLabel)}</span>\r\n                        <span class="status-dot-inline ${statusClass}"></span>\r\n                    </div>\r\n                    ${account.email && account.email !== account.displayName ? `<div class="account-email-compact">${escapeHtml(account.email)}</div>` : ""}\r\n                    <div class="account-meta-compact">\r\n                        <span>Created ${formatDate(account.createdAt)}</span>\r\n                        ${statsText ? `<span class="account-stats">${statsText}</span>` : ""}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n            ${isQuotaLimited || isInQuotaCooldown\r\n            ? `\r\n                <div class="quota-badge-compact">\r\n                    <span class="quota-countdown-compact account-quota-countdown" data-reset-at="${isQuotaLimited ? antigravityQuota.resetAt : quotaState.quotaResetAt}">${formatCountdown((isQuotaLimited ? antigravityQuota.resetAt : quotaState.quotaResetAt) - Date.now())}</span>\r\n                </div>\r\n            `\r\n            : ""\r\n        }\r\n            <div class="account-actions-compact">\r\n                ${!isDefault ? `<button class="btn-action btn-use" onclick="event.stopPropagation(); setDefaultAccount(\'${account.id}\')" title="Use this account">Use</button>` : ""}\r\n                <button class="btn-action btn-info" onclick="event.stopPropagation(); showAccountDetails(\'${account.id}\')" title="View details">\u2139</button>\r\n                <button class="btn-action btn-delete" onclick="event.stopPropagation(); confirmDeleteAccount(\'${account.id}\', \'${escapeHtml(account.displayName)}\')" title="Delete account">\u2715</button>\r\n            </div>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Render empty state when no accounts\r\n */\r\nfunction renderEmptyState() {\r\n    return `\r\n        <div class="empty-state">\r\n            <div class="empty-state-title">No Accounts Configured</div>\r\n            <div class="empty-state-description">\r\n                Add your first account to start using AI models from different providers.\r\n            </div>\r\n            <button class="btn btn-primary" onclick="showAddAccountModal()">\r\n                + Add Your First Account\r\n            </button>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Render empty state for a specific provider\r\n */\r\nfunction renderProviderEmptyState(providerId) {\r\n    return `\r\n        <div class="empty-state" style="padding: 24px;">\r\n            <div class="empty-state-description">No accounts for this provider yet.</div>\r\n            <button class="btn btn-ghost" onclick="addAccountForProvider(\'${providerId}\')">Add</button>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Show add account modal\r\n */\r\nfunction _showAddAccountModal() {\r\n    const modalContainer = document.getElementById("modal-container");\r\n    modalContainer.innerHTML = `\r\n        <div class="modal-overlay" onclick="closeModal(event)">\r\n            <div class="modal" onclick="event.stopPropagation()">\r\n                <div class="modal-header">\r\n                    <h2 class="modal-title">Add New Account</h2>\r\n                    <button class="modal-close" onclick="closeModal()">&times;</button>\r\n                </div>\r\n                <div class="modal-body">\r\n                    <p style="margin-bottom: 16px; color: var(--vscode-descriptionForeground);">\r\n                        Select a provider to add an account:\r\n                    </p>\r\n                   \r\n                    <div class="provider-select-grid">\r\n                        ${providers\r\n            .map(\r\n                (p) => `\r\n                            <div class="provider-select-item" onclick="selectProviderForAdd(\'${p.id}\')" data-provider="${p.id}">\r\n                                <div class="provider-select-icon">${getProviderIcon(p.id)}</div>\r\n                                <div class="provider-select-info">\r\n                                    <div class="provider-select-name">${escapeHtml(p.name)}</div>\r\n                                    <div class="provider-select-type">${p.authType === "oauth" ? "OAuth Login" : "API Key"}</div>\r\n                                </div>\r\n                            </div>\r\n                        `,\r\n            )\r\n            .join("")}\r\n                    </div>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Select provider and show appropriate form\r\n */\r\nfunction _selectProviderForAdd(providerId) {\r\n    const provider = providers.find((p) => p.id === providerId);\r\n    if (!provider) return;\r\n\r\n    if (provider.authType === "oauth") {\r\n        // Trigger OAuth login\r\n        vscode.postMessage({\r\n            command: "addOAuthAccount",\r\n            provider: providerId,\r\n        });\r\n        closeModal();\r\n    } else {\r\n        showApiKeyForm(providerId, provider.name);\r\n    }\r\n}\r\n\r\n/**\r\n * Show API Key form\r\n */\r\nfunction showApiKeyForm(providerId, providerName) {\r\n    const modalContainer = document.getElementById("modal-container");\r\n    modalContainer.innerHTML = `\r\n        <div class="modal-overlay" onclick="closeModal(event)">\r\n            <div class="modal" onclick="event.stopPropagation()">\r\n                <div class="modal-header">\r\n                    <h2 class="modal-title">Add ${escapeHtml(providerName)} Account</h2>\r\n                    <button class="modal-close" onclick="closeModal()">&times;</button>\r\n                </div>\r\n                <div class="modal-body">\r\n                    <form id="add-account-form" onsubmit="submitAddAccount(event, \'${providerId}\')">\r\n                        <div class="form-group">\r\n                            <label class="form-label">Display Name *</label>\r\n                            <input type="text" class="form-input" id="displayName" \r\n                                   placeholder="e.g., Work Account, Personal" required>\r\n                            <div class="form-hint">A friendly name to identify this account</div>\r\n                        </div>\r\n                        <div class="form-group">\r\n                            <label class="form-label">API Key *</label>\r\n                            <input type="password" class="form-input" id="apiKey" \r\n                                   placeholder="sk-xxxxxxxxxxxxxxxxxxxxxxxx" required>\r\n                            <div class="form-hint">Your ${escapeHtml(providerName)} API key</div>\r\n                        </div>\r\n                        <div class="form-group">\r\n                            <label class="form-label">Base URL (Optional)</label>\r\n                            <input type="url" class="form-input" id="endpoint" \r\n                                   placeholder="http://154.53.47.9:8000/v1">\r\n                            <div class="form-hint">Override the provider API base URL (e.g., proxy URL).</div>\r\n                        </div>\r\n                    </form>\r\n                </div>\r\n                <div class="modal-footer">\r\n                    <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>\r\n                    <button class="btn btn-primary" onclick="document.getElementById(\'add-account-form\').requestSubmit()">\r\n                        Add Account\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Submit add account form\r\n */\r\nfunction _submitAddAccount(event, providerId) {\r\n    event.preventDefault();\r\n\r\n    const displayName = document.getElementById("displayName").value.trim();\r\n    const apiKey = document.getElementById("apiKey").value.trim();\r\n    const endpointEl = document.getElementById("endpoint");\r\n    const endpoint = endpointEl ? endpointEl.value.trim() : undefined;\r\n\r\n    if (!displayName || !apiKey) {\r\n        showToast("Please fill in all required fields", "error");\r\n        return;\r\n    }\r\n\r\n    vscode.postMessage({\r\n        command: "addApiKeyAccount",\r\n        provider: providerId,\r\n        displayName: displayName,\r\n        apiKey: apiKey,\r\n        endpoint: endpoint,\r\n    });\r\n\r\n    closeModal();\r\n}\r\n\r\n/**\r\n * Add account for specific provider\r\n */\r\nfunction _addAccountForProvider(providerId) {\r\n    const provider = providers.find((p) => p.id === providerId);\r\n    if (!provider) {\r\n        // If provider not in list, assume API key\r\n        showApiKeyForm(providerId, capitalizeFirst(providerId));\r\n        return;\r\n    }\r\n\r\n    if (provider.authType === "oauth") {\r\n        vscode.postMessage({\r\n            command: "addOAuthAccount",\r\n            provider: providerId,\r\n        });\r\n    } else {\r\n        showApiKeyForm(providerId, provider.name);\r\n    }\r\n}\r\n\r\n/**\r\n * Set account as default\r\n */\r\nfunction setDefaultAccount(accountId) {\r\n    const account = accounts.find((a) => a.id === accountId);\r\n\r\n    // Check quota for Antigravity accounts before switching\r\n    if (account && account.provider === "antigravity") {\r\n        checkQuotaBeforeSwitch(accountId);\r\n    } else {\r\n        // For non-Antigravity accounts, switch immediately\r\n        vscode.postMessage({\r\n            command: "setDefaultAccount",\r\n            accountId: accountId,\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Check quota before switching to Antigravity account\r\n */\r\nfunction checkQuotaBeforeSwitch(accountId) {\r\n    const account = accounts.find((a) => a.id === accountId);\r\n    if (!account) return;\r\n\r\n    // Show loading state on the Use button\r\n    const useButton = document.querySelector(\r\n        `[data-account-id="${accountId}"] .btn-use`,\r\n    );\r\n    if (useButton) {\r\n        useButton.disabled = true;\r\n        useButton.textContent = "Checking...";\r\n    }\r\n\r\n    // Request quota check from backend\r\n    vscode.postMessage({\r\n        command: "checkQuota",\r\n        accountId: accountId,\r\n    });\r\n}\r\n\r\n/**\r\n * Handle quota check result from backend\r\n */\r\nfunction handleQuotaCheckResult(message) {\r\n    const {\r\n        accountId,\r\n        success,\r\n        quotaData,\r\n        error,\r\n        message: resultMessage,\r\n    } = message;\r\n    const _account = accounts.find((a) => a.id === accountId);\r\n\r\n    // Restore button state\r\n    const useButton = document.querySelector(\r\n        `[data-account-id="${accountId}"] .btn-use`,\r\n    );\r\n    if (useButton) {\r\n        useButton.disabled = false;\r\n        useButton.textContent = "Use";\r\n    }\r\n\r\n    if (success) {\r\n        if (quotaData) {\r\n            // Show quota info in toast with color coding\r\n            const minQuota = quotaData.minQuota;\r\n            let toastType = "success";\r\n            let icon = "OK";\r\n\r\n            if (minQuota < 10) {\r\n                toastType = "error";\r\n                icon = "WARN";\r\n            } else if (minQuota < 30) {\r\n                toastType = "warning";\r\n                icon = "WARN";\r\n            }\r\n            const quotaMsg = `${icon} Quota refreshed - Gemini: ${quotaData.geminiQuota}%, Claude: ${quotaData.claudeQuota}%`;\r\n            showToast(quotaMsg, toastType);\r\n        } else if (resultMessage) {\r\n            showToast(resultMessage, "info");\r\n        }\r\n\r\n        // Proceed with account switch\r\n        vscode.postMessage({\r\n            command: "setDefaultAccount",\r\n            accountId: accountId,\r\n        });\r\n    } else {\r\n        // Show error\r\n        showToast(error || "Failed to check quota", "error");\r\n    }\r\n}\r\n\r\nfunction _handleAccountCardClick(_event, accountId, isDefault) {\r\n    if (isDefault) {\r\n        return;\r\n    }\r\n    setDefaultAccount(accountId);\r\n}\r\n\r\n/**\r\n * Show account details\r\n */\r\nfunction _showAccountDetails(accountId) {\r\n    const account = accounts.find((a) => a.id === accountId);\r\n    if (!account) return;\r\n\r\n    // Find the endpoint for this account\r\n    const accountEndpoint = window._accountEndpoints && window._accountEndpoints.find((ae) => ae.id === accountId);\r\n    const endpoint = accountEndpoint?.endpoint;\r\n\r\n    const isQuotaLimited =\r\n        antigravityQuota &&\r\n        account.provider === "antigravity" &&\r\n        antigravityQuota.accountId === account.id;\r\n\r\n    const quotaSection = isQuotaLimited\r\n        ? `\r\n        <div style="margin-top: 16px; padding: 12px; background: rgba(255, 196, 0, 0.1); border-radius: 8px; border: 1px solid rgba(255, 196, 0, 0.3);">\r\n            <div style="font-weight: 600; color: var(--vscode-notificationsWarningForeground, #ffc400); margin-bottom: 8px;">\r\n                Quota Exceeded\r\n            </div>\r\n            <div style="display: grid; gap: 8px; font-size: 13px;">\r\n                <div>\r\n                    <strong>Model:</strong> ${escapeHtml(antigravityQuota.modelName || "Unknown")}\r\n                </div>\r\n                <div>\r\n                    <strong>Retry in:</strong> <span style="font-weight: 600; color: var(--vscode-notificationsWarningForeground, #ffc400);">${formatCountdown(antigravityQuota.resetAt - Date.now())}</span>\r\n                </div>\r\n                <div>\r\n                    <strong>Reset at:</strong> ${formatDateTime(new Date(antigravityQuota.resetAt).toISOString())}\r\n                </div>\r\n            </div>\r\n        </div>\r\n    `\r\n        : "";\r\n\r\n    const modalContainer = document.getElementById("modal-container");\r\n    modalContainer.innerHTML = `\r\n        <div class="modal-overlay" onclick="closeModal(event)">\r\n            <div class="modal" onclick="event.stopPropagation()">\r\n                <div class="modal-header">\r\n                    <h2 class="modal-title">Account Details</h2>\r\n                    <button class="modal-close" onclick="closeModal()">&times;</button>\r\n                </div>\r\n                <div class="modal-body">\r\n                    <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 20px;">\r\n                        <div class="account-avatar" style="width: 64px; height: 64px; font-size: 24px;">\r\n                            ${getInitials(account.displayName)}\r\n                        </div>\r\n                        <div>\r\n                            <div style="font-size: 18px; font-weight: 600;">${escapeHtml(account.displayName)}</div>\r\n                            ${account.email ? `<div style="color: var(--vscode-descriptionForeground);">${escapeHtml(account.email)}</div>` : ""}\r\n                        </div>\r\n                    </div>\r\n                    ${quotaSection}\r\n                    <div style="display: grid; gap: 12px; ${isQuotaLimited ? "margin-top: 16px;" : ""}">\r\n                        <div>\r\n                            <strong>Provider:</strong> ${capitalizeFirst(account.provider)}\r\n                        </div>\r\n                        <div>\r\n                            <strong>Auth Type:</strong> ${account.authType === "oauth" ? "OAuth" : "API Key"}\r\n                        </div>\r\n                        <div>\r\n                            <strong>Status:</strong> \r\n                            <span class="account-status ${account.status}" style="display: inline-flex;">\r\n                                <span class="status-dot ${account.status}"></span>\r\n                                ${capitalizeFirst(account.status)}\r\n                            </span>\r\n                        </div>\r\n                        <div>\r\n                            <strong>Created:</strong> ${formatDateTime(account.createdAt)}\r\n                        </div>\r\n                        <div>\r\n                            <strong>Last Updated:</strong> ${formatDateTime(account.updatedAt)}\r\n                        </div>\r\n                        ${account.expiresAt\r\n            ? `\r\n                            <div>\r\n                                <strong>Expires:</strong> ${formatDateTime(account.expiresAt)}\r\n                            </div>\r\n                        `\r\n            : ""\r\n        }\r\n                        ${endpoint\r\n            ? `\r\n                            <div>\r\n                                <strong>Proxy/Base URL:</strong> \r\n                                <div style="font-family: monospace; font-size: 12px; margin-top: 4px; word-break: break-all; color: var(--vscode-descriptionForeground);">\r\n                                    ${escapeHtml(endpoint)}\r\n                                </div>\r\n                            </div>\r\n                        `\r\n            : ""\r\n        }\r\n                        <div>\r\n                            <strong>Default:</strong> ${account.isDefault ? "Yes \u2B50" : "No"}\r\n                        </div>\r\n                    </div>\r\n                </div>\r\n                <div class="modal-footer">\r\n                    <button class="btn btn-secondary" onclick="closeModal()">Close</button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Confirm delete account\r\n */\r\nfunction _confirmDeleteAccount(accountId, displayName) {\r\n    const modalContainer = document.getElementById("modal-container");\r\n    modalContainer.innerHTML = `\r\n        <div class="modal-overlay" onclick="closeModal(event)">\r\n            <div class="modal" onclick="event.stopPropagation()">\r\n                <div class="modal-header">\r\n                    <h2 class="modal-title">Delete Account</h2>\r\n                    <button class="modal-close" onclick="closeModal()">&times;</button>\r\n                </div>\r\n                <div class="modal-body">\r\n                    <p>Are you sure you want to delete the account "<strong>${escapeHtml(displayName)}</strong>"?</p>\r\n                    <p style="color: var(--vscode-errorForeground); margin-top: 12px;">\r\n                        This action cannot be undone. All credentials will be permanently removed.\r\n                    </p>\r\n                </div>\r\n                <div class="modal-footer">\r\n                    <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>\r\n                    <button class="btn btn-danger" onclick="deleteAccount(\'${accountId}\')">\r\n                        Delete Account\r\n                    </button>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    `;\r\n}\r\n\r\n/**\r\n * Delete account\r\n */\r\nfunction _deleteAccount(accountId) {\r\n    vscode.postMessage({\r\n        command: "deleteAccount",\r\n        accountId: accountId,\r\n    });\r\n    closeModal();\r\n}\r\n\r\nfunction ensureSelectedProvider() {\r\n    const providerSummary = getProviderSummary();\r\n    if (providerSummary.length === 0) {\r\n        selectedProvider = null;\r\n        return;\r\n    }\r\n    // If selected provider not present anymore, fall back\r\n    const exists =\r\n        selectedProvider && providerSummary.some((p) => p.id === selectedProvider);\r\n    if (!exists) {\r\n        selectedProvider = providerSummary[0].id;\r\n        try {\r\n            vscode.setState({ ...(vscode.getState() || {}), selectedProvider });\r\n        } catch {\r\n            // Ignore\r\n        }\r\n    }\r\n}\r\n\r\nfunction setSelectedProvider(providerId) {\r\n    selectedProvider = providerId;\r\n    try {\r\n        vscode.setState({ ...(vscode.getState() || {}), selectedProvider });\r\n    } catch {\r\n        // Ignore\r\n    }\r\n    renderPage();\r\n}\r\n\r\n/**\r\n * Refresh accounts\r\n */\r\nfunction _refreshAccounts() {\r\n    vscode.postMessage({\r\n        command: "refresh",\r\n    });\r\n}\r\n\r\n/**\r\n * Close modal\r\n */\r\nfunction closeModal(event) {\r\n    if (event && event.target !== event.currentTarget) return;\r\n    document.getElementById("modal-container").innerHTML = "";\r\n}\r\n\r\n/**\r\n * Show toast notification\r\n */\r\nfunction showToast(message, type = "info") {\r\n    const container = document.getElementById("toast-container");\r\n    const toast = document.createElement("div");\r\n    toast.className = `toast ${type}`;\r\n    toast.innerHTML = `\r\n        <span>${type === "success" ? "OK" : type === "error" ? "ERR" : "INFO"}</span>\r\n        <span>${escapeHtml(message)}</span>\r\n    `;\r\n    container.appendChild(toast);\r\n\r\n    setTimeout(() => {\r\n        toast.remove();\r\n    }, 3000);\r\n}\r\n\r\n/**\r\n * Update accounts data\r\n */\r\nfunction updateAccounts(newAccounts) {\r\n    accounts = newAccounts || [];\r\n    ensureSelectedProvider();\r\n    renderPage();\r\n}\r\n\r\n/**\r\n * Update Antigravity quota notice\r\n */\r\nfunction updateAntigravityQuota(notice) {\r\n    antigravityQuota = normalizeAntigravityQuota(notice);\r\n    renderPage();\r\n}\r\n\r\n/**\r\n * Setup event listeners\r\n */\r\nfunction setupEventListeners() {\r\n    // Listen for messages from extension\r\n    window.addEventListener("message", (event) => {\r\n        const message = event.data;\r\n        switch (message.command) {\r\n            case "updateAccounts":\r\n                updateAccounts(message.accounts);\r\n                // Store account endpoints for displaying in details modal\r\n                if (message.accountEndpoints) {\r\n                    window._accountEndpoints = message.accountEndpoints;\r\n                }\r\n                break;\r\n            case "showToast":\r\n                showToast(message.message, message.type);\r\n                break;\r\n            case "updateAntigravityQuota":\r\n                updateAntigravityQuota(message.notice);\r\n                break;\r\n            case "updateAccountQuotaState":\r\n                updateAccountQuotaState(message.accountId, message.state);\r\n                break;\r\n            case "quotaCheckResult":\r\n                handleQuotaCheckResult(message);\r\n                break;\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Update account quota state from extension\r\n */\r\nfunction updateAccountQuotaState(accountId, state) {\r\n    if (!state) {\r\n        // Remove state\r\n        accountQuotaStates = accountQuotaStates.filter(\r\n            (s) => s.accountId !== accountId,\r\n        );\r\n    } else {\r\n        // Update or add state\r\n        const existingIndex = accountQuotaStates.findIndex(\r\n            (s) => s.accountId === accountId,\r\n        );\r\n        if (existingIndex >= 0) {\r\n            accountQuotaStates[existingIndex] = state;\r\n        } else {\r\n            accountQuotaStates.push(state);\r\n        }\r\n    }\r\n\r\n    // Re-render the affected account card\r\n    const accountCard = document.querySelector(\r\n        `[data-account-id="${accountId}"]`,\r\n    );\r\n    if (accountCard) {\r\n        const account = accounts.find((a) => a.id === accountId);\r\n        if (account) {\r\n            accountCard.outerHTML = renderAccountCard(account);\r\n        }\r\n    }\r\n}\r\n\r\n// Utility functions\r\nfunction getProviderIcon(providerId) {\r\n    // Use image if available, otherwise fallback to emoji\r\n    // if (providerImageUris[providerId]) {\r\n    //     return `<img src="${providerImageUris[providerId]}" alt="${providerId}" class="provider-icon-img" />`;\r\n    // }\r\n\r\n    // Fallback emoji icons\r\n    const icons = {\r\n        antigravity: "\u{1F310}",\r\n        codex: "\u2728",\r\n        zhipu: "\u{1F9E0}",\r\n        moonshot: "\u{1F319}",\r\n        minimax: "\u{1F537}",\r\n        deepseek: "\u{1F50D}",\r\n        deepinfra: "\u{1F680}",\r\n        compatible: "\u2699\uFE0F",\r\n    };\r\n    return icons[providerId] || "\u{1F916}";\r\n}\r\n\r\nfunction getProviderSummary() {\r\n    const accountsByProvider = {};\r\n    for (const account of accounts) {\r\n        accountsByProvider[account.provider] =\r\n            (accountsByProvider[account.provider] || 0) + 1;\r\n    }\r\n\r\n    const allProviderIds = [\r\n        ...new Set([\r\n            ...providers.map((p) => p.id),\r\n            ...Object.keys(accountsByProvider),\r\n        ]),\r\n    ];\r\n    const summary = allProviderIds.map((id) => {\r\n        const info = providers.find((p) => p.id === id);\r\n        return {\r\n            id,\r\n            name: info?.name ? info.name : capitalizeFirst(id),\r\n            authType: info?.authType ? info.authType : "apiKey",\r\n            count: accountsByProvider[id] || 0,\r\n        };\r\n    });\r\n\r\n    // Sort: providers with accounts first, then by name\r\n    summary.sort((a, b) => {\r\n        if (a.count !== b.count) {\r\n            return b.count - a.count;\r\n        }\r\n        return a.name.localeCompare(b.name);\r\n    });\r\n\r\n    return summary;\r\n}\r\n\r\nfunction getInitials(name) {\r\n    if (!name) return "?";\r\n    const words = name.trim().split(/\\s+/);\r\n    if (words.length >= 2) {\r\n        return (words[0][0] + words[1][0]).toUpperCase();\r\n    }\r\n    return name.substring(0, 2).toUpperCase();\r\n}\r\n\r\nfunction escapeHtml(text) {\r\n    if (!text) return "";\r\n    const div = document.createElement("div");\r\n    div.textContent = text;\r\n    return div.innerHTML;\r\n}\r\n\r\nfunction capitalizeFirst(str) {\r\n    if (!str) return "";\r\n    return str.charAt(0).toUpperCase() + str.slice(1);\r\n}\r\n\r\nfunction formatDate(dateStr) {\r\n    if (!dateStr) return "N/A";\r\n    try {\r\n        return new Date(dateStr).toLocaleDateString();\r\n    } catch {\r\n        return "N/A";\r\n    }\r\n}\r\n\r\nfunction formatDateTime(dateStr) {\r\n    if (!dateStr) return "N/A";\r\n    try {\r\n        return new Date(dateStr).toLocaleString();\r\n    } catch {\r\n        return "N/A";\r\n    }\r\n}\r\n\r\nfunction normalizeAntigravityQuota(notice) {\r\n    if (!notice || typeof notice.resetAt !== "number") {\r\n        return null;\r\n    }\r\n    const modelName =\r\n        typeof notice.modelName === "string" ? notice.modelName : "";\r\n    const accountId =\r\n        typeof notice.accountId === "string" ? notice.accountId : "";\r\n    const accountName =\r\n        typeof notice.accountName === "string" ? notice.accountName : "";\r\n    return { resetAt: notice.resetAt, modelName, accountId, accountName };\r\n}\r\n\r\nfunction startQuotaCountdown() {\r\n    stopQuotaCountdown();\r\n    if (!antigravityQuota) {\r\n        return;\r\n    }\r\n    updateQuotaCountdown();\r\n}\r\n\r\nfunction stopQuotaCountdown() {\r\n    if (antigravityQuotaTimer) {\r\n        clearTimeout(antigravityQuotaTimer);\r\n        antigravityQuotaTimer = null;\r\n    }\r\n}\r\n\r\nfunction updateQuotaCountdown() {\r\n    if (!antigravityQuota) {\r\n        return;\r\n    }\r\n    const remaining = antigravityQuota.resetAt - Date.now();\r\n    if (remaining <= 0) {\r\n        antigravityQuota = null;\r\n        renderPage();\r\n        return;\r\n    }\r\n\r\n    // Update main banner countdown\r\n    const countdownEl = document.getElementById("quota-countdown");\r\n    if (countdownEl) {\r\n        countdownEl.textContent = formatCountdown(remaining);\r\n    }\r\n\r\n    // Update account card countdown\r\n    const accountCountdowns = document.querySelectorAll(\r\n        ".account-quota-countdown",\r\n    );\r\n    accountCountdowns.forEach((el) => {\r\n        const resetAt = parseInt(el.dataset.resetAt, 10);\r\n        if (resetAt) {\r\n            const accountRemaining = resetAt - Date.now();\r\n            if (accountRemaining > 0) {\r\n                el.textContent = formatCountdown(accountRemaining);\r\n            }\r\n        }\r\n    });\r\n\r\n    antigravityQuotaTimer = setTimeout(\r\n        updateQuotaCountdown,\r\n        getCountdownUpdateInterval(remaining),\r\n    );\r\n}\r\n\r\nfunction formatCountdown(ms) {\r\n    const totalSeconds = Math.max(0, Math.floor(ms / 1000));\r\n    const seconds = totalSeconds % 60;\r\n    const minutes = Math.floor(totalSeconds / 60) % 60;\r\n    const hours = Math.floor(totalSeconds / 3600) % 24;\r\n    const days = Math.floor(totalSeconds / 86400);\r\n\r\n    if (days > 0) {\r\n        return `${days}d ${hours}h ${minutes}m`;\r\n    }\r\n    if (hours > 0) {\r\n        return `${hours}h ${minutes}m ${seconds}s`;\r\n    }\r\n    if (minutes > 0) {\r\n        return `${minutes}m ${seconds}s`;\r\n    }\r\n    return `${seconds}s`;\r\n}\r\n\r\nfunction getCountdownUpdateInterval(remainingMs) {\r\n    if (remainingMs >= 60 * 60 * 1000) {\r\n        return 60 * 1000;\r\n    }\r\n    return 1000;\r\n}\r\n\r\n// Expose handlers used by inline HTML and host initialization.\r\nwindow.initializeAccountManager = _initializeAccountManager;\r\nwindow.openGCMPSettings = _openGCMPSettings;\r\nwindow.showAddAccountModal = _showAddAccountModal;\r\nwindow.selectProviderForAdd = _selectProviderForAdd;\r\nwindow.submitAddAccount = _submitAddAccount;\r\nwindow.addAccountForProvider = _addAccountForProvider;\r\nwindow.handleAccountCardClick = _handleAccountCardClick;\r\nwindow.showAccountDetails = _showAccountDetails;\r\nwindow.confirmDeleteAccount = _confirmDeleteAccount;\r\nwindow.deleteAccount = _deleteAccount;\r\nwindow.refreshAccounts = _refreshAccounts;\r\n';
  }
});

// src/providers/config/antigravity.json
var antigravity_default;
var init_antigravity = __esm({
  "src/providers/config/antigravity.json"() {
    antigravity_default = {
      displayName: "Antigravity (Google Cloud Code)",
      baseUrl: "https://api.antigravity.com/v1",
      apiKeyTemplate: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      models: [
        {
          id: "claude-opus-4-5-thinking",
          name: "Claude Opus 4.5 Thinking",
          tooltip: "Claude Opus 4.5 v\u1EDBi kh\u1EA3 n\u0103ng suy lu\u1EADn m\u1EDF r\u1ED9ng",
          sdkMode: "anthropic",
          maxInputTokens: 2e5,
          maxOutputTokens: 64e3,
          includeThinking: true,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "claude-sonnet-4-5",
          name: "Claude Sonnet 4.5",
          tooltip: "Claude Sonnet 4.5 - m\xF4 h\xECnh c\xE2n b\u1EB1ng gi\u1EEFa hi\u1EC7u su\u1EA5t v\xE0 chi ph\xED",
          sdkMode: "anthropic",
          maxInputTokens: 2e5,
          maxOutputTokens: 8192,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "claude-sonnet-4-5-thinking",
          name: "Claude Sonnet 4.5 Thinking",
          tooltip: "Claude Sonnet 4.5 v\u1EDBi kh\u1EA3 n\u0103ng suy lu\u1EADn m\u1EDF r\u1ED9ng",
          sdkMode: "anthropic",
          maxInputTokens: 2e5,
          maxOutputTokens: 64e3,
          includeThinking: true,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gemini-3-flash",
          name: "Gemini 3 Flash",
          tooltip: "Gemini 3 Flash - m\xF4 h\xECnh nhanh v\xE0 hi\u1EC7u qu\u1EA3",
          sdkMode: "anthropic",
          maxInputTokens: 1e6,
          maxOutputTokens: 8192,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gemini-3-pro-high",
          name: "Gemini 3 Pro High",
          tooltip: "Gemini 3 Pro v\u1EDBi ch\u1EBF \u0111\u1ED9 ch\u1EA5t l\u01B0\u1EE3ng cao",
          sdkMode: "anthropic",
          maxInputTokens: 2e6,
          maxOutputTokens: 32768,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gemini-3-pro-image",
          name: "Gemini 3 Pro Image",
          tooltip: "Gemini 3 Pro t\u1ED1i \u01B0u cho x\u1EED l\xFD h\xECnh \u1EA3nh",
          sdkMode: "anthropic",
          maxInputTokens: 2e6,
          maxOutputTokens: 8192,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gemini-3-pro-low",
          name: "Gemini 3 Pro Low",
          tooltip: "Gemini 3 Pro v\u1EDBi ch\u1EBF \u0111\u1ED9 ti\u1EBFt ki\u1EC7m chi ph\xED",
          sdkMode: "anthropic",
          maxInputTokens: 2e6,
          maxOutputTokens: 8192,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gpt-oss-120b-medium",
          name: "GPT OSS 120B Medium",
          tooltip: "GPT Open Source 120B - m\xF4 h\xECnh m\xE3 ngu\u1ED3n m\u1EDF",
          sdkMode: "anthropic",
          maxInputTokens: 128e3,
          maxOutputTokens: 8192,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        }
      ]
    };
  }
});

// src/providers/config/chutes.json
var chutes_default;
var init_chutes = __esm({
  "src/providers/config/chutes.json"() {
    chutes_default = {
      displayName: "Chutes",
      baseUrl: "https://llm.chutes.ai/v1",
      apiKeyTemplate: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      models: [
        {
          id: "qwen-qwen3-32b",
          name: "Qwen/Qwen3-32B",
          tooltip: "Qwen/Qwen3-32B by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 40960,
          model: "Qwen/Qwen3-32B",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "deepseek-ai-deepseek-v3-0324-tee",
          name: "deepseek-ai/DeepSeek-V3-0324-TEE",
          tooltip: "deepseek-ai/DeepSeek-V3-0324-TEE by Chutes",
          maxInputTokens: 98304,
          maxOutputTokens: 65536,
          model: "deepseek-ai/DeepSeek-V3-0324-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "deepseek-ai-deepseek-v3-2-tee",
          name: "deepseek-ai/DeepSeek-V3.2-TEE",
          tooltip: "deepseek-ai/DeepSeek-V3.2-TEE by Chutes",
          maxInputTokens: 98304,
          maxOutputTokens: 65536,
          model: "deepseek-ai/DeepSeek-V3.2-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "chutesai-mistral-small-3-1-24b-instruct-2503",
          name: "chutesai/Mistral-Small-3.1-24B-Instruct-2503",
          tooltip: "chutesai/Mistral-Small-3.1-24B-Instruct-2503 by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 131072,
          model: "chutesai/Mistral-Small-3.1-24B-Instruct-2503",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "unsloth-mistral-nemo-instruct-2407",
          name: "unsloth/Mistral-Nemo-Instruct-2407",
          tooltip: "unsloth/Mistral-Nemo-Instruct-2407 by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 131072,
          model: "unsloth/Mistral-Nemo-Instruct-2407",
          capabilities: {
            toolCalling: false,
            imageInput: false
          }
        },
        {
          id: "unsloth-gemma-3-27b-it",
          name: "unsloth/gemma-3-27b-it",
          tooltip: "unsloth/gemma-3-27b-it by Chutes",
          maxInputTokens: 62464,
          maxOutputTokens: 65536,
          model: "unsloth/gemma-3-27b-it",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "qwen-qwen3-235b-a22b-instruct-2507-tee",
          name: "Qwen/Qwen3-235B-A22B-Instruct-2507-TEE",
          tooltip: "Qwen/Qwen3-235B-A22B-Instruct-2507-TEE by Chutes",
          maxInputTokens: 196608,
          maxOutputTokens: 65536,
          model: "Qwen/Qwen3-235B-A22B-Instruct-2507-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "tngtech-deepseek-tng-r1t2-chimera",
          name: "tngtech/DeepSeek-TNG-R1T2-Chimera",
          tooltip: "tngtech/DeepSeek-TNG-R1T2-Chimera by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 163840,
          model: "tngtech/DeepSeek-TNG-R1T2-Chimera",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen3-next-80b-a3b-instruct",
          name: "Qwen/Qwen3-Next-80B-A3B-Instruct",
          tooltip: "Qwen/Qwen3-Next-80B-A3B-Instruct by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 262144,
          model: "Qwen/Qwen3-Next-80B-A3B-Instruct",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "openai-gpt-oss-120b-tee",
          name: "openai/gpt-oss-120b-TEE",
          tooltip: "openai/gpt-oss-120b-TEE by Chutes",
          maxInputTokens: 65536,
          maxOutputTokens: 65536,
          model: "openai/gpt-oss-120b-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "zai-org-glm-4-6-tee",
          name: "zai-org/GLM-4.6-TEE",
          tooltip: "zai-org/GLM-4.6-TEE by Chutes",
          maxInputTokens: 137216,
          maxOutputTokens: 65536,
          model: "zai-org/GLM-4.6-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "zai-org-glm-4-7-tee",
          name: "zai-org/GLM-4.7-TEE",
          tooltip: "zai-org/GLM-4.7-TEE by Chutes",
          maxInputTokens: 137217,
          maxOutputTokens: 65535,
          model: "zai-org/GLM-4.7-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "nousresearch-hermes-4-70b",
          name: "NousResearch/Hermes-4-70B",
          tooltip: "NousResearch/Hermes-4-70B by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 131072,
          model: "NousResearch/Hermes-4-70B",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "deepseek-ai-deepseek-v3-1-tee",
          name: "deepseek-ai/DeepSeek-V3.1-TEE",
          tooltip: "deepseek-ai/DeepSeek-V3.1-TEE by Chutes",
          maxInputTokens: 98304,
          maxOutputTokens: 65536,
          model: "deepseek-ai/DeepSeek-V3.1-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen3-30b-a3b-instruct-2507",
          name: "Qwen/Qwen3-30B-A3B-Instruct-2507",
          tooltip: "Qwen/Qwen3-30B-A3B-Instruct-2507 by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 262144,
          model: "Qwen/Qwen3-30B-A3B-Instruct-2507",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "deepseek-ai-deepseek-v3",
          name: "deepseek-ai/DeepSeek-V3",
          tooltip: "deepseek-ai/DeepSeek-V3 by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 163840,
          model: "deepseek-ai/DeepSeek-V3",
          capabilities: {
            toolCalling: false,
            imageInput: false
          }
        },
        {
          id: "nousresearch-hermes-4-3-36b",
          name: "NousResearch/Hermes-4.3-36B",
          tooltip: "NousResearch/Hermes-4.3-36B by Chutes",
          maxInputTokens: 508288,
          maxOutputTokens: 16e3,
          model: "NousResearch/Hermes-4.3-36B",
          capabilities: {
            toolCalling: false,
            imageInput: false
          }
        },
        {
          id: "nousresearch-hermes-4-405b-fp8-tee",
          name: "NousResearch/Hermes-4-405B-FP8-TEE",
          tooltip: "NousResearch/Hermes-4-405B-FP8-TEE by Chutes",
          maxInputTokens: 65536,
          maxOutputTokens: 65536,
          model: "NousResearch/Hermes-4-405B-FP8-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "chutesai-mistral-small-3-2-24b-instruct-2506",
          name: "chutesai/Mistral-Small-3.2-24B-Instruct-2506",
          tooltip: "chutesai/Mistral-Small-3.2-24B-Instruct-2506 by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 131072,
          model: "chutesai/Mistral-Small-3.2-24B-Instruct-2506",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "qwen-qwen3-14b",
          name: "Qwen/Qwen3-14B",
          tooltip: "Qwen/Qwen3-14B by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 40960,
          model: "Qwen/Qwen3-14B",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "moonshotai-kimi-k2-5-tee",
          name: "moonshotai/Kimi-K2.5-TEE",
          tooltip: "moonshotai/Kimi-K2.5-TEE by Chutes",
          maxInputTokens: 196609,
          maxOutputTokens: 65535,
          model: "moonshotai/Kimi-K2.5-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "deepseek-ai-deepseek-v3-1-terminus-tee",
          name: "deepseek-ai/DeepSeek-V3.1-Terminus-TEE",
          tooltip: "deepseek-ai/DeepSeek-V3.1-Terminus-TEE by Chutes",
          maxInputTokens: 98304,
          maxOutputTokens: 65536,
          model: "deepseek-ai/DeepSeek-V3.1-Terminus-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "xiaomimimo-mimo-v2-flash",
          name: "XiaomiMiMo/MiMo-V2-Flash",
          tooltip: "XiaomiMiMo/MiMo-V2-Flash by Chutes",
          maxInputTokens: 246144,
          maxOutputTokens: 16e3,
          model: "XiaomiMiMo/MiMo-V2-Flash",
          capabilities: {
            toolCalling: false,
            imageInput: false
          }
        },
        {
          id: "unsloth-gemma-3-4b-it",
          name: "unsloth/gemma-3-4b-it",
          tooltip: "unsloth/gemma-3-4b-it by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 96e3,
          model: "unsloth/gemma-3-4b-it",
          capabilities: {
            toolCalling: false,
            imageInput: true
          }
        },
        {
          id: "deepseek-ai-deepseek-r1-0528-tee",
          name: "deepseek-ai/DeepSeek-R1-0528-TEE",
          tooltip: "deepseek-ai/DeepSeek-R1-0528-TEE by Chutes",
          maxInputTokens: 98304,
          maxOutputTokens: 65536,
          model: "deepseek-ai/DeepSeek-R1-0528-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen3-coder-480b-a35b-instruct-fp8-tee",
          name: "Qwen/Qwen3-Coder-480B-A35B-Instruct-FP8-TEE",
          tooltip: "Qwen/Qwen3-Coder-480B-A35B-Instruct-FP8-TEE by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 262144,
          model: "Qwen/Qwen3-Coder-480B-A35B-Instruct-FP8-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "opengvlab-internvl3-78b-tee",
          name: "OpenGVLab/InternVL3-78B-TEE",
          tooltip: "OpenGVLab/InternVL3-78B-TEE by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 32768,
          model: "OpenGVLab/InternVL3-78B-TEE",
          capabilities: {
            toolCalling: false,
            imageInput: true
          }
        },
        {
          id: "unsloth-gemma-3-12b-it",
          name: "unsloth/gemma-3-12b-it",
          tooltip: "unsloth/gemma-3-12b-it by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 131072,
          model: "unsloth/gemma-3-12b-it",
          capabilities: {
            toolCalling: false,
            imageInput: true
          }
        },
        {
          id: "qwen-qwen2-5-coder-32b-instruct",
          name: "Qwen/Qwen2.5-Coder-32B-Instruct",
          tooltip: "Qwen/Qwen2.5-Coder-32B-Instruct by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 32768,
          model: "Qwen/Qwen2.5-Coder-32B-Instruct",
          capabilities: {
            toolCalling: false,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen3-235b-a22b-thinking-2507",
          name: "Qwen/Qwen3-235B-A22B-Thinking-2507",
          tooltip: "Qwen/Qwen3-235B-A22B-Thinking-2507 by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 262144,
          model: "Qwen/Qwen3-235B-A22B-Thinking-2507",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "tngtech-deepseek-r1t-chimera",
          name: "tngtech/DeepSeek-R1T-Chimera",
          tooltip: "tngtech/DeepSeek-R1T-Chimera by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 163840,
          model: "tngtech/DeepSeek-R1T-Chimera",
          capabilities: {
            toolCalling: false,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen3-coder-next",
          name: "Qwen/Qwen3-Coder-Next",
          tooltip: "Qwen/Qwen3-Coder-Next by Chutes",
          maxInputTokens: 196608,
          maxOutputTokens: 65536,
          model: "Qwen/Qwen3-Coder-Next",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen2-5-72b-instruct",
          name: "Qwen/Qwen2.5-72B-Instruct",
          tooltip: "Qwen/Qwen2.5-72B-Instruct by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 32768,
          model: "Qwen/Qwen2.5-72B-Instruct",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "moonshotai-kimi-k2-thinking-tee",
          name: "moonshotai/Kimi-K2-Thinking-TEE",
          tooltip: "moonshotai/Kimi-K2-Thinking-TEE by Chutes",
          maxInputTokens: 196609,
          maxOutputTokens: 65535,
          model: "moonshotai/Kimi-K2-Thinking-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "unsloth-mistral-small-24b-instruct-2501",
          name: "unsloth/Mistral-Small-24B-Instruct-2501",
          tooltip: "unsloth/Mistral-Small-24B-Instruct-2501 by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 32768,
          model: "unsloth/Mistral-Small-24B-Instruct-2501",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "qwen-qwen2-5-vl-72b-instruct-tee",
          name: "Qwen/Qwen2.5-VL-72B-Instruct-TEE",
          tooltip: "Qwen/Qwen2.5-VL-72B-Instruct-TEE by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 32768,
          model: "Qwen/Qwen2.5-VL-72B-Instruct-TEE",
          capabilities: {
            toolCalling: false,
            imageInput: true
          }
        },
        {
          id: "deepseek-ai-deepseek-r1-distill-llama-70b",
          name: "deepseek-ai/DeepSeek-R1-Distill-Llama-70B",
          tooltip: "deepseek-ai/DeepSeek-R1-Distill-Llama-70B by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 131072,
          model: "deepseek-ai/DeepSeek-R1-Distill-Llama-70B",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "minimaxai-minimax-m2-1-tee",
          name: "MiniMaxAI/MiniMax-M2.1-TEE",
          tooltip: "MiniMaxAI/MiniMax-M2.1-TEE by Chutes",
          maxInputTokens: 131072,
          maxOutputTokens: 65536,
          model: "MiniMaxAI/MiniMax-M2.1-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "zai-org-glm-4-7-fp8",
          name: "zai-org/GLM-4.7-FP8",
          tooltip: "zai-org/GLM-4.7-FP8 by Chutes",
          maxInputTokens: 137217,
          maxOutputTokens: 65535,
          model: "zai-org/GLM-4.7-FP8",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "zai-org-glm-4-5-tee",
          name: "zai-org/GLM-4.5-TEE",
          tooltip: "zai-org/GLM-4.5-TEE by Chutes",
          maxInputTokens: 65536,
          maxOutputTokens: 65536,
          model: "zai-org/GLM-4.5-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen3-vl-235b-a22b-instruct",
          name: "Qwen/Qwen3-VL-235B-A22B-Instruct",
          tooltip: "Qwen/Qwen3-VL-235B-A22B-Instruct by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 262144,
          model: "Qwen/Qwen3-VL-235B-A22B-Instruct",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "nousresearch-deephermes-3-mistral-24b-preview",
          name: "NousResearch/DeepHermes-3-Mistral-24B-Preview",
          tooltip: "NousResearch/DeepHermes-3-Mistral-24B-Preview by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 32768,
          model: "NousResearch/DeepHermes-3-Mistral-24B-Preview",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "mistralai-devstral-2-123b-instruct-2512-tee",
          name: "mistralai/Devstral-2-123B-Instruct-2512-TEE",
          tooltip: "mistralai/Devstral-2-123B-Instruct-2512-TEE by Chutes",
          maxInputTokens: 196608,
          maxOutputTokens: 65536,
          model: "mistralai/Devstral-2-123B-Instruct-2512-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "deepseek-ai-deepseek-r1-tee",
          name: "deepseek-ai/DeepSeek-R1-TEE",
          tooltip: "deepseek-ai/DeepSeek-R1-TEE by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 163840,
          model: "deepseek-ai/DeepSeek-R1-TEE",
          capabilities: {
            toolCalling: false,
            imageInput: false
          }
        },
        {
          id: "openai-gpt-oss-20b",
          name: "openai/gpt-oss-20b",
          tooltip: "openai/gpt-oss-20b by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 131072,
          model: "openai/gpt-oss-20b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "zai-org-glm-4-5-air",
          name: "zai-org/GLM-4.5-Air",
          tooltip: "zai-org/GLM-4.5-Air by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 131072,
          model: "zai-org/GLM-4.5-Air",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen2-5-vl-32b-instruct",
          name: "Qwen/Qwen2.5-VL-32B-Instruct",
          tooltip: "Qwen/Qwen2.5-VL-32B-Instruct by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 16384,
          model: "Qwen/Qwen2.5-VL-32B-Instruct",
          capabilities: {
            toolCalling: false,
            imageInput: true
          }
        },
        {
          id: "zai-org-glm-4-6v",
          name: "zai-org/GLM-4.6V",
          tooltip: "zai-org/GLM-4.6V by Chutes",
          maxInputTokens: 65536,
          maxOutputTokens: 65536,
          model: "zai-org/GLM-4.6V",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "qwen-qwen3-235b-a22b",
          name: "Qwen/Qwen3-235B-A22B",
          tooltip: "Qwen/Qwen3-235B-A22B by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 40960,
          model: "Qwen/Qwen3-235B-A22B",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "zai-org-glm-4-6-fp8",
          name: "zai-org/GLM-4.6-FP8",
          tooltip: "zai-org/GLM-4.6-FP8 by Chutes",
          maxInputTokens: 137217,
          maxOutputTokens: 65535,
          model: "zai-org/GLM-4.6-FP8",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "zai-org-glm-4-7-flash",
          name: "zai-org/GLM-4.7-Flash",
          tooltip: "zai-org/GLM-4.7-Flash by Chutes",
          maxInputTokens: 137217,
          maxOutputTokens: 65535,
          model: "zai-org/GLM-4.7-Flash",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen3-30b-a3b",
          name: "Qwen/Qwen3-30B-A3B",
          tooltip: "Qwen/Qwen3-30B-A3B by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 40960,
          model: "Qwen/Qwen3-30B-A3B",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "tngtech-tng-r1t-chimera-tee",
          name: "tngtech/TNG-R1T-Chimera-TEE",
          tooltip: "tngtech/TNG-R1T-Chimera-TEE by Chutes",
          maxInputTokens: 98304,
          maxOutputTokens: 65536,
          model: "tngtech/TNG-R1T-Chimera-TEE",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "deepseek-ai-deepseek-v3-2-speciale-tee",
          name: "deepseek-ai/DeepSeek-V3.2-Speciale-TEE",
          tooltip: "deepseek-ai/DeepSeek-V3.2-Speciale-TEE by Chutes",
          maxInputTokens: 98304,
          maxOutputTokens: 65536,
          model: "deepseek-ai/DeepSeek-V3.2-Speciale-TEE",
          capabilities: {
            toolCalling: false,
            imageInput: false
          }
        },
        {
          id: "nvidia-nvidia-nemotron-3-nano-30b-a3b-bf16",
          name: "nvidia/NVIDIA-Nemotron-3-Nano-30B-A3B-BF16",
          tooltip: "nvidia/NVIDIA-Nemotron-3-Nano-30B-A3B-BF16 by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 262144,
          model: "nvidia/NVIDIA-Nemotron-3-Nano-30B-A3B-BF16",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "zai-org-glm-4-5-fp8",
          name: "zai-org/GLM-4.5-FP8",
          tooltip: "zai-org/GLM-4.5-FP8 by Chutes",
          maxInputTokens: 65536,
          maxOutputTokens: 65536,
          model: "zai-org/GLM-4.5-FP8",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "tngtech-r1t2-chimera-speed",
          name: "tngtech/R1T2-Chimera-Speed",
          tooltip: "tngtech/R1T2-Chimera-Speed by Chutes",
          maxInputTokens: 65536,
          maxOutputTokens: 65536,
          model: "tngtech/R1T2-Chimera-Speed",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "miromind-ai-mirothinker-v1-5-235b",
          name: "miromind-ai/MiroThinker-v1.5-235B",
          tooltip: "miromind-ai/MiroThinker-v1.5-235B by Chutes",
          maxInputTokens: 246144,
          maxOutputTokens: 16e3,
          model: "miromind-ai/MiroThinker-v1.5-235B",
          capabilities: {
            toolCalling: false,
            imageInput: false
          }
        },
        {
          id: "nousresearch-hermes-4-14b",
          name: "NousResearch/Hermes-4-14B",
          tooltip: "NousResearch/Hermes-4-14B by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 40960,
          model: "NousResearch/Hermes-4-14B",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen3guard-gen-0-6b",
          name: "Qwen/Qwen3Guard-Gen-0.6B",
          tooltip: "Qwen/Qwen3Guard-Gen-0.6B by Chutes",
          maxInputTokens: 16768,
          maxOutputTokens: 16e3,
          model: "Qwen/Qwen3Guard-Gen-0.6B",
          capabilities: {
            toolCalling: false,
            imageInput: false
          }
        },
        {
          id: "unsloth-llama-3-2-1b-instruct",
          name: "unsloth/Llama-3.2-1B-Instruct",
          tooltip: "unsloth/Llama-3.2-1B-Instruct by Chutes",
          maxInputTokens: 384,
          maxOutputTokens: 16e3,
          model: "unsloth/Llama-3.2-1B-Instruct",
          capabilities: {
            toolCalling: false,
            imageInput: false
          }
        },
        {
          id: "rednote-hilab-dots-ocr",
          name: "rednote-hilab/dots.ocr",
          tooltip: "rednote-hilab/dots.ocr by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 131072,
          model: "rednote-hilab/dots.ocr",
          capabilities: {
            toolCalling: false,
            imageInput: true
          }
        },
        {
          id: "tngtech-tng-r1t-chimera-turbo",
          name: "tngtech/TNG-R1T-Chimera-Turbo",
          tooltip: "tngtech/TNG-R1T-Chimera-Turbo by Chutes",
          maxInputTokens: 98304,
          maxOutputTokens: 65536,
          model: "tngtech/TNG-R1T-Chimera-Turbo",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "unsloth-llama-3-2-3b-instruct",
          name: "unsloth/Llama-3.2-3B-Instruct",
          tooltip: "unsloth/Llama-3.2-3B-Instruct by Chutes",
          maxInputTokens: 384,
          maxOutputTokens: 16e3,
          model: "unsloth/Llama-3.2-3B-Instruct",
          capabilities: {
            toolCalling: false,
            imageInput: false
          }
        },
        {
          id: "moonshotai-kimi-k2-instruct-0905",
          name: "moonshotai/Kimi-K2-Instruct-0905",
          tooltip: "moonshotai/Kimi-K2-Instruct-0905 by Chutes",
          maxInputTokens: 1,
          maxOutputTokens: 262144,
          model: "moonshotai/Kimi-K2-Instruct-0905",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        }
      ]
    };
  }
});

// src/providers/config/codex.json
var codex_default;
var init_codex = __esm({
  "src/providers/config/codex.json"() {
    codex_default = {
      displayName: "Codex",
      baseUrl: "https://chatgpt.com/backend-api/codex",
      apiKeyTemplate: "",
      models: [
        {
          id: "gpt-5.2-codex-low",
          name: "GPT-5.2 Codex (Low Reasoning)",
          model: "gpt-5.2-codex",
          tooltip: "GPT-5.2 Codex with low reasoning effort - faster responses",
          maxInputTokens: 4e5,
          maxOutputTokens: 128e3,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gpt-5.2-codex-medium",
          name: "GPT-5.2 Codex (Medium Reasoning)",
          model: "gpt-5.2-codex",
          tooltip: "GPT-5.2 Codex with medium reasoning effort - balanced",
          maxInputTokens: 4e5,
          maxOutputTokens: 128e3,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gpt-5.2-codex-high",
          name: "GPT-5.2 Codex (High Reasoning)",
          model: "gpt-5.2-codex",
          tooltip: "GPT-5.2 Codex with high reasoning effort - most thorough",
          maxInputTokens: 4e5,
          maxOutputTokens: 128e3,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gpt-5.2",
          name: "GPT-5.2",
          model: "gpt-5.2",
          tooltip: "GPT-5.2 - OpenAI's latest model",
          maxInputTokens: 4e5,
          maxOutputTokens: 128e3,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gpt-5.2-low",
          name: "GPT-5.2 (Low Reasoning)",
          model: "gpt-5.2",
          tooltip: "GPT-5.2 with low reasoning effort",
          maxInputTokens: 4e5,
          maxOutputTokens: 128e3,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gpt-5.2-medium",
          name: "GPT-5.2 (Medium Reasoning)",
          model: "gpt-5.2",
          tooltip: "GPT-5.2 with medium reasoning effort",
          maxInputTokens: 4e5,
          maxOutputTokens: 128e3,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gpt-5.2-high",
          name: "GPT-5.2 (High Reasoning)",
          model: "gpt-5.2",
          tooltip: "GPT-5.2 with high reasoning effort",
          maxInputTokens: 4e5,
          maxOutputTokens: 128e3,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gpt-5.1-codex-mini",
          name: "GPT-5.1 Codex Mini",
          model: "gpt-5.1-codex-mini",
          tooltip: "GPT-5.1 Codex Mini - OpenAI's optimized model",
          maxInputTokens: 128e3,
          maxOutputTokens: 8192,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        }
      ]
    };
  }
});

// src/providers/config/deepinfra.json
var deepinfra_default;
var init_deepinfra = __esm({
  "src/providers/config/deepinfra.json"() {
    deepinfra_default = {
      displayName: "DeepInfra",
      baseUrl: "https://api.deepinfra.com/v1/openai",
      apiKeyTemplate: "di-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      models: [
        {
          id: "meta-llama/Meta-Llama-3.1-70B-Instruct",
          name: "Meta Llama 3.1 70B Instruct",
          tooltip: "Meta Llama 3.1 70B - Instruct by DeepInfra",
          maxInputTokens: 2e5,
          maxOutputTokens: 8192,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "Qwen/Qwen2-7B-Instruct",
          name: "Qwen 2 7B Instruct",
          tooltip: "Qwen2 7B - Instruct by DeepInfra",
          maxInputTokens: 128e3,
          maxOutputTokens: 8192,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        }
      ]
    };
  }
});

// src/providers/config/deepseek.json
var deepseek_default;
var init_deepseek = __esm({
  "src/providers/config/deepseek.json"() {
    deepseek_default = {
      displayName: "DeepSeek",
      baseUrl: "https://api.deepseek.com/v1",
      apiKeyTemplate: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      models: [
        {
          id: "deepseek-chat",
          name: "DeepSeek-V3.2",
          tooltip: "DeepSeek V3.2 official model. DeepSeek-V3.2 aims to balance reasoning capability with output length, suitable for daily use such as Q&A and general Agent tasks. In public reasoning benchmarks, DeepSeek-V3.2 reached GPT-5 levels, slightly below Gemini-3.0-Pro; compared to Kimi-K2-Thinking, V3.2's output length is significantly reduced, notably decreasing computational overhead and user wait time.",
          sdkMode: "anthropic",
          baseUrl: "https://api.deepseek.com/anthropic",
          maxInputTokens: 128e3,
          maxOutputTokens: 8192,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "deepseek-reasoner",
          name: "DeepSeek-V3.2 (Reasoner)",
          tooltip: "DeepSeek V3.2 reasoning mode. DeepSeek-V3.2 aims to balance reasoning capability with output length, suitable for daily use such as Q&A and general Agent tasks. In public reasoning benchmarks, DeepSeek-V3.2 reached GPT-5 levels, slightly below Gemini-3.0-Pro; compared to Kimi-K2-Thinking, V3.2's output length is significantly reduced, notably decreasing computational overhead and user wait time.",
          sdkMode: "anthropic",
          baseUrl: "https://api.deepseek.com/anthropic",
          maxInputTokens: 128e3,
          maxOutputTokens: 64e3,
          includeThinking: true,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        }
      ]
    };
  }
});

// src/providers/config/geminicli.json
var geminicli_default;
var init_geminicli = __esm({
  "src/providers/config/geminicli.json"() {
    geminicli_default = {
      displayName: "Gemini CLI",
      baseUrl: "https://cloudcode-pa.googleapis.com/v1internal",
      apiKeyTemplate: "OAuth via Gemini CLI",
      models: [
        {
          id: "gemini-2.5-pro",
          name: "Gemini 2.5 Pro",
          tooltip: "Gemini 2.5 Pro via CLI",
          maxInputTokens: 1e6,
          maxOutputTokens: 65536,
          sdkMode: "openai",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gemini-2.5-flash",
          name: "Gemini 2.5 Flash",
          tooltip: "Gemini 2.5 Flash via CLI",
          maxInputTokens: 1e6,
          maxOutputTokens: 65536,
          sdkMode: "openai",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gemini-2.5-flash-lite",
          name: "Gemini 2.5 Flash Lite",
          tooltip: "Gemini 2.5 Flash Lite via CLI",
          maxInputTokens: 1e6,
          maxOutputTokens: 65536,
          sdkMode: "openai",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gemini-3-pro-preview",
          name: "Gemini 3 Pro Preview",
          tooltip: "Gemini 3 Pro Preview via CLI",
          maxInputTokens: 1e6,
          maxOutputTokens: 65536,
          sdkMode: "openai",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gemini-3-flash-preview",
          name: "Gemini 3 Flash Preview",
          tooltip: "Gemini 3 Flash Preview via CLI",
          maxInputTokens: 1e6,
          maxOutputTokens: 65536,
          sdkMode: "openai",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        }
      ]
    };
  }
});

// src/providers/config/huggingface.json
var huggingface_default;
var init_huggingface = __esm({
  "src/providers/config/huggingface.json"() {
    huggingface_default = {
      displayName: "Hugging Face",
      baseUrl: "https://router.huggingface.co/v1",
      apiKeyTemplate: "hf_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      models: []
    };
  }
});

// src/providers/config/lightningai.json
var lightningai_default;
var init_lightningai = __esm({
  "src/providers/config/lightningai.json"() {
    lightningai_default = {
      displayName: "Lightning AI",
      baseUrl: "https://lightning.ai/api/v1",
      apiKeyTemplate: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      models: [
        {
          id: "openai/o3",
          name: "o3",
          tooltip: "o3 is a versatile, high-performing model across many domains. It raises the bar in math, science, coding, and visual reasoning, and it\u2019s excellent at technical writing and following instructions. Use it to tackle multi-step problems that combine text, code, and images.",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "openai/o3",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai/gpt-4o",
          name: "GPT 4o",
          tooltip: "GPT-4o is OpenAI\u2019s multimodal model, handling both text and image inputs with text outputs. It matches the intelligence of GPT-4 Turbo but runs twice as fast at half the cost. The model also brings stronger non-English language support and improved visual understanding.",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-4o",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai/gpt-4",
          name: "GPT 4",
          tooltip: "The default GPT-4 model with an 8,192-token context window.",
          maxInputTokens: 1,
          maxOutputTokens: 16e3,
          model: "openai/gpt-4",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "google/gemini-2.5-flash-lite-preview-06-17",
          name: "Gemini 2.5 Flash Lite",
          tooltip: "Gemini 2.5 Flash-Lite is a model developed by Google DeepMind, designed to handle various tasks including reasoning, science, mathematics, code generation, and more. It features advanced capabilities in multilingual performance and long context understanding. It is optimized for low latency use cases, supporting multimodal input with a 1 million-token context length.\n\n",
          maxInputTokens: 1032576,
          maxOutputTokens: 16e3,
          model: "google/gemini-2.5-flash-lite-preview-06-17",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "lightning-ai/llama-3.3-70b",
          name: "llama-3.3-70b",
          tooltip: "Llama 3.3 is a text-only 70B instruction-tuned model that provides enhanced performance relative to Llama 3.1 70B\u2013and relative to Llama 3.2 90B when used for text-only applications. Moreover, for some applications, Llama 3.3 70B approaches the performance of Llama 3.1 405B.",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "lightning-ai/llama-3.3-70b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "lightning-ai/DeepSeek-V3.1",
          name: "DeepSeek-V3.1",
          tooltip: "DeepSeek-V3.1 is a hybrid model that supports both thinking mode and non-thinking mode, switching between them with a simple chat template. It brings smarter tool calling, with much better performance in tool usage and agent tasks thanks to post-training optimization. The model also delivers higher thinking efficiency, reaching answer quality similar to DeepSeek-R1-0528 but with faster responses.",
          maxInputTokens: 147840,
          maxOutputTokens: 16e3,
          model: "lightning-ai/DeepSeek-V3.1",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "anthropic/claude-haiku-4-5-20251001",
          name: "Claude Haiku 4.5",
          tooltip: "Claude Haiku 4.5 delivers near-frontier performance with exceptional speed and cost-efficiency. It excels at real-time tasks like chat assistants, coding, and multi-agent workflows. Use it alone or alongside Sonnet 4.5 for fast, scalable execution.",
          maxInputTokens: 136e3,
          maxOutputTokens: 64e3,
          model: "anthropic/claude-haiku-4-5-20251001",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "anthropic/claude-sonnet-4-5-20250929",
          name: "Claude Sonnet 4.5",
          tooltip: "Claude Sonnet 4.5 is a frontier AI model that excels at coding, creating complex agents, and using computers for real-world tasks. It also features significant improvements in reasoning, math, and alignment, making it the most powerful model in its series.",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-sonnet-4-5-20250929",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "anthropic/claude-opus-4-5-20251101",
          name: "Claude Opus 4.5",
          tooltip: "Anthropic's Premium model combining maximum intelligence with practical performance",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-opus-4-5-20251101",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai/o3-mini",
          name: "o3 mini",
          tooltip: "OpenAI o3-mini is a lightweight, cost-efficient model built for STEM reasoning tasks like math, science, and coding. It lets you adjust its reasoning effort to balance speed and depth.The model delivers strong accuracy, matching the larger o1 on tough benchmarks while running faster and cheaper.",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "openai/o3-mini",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "anthropic/claude-sonnet-4-20250514",
          name: "Claude Sonnet 4",
          tooltip: "Claude Sonnet 4 improves on Sonnet 3.7 with stronger coding and reasoning skills, better precision, and greater reliability. It scores 72.7% on SWE-bench while staying efficient, making it ideal for both everyday coding and complex software projects.\n",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-sonnet-4-20250514",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "lightning-ai/gpt-oss-120b",
          name: "gpt-oss-120b",
          tooltip: "gpt-oss-120B is a 117 billion parameter language model, using a mixture-of-experts approach but activating only 5.1 billion per token for efficiency. It supports long contexts of up to 128k tokens, enabling it to handle extended conversations or documents smoothly. The model performs nearly at the level of o4-mini on reasoning tasks and surpasses many other open models in quality.",
          maxInputTokens: 1,
          maxOutputTokens: 131072,
          model: "lightning-ai/gpt-oss-120b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "lightning-ai/gpt-oss-20b",
          name: "gpt-oss-20b",
          tooltip: "gpt-oss-20B is a 21-billion parameter language model built with a mixture-of-experts design that activates only about 3.6 billion parameters per token. This efficiency allows it to run on devices with as little as 16 GB of memory, making it well-suited for local setups or edge devices.",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "lightning-ai/gpt-oss-20b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "anthropic/claude-opus-4-1-20250805",
          name: "Claude Opus 4.1",
          tooltip: "Claude Opus 4.1 is an enhanced version of Anthropic\u2019s flagship model, with stronger coding, reasoning, and agentic capabilities. It scores 74.5% on SWE-bench Verified and improves at multi-file refactoring, debugging, and detailed reasoning. With support for extended thinking up to 64K tokens, it\u2019s well-suited for research, data analysis, and tool-assisted problem solving.",
          maxInputTokens: 168e3,
          maxOutputTokens: 32e3,
          model: "anthropic/claude-opus-4-1-20250805",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai/gpt-5",
          name: "GPT 5",
          tooltip: "GPT-5 is OpenAI model that is built for complex, step-by-step tasks that demand precise instruction following and high-stakes accuracy. It supports test-time routing plus prompts like \u201Cthink hard about this.\u201D It also reduces hallucinations and sycophancy while improving performance in coding, writing, and health-related tasks.\n",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "openai/gpt-5-mini",
          name: "GPT 5 mini",
          tooltip: "GPT-5 Mini is a smaller, more efficient variant of GPT-5 built for lighter reasoning tasks. It maintains the strong instruction-following and safety features of GPT-5 while offering faster responses and lower costs.",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5-mini",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "openai/gpt-5-nano",
          name: "GPT 5 nano",
          tooltip: "GPT-5-Nano is the smallest and fastest variant in the GPT-5 system, built as a unified system that can decide when to respond quickly or dig deeper depending on what you ask it. It gets much better across a wide range of skills \u2014 writing, coding, math, health, and visual tasks \u2014 and is more reliable and accurate in real-world scenarios. Compared to earlier models, it hallucinates less, follows instructions more faithfully, and understands the context better.",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5-nano",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "google/gemini-2.5-pro",
          name: "Gemini 2.5 Pro",
          tooltip: "Gemini 2.5 Pro is Google\u2019s AI model built for advanced reasoning, coding, math, and scientific work. With integrated \u201Cthinking\u201D capabilities, it delivers more accurate answers and handles context with greater nuance. It ranks at the top of multiple benchmarks, including first place on the LMArena leaderboard, showcasing strong human-preference alignment and exceptional problem-solving skills.",
          maxInputTokens: 1032576,
          maxOutputTokens: 16e3,
          model: "google/gemini-2.5-pro",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "google/gemini-2.5-flash",
          name: "Gemini 2.5 Flash",
          tooltip: "Gemini 2.5 Flash is Google\u2019s powerful model built for complex reasoning, coding, math, and scientific challenges. With integrated \u201Cthinking\u201D capabilities, it delivers more accurate answers and handles context with greater nuance.",
          maxInputTokens: 1032576,
          maxOutputTokens: 16e3,
          model: "google/gemini-2.5-flash",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai/gpt-5.2-2025-12-11",
          name: "GPT 5.2",
          tooltip: "GPT-5.2 is OpenAI's  flagship model for coding and agentic tasks across industries. ",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5.2-2025-12-11",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai/gpt-4.1",
          name: "GPT 4.1",
          tooltip: "OpenAI\u2019s fast and capable model for reasoning, coding, and chat. It responds quickly, supports long context (128k tokens), and runs efficiently at scale\u2014ideal for advanced API applications.",
          maxInputTokens: 1031576,
          maxOutputTokens: 16e3,
          model: "openai/gpt-4.1",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai/gpt-4-turbo-preview",
          name: "Lightning SDK expert",
          tooltip: "openai/gpt-4-turbo-preview by Lightning AI",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-4-turbo-preview",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "openai/gpt-4-turbo-preview",
          name: "LitLogger helper",
          tooltip: "openai/gpt-4-turbo-preview by Lightning AI",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-4-turbo-preview",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "anthropic/claude-opus-4-6",
          name: "Claude Opus 4.6",
          tooltip: "Claude Opus 4.6 is Anthropic\u2019s most intelligent model for building agents and coding",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-opus-4-6",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "lightning-ai/kimi-k2.5",
          name: "kimi-k2.5",
          tooltip: "Kimi K2.5 is an open-source, native multimodal agentic model built through continual pretraining on approximately 15 trillion mixed visual and text tokens atop Kimi-K2-Base. It seamlessly integrates vision and language understanding with advanced agentic capabilities, instant and thinking modes, as well as conversational and agentic paradigms.",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "lightning-ai/kimi-k2.5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "google/gemini-3-flash-preview",
          name: "Gemini 3 Flash",
          tooltip: "Gemini 3 Flash Preview is designed to deliver strong agentic capabilities (near-Pro level) at substantial speed and value.",
          maxInputTokens: 1032576,
          maxOutputTokens: 16e3,
          model: "google/gemini-3-flash-preview",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai/gpt-4-turbo",
          name: "GPT 4 turbo",
          tooltip: "GPT-4 Turbo is an upgraded version of GPT-4, designed to deliver the same high intelligence while being faster and more cost-effective.",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-4-turbo",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "google/gemini-3-pro-preview",
          name: "Gemini 3 Pro Preview",
          tooltip: "The best model in the world for multimodal understanding, and our most powerful agentic and vibe-coding model yet",
          maxInputTokens: 1032576,
          maxOutputTokens: 16e3,
          model: "google/gemini-3-pro-preview",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "anthropic/claude-opus-4-20250514",
          name: "Claude Opus 4",
          tooltip: "Claude Opus 4 is Anthropic\u2019s coding model, built for complex, long-running tasks and agent workflows. It leads in software engineering benchmarks with 72.5% on SWE-bench and 43.2% on Terminal-bench. The model is designed for extended use, sustaining thousands of task steps over hours without performance drop.",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-opus-4-20250514",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai/gpt-3.5-turbo",
          name: "GPT 3.5 turbo",
          tooltip: "GPT-3.5 Turbo is OpenAI's fastest model. It can understand and generate natural language or code, and is optimized for chat and traditional completion tasks.",
          maxInputTokens: 385,
          maxOutputTokens: 16e3,
          model: "openai/gpt-3.5-turbo",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        }
      ]
    };
  }
});

// src/providers/config/minimax.json
var minimax_default;
var init_minimax = __esm({
  "src/providers/config/minimax.json"() {
    minimax_default = {
      displayName: "MiniMax",
      baseUrl: "https://api.minimaxi.com/v1",
      apiKeyTemplate: "This ApiKey is a long string with a JWT-like structure",
      models: [
        {
          id: "MiniMax-M2.1-Coding-Plan",
          name: "MiniMax-M2.1 (Coding Plan)",
          model: "MiniMax-M2.1",
          sdkMode: "anthropic",
          baseUrl: "https://api.minimaxi.com/anthropic",
          tooltip: "MiniMax-M2.1 - Strong multi-language programming capabilities, fully upgraded programming experience",
          provider: "minimax-coding",
          maxInputTokens: 204800,
          maxOutputTokens: 64e3,
          includeThinking: true,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "MiniMax-M2-Coding-Plan",
          name: "MiniMax-M2 (Coding Plan)",
          model: "MiniMax-M2",
          sdkMode: "anthropic",
          baseUrl: "https://api.minimaxi.com/anthropic",
          tooltip: "MiniMax-M2 - Born for efficient coding and Agent workflows",
          provider: "minimax-coding",
          maxInputTokens: 204800,
          maxOutputTokens: 64e3,
          includeThinking: true,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "MiniMax-M2.1",
          name: "MiniMax-M2.1 (Pay-per-use)",
          sdkMode: "anthropic",
          baseUrl: "https://api.minimaxi.com/anthropic",
          tooltip: "MiniMax-M2.1 - Strong multi-language programming capabilities, fully upgraded programming experience",
          maxInputTokens: 204800,
          maxOutputTokens: 128e3,
          includeThinking: true,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "MiniMax-M2.1-Lightning",
          name: "MiniMax-M2.1-Lightning (2x Speed Rate)",
          sdkMode: "anthropic",
          baseUrl: "https://api.minimaxi.com/anthropic",
          tooltip: "MiniMax-M2.1 - Faster, more efficient - Strong multi-language programming capabilities, fully upgraded programming experience",
          maxInputTokens: 204800,
          maxOutputTokens: 128e3,
          includeThinking: true,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "MiniMax-M2",
          name: "MiniMax-M2 (Pay-per-use)",
          sdkMode: "anthropic",
          baseUrl: "https://api.minimaxi.com/anthropic",
          tooltip: "MiniMax-M2 - Born for efficient coding and Agent workflows",
          maxInputTokens: 204800,
          maxOutputTokens: 64e3,
          includeThinking: true,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        }
      ]
    };
  }
});

// src/providers/config/mistral.json
var mistral_default;
var init_mistral = __esm({
  "src/providers/config/mistral.json"() {
    mistral_default = {
      displayName: "Mistral AI",
      baseUrl: "https://api.mistral.ai/v1",
      apiKeyTemplate: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      models: [
        {
          id: "devstral-small-latest",
          name: "Devstral Small 2",
          tooltip: "Devstral Small 2 - Latest version",
          maxInputTokens: 256e3,
          maxOutputTokens: 65536,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "devstral-latest",
          name: "Devstral 2",
          tooltip: "Devstral 2 - Latest version",
          maxInputTokens: 256e3,
          maxOutputTokens: 65536,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        }
      ]
    };
  }
});

// src/providers/config/moonshot.json
var moonshot_default;
var init_moonshot = __esm({
  "src/providers/config/moonshot.json"() {
    moonshot_default = {
      displayName: "MoonshotAI",
      baseUrl: "https://api.moonshot.cn/v1",
      apiKeyTemplate: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      models: [
        {
          id: "kimi-for-coding",
          name: "Kimi For Coding",
          sdkMode: "anthropic",
          baseUrl: "https://api.kimi.com/coding",
          provider: "kimi",
          tooltip: "Kimi For Coding - Professional programming model by Moonshot AI, providing strong code generation and understanding capabilities",
          maxInputTokens: 256e3,
          maxOutputTokens: 32e3,
          capabilities: {
            toolCalling: true,
            imageInput: false
          },
          customHeader: {
            "HTTP-Referer": "https://github.com/RooVetGit/Roo-Cline",
            "X-Title": "Roo Code",
            "User-Agent": "RooCode/3.36.16"
          }
        },
        {
          id: "kimi-k2-thinking",
          name: "Kimi-K2-Thinking",
          tooltip: "Moonshot AI Kimi-K2-Thinking - Model context length 256k, a thinking model with general Agentic and reasoning capabilities, excels at deep reasoning",
          maxInputTokens: 256e3,
          maxOutputTokens: 16e3,
          includeThinking: true,
          capabilities: {
            toolCalling: true,
            imageInput: false
          },
          extraBody: {
            temperature: 1,
            top_p: 1
          }
        },
        {
          id: "kimi-k2-thinking-turbo",
          name: "Kimi-K2-Thinking-Turbo",
          tooltip: "Moonshot AI Kimi-K2-Thinking-Turbo - Model context length 256k, high-speed version of kimi-k2-thinking, suitable for scenarios requiring deep reasoning and extreme speed",
          maxInputTokens: 256e3,
          maxOutputTokens: 16e3,
          includeThinking: true,
          capabilities: {
            toolCalling: true,
            imageInput: false
          },
          extraBody: {
            temperature: 1,
            top_p: 1
          }
        },
        {
          id: "kimi-k2-0905-preview",
          name: "Kimi-K2-0905-Preview",
          sdkMode: "anthropic",
          baseUrl: "https://api.moonshot.cn/anthropic",
          tooltip: "Moonshot AI Kimi-K2-0905-Preview - Stronger Agentic Coding capabilities, more prominent frontend code aesthetics and practicality, 256K context",
          maxInputTokens: 256e3,
          maxOutputTokens: 8192,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "kimi-k2-turbo-preview",
          name: "Kimi-K2-Turbo-Preview",
          sdkMode: "anthropic",
          baseUrl: "https://api.moonshot.cn/anthropic",
          tooltip: "Moonshot AI Kimi-K2-Turbo-Preview - High-speed version model, output speed 60-100 tokens/sec, 256K context",
          maxInputTokens: 256e3,
          maxOutputTokens: 8192,
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "kimi-k2-0711-preview",
          name: "Kimi-K2-0711-Preview",
          sdkMode: "anthropic",
          baseUrl: "https://api.moonshot.cn/anthropic",
          tooltip: "Moonshot AI Kimi-K2-0711-Preview - K2 series base version, 128K context",
          maxInputTokens: 128e3,
          maxOutputTokens: 8192,
          version: "kimi-k2-0711-previw",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "kimi-latest",
          name: "Kimi-Latest",
          tooltip: "Moonshot AI Kimi-Latest - Latest generation visual model, 128K context, supports image understanding, automatic context caching, intelligent selection of 8K/32K/128K billing models",
          maxInputTokens: 128e3,
          maxOutputTokens: 8192,
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        }
      ]
    };
  }
});

// src/providers/config/opencode.json
var opencode_default;
var init_opencode = __esm({
  "src/providers/config/opencode.json"() {
    opencode_default = {
      displayName: "OpenCode",
      baseUrl: "https://opencode.ai/zen/v1",
      apiKeyTemplate: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      models: [
        {
          id: "claude-opus-4-6",
          name: "claude-opus-4-6",
          tooltip: "claude-opus-4-6 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "claude-opus-4-6",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "claude-opus-4-5",
          name: "claude-opus-4-5",
          tooltip: "claude-opus-4-5 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "claude-opus-4-5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "claude-opus-4-1",
          name: "claude-opus-4-1",
          tooltip: "claude-opus-4-1 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "claude-opus-4-1",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "claude-sonnet-4",
          name: "claude-sonnet-4",
          tooltip: "claude-sonnet-4 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "claude-sonnet-4",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "claude-sonnet-4-5",
          name: "claude-sonnet-4-5",
          tooltip: "claude-sonnet-4-5 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "claude-sonnet-4-5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "claude-3-5-haiku",
          name: "claude-3-5-haiku",
          tooltip: "claude-3-5-haiku by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "claude-3-5-haiku",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "claude-haiku-4-5",
          name: "claude-haiku-4-5",
          tooltip: "claude-haiku-4-5 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "claude-haiku-4-5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gemini-3-pro",
          name: "gemini-3-pro",
          tooltip: "gemini-3-pro by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "gemini-3-pro",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gemini-3-flash",
          name: "gemini-3-flash",
          tooltip: "gemini-3-flash by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "gemini-3-flash",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gpt-5.2",
          name: "gpt-5.2",
          tooltip: "gpt-5.2 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "gpt-5.2",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gpt-5.2-codex",
          name: "gpt-5.2-codex",
          tooltip: "gpt-5.2-codex by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "gpt-5.2-codex",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gpt-5.1",
          name: "gpt-5.1",
          tooltip: "gpt-5.1 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "gpt-5.1",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gpt-5.1-codex-max",
          name: "gpt-5.1-codex-max",
          tooltip: "gpt-5.1-codex-max by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "gpt-5.1-codex-max",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gpt-5.1-codex",
          name: "gpt-5.1-codex",
          tooltip: "gpt-5.1-codex by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "gpt-5.1-codex",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gpt-5.1-codex-mini",
          name: "gpt-5.1-codex-mini",
          tooltip: "gpt-5.1-codex-mini by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "gpt-5.1-codex-mini",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gpt-5",
          name: "gpt-5",
          tooltip: "gpt-5 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "gpt-5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gpt-5-codex",
          name: "gpt-5-codex",
          tooltip: "gpt-5-codex by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "gpt-5-codex",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gpt-5-nano",
          name: "gpt-5-nano",
          tooltip: "gpt-5-nano by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "gpt-5-nano",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "glm-4.7",
          name: "glm-4.7",
          tooltip: "glm-4.7 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "glm-4.7",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "glm-4.6",
          name: "glm-4.6",
          tooltip: "glm-4.6 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "glm-4.6",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "minimax-m2.1",
          name: "minimax-m2.1",
          tooltip: "minimax-m2.1 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "minimax-m2.1",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "minimax-m2.5-free",
          name: "minimax-m2.5-free",
          tooltip: "minimax-m2.5-free by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "minimax-m2.5-free",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "minimax-m2.1-free",
          name: "minimax-m2.1-free",
          tooltip: "minimax-m2.1-free by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "minimax-m2.1-free",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "kimi-k2.5",
          name: "kimi-k2.5",
          tooltip: "kimi-k2.5 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "kimi-k2.5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "kimi-k2.5-free",
          name: "kimi-k2.5-free",
          tooltip: "kimi-k2.5-free by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "kimi-k2.5-free",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "kimi-k2",
          name: "kimi-k2",
          tooltip: "kimi-k2 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "kimi-k2",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "kimi-k2-thinking",
          name: "kimi-k2-thinking",
          tooltip: "kimi-k2-thinking by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "kimi-k2-thinking",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "trinity-large-preview-free",
          name: "trinity-large-preview-free",
          tooltip: "trinity-large-preview-free by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "trinity-large-preview-free",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "glm-4.7-free",
          name: "glm-4.7-free",
          tooltip: "glm-4.7-free by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "glm-4.7-free",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "big-pickle",
          name: "big-pickle",
          tooltip: "big-pickle by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "big-pickle",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "alpha-g5",
          name: "alpha-g5",
          tooltip: "alpha-g5 by OpenCode",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "alpha-g5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        }
      ]
    };
  }
});

// src/providers/config/ollama.json
var ollama_default;
var init_ollama = __esm({
  "src/providers/config/ollama.json"() {
    ollama_default = {
      displayName: "Ollama Cloud",
      baseUrl: "https://ollama.com/v1",
      apiKeyTemplate: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      models: [
        {
          id: "cogito-2.1:671b",
          name: "cogito-2.1:671b",
          tooltip: "128K context window",
          maxInputTokens: 128e3,
          maxOutputTokens: 3e4,
          model: "cogito-2.1:671b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "glm-4.6",
          name: "glm-4.6",
          tooltip: "Context expanded from 128K to 200K tokens",
          maxInputTokens: 2e5,
          maxOutputTokens: 1e5,
          model: "glm-4.6",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "glm-4.7",
          name: "glm-4.7",
          tooltip: "200K+ token context window",
          maxInputTokens: 204800,
          maxOutputTokens: 1e5,
          model: "glm-4.7",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "glm-5",
          name: "glm-5",
          tooltip: "200K context window",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "glm-5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "kimi-k2:1t",
          name: "kimi-k2:1t",
          tooltip: "Instruct variant, 128K context",
          maxInputTokens: 128e3,
          maxOutputTokens: 16384,
          model: "kimi-k2:1t",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "kimi-k2-thinking",
          name: "kimi-k2-thinking",
          tooltip: "200K context window with reasoning capabilities",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "kimi-k2-thinking",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "kimi-k2.5",
          name: "kimi-k2.5",
          tooltip: "200K context window with reasoning capabilities",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "kimi-k2.5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen3-coder:480b",
          name: "qwen3-coder:480b",
          tooltip: "Native 200K, extensible to 1M with Yarn",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "qwen3-coder:480b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen3-next:80b",
          name: "qwen3-next:80b",
          tooltip: "Native 200K tokens, extensible to 1M",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "qwen3-next:80b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen3-coder-next",
          name: "qwen3-coder-next",
          tooltip: "Native 200K tokens, coding-focused",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "qwen3-coder-next",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "deepseek-v3.2",
          name: "deepseek-v3.2",
          tooltip: "128K context, default max output 4K, maximum 8K",
          maxInputTokens: 131072,
          maxOutputTokens: 3e4,
          model: "deepseek-v3.2",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "deepseek-v3.1:671b",
          name: "deepseek-v3.1:671b",
          tooltip: "128K context window, 671B total parameters, 37B active",
          maxInputTokens: 131072,
          maxOutputTokens: 3e4,
          model: "deepseek-v3.1:671b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gpt-oss:120b",
          name: "gpt-oss:120b",
          tooltip: "64K context using RoPE, extended to 64K with YaRN",
          maxInputTokens: 64e3,
          maxOutputTokens: 64e3,
          model: "gpt-oss:120b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "nemotron-3-nano:30b",
          name: "nemotron-3-nano:30b",
          tooltip: "1M token context window, output limit not specified",
          maxInputTokens: 9e5,
          maxOutputTokens: 1e5,
          model: "nemotron-3-nano:30b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gpt-oss:20b",
          name: "gpt-oss:20b",
          tooltip: "Same 64K context as 120B variant",
          maxInputTokens: 64e3,
          maxOutputTokens: 64e3,
          model: "gpt-oss:20b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen3-vl:235b-instruct",
          name: "qwen3-vl:235b-instruct",
          tooltip: "200K context, vision-language model",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "qwen3-vl:235b-instruct",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "qwen3-vl:235b",
          name: "qwen3-vl:235b",
          tooltip: "200K context, base model variant",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "qwen3-vl:235b",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "minimax-m2",
          name: "minimax-m2",
          tooltip: "200K context length, 62K max output",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "minimax-m2",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "minimax-m2.1",
          name: "minimax-m2.1",
          tooltip: "200K context, enhanced from M2",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "minimax-m2.1",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "minimax-m2.5",
          name: "minimax-m2.5",
          tooltip: "200K context window",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "minimax-m2.5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "ministral-3:3b",
          name: "ministral-3:3b",
          tooltip: "200K context window",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "ministral-3:3b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "ministral-3:8b",
          name: "ministral-3:8b",
          tooltip: "200K context window",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "ministral-3:8b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "ministral-3:14b",
          name: "ministral-3:14b",
          tooltip: "200K context window",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "ministral-3:14b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "mistral-large-3:675b",
          name: "mistral-large-3:675b",
          tooltip: "200K context, 62K max output capacity",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "mistral-large-3:675b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "devstral-2:123b",
          name: "devstral-2:123b",
          tooltip: "200K context window, coding-focused",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "devstral-2:123b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "devstral-small-2:24b",
          name: "devstral-small-2:24b",
          tooltip: "200K context window",
          maxInputTokens: 2e5,
          maxOutputTokens: 62e3,
          model: "devstral-small-2:24b",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gemini-3-pro-preview",
          name: "gemini-3-pro-preview",
          tooltip: "1M input tokens, 64K output limit",
          maxInputTokens: 1048576,
          maxOutputTokens: 65536,
          model: "gemini-3-pro-preview",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gemini-3-flash-preview",
          name: "gemini-3-flash-preview",
          tooltip: "1M input tokens, 64K output limit",
          maxInputTokens: 1048576,
          maxOutputTokens: 65536,
          model: "gemini-3-flash-preview",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "gemma3:4b",
          name: "gemma3:4b",
          tooltip: "128K context window",
          maxInputTokens: 131072,
          maxOutputTokens: 3e4,
          model: "gemma3:4b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gemma3:12b",
          name: "gemma3:12b",
          tooltip: "128K context window",
          maxInputTokens: 131072,
          maxOutputTokens: 3e4,
          model: "gemma3:12b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "gemma3:27b",
          name: "gemma3:27b",
          tooltip: "128K context window",
          maxInputTokens: 131072,
          maxOutputTokens: 3e4,
          model: "gemma3:27b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "rnj-1:8b",
          name: "rnj-1:8b",
          tooltip: "16K context with YaRN extension, max output 16K",
          maxInputTokens: 16e3,
          maxOutputTokens: 16e3,
          model: "rnj-1:8b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        }
      ]
    };
  }
});

// src/providers/config/qwencli.json
var qwencli_default;
var init_qwencli = __esm({
  "src/providers/config/qwencli.json"() {
    qwencli_default = {
      displayName: "Qwen Code CLI",
      baseUrl: "https://dashscope.aliyuncs.com/compatible-mode/v1",
      apiKeyTemplate: "OAuth via Qwen CLI",
      models: [
        {
          id: "coder-model",
          name: "Qwen Coder (CLI Default)",
          tooltip: "Qwen Coder via CLI",
          maxInputTokens: 1e6,
          maxOutputTokens: 65536,
          model: "coder-model",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "vision-model",
          name: "Qwen Vision",
          tooltip: "Qwen Vision model via CLI",
          maxInputTokens: 1e6,
          maxOutputTokens: 65536,
          model: "vision-model",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "qwen3-coder-plus",
          name: "Qwen3 Coder Plus",
          tooltip: "Qwen3 Coder Plus via CLI",
          maxInputTokens: 1e6,
          maxOutputTokens: 65536,
          model: "qwen3-coder-plus",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        }
      ]
    };
  }
});

// src/providers/config/zenmux.json
var zenmux_default;
var init_zenmux = __esm({
  "src/providers/config/zenmux.json"() {
    zenmux_default = {
      displayName: "Zenmux",
      baseUrl: "https://zenmux.ai/api/v1",
      apiKeyTemplate: "zm-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      models: [
        {
          id: "kuaishou-kat-coder-pro-v1-free",
          name: "KwaiKAT: KAT-Coder-Pro-V1 Free",
          tooltip: "KwaiKAT: KAT-Coder-Pro-V1 Free by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "kuaishou/kat-coder-pro-v1-free",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "z-ai-glm-4-6v-flash-free",
          name: "Z.AI: GLM 4.6V Flash (Free)",
          tooltip: "Z.AI: GLM 4.6V Flash (Free) by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "z-ai/glm-4.6v-flash-free",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "xiaomi-mimo-v2-flash-free",
          name: "Xiaomi: MiMo-V2-Flash Free",
          tooltip: "Xiaomi: MiMo-V2-Flash Free by Zenmux",
          maxInputTokens: 246144,
          maxOutputTokens: 16e3,
          model: "xiaomi/mimo-v2-flash-free",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "openai-gpt-4-1-mini",
          name: "OpenAI: GPT-4.1 Mini",
          tooltip: "OpenAI: GPT-4.1 Mini by Zenmux",
          maxInputTokens: 1031576,
          maxOutputTokens: 16e3,
          model: "openai/gpt-4.1-mini",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "anthropic-claude-opus-4",
          name: "Anthropic: Claude Opus 4",
          tooltip: "Anthropic: Claude Opus 4 by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-opus-4",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-4-1-nano",
          name: "OpenAI: GPT-4.1 Nano",
          tooltip: "OpenAI: GPT-4.1 Nano by Zenmux",
          maxInputTokens: 1031576,
          maxOutputTokens: 16e3,
          model: "openai/gpt-4.1-nano",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-o4-mini",
          name: "OpenAI: o4 Mini",
          tooltip: "OpenAI: o4 Mini by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "openai/o4-mini",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-5",
          name: "OpenAI: GPT-5",
          tooltip: "OpenAI: GPT-5 by Zenmux",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-4o",
          name: "OpenAI: GPT-4o",
          tooltip: "OpenAI: GPT-4o by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-4o",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-5-nano",
          name: "OpenAI: GPT-5 Nano",
          tooltip: "OpenAI: GPT-5 Nano by Zenmux",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5-nano",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-4-1",
          name: "OpenAI: GPT-4.1",
          tooltip: "OpenAI: GPT-4.1 by Zenmux",
          maxInputTokens: 1031576,
          maxOutputTokens: 16e3,
          model: "openai/gpt-4.1",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "anthropic-claude-3-5-haiku",
          name: "Anthropic: Claude 3.5 Haiku",
          tooltip: "Anthropic: Claude 3.5 Haiku by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-3.5-haiku",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "google-gemini-2-5-flash-lite",
          name: "Google: Gemini 2.5 Flash Lite",
          tooltip: "Google: Gemini 2.5 Flash Lite by Zenmux",
          maxInputTokens: 1032576,
          maxOutputTokens: 16e3,
          model: "google/gemini-2.5-flash-lite",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "anthropic-claude-3-7-sonnet",
          name: "Anthropic: Claude 3.7 Sonnet",
          tooltip: "Anthropic: Claude 3.7 Sonnet by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-3.7-sonnet",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "deepseek-deepseek-r1-0528",
          name: "DeepSeek: R1 0528",
          tooltip: "DeepSeek: R1 0528 by Zenmux",
          maxInputTokens: 48e3,
          maxOutputTokens: 16e3,
          model: "deepseek/deepseek-r1-0528",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "anthropic-claude-opus-4-1",
          name: "Anthropic: Claude Opus 4.1",
          tooltip: "Anthropic: Claude Opus 4.1 by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-opus-4.1",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "anthropic-claude-sonnet-4",
          name: "Anthropic: Claude Sonnet 4",
          tooltip: "Anthropic: Claude Sonnet 4 by Zenmux",
          maxInputTokens: 984e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-sonnet-4",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-5-mini",
          name: "OpenAI: GPT-5 Mini",
          tooltip: "OpenAI: GPT-5 Mini by Zenmux",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5-mini",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-5-chat",
          name: "OpenAI: GPT-5 Chat",
          tooltip: "OpenAI: GPT-5 Chat by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5-chat",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "google-gemini-2-5-flash",
          name: "Google: Gemini 2.5 Flash",
          tooltip: "Google: Gemini 2.5 Flash by Zenmux",
          maxInputTokens: 1032576,
          maxOutputTokens: 16e3,
          model: "google/gemini-2.5-flash",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "deepseek-deepseek-chat-v3-1",
          name: "DeepSeek: DeepSeek V3.1",
          tooltip: "DeepSeek: DeepSeek V3.1 by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "deepseek/deepseek-chat-v3.1",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "google-gemini-2-5-pro",
          name: "Google: Gemini 2.5 Pro",
          tooltip: "Google: Gemini 2.5 Pro by Zenmux",
          maxInputTokens: 1032576,
          maxOutputTokens: 16e3,
          model: "google/gemini-2.5-pro",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "google-gemini-2-0-flash",
          name: "Google: Gemini 2.0 Flash",
          tooltip: "Google: Gemini 2.0 Flash by Zenmux",
          maxInputTokens: 1032576,
          maxOutputTokens: 16e3,
          model: "google/gemini-2.0-flash",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "x-ai-grok-4",
          name: "xAI: Grok 4",
          tooltip: "xAI: Grok 4 by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "x-ai/grok-4",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "qwen-qwen3-235b-a22b-2507",
          name: "Qwen: Qwen3 235B A22B Instruct 2507",
          tooltip: "Qwen: Qwen3 235B A22B Instruct 2507 by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "qwen/qwen3-235b-a22b-2507",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "openai-gpt-4o-mini",
          name: "OpenAI: GPT-4o-mini",
          tooltip: "OpenAI: GPT-4o-mini by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-4o-mini",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "qwen-qwen3-235b-a22b-thinking-2507",
          name: "Qwen: Qwen3 235B A22B Thinking 2507",
          tooltip: "Qwen: Qwen3 235B A22B Thinking 2507 by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "qwen/qwen3-235b-a22b-thinking-2507",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen3-coder",
          name: "Qwen: Qwen3-Coder",
          tooltip: "Qwen: Qwen3-Coder by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "qwen/qwen3-coder",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "google-gemini-2-0-flash-lite-001",
          name: "Google: Gemini 2.0 Flash Lite",
          tooltip: "Google: Gemini 2.0 Flash Lite by Zenmux",
          maxInputTokens: 1032576,
          maxOutputTokens: 16e3,
          model: "google/gemini-2.0-flash-lite-001",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "z-ai-glm-4-5-air",
          name: "Z.AI: GLM 4.5 Air",
          tooltip: "Z.AI: GLM 4.5 Air by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "z-ai/glm-4.5-air",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen3-coder-plus",
          name: "Qwen: Qwen3-Coder-Plus",
          tooltip: "Qwen: Qwen3-Coder-Plus by Zenmux",
          maxInputTokens: 984e3,
          maxOutputTokens: 16e3,
          model: "qwen/qwen3-coder-plus",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "deepseek-deepseek-chat",
          name: "DeepSeek: DeepSeek-V3.2 (Non-thinking Mode)",
          tooltip: "DeepSeek: DeepSeek-V3.2 (Non-thinking Mode) by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "deepseek/deepseek-chat",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "inclusionai-ring-mini-2-0",
          name: "inclusionAI: Ring-mini-2.0",
          tooltip: "inclusionAI: Ring-mini-2.0 by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "inclusionai/ring-mini-2.0",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "moonshotai-kimi-k2-0905",
          name: "MoonshotAI: Kimi K2 0905",
          tooltip: "MoonshotAI: Kimi K2 0905 by Zenmux",
          maxInputTokens: 246100,
          maxOutputTokens: 16e3,
          model: "moonshotai/kimi-k2-0905",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "inclusionai-ling-mini-2-0",
          name: "inclusionAI: Ling-mini-2.0",
          tooltip: "inclusionAI: Ling-mini-2.0 by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "inclusionai/ling-mini-2.0",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "z-ai-glm-4-5",
          name: "Z.AI: GLM 4.5",
          tooltip: "Z.AI: GLM 4.5 by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "z-ai/glm-4.5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "moonshotai-kimi-k2-0711",
          name: "MoonshotAI: Kimi K2 0711",
          tooltip: "MoonshotAI: Kimi K2 0711 by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "moonshotai/kimi-k2-0711",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "inclusionai-ling-flash-2-0",
          name: "inclusionAI: Ling-flash-2.0",
          tooltip: "inclusionAI: Ling-flash-2.0 by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "inclusionai/ling-flash-2.0",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "inclusionai-ring-flash-2-0",
          name: "inclusionAI: Ring-flash-2.0",
          tooltip: "inclusionAI: Ring-flash-2.0 by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "inclusionai/ring-flash-2.0",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "x-ai-grok-code-fast-1",
          name: "xAI: Grok Code Fast 1",
          tooltip: "xAI: Grok Code Fast 1 by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "x-ai/grok-code-fast-1",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "x-ai-grok-4-fast",
          name: "xAI: Grok 4 Fast",
          tooltip: "xAI: Grok 4 Fast by Zenmux",
          maxInputTokens: 1984e3,
          maxOutputTokens: 16e3,
          model: "x-ai/grok-4-fast",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "x-ai-grok-4-fast-non-reasoning",
          name: "xAI: Grok 4 Fast None Reasoning",
          tooltip: "xAI: Grok 4 Fast None Reasoning by Zenmux",
          maxInputTokens: 1984e3,
          maxOutputTokens: 16e3,
          model: "x-ai/grok-4-fast-non-reasoning",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "qwen-qwen3-vl-plus",
          name: "Qwen: Qwen3-VL-Plus",
          tooltip: "Qwen: Qwen3-VL-Plus by Zenmux",
          maxInputTokens: 246144,
          maxOutputTokens: 16e3,
          model: "qwen/qwen3-vl-plus",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "qwen-qwen3-max",
          name: "Qwen: Qwen3-Max-Thinking",
          tooltip: "Qwen: Qwen3-Max-Thinking by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "qwen/qwen3-max",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "z-ai-glm-4-6",
          name: "Z.AI: GLM 4.6",
          tooltip: "Z.AI: GLM 4.6 by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "z-ai/glm-4.6",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "inclusionai-ling-1t",
          name: "inclusionAI: Ling-1T",
          tooltip: "inclusionAI: Ling-1T by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "inclusionai/ling-1t",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "inclusionai-ring-1t",
          name: "inclusionAI: Ring-1T",
          tooltip: "inclusionAI: Ring-1T by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "inclusionai/ring-1t",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "anthropic-claude-sonnet-4-5",
          name: "Anthropic: Claude Sonnet 4.5",
          tooltip: "Anthropic: Claude Sonnet 4.5 by Zenmux",
          maxInputTokens: 984e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-sonnet-4.5",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "anthropic-claude-haiku-4-5",
          name: "Anthropic: Claude Haiku 4.5",
          tooltip: "Anthropic: Claude Haiku 4.5 by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-haiku-4.5",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-5-pro",
          name: "OpenAI: GPT-5 Pro",
          tooltip: "OpenAI: GPT-5 Pro by Zenmux",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5-pro",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-5-codex",
          name: "OpenAI: GPT-5 Codex",
          tooltip: "OpenAI: GPT-5 Codex by Zenmux",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5-codex",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "deepseek-deepseek-reasoner",
          name: "DeepSeek: DeepSeek-V3.2 (Thinking Mode)",
          tooltip: "DeepSeek: DeepSeek-V3.2 (Thinking Mode) by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "deepseek/deepseek-reasoner",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "kuaishou-kat-coder-pro-v1",
          name: "KwaiKAT: KAT-Coder-Pro-V1",
          tooltip: "KwaiKAT: KAT-Coder-Pro-V1 by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "kuaishou/kat-coder-pro-v1",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "minimax-minimax-m2",
          name: "MiniMax: MiniMax M2",
          tooltip: "MiniMax: MiniMax M2 by Zenmux",
          maxInputTokens: 188800,
          maxOutputTokens: 16e3,
          model: "minimax/minimax-m2",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "moonshotai-kimi-k2-thinking",
          name: "MoonshotAI: Kimi K2 Thinking",
          tooltip: "MoonshotAI: Kimi K2 Thinking by Zenmux",
          maxInputTokens: 246144,
          maxOutputTokens: 16e3,
          model: "moonshotai/kimi-k2-thinking",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "moonshotai-kimi-k2-thinking-turbo",
          name: "MoonshotAI: Kimi K2 Thinking Turbo",
          tooltip: "MoonshotAI: Kimi K2 Thinking Turbo by Zenmux",
          maxInputTokens: 246144,
          maxOutputTokens: 16e3,
          model: "moonshotai/kimi-k2-thinking-turbo",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "qwen-qwen3-max-preview",
          name: "Qwen: Qwen3 Max Thinking Preview",
          tooltip: "Qwen: Qwen3 Max Thinking Preview by Zenmux",
          maxInputTokens: 246144,
          maxOutputTokens: 16e3,
          model: "qwen/qwen3-max-preview",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "baidu-ernie-5-0-thinking-preview",
          name: "Baidu: ERNIE 5.0",
          tooltip: "Baidu: ERNIE 5.0 by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "baidu/ernie-5.0-thinking-preview",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-5-1-codex",
          name: "OpenAI: GPT-5.1-Codex",
          tooltip: "OpenAI: GPT-5.1-Codex by Zenmux",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5.1-codex",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-5-1-chat",
          name: "OpenAI: GPT-5.1 Chat",
          tooltip: "OpenAI: GPT-5.1 Chat by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5.1-chat",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "qwen-qwen3-14b",
          name: "Qwen: Qwen3 14B",
          tooltip: "Qwen: Qwen3 14B by Zenmux",
          maxInputTokens: 16e3,
          maxOutputTokens: 16e3,
          model: "qwen/qwen3-14b",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "openai-gpt-5-1-codex-mini",
          name: "OpenAI: GPT-5.1-Codex-Mini",
          tooltip: "OpenAI: GPT-5.1-Codex-Mini by Zenmux",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5.1-codex-mini",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "volcengine-doubao-seed-code",
          name: "VolcanoEngine: Doubao-Seed-Code",
          tooltip: "VolcanoEngine: Doubao-Seed-Code by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "volcengine/doubao-seed-code",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-5-1",
          name: "OpenAI: GPT-5.1",
          tooltip: "OpenAI: GPT-5.1 by Zenmux",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5.1",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "x-ai-grok-4-1-fast",
          name: "xAI: Grok 4.1 Fast",
          tooltip: "xAI: Grok 4.1 Fast by Zenmux",
          maxInputTokens: 1984e3,
          maxOutputTokens: 16e3,
          model: "x-ai/grok-4.1-fast",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "x-ai-grok-4-1-fast-non-reasoning",
          name: "xAI: Grok 4.1 Fast Non Reasoning",
          tooltip: "xAI: Grok 4.1 Fast Non Reasoning by Zenmux",
          maxInputTokens: 1984e3,
          maxOutputTokens: 16e3,
          model: "x-ai/grok-4.1-fast-non-reasoning",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "google-gemini-3-pro-preview",
          name: "Google: Gemini 3 Pro Preview",
          tooltip: "Google: Gemini 3 Pro Preview by Zenmux",
          maxInputTokens: 1032576,
          maxOutputTokens: 16e3,
          model: "google/gemini-3-pro-preview",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "volcengine-doubao-seed-1-6-vision",
          name: "VolcanoEngine: Doubao-Seed-1.6-vision",
          tooltip: "VolcanoEngine: Doubao-Seed-1.6-vision by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "volcengine/doubao-seed-1-6-vision",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "google-gemma-3-12b-it",
          name: "Google: Gemma 3 12B",
          tooltip: "Google: Gemma 3 12B by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "google/gemma-3-12b-it",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "anthropic-claude-opus-4-5",
          name: "Anthropic: Claude Opus 4.5",
          tooltip: "Anthropic: Claude Opus 4.5 by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-opus-4.5",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "deepseek-deepseek-v3-2-exp",
          name: "DeepSeek: DeepSeek-V3.2-Exp",
          tooltip: "DeepSeek: DeepSeek-V3.2-Exp by Zenmux",
          maxInputTokens: 147840,
          maxOutputTokens: 16e3,
          model: "deepseek/deepseek-v3.2-exp",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "meta-llama-3-3-70b-instruct",
          name: "Meta: Llama 3.3 70B Instruct",
          tooltip: "Meta: Llama 3.3 70B Instruct by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "meta/llama-3.3-70b-instruct",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "mistralai-mistral-large-2512",
          name: "Mistral: Mistral Large 3",
          tooltip: "Mistral: Mistral Large 3 by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "mistralai/mistral-large-2512",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "meta-llama-4-scout-17b-16e-instruct",
          name: "Meta: Llama 4 Scout Instruct",
          tooltip: "Meta: Llama 4 Scout Instruct by Zenmux",
          maxInputTokens: 115072,
          maxOutputTokens: 16e3,
          model: "meta/llama-4-scout-17b-16e-instruct",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "baidu-ernie-x1-1-preview",
          name: "Baidu: ERNIE-X1.1-Preview",
          tooltip: "Baidu: ERNIE-X1.1-Preview by Zenmux",
          maxInputTokens: 49536,
          maxOutputTokens: 16e3,
          model: "baidu/ernie-x1.1-preview",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "z-ai-glm-4-6v-flash",
          name: "Z.AI: GLM 4.6V FlashX",
          tooltip: "Z.AI: GLM 4.6V FlashX by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "z-ai/glm-4.6v-flash",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "z-ai-glm-4-6v",
          name: "Z.AI: GLM 4.6V",
          tooltip: "Z.AI: GLM 4.6V by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "z-ai/glm-4.6v",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "deepseek-deepseek-v3-2",
          name: "DeepSeek: DeepSeek V3.2",
          tooltip: "DeepSeek: DeepSeek V3.2 by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "deepseek/deepseek-v3.2",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "openai-gpt-5-2-pro",
          name: "OpenAI: GPT-5.2 Pro",
          tooltip: "OpenAI: GPT-5.2 Pro by Zenmux",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5.2-pro",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-5-2",
          name: "OpenAI: GPT-5.2",
          tooltip: "OpenAI: GPT-5.2 by Zenmux",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5.2",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "openai-gpt-5-2-chat",
          name: "OpenAI: GPT-5.2 Chat",
          tooltip: "OpenAI: GPT-5.2 Chat by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5.2-chat",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "google-gemini-3-flash-preview",
          name: "Google: Gemini 3 Flash Preview",
          tooltip: "Google: Gemini 3 Flash Preview by Zenmux",
          maxInputTokens: 1032576,
          maxOutputTokens: 16e3,
          model: "google/gemini-3-flash-preview",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "stepfun-step-3",
          name: "StepFun: Step-3",
          tooltip: "StepFun: Step-3 by Zenmux",
          maxInputTokens: 49536,
          maxOutputTokens: 16e3,
          model: "stepfun/step-3",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "inclusionai-llada2-0-flash-cap",
          name: "inclusionAI: LLaDA2-flash-CAP",
          tooltip: "inclusionAI: LLaDA2-flash-CAP by Zenmux",
          maxInputTokens: 16e3,
          maxOutputTokens: 16e3,
          model: "inclusionai/llada2.0-flash-cap",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "openai-gpt-5-2-codex",
          name: "OpenAI: GPT-5.2-Codex",
          tooltip: "OpenAI: GPT-5.2-Codex by Zenmux",
          maxInputTokens: 384e3,
          maxOutputTokens: 16e3,
          model: "openai/gpt-5.2-codex",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "xiaomi-mimo-v2-flash",
          name: "Xiaomi: MiMo-V2-Flash",
          tooltip: "Xiaomi: MiMo-V2-Flash by Zenmux",
          maxInputTokens: 246144,
          maxOutputTokens: 16e3,
          model: "xiaomi/mimo-v2-flash",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "volcengine-doubao-seed-1-8",
          name: "VolcanoEngine: Doubao-Seed-1.8",
          tooltip: "VolcanoEngine: Doubao-Seed-1.8 by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "volcengine/doubao-seed-1.8",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "minimax-minimax-m2-1",
          name: "MiniMax: MiniMax M2.1",
          tooltip: "MiniMax: MiniMax M2.1 by Zenmux",
          maxInputTokens: 188800,
          maxOutputTokens: 16e3,
          model: "minimax/minimax-m2.1",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "z-ai-glm-4-7",
          name: "Z.AI: GLM 4.7",
          tooltip: "Z.AI: GLM 4.7 by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "z-ai/glm-4.7",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "z-ai-glm-4-7-flash-free",
          name: "Z.AI: GLM 4.7 Flash (Free)",
          tooltip: "Z.AI: GLM 4.7 Flash (Free) by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "z-ai/glm-4.7-flash-free",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "z-ai-glm-4-7-flashx",
          name: "Z.AI: GLM 4.7 FlashX",
          tooltip: "Z.AI: GLM 4.7 FlashX by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "z-ai/glm-4.7-flashx",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "minimax-minimax-m2-her",
          name: "MiniMax: MiniMax M2-her",
          tooltip: "MiniMax: MiniMax M2-her by Zenmux",
          maxInputTokens: 48e3,
          maxOutputTokens: 16e3,
          model: "minimax/minimax-m2-her",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "moonshotai-kimi-k2-5",
          name: "MoonshotAI: Kimi K2.5",
          tooltip: "MoonshotAI: Kimi K2.5 by Zenmux",
          maxInputTokens: 246144,
          maxOutputTokens: 16e3,
          model: "moonshotai/kimi-k2.5",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "anthropic-claude-opus-4-6",
          name: "Anthropic: Claude Opus 4.6",
          tooltip: "Anthropic: Claude Opus 4.6 by Zenmux",
          maxInputTokens: 984e3,
          maxOutputTokens: 16e3,
          model: "anthropic/claude-opus-4.6",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "tencent-hunyuan-2-0-thinking",
          name: "Tencent: HY 2.0 Think",
          tooltip: "Tencent: HY 2.0 Think by Zenmux",
          maxInputTokens: 112e3,
          maxOutputTokens: 16e3,
          model: "tencent/hunyuan-2.0-thinking",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "stepfun-step-3-5-flash-free",
          name: "StepFun: Step 3.5 Flash (Free)",
          tooltip: "StepFun: Step 3.5 Flash (Free) by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "stepfun/step-3.5-flash-free",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "stepfun-step-3-5-flash",
          name: "StepFun: Step 3.5 Flash",
          tooltip: "StepFun: Step 3.5 Flash by Zenmux",
          maxInputTokens: 24e4,
          maxOutputTokens: 16e3,
          model: "stepfun/step-3.5-flash",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "z-ai-glm-5",
          name: "Z.AI: GLM 5",
          tooltip: "Z.AI: GLM 5 by Zenmux",
          maxInputTokens: 184e3,
          maxOutputTokens: 16e3,
          model: "z-ai/glm-5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "inclusionai-ming-flash-omni-2-0",
          name: "inclusionAI: Ming-flash-omni-2.0",
          tooltip: "inclusionAI: Ming-flash-omni-2.0 by Zenmux",
          maxInputTokens: 48e3,
          maxOutputTokens: 16e3,
          model: "inclusionai/ming-flash-omni-2.0",
          capabilities: {
            toolCalling: true,
            imageInput: true
          }
        },
        {
          id: "minimax-minimax-m2-5",
          name: "MiniMax: MiniMax M2.5",
          tooltip: "MiniMax: MiniMax M2.5 by Zenmux",
          maxInputTokens: 188800,
          maxOutputTokens: 16e3,
          model: "minimax/minimax-m2.5",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "minimax-minimax-m2-5-lightning",
          name: "MiniMax: MiniMax M2.5 highspeed",
          tooltip: "MiniMax: MiniMax M2.5 highspeed by Zenmux",
          maxInputTokens: 188800,
          maxOutputTokens: 16e3,
          model: "minimax/minimax-m2.5-lightning",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        }
      ]
    };
  }
});

// src/providers/config/zhipu.json
var zhipu_default;
var init_zhipu = __esm({
  "src/providers/config/zhipu.json"() {
    zhipu_default = {
      displayName: "ZhipuAI",
      baseUrl: "https://api.z.ai/api/paas/v4",
      apiKeyTemplate: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxx",
      models: [
        {
          id: "glm-4.5",
          name: "GLM-4.5",
          tooltip: "glm-4.5 by ZhipuAI",
          maxInputTokens: 1e5,
          maxOutputTokens: 28e3,
          model: "glm-4.5",
          sdkMode: "openai",
          baseUrl: "https://api.z.ai/api/paas/v4",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "glm-4.5-air",
          name: "GLM-4.5-Air",
          tooltip: "glm-4.5-air by ZhipuAI",
          maxInputTokens: 1e5,
          maxOutputTokens: 28e3,
          model: "glm-4.5-air",
          sdkMode: "openai",
          baseUrl: "https://api.z.ai/api/paas/v4",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "glm-4.6",
          name: "GLM-4.6",
          tooltip: "glm-4.6 by ZhipuAI",
          maxInputTokens: 186e3,
          maxOutputTokens: 16752,
          model: "glm-4.6",
          sdkMode: "openai",
          baseUrl: "https://api.z.ai/api/paas/v4",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "glm-4.7",
          name: "GLM-4.7",
          tooltip: "glm-4.7 by ZhipuAI",
          maxInputTokens: 186e3,
          maxOutputTokens: 16752,
          model: "glm-4.7",
          sdkMode: "openai",
          baseUrl: "https://api.z.ai/api/paas/v4",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "glm-5",
          name: "GLM-5 (Latest)",
          tooltip: "glm-5 by ZhipuAI",
          maxInputTokens: 186e3,
          maxOutputTokens: 16752,
          model: "glm-5",
          sdkMode: "openai",
          baseUrl: "https://api.z.ai/api/paas/v4",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "glm-4.7-flash",
          name: "GLM-4.7-Flash (Free, 1 Concurrent)",
          tooltip: "glm-4.7-flash by ZhipuAI",
          maxInputTokens: 186e3,
          maxOutputTokens: 16752,
          model: "glm-4.7-flash",
          sdkMode: "openai",
          baseUrl: "https://api.z.ai/api/paas/v4",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        },
        {
          id: "glm-4.7-flashx",
          name: "GLM-4.7-FlashX (Paid)",
          tooltip: "glm-4.7-flashx by ZhipuAI",
          maxInputTokens: 186e3,
          maxOutputTokens: 16752,
          model: "glm-4.7-flashx",
          sdkMode: "openai",
          baseUrl: "https://api.z.ai/api/paas/v4",
          capabilities: {
            toolCalling: true,
            imageInput: false
          }
        }
      ]
    };
  }
});

// src/providers/config/index.ts
var config_exports = {};
__export(config_exports, {
  configProviders: () => configProviders
});
var providers, configProviders;
var init_config = __esm({
  "src/providers/config/index.ts"() {
    "use strict";
    init_antigravity();
    init_chutes();
    init_codex();
    init_deepinfra();
    init_deepseek();
    init_geminicli();
    init_huggingface();
    init_lightningai();
    init_minimax();
    init_mistral();
    init_moonshot();
    init_opencode();
    init_ollama();
    init_qwencli();
    init_zenmux();
    init_zhipu();
    providers = {
      zhipu: zhipu_default,
      minimax: minimax_default,
      moonshot: moonshot_default,
      deepseek: deepseek_default,
      codex: codex_default,
      antigravity: antigravity_default,
      chutes: chutes_default,
      opencode: opencode_default,
      ollama: ollama_default,
      qwencli: qwencli_default,
      geminicli: geminicli_default,
      huggingface: huggingface_default,
      lightningai: lightningai_default,
      deepinfra: deepinfra_default,
      mistral: mistral_default,
      zenmux: zenmux_default
    };
    configProviders = providers;
  }
});

// src/utils/apiKeyManager.ts
var apiKeyManager_exports = {};
__export(apiKeyManager_exports, {
  ApiKeyManager: () => ApiKeyManager
});
var vscode4, ApiKeyManager;
var init_apiKeyManager = __esm({
  "src/utils/apiKeyManager.ts"() {
    "use strict";
    vscode4 = __toESM(require("vscode"));
    init_logger();
    ApiKeyManager = class _ApiKeyManager {
      static context;
      static builtinProviders = null;
      /**
       * Initialize API key manager
       */
      static initialize(context) {
        _ApiKeyManager.context = context;
      }
      /**
       * Get built-in provider list
       */
      static async getBuiltinProviders() {
        if (_ApiKeyManager.builtinProviders !== null) {
          return _ApiKeyManager.builtinProviders;
        }
        try {
          const { configProviders: configProviders2 } = await Promise.resolve().then(() => (init_config(), config_exports));
          _ApiKeyManager.builtinProviders = new Set(Object.keys(configProviders2));
        } catch (error2) {
          Logger.warn("Failed to get built-in provider list:", error2);
          _ApiKeyManager.builtinProviders = /* @__PURE__ */ new Set();
        }
        return _ApiKeyManager.builtinProviders;
      }
      /**
       * Get provider's key storage key name
       * For built-in providers, use their original key name
       * For custom providers, use provider as key name
       */
      static getSecretKey(vendor) {
        return `${vendor}.apiKey`;
      }
      /**
       * Check if API key exists
       */
      static async hasValidApiKey(vendor) {
        const secretKey = _ApiKeyManager.getSecretKey(vendor);
        const apiKey = await _ApiKeyManager.context.secrets.get(secretKey);
        return apiKey !== void 0 && apiKey.trim().length > 0;
      }
      /**
       * Get API key
       * Built-in providers: directly use provider name as key name
       * Custom providers: use provider as key name
       */
      static async getApiKey(vendor) {
        const secretKey = _ApiKeyManager.getSecretKey(vendor);
        return await _ApiKeyManager.context.secrets.get(secretKey);
      }
      /**
       * Validate API key
       */
      static validateApiKey(apiKey, _vendor) {
        if (!apiKey || apiKey.trim().length === 0) {
          return { isValid: true, isEmpty: true };
        }
        return { isValid: true };
      }
      /**
       * Set API key to secure storage
       */
      static async setApiKey(vendor, apiKey) {
        const secretKey = _ApiKeyManager.getSecretKey(vendor);
        await _ApiKeyManager.context.secrets.store(secretKey, apiKey);
      }
      /**
       * Delete API key
       */
      static async deleteApiKey(vendor) {
        const secretKey = _ApiKeyManager.getSecretKey(vendor);
        await _ApiKeyManager.context.secrets.delete(secretKey);
      }
      /**
       * Ensure API key exists, prompt user to input if missing
       * @param vendor Provider identifier
       * @param displayName Display name
       * @param throwError Whether to throw error when check fails, default true
       * @returns Whether check succeeded
       */
      static async ensureApiKey(vendor, displayName, throwError = true) {
        if (await _ApiKeyManager.hasValidApiKey(vendor)) {
          return true;
        }
        const builtinProviders = await _ApiKeyManager.getBuiltinProviders();
        if (builtinProviders.has(vendor)) {
          const commandId = `chp.${vendor}.setApiKey`;
          await vscode4.commands.executeCommand(commandId);
        } else {
          await _ApiKeyManager.promptAndSetApiKey(
            vendor,
            vendor,
            "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
          );
        }
        const isValid = await _ApiKeyManager.hasValidApiKey(vendor);
        if (!isValid && throwError) {
          throw new Error(`API key required to use ${displayName} model`);
        }
        return isValid;
      }
      /**
       * Handle API key replacement in customHeader
       * Replace ${APIKEY} with actual API key (case insensitive)
       */
      static processCustomHeader(customHeader, apiKey) {
        if (!customHeader) {
          return {};
        }
        const processedHeader = {};
        for (const [key, value] of Object.entries(customHeader)) {
          const processedValue = value.replace(/\$\{\s*APIKEY\s*\}/gi, apiKey);
          processedHeader[key] = processedValue;
        }
        return processedHeader;
      }
      /**
       * Universal API key input and setup logic
       */
      static async promptAndSetApiKey(vendor, displayName, placeHolder) {
        const apiKey = await vscode4.window.showInputBox({
          prompt: `Please enter your ${displayName} API key (leave empty to clear key)`,
          password: true,
          placeHolder
        });
        if (apiKey !== void 0) {
          const validation = _ApiKeyManager.validateApiKey(apiKey, vendor);
          if (validation.isEmpty) {
            await _ApiKeyManager.deleteApiKey(vendor);
            vscode4.window.showInformationMessage(`${displayName} API key cleared`);
          } else {
            await _ApiKeyManager.setApiKey(vendor, apiKey.trim());
            vscode4.window.showInformationMessage(`${displayName} API key set`);
          }
          Logger.debug(`API key updated: ${vendor}`);
        }
      }
    };
  }
});

// src/utils/configManager.ts
var vscode5, ConfigManager;
var init_configManager = __esm({
  "src/utils/configManager.ts"() {
    "use strict";
    vscode5 = __toESM(require("vscode"));
    init_config();
    init_logger();
    ConfigManager = class _ConfigManager {
      static CONFIG_SECTION = "chp";
      static cache = null;
      static configListener = null;
      /**
       * Initialize configuration manager
       * Set up configuration change listener
       */
      static initialize() {
        if (_ConfigManager.configListener) {
          _ConfigManager.configListener.dispose();
        }
        _ConfigManager.configListener = vscode5.workspace.onDidChangeConfiguration(
          (event) => {
            if (event.affectsConfiguration(_ConfigManager.CONFIG_SECTION)) {
              _ConfigManager.cache = null;
              Logger.info("Copilot ++ updated, cache cleared");
            }
          }
        );
        Logger.debug("Configuration manager initialized");
        return _ConfigManager.configListener;
      }
      /**
       * Get current configuration
       * Use caching mechanism to improve performance
       */
      static getConfig() {
        if (_ConfigManager.cache) {
          return _ConfigManager.cache;
        }
        const config2 = vscode5.workspace.getConfiguration(
          _ConfigManager.CONFIG_SECTION
        );
        const providerOverrides = _ConfigManager.buildProviderOverrides(config2);
        _ConfigManager.cache = {
          temperature: _ConfigManager.validateTemperature(
            config2.get("temperature", 0.1)
          ),
          topP: _ConfigManager.validateTopP(config2.get("topP", 1)),
          maxTokens: _ConfigManager.validateMaxTokens(
            config2.get("maxTokens", 256e3)
          ),
          rememberLastModel: config2.get("rememberLastModel", true),
          zhipu: {
            search: {
              enableMCP: config2.get("zhipu.search.enableMCP", true)
              // Default enable MCP mode (Coding Plan exclusive)
            },
            endpoint: config2.get(
              "zhipu.endpoint",
              "open.bigmodel.cn"
            ),
            plan: config2.get(
              "zhipu.plan",
              "coding"
            ),
            thinking: config2.get(
              "zhipu.thinking",
              "auto"
            ),
            clearThinking: config2.get(
              "zhipu.clearThinking",
              true
            )
          },
          minimax: {
            endpoint: config2.get(
              "minimax.endpoint",
              "minimaxi.com"
            )
          },
          fimCompletion: {
            enabled: config2.get("fimCompletion.enabled", false),
            debounceMs: _ConfigManager.validateNESDebounceMs(
              config2.get("fimCompletion.debounceMs", 500)
            ),
            timeoutMs: _ConfigManager.validateNESTimeoutMs(
              config2.get("fimCompletion.timeoutMs", 5e3)
            ),
            modelConfig: {
              provider: config2.get(
                "fimCompletion.modelConfig.provider",
                ""
              ),
              baseUrl: config2.get("fimCompletion.modelConfig.baseUrl", ""),
              model: config2.get("fimCompletion.modelConfig.model", ""),
              maxTokens: _ConfigManager.validateNESMaxTokens(
                config2.get("fimCompletion.modelConfig.maxTokens", 200)
              ),
              extraBody: config2.get("fimCompletion.modelConfig.extraBody")
            }
          },
          nesCompletion: {
            enabled: config2.get("nesCompletion.enabled", false),
            debounceMs: _ConfigManager.validateNESDebounceMs(
              config2.get("nesCompletion.debounceMs", 500)
            ),
            timeoutMs: _ConfigManager.validateNESTimeoutMs(
              config2.get("nesCompletion.timeoutMs", 5e3)
            ),
            manualOnly: config2.get("nesCompletion.manualOnly", false),
            modelConfig: {
              provider: config2.get(
                "nesCompletion.modelConfig.provider",
                ""
              ),
              baseUrl: config2.get("nesCompletion.modelConfig.baseUrl", ""),
              model: config2.get("nesCompletion.modelConfig.model", ""),
              maxTokens: _ConfigManager.validateNESMaxTokens(
                config2.get("nesCompletion.modelConfig.maxTokens", 200)
              ),
              extraBody: config2.get("nesCompletion.modelConfig.extraBody")
            }
          },
          providerOverrides
        };
        Logger.debug("Configuration loaded", _ConfigManager.cache);
        return _ConfigManager.cache;
      }
      /**
       * Get temperature parameter
       */
      static getTemperature() {
        return _ConfigManager.getConfig().temperature;
      }
      /**
       * Get Top-p parameter
       */
      static getTopP() {
        return _ConfigManager.getConfig().topP;
      }
      /**
       * Get maximum token count
       */
      static getMaxTokens() {
        return _ConfigManager.getConfig().maxTokens;
      }
      /**
       * Get whether to remember last selected model
       */
      static getRememberLastModel() {
        return _ConfigManager.getConfig().rememberLastModel;
      }
      /**
       * Get ZhipuAI search configuration
       */
      static getZhipuSearchConfig() {
        return _ConfigManager.getConfig().zhipu.search;
      }
      /**
       * Get ZhipuAI unified configuration
       */
      static getZhipuConfig() {
        return _ConfigManager.getConfig().zhipu;
      }
      /**
       * Get ZhipuAI access point configuration
       * @returns 'open.bigmodel.cn' or 'api.z.ai', default 'open.bigmodel.cn'
       */
      static getZhipuEndpoint() {
        return _ConfigManager.getConfig().zhipu.endpoint;
      }
      /**
       * Get ZhipuAI plan type configuration
       * @returns 'coding' or 'normal', default 'coding'
       */
      static getZhipuPlan() {
        return _ConfigManager.getConfig().zhipu.plan;
      }
      /**
       * Get ZhipuAI thinking mode configuration
       * @returns 'enabled', 'disabled', or 'auto', default 'auto'
       */
      static getZhipuThinking() {
        return _ConfigManager.getConfig().zhipu.thinking;
      }
      /**
       * Get ZhipuAI clear thinking configuration
       * @returns true to show thinking in response, false to hide, default true
       */
      static getZhipuClearThinking() {
        return _ConfigManager.getConfig().zhipu.clearThinking;
      }
      /**
       * Get MiniMax Coding Plan access point configuration
       * @returns 'minimaxi.com' or 'minimax.io', default 'minimaxi.com'
       */
      static getMinimaxEndpoint() {
        return _ConfigManager.getConfig().minimax.endpoint;
      }
      /**
       * Get FIM completion configuration
       */
      static getFIMConfig() {
        return _ConfigManager.getConfig().fimCompletion;
      }
      /**
       * Get NES completion configuration
       */
      static getNESConfig() {
        return _ConfigManager.getConfig().nesCompletion;
      }
      /**
       * Get maximum token count suitable for model
       * Consider model limits and user configuration
       */
      static getMaxTokensForModel(modelMaxTokens) {
        const configMaxTokens = _ConfigManager.getMaxTokens();
        return Math.min(modelMaxTokens, configMaxTokens);
      }
      /**
       * Validate temperature parameter
       */
      static validateTemperature(value) {
        if (Number.isNaN(value) || value < 0 || value > 2) {
          Logger.warn(
            `Invalid temperature value: ${value}, using default value 0.1`
          );
          return 0.1;
        }
        return value;
      }
      /**
       * Validate Top-p parameter
       */
      static validateTopP(value) {
        if (Number.isNaN(value) || value < 0 || value > 1) {
          Logger.warn(`Invalid topP value: ${value}, using default value 1.0`);
          return 1;
        }
        return value;
      }
      /**
       * Validate maximum token count
       */
      static validateMaxTokens(value) {
        if (Number.isNaN(value) || value < 32 || value > 256e3) {
          Logger.warn(
            `Invalid maxTokens value: ${value}, using default value 8192`
          );
          return 8192;
        }
        return Math.floor(value);
      }
      /**
       * Validate debounce delay time
       */
      static validateNESDebounceMs(value) {
        if (Number.isNaN(value) || value < 50 || value > 2e3) {
          Logger.warn(
            `Invalid debounceMs value: ${value}, using default value 500`
          );
          return 500;
        }
        return Math.floor(value);
      }
      /**
       * Validate timeout time
       */
      static validateNESTimeoutMs(value) {
        if (Number.isNaN(value) || value < 1e3 || value > 3e4) {
          Logger.warn(
            `Invalid timeoutMs value: ${value}, using default value 5000`
          );
          return 5e3;
        }
        return Math.floor(value);
      }
      /**
       * Validate NES completion's maxTokens parameter
       */
      static validateNESMaxTokens(value) {
        if (Number.isNaN(value) || value < 50 || value > 16e3) {
          Logger.warn(
            `Invalid NES maxTokens value: ${value}, using default value 200`
          );
          return 200;
        }
        return Math.floor(value);
      }
      /**
       * Get provider configuration (new mode: directly import configProviders)
       */
      static getConfigProvider() {
        return configProviders;
      }
      /**
       * Get configuration override settings
       */
      static getProviderOverrides() {
        return _ConfigManager.getConfig().providerOverrides;
      }
      /**
       * Build provider overrides by merging baseUrl settings and providerOverrides config
       */
      static buildProviderOverrides(config2) {
        const configuredOverrides = config2.get(
          "providerOverrides",
          {}
        );
        const baseUrlOverrides = {};
        for (const providerKey of Object.keys(configProviders)) {
          const baseUrl = config2.get(`${providerKey}.baseUrl`, "").trim();
          if (baseUrl) {
            baseUrlOverrides[providerKey] = { baseUrl };
          }
        }
        const merged = { ...baseUrlOverrides };
        for (const [key, override] of Object.entries(configuredOverrides)) {
          const current = merged[key] ? { ...merged[key] } : {};
          const normalizedBaseUrl = override.baseUrl?.trim();
          const nextOverride = {
            ...current,
            ...override
          };
          if (!normalizedBaseUrl && current.baseUrl) {
            nextOverride.baseUrl = current.baseUrl;
          }
          merged[key] = nextOverride;
        }
        return merged;
      }
      /**
       * Apply configuration override to original provider configuration
       */
      static applyProviderOverrides(providerKey, originalConfig) {
        const overrides = _ConfigManager.getProviderOverrides();
        const override = overrides[providerKey];
        if (!override) {
          return originalConfig;
        }
        Logger.info(`Applying provider ${providerKey} configuration override`);
        const config2 = JSON.parse(JSON.stringify(originalConfig));
        if (override.baseUrl) {
          config2.baseUrl = override.baseUrl;
          Logger.debug(`  Override baseUrl: ${override.baseUrl}`);
          for (const model of config2.models) {
            model.baseUrl = override.baseUrl;
          }
        }
        if (override.customHeader) {
          for (const model of config2.models) {
            model.customHeader = {
              ...override.customHeader,
              ...model.customHeader
            };
          }
        }
        if (override.models && override.models.length > 0) {
          for (const modelOverride of override.models) {
            const existingModelIndex = config2.models.findIndex(
              (m) => m.id === modelOverride.id
            );
            if (existingModelIndex >= 0) {
              const existingModel = config2.models[existingModelIndex];
              if (modelOverride.model !== void 0) {
                existingModel.model = modelOverride.model;
                Logger.debug(
                  `  Model ${modelOverride.id}: Override model = ${modelOverride.model}`
                );
              }
              if (modelOverride.maxInputTokens !== void 0) {
                existingModel.maxInputTokens = modelOverride.maxInputTokens;
                Logger.debug(
                  `  Model ${modelOverride.id}: Override maxInputTokens = ${modelOverride.maxInputTokens}`
                );
              }
              if (modelOverride.maxOutputTokens !== void 0) {
                existingModel.maxOutputTokens = modelOverride.maxOutputTokens;
                Logger.debug(
                  `  Model ${modelOverride.id}: Override maxOutputTokens = ${modelOverride.maxOutputTokens}`
                );
              }
              if (modelOverride.sdkMode !== void 0) {
                existingModel.sdkMode = modelOverride.sdkMode;
                Logger.debug(
                  `  Model ${modelOverride.id}: Override sdkMode = ${modelOverride.sdkMode}`
                );
              }
              if (modelOverride.baseUrl !== void 0) {
                existingModel.baseUrl = modelOverride.baseUrl;
                Logger.debug(
                  `  Model ${modelOverride.id}: Override baseUrl = ${modelOverride.baseUrl}`
                );
              }
              if (modelOverride.capabilities) {
                existingModel.capabilities = {
                  ...existingModel.capabilities,
                  ...modelOverride.capabilities
                };
                Logger.debug(
                  `  Model ${modelOverride.id}: Merge capabilities = ${JSON.stringify(existingModel.capabilities)}`
                );
              }
              if (modelOverride.customHeader) {
                existingModel.customHeader = {
                  ...existingModel.customHeader,
                  ...modelOverride.customHeader
                };
                Logger.debug(
                  `  Model ${modelOverride.id}: Merge customHeader = ${JSON.stringify(existingModel.customHeader)}`
                );
              }
              if (modelOverride.extraBody) {
                existingModel.extraBody = {
                  ...existingModel.extraBody,
                  ...modelOverride.extraBody
                };
                Logger.debug(
                  `  Model ${modelOverride.id}: Merge extraBody = ${JSON.stringify(existingModel.extraBody)}`
                );
              }
              if (modelOverride.outputThinking !== void 0) {
                existingModel.outputThinking = modelOverride.outputThinking;
                Logger.debug(
                  `  Model ${modelOverride.id}: Override outputThinking = ${modelOverride.outputThinking}`
                );
              }
            } else {
              const fullConfig = modelOverride;
              const newModel = {
                id: modelOverride.id,
                name: fullConfig?.name || modelOverride.id,
                // Default use ID as name
                tooltip: fullConfig?.tooltip || `User custom model: ${modelOverride.id}`,
                maxInputTokens: modelOverride.maxInputTokens || 128e3,
                maxOutputTokens: modelOverride.maxOutputTokens || 8192,
                capabilities: {
                  toolCalling: modelOverride.capabilities?.toolCalling ?? false,
                  imageInput: modelOverride.capabilities?.imageInput ?? false
                },
                ...modelOverride.model && { model: modelOverride.model },
                ...modelOverride.sdkMode && { sdkMode: modelOverride.sdkMode },
                ...modelOverride.baseUrl && { baseUrl: modelOverride.baseUrl },
                ...override.baseUrl && !modelOverride.baseUrl && {
                  baseUrl: override.baseUrl
                },
                ...modelOverride.customHeader && {
                  customHeader: modelOverride.customHeader
                },
                ...override.customHeader && !modelOverride.customHeader && {
                  customHeader: override.customHeader
                },
                ...modelOverride.extraBody && {
                  extraBody: modelOverride.extraBody
                },
                ...modelOverride.outputThinking !== void 0 && {
                  outputThinking: modelOverride.outputThinking
                }
              };
              config2.models.push(newModel);
              Logger.info(`  Add new model: ${modelOverride.id}`);
            }
          }
        }
        if (override.customHeader) {
          for (const model of config2.models) {
            if (model.customHeader) {
              model.customHeader = {
                ...override.customHeader,
                ...model.customHeader
              };
            } else {
              model.customHeader = { ...override.customHeader };
            }
          }
          Logger.debug(
            `  Provider ${providerKey}: Merge provider level customHeader into all models`
          );
        }
        return config2;
      }
      /**
       * Clean up resources
       */
      static dispose() {
        if (_ConfigManager.configListener) {
          _ConfigManager.configListener.dispose();
          _ConfigManager.configListener = null;
        }
        _ConfigManager.cache = null;
        Logger.trace("Configuration manager disposed");
      }
    };
  }
});

// src/utils/knownProviders.ts
var KnownProviders;
var init_knownProviders = __esm({
  "src/utils/knownProviders.ts"() {
    "use strict";
    KnownProviders = {
      aihubmix: {
        displayName: "AIHubMix",
        customHeader: { "APP-Code": "TFUV4759" },
        openai: {
          baseUrl: "https://aihubmix.com/v1"
        },
        anthropic: {
          baseUrl: "https://aihubmix.com",
          extraBody: {
            top_p: null
          }
        }
      },
      aiping: { displayName: "AIPing" },
      codex: { displayName: "Codex" },
      modelscope: { displayName: "ModelScope" },
      openrouter: { displayName: "OpenRouter" },
      siliconflow: { displayName: "SiliconFlow" },
      tbox: { displayName: "Bailian" },
      chutes: { displayName: "Chutes" },
      opencode: { displayName: "OpenCode" },
      huggingface: { displayName: "Hugging Face" },
      lightningai: {
        displayName: "Lightning AI",
        openai: {
          baseUrl: "https://lightning.ai/api/v1"
        }
      },
      zenmux: {
        displayName: "Zenmux",
        openai: {
          baseUrl: "https://zenmux.ai/api/v1"
        }
      },
      deepinfra: {
        displayName: "DeepInfra",
        openai: {
          baseUrl: "https://api.deepinfra.com/v1/openai"
        }
      },
      mistral: {
        displayName: "Mistral AI",
        openai: {
          baseUrl: "https://api.mistral.ai/v1"
        }
      },
      qwencli: { displayName: "Qwen Code CLI" }
    };
  }
});

// raw-file:./modelEditor.css
var modelEditor_default;
var init_modelEditor = __esm({
  "raw-file:./modelEditor.css"() {
    modelEditor_default = 'body {\n	font-family: var(--vscode-font-family);\n	font-size: var(--vscode-font-size);\n	color: var(--vscode-foreground);\n	background-color: var(--vscode-editor-background);\n	padding: 15px 15px 60px 15px;\n	line-height: 1.4;\n	margin: 0;\n}\n\n.container {\n	max-width: 680px;\n	margin: 20px auto 80px;\n}\n\n.form-group {\n	margin-bottom: 15px;\n}\n\n.form-group.no-bottom {\n	margin-bottom: 0;\n}\n\nlabel {\n	display: block;\n	margin-bottom: 3px;\n	font-weight: 500;\n	color: var(--vscode-foreground);\n	font-size: 1em;\n}\n\n.field-name {\n	font-weight: normal;\n	color: var(--vscode-descriptionForeground);\n	font-size: 1em;\n	margin-left: 4px;\n}\n\ninput,\nselect,\ntextarea {\n	width: 100%;\n	padding: 6px 8px;\n	border: 1px solid var(--vscode-input-border);\n	background-color: var(--vscode-input-background);\n	color: var(--vscode-input-foreground);\n	border-radius: 3px;\n	font-family: var(--vscode-font-family);\n	font-size: 1em;\n	box-sizing: border-box;\n}\n\ninput.invalid,\nselect.invalid,\ntextarea.invalid {\n	border-color: var(--vscode-inputValidation-errorBorder);\n}\n\ninput[list] {\n	background-color: var(--vscode-input-background);\n	color: var(--vscode-input-foreground);\n}\n\ninput:focus,\nselect:focus,\ntextarea:focus {\n	outline: none;\n	border-color: var(--vscode-focusBorder);\n}\n\ntextarea {\n	resize: none;\n	min-height: 60px;\n	font-family: monospace;\n	overflow: hidden;\n	box-sizing: border-box;\n}\n\n.checkbox-group {\n	display: flex;\n	align-items: center;\n	gap: 8px;\n	margin: 0;\n}\n\ninput[type="checkbox"] {\n	width: auto;\n	margin: 0;\n}\n\n.button-group {\n	position: fixed;\n	bottom: 0;\n	left: 0;\n	right: 0;\n	margin: 0;\n	padding: 10px 15px;\n	border-top: 1px solid var(--vscode-panel-border);\n	background-color: var(--vscode-editor-background);\n	z-index: 100;\n}\n\n.button-group-inner {\n	max-width: 650px;\n	margin: 0 auto;\n	width: 100%;\n	display: flex;\n	gap: 10px;\n	justify-content: space-between;\n}\n\nbutton {\n	padding: 8px 16px;\n	border: none;\n	border-radius: 3px;\n	cursor: pointer;\n	font-size: 1.1em;\n	min-width: 80px;\n}\n\n.primary-button {\n	background-color: var(--vscode-button-background);\n	color: var(--vscode-button-foreground);\n}\n\n.primary-button:hover {\n	background-color: var(--vscode-button-hoverBackground);\n}\n\n.secondary-button {\n	background-color: var(--vscode-button-secondaryBackground);\n	color: var(--vscode-button-secondaryForeground);\n}\n\n.secondary-button:hover {\n	background-color: var(--vscode-button-secondaryHoverBackground);\n}\n\n.delete-button {\n	background-color: var(--vscode-inputValidation-errorBackground);\n	color: var(--vscode-inputValidation-errorForeground);\n}\n\n.delete-button:hover {\n	opacity: 0.8;\n}\n\n.section {\n	margin-bottom: 15px;\n	padding: 12px;\n	border: 1px solid var(--vscode-panel-border);\n	border-radius: 4px;\n}\n\n.section h3 {\n	margin: 0 0 10px 0;\n	color: var(--vscode-foreground);\n	font-size: 1.2em;\n	font-weight: 600;\n}\n\n.help-text {\n	font-size: 1em;\n	color: var(--vscode-descriptionForeground);\n	margin-top: 2px;\n}\n\n.help-text.detailed {\n	white-space: pre-wrap;\n	word-wrap: break-word;\n}\n\n.readonly {\n	background-color: var(--vscode-inputValidation-infoBackground);\n	color: var(--vscode-inputValidation-infoForeground);\n}\n\n.json-input {\n	font-family: monospace;\n	font-size: 1em;\n	min-height: 80px;\n	padding: 8px;\n	background-color: var(--vscode-editor-background);\n	border: 2px solid var(--vscode-input-border);\n	line-height: 1.5;\n	tab-size: 2;\n	resize: none;\n	overflow: hidden;\n	box-sizing: border-box;\n}\n\n.json-input:focus {\n	border-color: var(--vscode-focusBorder);\n}\n\n.json-input.json-invalid {\n	border-color: var(--vscode-inputValidation-errorBorder);\n}\n\n.json-container {\n	position: relative;\n}\n\n.json-toolbar {\n	display: flex;\n	gap: 8px;\n	margin-bottom: 6px;\n	align-items: center;\n}\n\n.json-button {\n	padding: 4px 10px;\n	font-size: 1em;\n	border: 1px solid var(--vscode-button-border);\n	border-radius: 2px;\n	background-color: var(--vscode-button-secondaryBackground);\n	color: var(--vscode-button-secondaryForeground);\n	cursor: pointer;\n	transition: background-color 0.2s;\n}\n\n.json-button:hover {\n	background-color: var(--vscode-button-secondaryHoverBackground);\n}\n\n.json-status {\n	display: flex;\n	align-items: center;\n	gap: 6px;\n	font-size: 1em;\n	height: 16px;\n}\n\n.json-status-indicator {\n	display: inline-block;\n	width: 8px;\n	height: 8px;\n	border-radius: 50%;\n	background-color: var(--vscode-descriptionForeground);\n}\n\n.json-status-indicator.invalid {\n	background-color: var(--vscode-inputValidation-errorForeground);\n}\n\n.json-error {\n	color: var(--vscode-testing-failed-foreground);\n	font-size: 1em;\n	margin-top: 2px;\n	display: none;\n}\n\n.json-error.show {\n	display: block;\n}\n\n.provider-dropdown {\n	position: relative;\n}\n\n.provider-input {\n	position: relative;\n	z-index: 10;\n}\n\n.provider-list {\n	position: absolute;\n	top: 100%;\n	left: 0;\n	right: 0;\n	background-color: var(--vscode-input-background);\n	border: 1px solid var(--vscode-input-border);\n	border-top: none;\n	border-radius: 0 0 3px 3px;\n	max-height: 200px;\n	overflow-y: auto;\n	box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);\n	display: none;\n	z-index: 1000;\n	margin-top: -1px;\n}\n\n.provider-list.show {\n	display: block;\n}\n\n.provider-list-item {\n	padding: 6px 8px;\n	cursor: pointer;\n	color: var(--vscode-input-foreground);\n	user-select: none;\n}\n\n.provider-list-item:hover {\n	background-color: var(--vscode-list-hoverBackground);\n}\n\n.provider-list-item.selected {\n	background-color: var(--vscode-list-activeSelectionBackground);\n	color: var(--vscode-list-activeSelectionForeground);\n}\n\n/* Global error banner styles */\n.error-banner {\n	display: none;\n	position: sticky;\n	top: 0;\n	left: 0;\n	right: 0;\n	padding: 12px 16px;\n	background-color: var(--vscode-inputValidation-errorBackground);\n	color: var(--vscode-inputValidation-errorForeground);\n	border: 1px solid var(--vscode-inputValidation-errorBorder);\n	border-radius: 4px;\n	margin-bottom: 16px;\n	align-items: center;\n	justify-content: space-between;\n	gap: 12px;\n	z-index: 200;\n	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);\n	animation: slideDown 0.3s ease-out;\n}\n\n@keyframes slideDown {\n	from {\n		opacity: 0;\n		transform: translateY(-10px);\n	}\n\n	to {\n		opacity: 1;\n		transform: translateY(0);\n	}\n}\n\n.error-banner span {\n	flex: 1;\n	white-space: pre-wrap;\n	word-wrap: break-word;\n	font-size: 1em;\n	line-height: 1.5;\n}\n\n.error-banner-close {\n	background: transparent;\n	color: var(--vscode-inputValidation-errorForeground);\n	border: 1px solid var(--vscode-inputValidation-errorBorder);\n	border-radius: 3px;\n	padding: 4px 10px;\n	font-size: 1.2em;\n	cursor: pointer;\n	min-width: auto;\n	line-height: 1;\n	flex-shrink: 0;\n}\n\n.error-banner-close:hover {\n	background-color: rgba(255, 255, 255, 0.1);\n}\n';
  }
});

// raw-file:./modelEditor.js
var modelEditor_default2;
var init_modelEditor2 = __esm({
  "raw-file:./modelEditor.js"() {
    modelEditor_default2 = '\uFEFF/**\n * Model Editor - Client Script\n * Responsible for DOM creation, event binding and communication with VSCode\n */\n\n// VSCode API\nconst vscode = acquireVsCodeApi();\n\n// Type definitions\n/**\n * @typedef {Object} Provider\n * @property {string} id - Provider ID\n * @property {string} name - Provider Name\n */\n\n/**\n * @typedef {Object} ModelCapabilities\n * @property {boolean} toolCalling - Whether tool calling is supported\n * @property {boolean} imageInput - Whether image input is supported\n */\n\n/**\n * @typedef {Object} ModelData\n * @property {string} id - Model ID\n * @property {string} name - Display Name\n * @property {string} [tooltip] - Description (optional)\n * @property {string} provider - Provider identifier\n * @property {string} [baseUrl] - API base URL (optional)\n * @property {string} [model] - Request model ID (optional)\n * @property {\'openai\'|\'openai-sse\'|\'anthropic\'} sdkMode - SDK compatibility mode\n * @property {number} maxInputTokens - Maximum input tokens\n * @property {number} maxOutputTokens - Maximum output tokens\n * @property {ModelCapabilities} capabilities - Capability configuration\n * @property {boolean} outputThinking - Whether to show thinking process in chat interface (recommended for thinking models)\n * @property {boolean} includeThinking - Whether to inject thinking content into context for multi-turn conversations (required for thinking models)\n * @property {Object} [customHeader] - Custom HTTP header (optional)\n * @property {Object} [extraBody] - Extra request body parameters (optional)\n */\n\n// Global variables\n/** @type {Provider[]} */\nlet allProviders = [];\n/** @type {ModelData} */\nlet modelData = {};\n/** @type {boolean} */\nlet isCreateMode = false;\n\n/**\n * Initialize editor\n * @param {ModelData} data - Model data\n * @param {boolean} createMode - Whether it is in creation mode\n * @returns {void}\n */\nfunction _initializeEditor(data, createMode) {\n	modelData = data;\n	isCreateMode = createMode;\n\n	// Create DOM\n	createDOM();\n\n	// Bind events\n	bindEvents();\n\n	// Request providers list\n	vscode.postMessage({ command: "getProviders" });\n\n	// Initialize JSON validation\n	validateJSON_UI("customHeader");\n	validateJSON_UI("extraBody");\n}\n\n/**\n * Create DOM structure\n * @returns {void}\n */\nfunction createDOM() {\n	const container = document.getElementById("app");\n\n	// Create basic information section\n	const basicSection = createSection("Basic Information", [\n		createFormGroup(\n			"modelId",\n			`Model ID${isCreateMode ? " *" : ""}`,\n			"id",\n			"input",\n			{\n				type: "text",\n				placeholder: "Example: zhipu:glm-4.6",\n				value: modelData.id,\n				readonly: !isCreateMode,\n			},\n			isCreateMode\n				? "Unique model identifier, cannot be changed after creation"\n				: "Unique model identifier, cannot be changed, please edit config file directly if modification needed.",\n		),\n		createFormGroup(\n			"modelName",\n			"Display Name *",\n			"name",\n			"input",\n			{\n				type: "text",\n				placeholder: "Example: GLM-4.6 (Zhipu AI)",\n				value: modelData.name,\n			},\n			"Name displayed in model selector",\n		),\n		createFormGroup(\n			"modelTooltip",\n			"Description",\n			"tooltip",\n			"textarea",\n			{\n				rows: 2,\n				placeholder: "Detailed model description (optional)",\n				value: modelData.tooltip,\n			},\n			"Tooltip displayed on hover",\n		),\n		createFormGroup(\n			"requestModel",\n			"Request Model ID",\n			"model",\n			"input",\n			{\n				type: "text",\n				placeholder: "Example: gpt-4",\n				value: modelData.model,\n			},\n			"Model ID used when making requests (optional), uses Model ID (id) value if left empty",\n		),\n	]);\n\n	// Create API configuration section\n	const apiSection = createSection("API Configuration", [\n		createProviderFormGroup(),\n		createFormGroup(\n			"sdkMode",\n			"SDK Mode",\n			"sdkMode",\n			"select",\n			{\n				options: [\n					{\n						value: "openai",\n						label:\n							"OpenAI SDK (use official SDK for streaming data processing)",\n						selected: modelData.sdkMode === "openai",\n					},\n					{\n						value: "openai-sse",\n						label:\n							"OpenAI SSE (use built-in compatible parser for streaming data processing)",\n						selected: modelData.sdkMode === "openai-sse",\n					},\n					{\n						value: "anthropic",\n						label:\n							"Anthropic SDK (use official SDK for streaming data processing)",\n						selected: modelData.sdkMode === "anthropic",\n					},\n				],\n			},\n			"Compatibility mode used for model communication",\n		),\n		createFormGroup(\n			"baseUrl",\n			"BASE URL *",\n			"baseUrl",\n			"input",\n			{\n				type: "url",\n				placeholder:\n					"Example: https://api.openai.com/v1 or https://api.anthropic.com",\n				value: modelData.baseUrl,\n			},\n			"Base URL address for API requests, must start with http:// or https://\\nExample: https://api.openai.com/v1 or https://api.anthropic.com",\n		),\n	]);\n\n	// Create performance settings section\n	const perfSection = createSection("Model Performance", [\n		createFormGroup(\n			"maxInputTokens",\n			"Max Input Tokens",\n			"maxInputTokens",\n			"input",\n			{\n				type: "number",\n				min: 128,\n				value: modelData.maxInputTokens,\n			},\n			"Maximum input context limit supported by the model",\n		),\n		createFormGroup(\n			"maxOutputTokens",\n			"Max Output Tokens",\n			"maxOutputTokens",\n			"input",\n			{\n				type: "number",\n				min: 8,\n				value: modelData.maxOutputTokens,\n			},\n			"Maximum output token limit supported by the model",\n		),\n	]);\n\n	// Create capability configuration section\n	const capSection = createSection("Model Capabilities", [\n		createCheckboxFormGroup(\n			"toolCalling",\n			"Support Tool Calling",\n			"capabilities.toolCalling",\n			modelData.toolCalling,\n		),\n		createCheckboxFormGroup(\n			"imageInput",\n			"Support Image Input",\n			"capabilities.imageInput",\n			modelData.imageInput,\n		),\n	]);\n\n	// Create advanced settings section\n	const advSection = createSection("Advanced Settings", [\n		createCheckboxFormGroup(\n			"outputThinking",\n			"Show Thinking Process in Chat UI",\n			"outputThinking",\n			modelData.outputThinking,\n			"Display model\'s thinking process in chat interface. Enable this to see <thinking> tags in responses. Recommended for thinking models like Claude Sonnet/Opus 4.5.",\n		),\n		createCheckboxFormGroup(\n			"includeThinking",\n			"Inject Thinking into Multi-turn Conversations",\n			"includeThinking",\n			modelData.includeThinking,\n			"Include thinking content when sending conversation history to model. Required for thinking models to maintain context. Enable this for Claude Sonnet/Opus 4.5 thinking models.",\n		),\n		createJSONFormGroup(\n			"customHeader",\n			"Custom HTTP Header (JSON format)",\n			"customHeader",\n			modelData.customHeader,\n			\'{"Authorization": "Bearer ${APIKEY}", "X-Custom-Header": "value"}\',\n			"Optional custom HTTP header configuration. Supports ${APIKEY} placeholder to auto-replace with actual API key.",\n		),\n		createJSONFormGroup(\n			"extraBody",\n			"Extra Request Body Parameters (JSON format)",\n			"extraBody",\n			modelData.extraBody,\n			\'{"temperature": 1, "top_p": null}\',\n			"Extra request body parameters, will be merged into request body in API. If model doesn\'t support certain parameters, can set to null to remove corresponding values.",\n		),\n	]);\n\n	// Create button group\n	const buttonGroup = createButtonGroup();\n\n	// Create global error banner\n	const errorBanner = createErrorBanner();\n\n	// Add to container (error banner at the very top)\n	container.appendChild(errorBanner);\n	container.appendChild(basicSection);\n	container.appendChild(apiSection);\n	container.appendChild(perfSection);\n	container.appendChild(capSection);\n	container.appendChild(advSection);\n	container.appendChild(buttonGroup);\n}\n\n/**\n * Create section element\n * @param {string} title - Section title\n * @param {Array<HTMLElement>} formGroups - Array of form group elements\n * @returns {HTMLElement} Created section element\n */\nfunction createSection(title, formGroups) {\n	const section = document.createElement("div");\n	section.className = "section";\n\n	const h3 = document.createElement("h3");\n	h3.textContent = title;\n	section.appendChild(h3);\n\n	for (const group of formGroups) {\n		section.appendChild(group);\n	}\n\n	return section;\n}\n\n/**\n * Create form group\n * @param {string} id - ID of the form element\n * @param {string} labelText - Label display text\n * @param {string} fieldName - Field name (displayed in parentheses)\n * @param {string} elementType - Element type: \'input\', \'textarea\' or \'select\'\n * @param {Object} attrs - Element attributes object\n * @param {string} [helpText] - Help text (optional)\n * @returns {HTMLElement} Created form group element\n */\nfunction createFormGroup(\n	id,\n	labelText,\n	fieldName,\n	elementType,\n	attrs,\n	helpText,\n) {\n	const group = document.createElement("div");\n	group.className = "form-group";\n\n	const label = document.createElement("label");\n	label.htmlFor = id;\n	label.innerHTML = `${labelText} <span class="field-name">(${fieldName})</span>`;\n	group.appendChild(label);\n\n	let element;\n	if (elementType === "input") {\n		element = document.createElement("input");\n		Object.entries(attrs).forEach(([key, value]) => {\n			if (key === "readonly" && value) {\n				element.setAttribute("readonly", "");\n				element.classList.add("readonly");\n			} else if (key !== "readonly") {\n				element.setAttribute(key, value || "");\n			}\n		});\n	} else if (elementType === "textarea") {\n		element = document.createElement("textarea");\n		Object.entries(attrs).forEach(([key, value]) => {\n			if (key === "value") {\n				element.textContent = value || "";\n			} else {\n				element.setAttribute(key, value || "");\n			}\n		});\n	} else if (elementType === "select") {\n		element = document.createElement("select");\n		attrs.options.forEach((opt) => {\n			const option = document.createElement("option");\n			option.value = opt.value;\n			option.textContent = opt.label;\n			if (opt.selected) option.selected = true;\n			element.appendChild(option);\n		});\n	}\n\n	element.id = id;\n	group.appendChild(element);\n\n	if (helpText) {\n		const help = document.createElement("div");\n		help.className = "help-text detailed";\n		help.textContent = helpText;\n		group.appendChild(help);\n	}\n\n	return group;\n}\n\n/**\n * Create checkbox form group\n * @param {string} id - ID of the checkbox element\n * @param {string} labelText - Label display text\n * @param {string} fieldName - Field name (displayed in parentheses)\n * @param {boolean} checked - Whether the checkbox is checked\n * @param {string} [detailedHelp] - Detailed help text (optional)\n * @returns {HTMLElement} Created checkbox form group element\n */\nfunction createCheckboxFormGroup(\n	id,\n	labelText,\n	fieldName,\n	checked,\n	detailedHelp,\n) {\n	const group = document.createElement("div");\n	group.className = "form-group";\n\n	const checkboxGroup = document.createElement("div");\n	checkboxGroup.className = "checkbox-group";\n\n	const checkbox = document.createElement("input");\n	checkbox.type = "checkbox";\n	checkbox.id = id;\n	checkbox.checked = checked || false;\n\n	const label = document.createElement("label");\n	label.htmlFor = id;\n	label.innerHTML = `${labelText} <span class="field-name">(${fieldName})</span>`;\n\n	checkboxGroup.appendChild(checkbox);\n	checkboxGroup.appendChild(label);\n	group.appendChild(checkboxGroup);\n\n	if (detailedHelp) {\n		const help = document.createElement("div");\n		help.className = "help-text detailed";\n		help.textContent = detailedHelp;\n		group.appendChild(help);\n	} else {\n		group.classList.add("no-bottom");\n	}\n\n	return group;\n}\n\n/**\n * Create provider form group\n * @returns {HTMLElement} Created provider form group element\n */\nfunction createProviderFormGroup() {\n	const group = document.createElement("div");\n	group.className = "form-group";\n\n	const label = document.createElement("label");\n	label.htmlFor = "provider";\n	label.innerHTML = \'Provider * <span class="field-name">(provider)</span>\';\n	group.appendChild(label);\n\n	const dropdown = document.createElement("div");\n	dropdown.className = "provider-dropdown";\n\n	const input = document.createElement("input");\n	input.type = "text";\n	input.id = "provider";\n	input.className = "provider-input";\n	input.value = modelData.provider;\n	input.placeholder = "Example: zhipu";\n	input.autocomplete = "off";\n\n	const list = document.createElement("div");\n	list.className = "provider-list";\n	list.id = "providerList";\n\n	dropdown.appendChild(input);\n	dropdown.appendChild(list);\n	group.appendChild(dropdown);\n\n	const help = document.createElement("div");\n	help.className = "help-text";\n	help.textContent =\n		"Model provider identifier (can select built-in/known providers or custom input)";\n	group.appendChild(help);\n\n	return group;\n}\n\n/**\n * Create JSON form group\n * @param {string} id - ID of the form element\n * @param {string} labelText - Label display text\n * @param {string} fieldName - Field name (displayed in parentheses)\n * @param {string} value - JSON string value\n * @param {string} placeholder - Placeholder text\n * @param {string} helpText - Help text\n * @returns {HTMLElement} Created JSON form group element\n */\nfunction createJSONFormGroup(\n	id,\n	labelText,\n	fieldName,\n	value,\n	placeholder,\n	helpText,\n) {\n	const group = document.createElement("div");\n	group.className = "form-group";\n\n	const label = document.createElement("label");\n	label.htmlFor = id;\n	label.innerHTML = `${labelText} <span class="field-name">(${fieldName})</span>`;\n	group.appendChild(label);\n\n	const container = document.createElement("div");\n	container.className = "json-container";\n\n	const toolbar = document.createElement("div");\n	toolbar.className = "json-toolbar";\n\n	const formatBtn = document.createElement("button");\n	formatBtn.type = "button";\n	formatBtn.className = "json-button";\n	formatBtn.textContent = "Format";\n	formatBtn.onclick = (e) => {\n		e.preventDefault();\n		formatJSON(id);\n	};\n\n	const clearBtn = document.createElement("button");\n	clearBtn.type = "button";\n	clearBtn.className = "json-button";\n	clearBtn.textContent = "Clear";\n	clearBtn.onclick = (e) => {\n		e.preventDefault();\n		clearJSON(id);\n	};\n\n	const status = document.createElement("div");\n	status.className = "json-status";\n	status.id = `${id}Status`;\n\n	const indicator = document.createElement("span");\n	indicator.className = "json-status-indicator";\n\n	const statusText = document.createElement("span");\n	statusText.id = `${id}StatusText`;\n	statusText.textContent = "No content";\n\n	status.appendChild(indicator);\n	status.appendChild(statusText);\n\n	toolbar.appendChild(formatBtn);\n	toolbar.appendChild(clearBtn);\n	toolbar.appendChild(status);\n	container.appendChild(toolbar);\n\n	const textarea = document.createElement("textarea");\n	textarea.id = id;\n	textarea.className = "json-input";\n	textarea.placeholder = placeholder;\n	textarea.value = value || "";\n\n	container.appendChild(textarea);\n\n	const error = document.createElement("div");\n	error.className = "json-error";\n	error.id = `${id}Error`;\n	container.appendChild(error);\n\n	group.appendChild(container);\n\n	const help = document.createElement("div");\n	help.className = "help-text detailed";\n	help.textContent = helpText;\n	group.appendChild(help);\n\n	return group;\n}\n\n/**\n * Create global error notification area\n * @returns {HTMLElement} Created error notification element\n */\nfunction createErrorBanner() {\n	const banner = document.createElement("div");\n	banner.id = "globalErrorBanner";\n	banner.className = "error-banner";\n	banner.style.display = "none";\n\n	const messageSpan = document.createElement("span");\n	messageSpan.id = "globalErrorMessage";\n\n	const closeBtn = document.createElement("button");\n	closeBtn.className = "error-banner-close";\n	closeBtn.textContent = "\xD7";\n	closeBtn.onclick = hideGlobalError;\n\n	banner.appendChild(messageSpan);\n	banner.appendChild(closeBtn);\n\n	return banner;\n}\n\n/**\n * Create button group\n * @returns {HTMLElement} Created button group element\n */\nfunction createButtonGroup() {\n	const group = document.createElement("div");\n	group.className = "button-group";\n\n	// Create internal container for center alignment\n	const inner = document.createElement("div");\n	inner.className = "button-group-inner";\n\n	// Left buttons container (Delete button)\n	const leftButtons = document.createElement("div");\n	leftButtons.style.display = "flex";\n	leftButtons.style.gap = "10px";\n\n	// Right buttons container (Save and Cancel buttons)\n	const rightButtons = document.createElement("div");\n	rightButtons.style.display = "flex";\n	rightButtons.style.gap = "10px";\n\n	// If in edit mode, add delete button to the left\n	if (!isCreateMode) {\n		const deleteBtn = document.createElement("button");\n		deleteBtn.className = "delete-button";\n		deleteBtn.textContent = "Delete";\n		deleteBtn.onclick = deleteModel;\n		leftButtons.appendChild(deleteBtn);\n	}\n\n	const saveBtn = document.createElement("button");\n	saveBtn.className = "primary-button";\n	saveBtn.textContent = isCreateMode ? "Create" : "Update";\n	saveBtn.onclick = saveModel;\n\n	const cancelBtn = document.createElement("button");\n	cancelBtn.className = "secondary-button";\n	cancelBtn.textContent = "Cancel";\n	cancelBtn.onclick = cancelEdit;\n\n	rightButtons.appendChild(saveBtn);\n	rightButtons.appendChild(cancelBtn);\n\n	inner.appendChild(leftButtons);\n	inner.appendChild(rightButtons);\n	group.appendChild(inner);\n\n	return group;\n}\n\n/**\n * Automatically adjust height of a single textarea to fit content\n * @param {HTMLTextAreaElement} textarea - textarea element\n * @returns {void}\n */\nfunction autoResizeTextarea(textarea) {\n	if (!textarea) return;\n\n	// Reset height to get correct scrollHeight\n	textarea.style.height = "auto";\n\n	// Set new height (scrollHeight + border)\n	const newHeight = textarea.scrollHeight;\n	textarea.style.height = `${newHeight}px`;\n}\n\n/**\n * Add auto-expanding height functionality to all textarea elements\n * @returns {void}\n */\nfunction autoResizeAllTextareas() {\n	const textareas = document.querySelectorAll("textarea");\n\n	textareas.forEach((textarea) => {\n		// Adjust height once during initialization\n		autoResizeTextarea(textarea);\n\n		// Listen to input events, adjust height in real time\n		textarea.addEventListener("input", function () {\n			autoResizeTextarea(this);\n		});\n\n		// Listen to change events (e.g. after pasting)\n		textarea.addEventListener("change", function () {\n			autoResizeTextarea(this);\n		});\n\n		// Listen to paste events\n		textarea.addEventListener("paste", function () {\n			// Use setTimeout to ensure content has been pasted\n			setTimeout(() => {\n				autoResizeTextarea(this);\n			}, 0);\n		});\n	});\n}\n\n/**\n * General input validation - non-empty validation\n * @param {HTMLElement} element - Input element to validate\n * @returns {void}\n */\nfunction addSimpleValidation(element) {\n	element.addEventListener("input", function () {\n		if (this.value.trim()) {\n			this.classList.remove("invalid");\n		} else {\n			this.classList.add("invalid");\n		}\n	});\n}\n\n/**\n * General number validation - must be a positive integer\n * @param {HTMLElement} element - Input element to validate\n * @returns {void}\n */\nfunction addNumberValidation(element) {\n	element.addEventListener("input", function () {\n		const value = parseInt(this.value, 10);\n		if (value && value > 0) {\n			this.classList.remove("invalid");\n		} else {\n			this.classList.add("invalid");\n		}\n	});\n}\n\n/**\n * Check if it is a valid JSON object (not an array, not null, not a primitive type)\n * @param {*} parsed - Parsed JSON data\n * @returns {boolean} Whether it is a valid JSON object\n */\nfunction isValidJSONObject(parsed) {\n	return (\n		typeof parsed === "object" && parsed !== null && !Array.isArray(parsed)\n	);\n}\n\n/**\n * Bind event listeners\n * @returns {void}\n */\nfunction bindEvents() {\n	// Real-time validation for required fields\n	const modelId = document.getElementById("modelId");\n	const modelName = document.getElementById("modelName");\n	const provider = document.getElementById("provider");\n	const baseUrl = document.getElementById("baseUrl");\n	const maxInputTokens = document.getElementById("maxInputTokens");\n	const maxOutputTokens = document.getElementById("maxOutputTokens");\n\n	// Add auto-expanding height functionality to all textarea elements\n	autoResizeAllTextareas();\n\n	// Model ID validation\n	if (modelId && !modelId.readOnly) {\n		addSimpleValidation(modelId);\n	}\n\n	// Display name validation\n	addSimpleValidation(modelName);\n\n	// Provider validation\n	addSimpleValidation(provider);\n\n	// baseUrl validation (required + URL format)\n	baseUrl.addEventListener("input", function () {\n		const value = this.value.trim();\n		if (!value) {\n			this.classList.add("invalid");\n			return;\n		}\n		try {\n			const urlObj = new URL(value);\n			if (urlObj.protocol === "http:" || urlObj.protocol === "https:") {\n				this.classList.remove("invalid");\n			} else {\n				this.classList.add("invalid");\n			}\n		} catch (_e) {\n			this.classList.add("invalid");\n		}\n	});\n\n	// Token count validation\n	addNumberValidation(maxInputTokens);\n	addNumberValidation(maxOutputTokens);\n\n	// JSON validation events\n	const customHeader = document.getElementById("customHeader");\n	const extraBody = document.getElementById("extraBody");\n\n	customHeader.addEventListener("input", () => validateJSON_UI("customHeader"));\n	customHeader.addEventListener("change", () =>\n		validateJSON_UI("customHeader"),\n	);\n\n	extraBody.addEventListener("input", () => validateJSON_UI("extraBody"));\n	extraBody.addEventListener("change", () => validateJSON_UI("extraBody"));\n\n	// Provider input events\n	const providerInput = document.getElementById("provider");\n	const providerList = document.getElementById("providerList");\n\n	providerInput.addEventListener("input", function () {\n		const searchText = this.value.toLowerCase();\n		if (searchText) {\n			const filtered = allProviders.filter(\n				(p) =>\n					p.id.toLowerCase().includes(searchText) ||\n					p.name.toLowerCase().includes(searchText),\n			);\n			renderProviderList(filtered);\n			providerList.classList.add("show");\n		} else {\n			providerList.classList.remove("show");\n		}\n	});\n\n	providerInput.addEventListener("focus", () => {\n		if (allProviders && allProviders.length > 0) {\n			renderProviderList(allProviders);\n			providerList.classList.add("show");\n		}\n	});\n\n	document.addEventListener("click", (event) => {\n		if (!event.target.closest(".provider-dropdown")) {\n			providerList.classList.remove("show");\n		}\n	});\n\n	// VSCode message events\n	window.addEventListener("message", (event) => {\n		const message = event.data;\n		if (message.command === "setProviders") {\n			updateProviderList(message.providers);\n		}\n	});\n}\n\n/**\n * Validate JSON string format\n * @param {string} jsonString - JSON string to validate\n * @returns {boolean} Whether JSON is valid\n */\nfunction validateJSON(jsonString) {\n	if (!jsonString || jsonString.trim() === "") {\n		return true;\n	}\n	try {\n		const parsed = JSON.parse(jsonString);\n		// Must be object type, cannot be array, string, number, etc.\n		return isValidJSONObject(parsed);\n	} catch (_e) {\n		return false;\n	}\n}\n\n/**\n * Parse JSON string\n * @param {string} jsonString - JSON string to parse\n * @returns {Object|undefined} Parsed object, returns undefined if parsing fails or not an object\n */\nfunction parseJSON(jsonString) {\n	if (!jsonString || jsonString.trim() === "") {\n		return undefined;\n	}\n	try {\n		const parsed = JSON.parse(jsonString);\n		// Must be object type, cannot be array, string, number, etc.\n		if (isValidJSONObject(parsed)) {\n			return parsed;\n		}\n		return undefined;\n	} catch (_e) {\n		return undefined;\n	}\n}\n\n/**\n * Validate JSON and update UI state (visual feedback only, does not take focus)\n * @param {string} fieldId - Form field ID\n * @returns {boolean} Whether JSON is valid\n */\nfunction validateJSON_UI(fieldId) {\n	const textarea = document.getElementById(fieldId);\n	const statusDiv = document.getElementById(`${fieldId}Status`);\n	const statusText = document.getElementById(`${fieldId}StatusText`);\n	const errorDiv = document.getElementById(`${fieldId}Error`);\n	const content = textarea.value.trim();\n\n	// Remove all validation state classes\n	textarea.classList.remove("json-valid", "json-invalid");\n	if (errorDiv) {\n		errorDiv.classList.remove("show");\n	}\n\n	if (!content) {\n		const indicator = statusDiv.querySelector(".json-status-indicator");\n		indicator.className = "json-status-indicator";\n		statusText.textContent = "No content";\n		return true;\n	}\n\n	try {\n		const parsed = JSON.parse(content);\n		// Must be object type, consistent with validateJSON logic\n		if (isValidJSONObject(parsed)) {\n			// Validation passed - restore default state (no green style added)\n			const indicator = statusDiv.querySelector(".json-status-indicator");\n			indicator.className = "json-status-indicator";\n			statusText.textContent = "Valid";\n			return true;\n		} else {\n			// Not an object type - show red error state\n			textarea.classList.add("json-invalid");\n			const indicator = statusDiv.querySelector(".json-status-indicator");\n			indicator.className = "json-status-indicator invalid";\n			statusText.textContent = "Invalid";\n			if (errorDiv) {\n				errorDiv.textContent =\n					\'Must be object type (like {"key": "value"}), cannot be array, number or string\';\n				errorDiv.classList.add("show");\n			}\n			return false;\n		}\n	} catch (e) {\n		// JSON parsing error - show red error state\n		textarea.classList.add("json-invalid");\n		const indicator = statusDiv.querySelector(".json-status-indicator");\n		indicator.className = "json-status-indicator invalid";\n		statusText.textContent = "Invalid";\n		if (errorDiv) {\n			errorDiv.textContent = `Error: ${e.message}`;\n			errorDiv.classList.add("show");\n		}\n		return false;\n	}\n}\n\n/**\n * Format JSON string\n * @param {string} fieldId - Form field ID\n * @returns {void}\n */\nfunction formatJSON(fieldId) {\n	const textarea = document.getElementById(fieldId);\n	const content = textarea.value.trim();\n\n	if (!content) {\n		showGlobalError("No content to format");\n		return;\n	}\n\n	try {\n		const parsed = JSON.parse(content);\n		// Must be object type, consistent with validateJSON logic\n		if (!isValidJSONObject(parsed)) {\n			showGlobalError(\n				\'JSON format error: Must be object type (like {"key": "value"}), cannot be array, number or string\',\n			);\n			return;\n		}\n		textarea.value = JSON.stringify(parsed, null, 2);\n		validateJSON_UI(fieldId);\n		// Adjust height after formatting\n		autoResizeTextarea(textarea);\n		textarea.style.opacity = "0.7";\n		setTimeout(() => {\n			textarea.style.opacity = "1";\n		}, 200);\n		// Clear error prompt when formatting is successful\n		hideGlobalError();\n	} catch (e) {\n		showGlobalError(`JSON format error, cannot format:\\n${e.message}`);\n	}\n}\n\n/**\n * Clear JSON field content\n * @param {string} fieldId - Form field ID\n * @returns {void}\n */\nfunction clearJSON(fieldId) {\n	const textarea = document.getElementById(fieldId);\n	// Clear directly without confirmation (user can restore via cancel save or Ctrl+Z)\n	textarea.value = "";\n	validateJSON_UI(fieldId);\n	// Adjust height after clearing\n	autoResizeTextarea(textarea);\n}\n\n/**\n * Provider list management\n * @param {Provider[]} providers - Provider list\n * @returns {void}\n */\nfunction updateProviderList(providers) {\n	allProviders = providers || [];\n	renderProviderList(allProviders);\n}\n\n/**\n * Render provider list\n * @param {Provider[]} providers - Provider list\n * @returns {void}\n */\nfunction renderProviderList(providers) {\n	const providerListDiv = document.getElementById("providerList");\n	const currentValue = document.getElementById("provider").value;\n\n	providerListDiv.innerHTML = "";\n\n	if (!providers || providers.length === 0) {\n		const item = document.createElement("div");\n		item.className = "provider-list-item";\n		item.textContent = "No matching providers";\n		item.style.pointerEvents = "none";\n		item.style.opacity = "0.5";\n		providerListDiv.appendChild(item);\n		return;\n	}\n\n	providers.forEach((provider) => {\n		const item = document.createElement("div");\n		item.className = "provider-list-item";\n		if (provider.id === currentValue) {\n			item.classList.add("selected");\n		}\n		item.textContent = `${provider.name} (${provider.id})`;\n		item.addEventListener("click", () => {\n			const providerInput = document.getElementById("provider");\n			providerInput.value = provider.id;\n			// Remove error style (if any)\n			providerInput.classList.remove("invalid");\n			providerListDiv.classList.remove("show");\n		});\n		providerListDiv.appendChild(item);\n	});\n}\n\n/**\n * Form validation\n */\n/**\n * Show global error info\n * @param {string} message - Error message\n * @returns {void}\n */\nfunction showGlobalError(message) {\n	const banner = document.getElementById("globalErrorBanner");\n	const messageSpan = document.getElementById("globalErrorMessage");\n\n	if (banner && messageSpan) {\n		messageSpan.textContent = message;\n		banner.style.display = "flex";\n		// Auto-scroll to top to ensure user sees error prompt\n		banner.scrollIntoView({ behavior: "smooth", block: "nearest" });\n	}\n}\n\n/**\n * Hide global error info\n * @returns {void}\n */\nfunction hideGlobalError() {\n	const banner = document.getElementById("globalErrorBanner");\n	if (banner) {\n		banner.style.display = "none";\n	}\n}\n\n/**\n * Validate form data\n * @returns {boolean} Whether form is valid\n */\nfunction validateForm() {\n	const modelId = document.getElementById("modelId").value.trim();\n	const modelName = document.getElementById("modelName").value.trim();\n	const provider = document.getElementById("provider").value.trim();\n	const baseUrl = document.getElementById("baseUrl").value.trim();\n	const maxInputTokens = document.getElementById("maxInputTokens").value.trim();\n	const maxOutputTokens = document\n		.getElementById("maxOutputTokens")\n		.value.trim();\n\n	// Validate required fields\n	if (!modelId) {\n		showGlobalError("Please enter Model ID");\n		document.getElementById("modelId").focus();\n		return false;\n	}\n	if (!modelName) {\n		showGlobalError("Please enter display name");\n		document.getElementById("modelName").focus();\n		return false;\n	}\n	if (!provider) {\n		showGlobalError("Please enter provider");\n		document.getElementById("provider").focus();\n		return false;\n	}\n	if (!baseUrl) {\n		showGlobalError("Please enter BASE URL");\n		document.getElementById("baseUrl").focus();\n		return false;\n	}\n\n	// Validate URL format\n	if (baseUrl) {\n		try {\n			const urlObj = new URL(baseUrl);\n			if (urlObj.protocol !== "http:" && urlObj.protocol !== "https:") {\n				showGlobalError("BASE URL must start with http:// or https://");\n				document.getElementById("baseUrl").focus();\n				return false;\n			}\n		} catch (_e) {\n			showGlobalError("BASE URL format is incorrect, please enter a valid URL");\n			document.getElementById("baseUrl").focus();\n			return false;\n		}\n	}\n\n	// Validate token count\n	if (\n		!maxInputTokens ||\n		Number.isNaN(parseInt(maxInputTokens, 10)) ||\n		parseInt(maxInputTokens, 10) <= 0\n	) {\n		showGlobalError("Input token must be a number greater than 0");\n		document.getElementById("maxInputTokens").focus();\n		return false;\n	}\n	if (\n		!maxOutputTokens ||\n		Number.isNaN(parseInt(maxOutputTokens, 10)) ||\n		parseInt(maxOutputTokens, 10) <= 0\n	) {\n		showGlobalError("Output token must be a number greater than 0");\n		document.getElementById("maxOutputTokens").focus();\n		return false;\n	}\n\n	// Validate JSON format\n	const customHeaderJson = document.getElementById("customHeader").value.trim();\n	if (customHeaderJson && !validateJSON(customHeaderJson)) {\n		showGlobalError(\n			"Custom HTTP header JSON format is incorrect, must be object type",\n		);\n		document.getElementById("customHeader").focus();\n		return false;\n	}\n\n	const extraBodyJson = document.getElementById("extraBody").value.trim();\n	if (extraBodyJson && !validateJSON(extraBodyJson)) {\n		showGlobalError(\n			"Extra request body parameters JSON format is incorrect, must be object type",\n		);\n		document.getElementById("extraBody").focus();\n		return false;\n	}\n\n	return true;\n}\n\n/**\n * Save model configuration\n * @returns {void}\n */\nfunction saveModel() {\n	// Clear previous errors\n	hideGlobalError();\n\n	if (!validateForm()) {\n		return;\n	}\n\n	const modelId = document.getElementById("modelId").value.trim();\n	const modelName = document.getElementById("modelName").value.trim();\n	const provider = document.getElementById("provider").value.trim();\n\n	if (!modelId || !modelName || !provider) {\n		showGlobalError("Please enter all required fields");\n		return;\n	}\n\n	const tooltipText = document.getElementById("modelTooltip").value.trim();\n	const requestModelText = document.getElementById("requestModel").value.trim();\n	const baseUrlText = document.getElementById("baseUrl").value.trim();\n\n	const model = {\n		id: modelId,\n		name: modelName,\n		// tooltip: use null to clear (undefined will be ignored when JSON serializing)\n		tooltip: tooltipText || null,\n		provider: provider,\n		// baseUrl: use null to clear\n		baseUrl: baseUrlText || null,\n		// model: use null to clear\n		model: requestModelText || null,\n		sdkMode: document.getElementById("sdkMode").value || "openai",\n		maxInputTokens:\n			parseInt(document.getElementById("maxInputTokens").value, 10) || 12800,\n		maxOutputTokens:\n			parseInt(document.getElementById("maxOutputTokens").value, 10) || 8192,\n		capabilities: {\n			toolCalling: document.getElementById("toolCalling").checked,\n			imageInput: document.getElementById("imageInput").checked,\n		},\n		outputThinking: document.getElementById("outputThinking").checked,\n		includeThinking: document.getElementById("includeThinking").checked,\n	};\n\n	const customHeaderText = document.getElementById("customHeader").value.trim();\n	const customHeader = parseJSON(customHeaderText);\n	// Explicitly set customHeader, use null to clear (undefined will be ignored when JSON serializing)\n	model.customHeader = customHeader || null;\n\n	const extraBodyText = document.getElementById("extraBody").value.trim();\n	const extraBody = parseJSON(extraBodyText);\n	// Explicitly set extraBody, use null to clear\n	model.extraBody = extraBody || null;\n\n	if (!model.id || !model.name || !model.provider) {\n		showGlobalError("Model configuration is incomplete, please try again");\n		return;\n	}\n\n	vscode.postMessage({\n		command: "save",\n		model: model,\n	});\n}\n\n/**\n * Cancel editing\n * @returns {void}\n */\nfunction cancelEdit() {\n	vscode.postMessage({\n		command: "cancel",\n	});\n}\n\n/**\n * Delete model\n * @returns {void}\n */\nfunction deleteModel() {\n	// Send delete request to VSCode side, VSCode will show confirmation dialog\n	vscode.postMessage({\n		command: "delete",\n		modelId: document.getElementById("modelId").value.trim(),\n		modelName: document.getElementById("modelName").value.trim(),\n	});\n}\n';
  }
});

// src/ui/modelEditor.ts
var vscode6, ModelEditor;
var init_modelEditor3 = __esm({
  "src/ui/modelEditor.ts"() {
    "use strict";
    vscode6 = __toESM(require("vscode"));
    init_config();
    init_knownProviders();
    init_modelEditor();
    init_modelEditor2();
    ModelEditor = class _ModelEditor {
      /**
       * Show model editor
       * @param model Model configuration to edit
       * @param isCreateMode Whether it is in creation mode
       * @returns Updated model configuration, or undefined if cancelled, or a delete marker object
       */
      static async show(model, isCreateMode = false) {
        const panel = vscode6.window.createWebviewPanel(
          "compatibleModelEditor",
          isCreateMode ? "Create New Model" : `Edit Model: ${model.name || "Unnamed Model"}`,
          vscode6.ViewColumn.One,
          {
            enableScripts: true,
            retainContextWhenHidden: true
          }
        );
        panel.webview.html = _ModelEditor.generateHTML(
          model,
          isCreateMode,
          panel.webview
        );
        return new Promise(
          (resolve) => {
            const disposables = [];
            disposables.push(
              panel.webview.onDidReceiveMessage(
                async (message) => {
                  switch (message.command) {
                    case "getProviders":
                      _ModelEditor.sendProvidersList(panel.webview);
                      break;
                    case "save":
                      if (message.model && typeof message.model === "object" && message.model.id && message.model.name && message.model.provider) {
                        resolve(message.model);
                      } else {
                        vscode6.window.showErrorMessage("Invalid saved model data");
                        resolve(void 0);
                      }
                      panel.dispose();
                      break;
                    case "delete":
                      if (message.modelId && typeof message.modelId === "string") {
                        const modelName = message.modelName || "this model";
                        const confirmed = await vscode6.window.showWarningMessage(
                          `Are you sure you want to delete model "${modelName}"?`,
                          { modal: true },
                          "Delete"
                        );
                        if (confirmed === "Delete") {
                          resolve({ _deleteModel: true, modelId: message.modelId });
                          panel.dispose();
                        }
                      } else {
                        vscode6.window.showErrorMessage(
                          "Delete failed: Invalid model ID"
                        );
                      }
                      break;
                    case "cancel":
                      resolve(void 0);
                      panel.dispose();
                      break;
                  }
                },
                void 0,
                disposables
              )
            );
            disposables.push(
              panel.onDidDispose(
                () => {
                  disposables.forEach((d) => {
                    d.dispose();
                  });
                },
                void 0,
                disposables
              )
            );
          }
        );
      }
      /**
       * Generate model editor HTML
       */
      static generateHTML(model, isCreateMode, webview) {
        const cspSource = webview.cspSource || "";
        const modelData = {
          id: model?.id || "",
          name: model?.name || "",
          provider: model?.provider || "",
          sdkMode: model?.sdkMode || "openai",
          tooltip: model?.tooltip || "",
          baseUrl: model?.baseUrl || "",
          model: model?.model || "",
          maxInputTokens: model?.maxInputTokens || 128e3,
          maxOutputTokens: model?.maxOutputTokens || 4096,
          toolCalling: model?.capabilities?.toolCalling || false,
          imageInput: model?.capabilities?.imageInput || false,
          outputThinking: model?.outputThinking !== false,
          includeThinking: model?.includeThinking !== false,
          customHeader: model?.customHeader ? JSON.stringify(model.customHeader, null, 2) : "",
          extraBody: model?.extraBody ? JSON.stringify(model.extraBody, null, 2) : ""
        };
        const pageTitle = isCreateMode ? "Create New Model" : `Edit Model: ${_ModelEditor.escapeHtml(modelData.name)}`;
        return `<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>${pageTitle}</title>
        <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline' ${cspSource}; script-src 'unsafe-inline' ${cspSource};" />
        <style>
            ${modelEditor_default}
        </style>
    </head>
    <body>
        <div class="container">
            <div id="app"></div>
        </div>
        <script>
            ${modelEditor_default2}

            // Initialize data
            const initialModelData = ${JSON.stringify(modelData)};
            const initialIsCreateMode = ${isCreateMode};

            // Start editor
            document.addEventListener('DOMContentLoaded', function() {
                initializeEditor(initialModelData, initialIsCreateMode);
            });
        </script>
    </body>
</html>`;
      }
      /**
       * HTML escape function
       */
      static escapeHtml(text) {
        if (!text) {
          return "";
        }
        const map = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          // eslint-disable-next-line @stylistic/quotes
          "'": "&#039;"
        };
        return text.replace(/[&<>"']/g, (char) => map[char]);
      }
      /**
       * Send providers list to webview
       */
      static sendProvidersList(webview) {
        const providersMap = /* @__PURE__ */ new Map();
        Object.entries(configProviders).forEach(([key, config2]) => {
          providersMap.set(key, {
            id: key,
            name: config2.displayName || key
          });
        });
        Object.entries(KnownProviders).forEach(([key, config2]) => {
          if (!providersMap.has(key)) {
            providersMap.set(key, {
              id: key,
              name: config2.displayName || key
            });
          }
        });
        webview.postMessage({
          command: "setProviders",
          providers: Array.from(providersMap.values())
        });
      }
    };
  }
});

// src/utils/compatibleModelManager.ts
var compatibleModelManager_exports = {};
__export(compatibleModelManager_exports, {
  CompatibleModelManager: () => CompatibleModelManager
});
function isBackButtonClick(value) {
  return typeof value === "object" && value?.back === true;
}
var vscode7, CompatibleModelManager;
var init_compatibleModelManager = __esm({
  "src/utils/compatibleModelManager.ts"() {
    "use strict";
    vscode7 = __toESM(require("vscode"));
    init_config();
    init_modelEditor3();
    init_apiKeyManager();
    init_knownProviders();
    init_logger();
    CompatibleModelManager = class _CompatibleModelManager {
      static models = [];
      static configListener = null;
      static _onDidChangeModels = new vscode7.EventEmitter();
      static onDidChangeModels = _CompatibleModelManager._onDidChangeModels.event;
      static isSaving = false;
      // Mark whether currently saving, avoid triggering configuration listeners
      /**
       * Initialize model manager
       */
      static initialize() {
        _CompatibleModelManager.loadModels();
        _CompatibleModelManager.setupConfigListener();
        Logger.debug("Custom model manager initialized");
      }
      /**
       * Clean up resources
       */
      static dispose() {
        if (_CompatibleModelManager.configListener) {
          _CompatibleModelManager.configListener.dispose();
          _CompatibleModelManager.configListener = null;
        }
        _CompatibleModelManager._onDidChangeModels.dispose();
        Logger.trace("Custom model manager disposed");
      }
      /**
       * Setup configuration file change listener
       */
      static setupConfigListener() {
        if (_CompatibleModelManager.configListener) {
          _CompatibleModelManager.configListener.dispose();
        }
        _CompatibleModelManager.configListener = vscode7.workspace.onDidChangeConfiguration((event) => {
          if (event.affectsConfiguration("chp.compatibleModels")) {
            if (_CompatibleModelManager.isSaving) {
              Logger.debug("Saving configuration, skipping reload");
              return;
            }
            Logger.info(
              "Detected custom model configuration changes, reloading..."
            );
            _CompatibleModelManager.loadModels();
            _CompatibleModelManager._onDidChangeModels.fire();
          }
        });
      }
      /**
       * Load models from configuration
       */
      static loadModels() {
        try {
          const config2 = vscode7.workspace.getConfiguration("chp");
          const modelsData = config2.get(
            "compatibleModels",
            []
          );
          _CompatibleModelManager.models = (modelsData || []).filter(
            (model) => model != null && typeof model === "object" && model.id && model.name && model.provider
          );
          Logger.debug(
            `Loaded ${_CompatibleModelManager.models.length} custom models`
          );
        } catch (error2) {
          Logger.error("Failed to load custom models:", error2);
          _CompatibleModelManager.models = [];
        }
      }
      /**
       * Save models to configuration
       */
      static async saveModels() {
        try {
          _CompatibleModelManager.isSaving = true;
          const config2 = vscode7.workspace.getConfiguration("chp");
          const modelsToSave = _CompatibleModelManager.models.filter((model) => model != null && typeof model === "object").map((model) => {
            const { _isFromWizard, ...rest } = model;
            const cleaned = {};
            for (const [key, value] of Object.entries(rest)) {
              if (value !== void 0 && value !== null) {
                cleaned[key] = value;
              }
            }
            return cleaned;
          });
          Logger.debug(
            "Preparing to save models, cleaned data:",
            JSON.stringify(modelsToSave, null, 2)
          );
          await config2.update(
            "compatibleModels",
            modelsToSave,
            vscode7.ConfigurationTarget.Global
          );
          Logger.debug("Custom models saved to configuration");
          _CompatibleModelManager.loadModels();
          _CompatibleModelManager._onDidChangeModels.fire();
          Logger.debug("Model change event triggered");
        } catch (error2) {
          Logger.error("Failed to save custom models:", error2);
          throw error2;
        } finally {
          setTimeout(() => {
            _CompatibleModelManager.isSaving = false;
          }, 100);
        }
      }
      /**
       * Get all models
       */
      static getModels() {
        return _CompatibleModelManager.models;
      }
      /**
       * Get raw data of specified model from configuration file (unprocessed)
       * @param modelId Model ID
       * @returns Original model configuration, or undefined
       */
      static getRawModelFromConfig(modelId) {
        try {
          const config2 = vscode7.workspace.getConfiguration("chp");
          const modelsData = config2.get(
            "compatibleModels",
            []
          );
          const rawModel = modelsData.find(
            (model) => model && model.id === modelId
          );
          return rawModel;
        } catch (error2) {
          Logger.error(
            "Failed to read raw model data from configuration file:",
            error2
          );
          return void 0;
        }
      }
      /**
       * Add model
       */
      static async addModel(model) {
        if (!model) {
          throw new Error("Model configuration cannot be empty");
        }
        if (!model.id || !model.name || !model.provider) {
          throw new Error(
            "Model configuration missing required fields (id, name, provider)"
          );
        }
        if (_CompatibleModelManager.models.some((m) => m.id === model.id)) {
          throw new Error(`Model ID "${model.id}" already exists`);
        }
        if (typeof model !== "object") {
          throw new Error("Model configuration must be a valid object");
        }
        if (!model.capabilities || typeof model.capabilities !== "object") {
          model.capabilities = {
            toolCalling: false,
            imageInput: false
          };
        }
        _CompatibleModelManager.models.push(model);
        await _CompatibleModelManager.saveModels();
        Logger.info(
          `Added custom model: ${model.name} (${model.provider}, ${model.sdkMode})`
        );
      }
      /**
       * Update model
       */
      static async updateModel(id, updates) {
        if (!updates) {
          throw new Error("Update data cannot be empty");
        }
        const index = _CompatibleModelManager.models.findIndex((m) => m.id === id);
        if (index === -1) {
          throw new Error(`Model ID "${id}" not found`);
        }
        if (!_CompatibleModelManager.models[index]) {
          throw new Error(`Model data corrupted, cannot update model ID "${id}"`);
        }
        _CompatibleModelManager.models[index] = {
          ..._CompatibleModelManager.models[index],
          ...updates
        };
        await _CompatibleModelManager.saveModels();
        Logger.info(`Updated custom model: ${id}`);
      }
      /**
       * Delete model
       */
      static async removeModel(id) {
        const index = _CompatibleModelManager.models.findIndex((m) => m.id === id);
        if (index === -1) {
          throw new Error(`Model ID "${id}" not found`);
        }
        const removedModel = _CompatibleModelManager.models[index];
        if (!removedModel) {
          throw new Error(`Model data corrupted, cannot delete model ID "${id}"`);
        }
        _CompatibleModelManager.models.splice(index, 1);
        await _CompatibleModelManager.saveModels();
        Logger.info(`Deleted custom model: ${removedModel.name}`);
      }
      /**
       * Delete multiple models at once
       */
      static async removeModels(ids) {
        let success = 0;
        let failed = 0;
        const validIds = ids.filter(
          (id) => _CompatibleModelManager.models.some((m) => m.id === id)
        );
        for (const id of validIds) {
          const index = _CompatibleModelManager.models.findIndex((m) => m.id === id);
          if (index !== -1) {
            const removedModel = _CompatibleModelManager.models[index];
            _CompatibleModelManager.models.splice(index, 1);
            Logger.info(`Deleted custom model: ${removedModel?.name || id}`);
            success++;
          } else {
            failed++;
          }
        }
        if (success > 0) {
          await _CompatibleModelManager.saveModels();
        }
        return { success, failed };
      }
      /**
       * Configure model or update API key (main entry point)
       */
      static async configureModelOrUpdateAPIKey() {
        if (_CompatibleModelManager.models.length === 0) {
          Logger.info("No custom models, directly entering add flow");
          await _CompatibleModelManager.configureModels();
          return;
        }
        const options = [
          {
            label: "$(key) Manage API Keys",
            detail: "Update or configure provider or model API keys",
            action: "apiKey"
          },
          {
            label: "$(settings-gear) Configure Models",
            detail: "Add, edit, or delete model configurations",
            action: "configureModels"
          }
        ];
        const quickPick = vscode7.window.createQuickPick();
        quickPick.title = "Manage OpenAI / Anthropic Compatible Models";
        quickPick.placeholder = "Select an action";
        quickPick.items = options;
        quickPick.ignoreFocusOut = true;
        const selected = await new Promise(
          (resolve) => {
            quickPick.onDidAccept(() => {
              const selectedItem = quickPick.selectedItems[0];
              resolve(selectedItem);
              quickPick.hide();
            });
            quickPick.onDidHide(() => {
              resolve(void 0);
            });
            quickPick.show();
          }
        );
        if (selected?.action === "apiKey") {
          await _CompatibleModelManager.promptAndSetApiKey();
        } else if (selected?.action === "configureModels") {
          await _CompatibleModelManager.configureModels();
        }
      }
      /**
       * Prompt and set API key - set by provider unit
       */
      static async promptAndSetApiKey() {
        try {
          const providers2 = await _CompatibleModelManager.getUniqueProviders();
          if (providers2.length === 0) {
            vscode7.window.showWarningMessage(
              "No custom model configurations, please add a model first"
            );
            return;
          }
          if (providers2.length === 1) {
            await _CompatibleModelManager.setApiKeyForProvider(providers2[0]);
            return;
          }
          const historicalProviders = await _CompatibleModelManager.getHistoricalCustomProviders();
          const customProviders = [];
          const knownProviders = [];
          const builtinProviders = [];
          providers2.forEach((provider) => {
            if (historicalProviders.includes(provider)) {
              customProviders.push(provider);
            } else if (provider in KnownProviders) {
              knownProviders.push(provider);
            } else if (provider in configProviders) {
              builtinProviders.push(provider);
            } else {
              customProviders.push(provider);
            }
          });
          const providerChoices = [];
          if (customProviders.length > 0) {
            providerChoices.push(
              ...customProviders.map((provider) => ({ label: provider }))
            );
          }
          if (knownProviders.length > 0) {
            if (customProviders.length > 0) {
              providerChoices.push({
                label: "Known Providers",
                kind: vscode7.QuickPickItemKind.Separator
              });
            }
            providerChoices.push(
              ...knownProviders.map((provider) => ({
                label: provider,
                description: KnownProviders[provider]?.displayName
              }))
            );
          }
          if (builtinProviders.length > 0) {
            if (customProviders.length > 0 || knownProviders.length > 0) {
              providerChoices.push({
                label: "Built-in Providers",
                kind: vscode7.QuickPickItemKind.Separator
              });
            }
            providerChoices.push(
              ...builtinProviders.map((provider) => ({
                label: provider,
                description: configProviders[provider]?.displayName
              }))
            );
          }
          const selected = await vscode7.window.showQuickPick(providerChoices, {
            placeHolder: "Select provider to set API key for"
          });
          if (!selected) {
            return;
          }
          await _CompatibleModelManager.setApiKeyForProvider(selected.label);
        } catch (error2) {
          Logger.error("Failed to set API key:", error2);
          vscode7.window.showErrorMessage(
            `Failed to set API key: ${error2 instanceof Error ? error2.message : "Unknown error"}`
          );
        }
      }
      /**
       * Get all unique provider list
       */
      static async getUniqueProviders() {
        const providers2 = /* @__PURE__ */ new Set();
        for (const model of _CompatibleModelManager.models) {
          if (model.provider?.trim()) {
            providers2.add(model.provider.trim());
          } else {
            providers2.add("compatible");
          }
        }
        return Array.from(providers2).sort();
      }
      /**
       * Set API key for specified provider
       */
      static async setApiKeyForProvider(provider) {
        const apiKey = await vscode7.window.showInputBox({
          prompt: `Please enter API key for "${provider}" (leave empty to clear key)`,
          placeHolder: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
          password: true
        });
        if (apiKey === void 0) {
          return;
        }
        if (apiKey.trim().length === 0) {
          await ApiKeyManager.deleteApiKey(provider);
          Logger.info(`API key for provider "${provider}" has been cleared`);
        } else {
          await ApiKeyManager.setApiKey(provider, apiKey.trim());
          Logger.info(`API key for provider "${provider}" has been set`);
        }
      }
      /**
      * Configure models - main configuration flow
      */
      static async configureModels() {
        while (true) {
          const items = [];
          for (const model of _CompatibleModelManager.models) {
            const details = [
              `$(arrow-up) ${model.maxInputTokens} $(arrow-down) ${model.maxOutputTokens}`,
              `$(chip) ${model.sdkMode === "openai" ? "OpenAI" : "Anthropic"}`
            ];
            if (model.capabilities.toolCalling) {
              details.push("$(plug) Tool calling");
            }
            if (model.capabilities.imageInput) {
              details.push("$(circuit-board) Image understanding");
            }
            items.push({
              label: model.name,
              description: model.id,
              detail: details.join("	"),
              modelId: model.id,
              action: "edit"
            });
          }
          if (items.length === 0) {
            const newModel = await _CompatibleModelManager.showVisualModelEditorForCreate();
            if (newModel) {
              await _CompatibleModelManager.addModel(newModel);
            }
            return;
          }
          if (items.length > 0) {
            const separator = {
              label: "",
              kind: vscode7.QuickPickItemKind.Separator
            };
            items.push(separator);
          }
          items.push({
            label: "$(add) Add New Model",
            detail: "Create new custom model configuration",
            action: "add"
          });
          items.push({
            label: "$(trash) Bulk Delete Models",
            detail: "Select multiple models to delete at once",
            action: "bulkDelete"
          });
          const quickPick = vscode7.window.createQuickPick();
          quickPick.title = "Custom Model Configuration";
          quickPick.placeholder = "Select a model to edit or add new model";
          quickPick.items = items;
          quickPick.ignoreFocusOut = true;
          const selected = await new Promise((resolve) => {
            const disposables = [];
            disposables.push(
              quickPick.onDidAccept(() => {
                const selectedItem = quickPick.selectedItems[0];
                resolve(selectedItem);
                quickPick.hide();
              })
            );
            disposables.push(
              quickPick.onDidHide(() => {
                resolve(void 0);
                disposables.forEach((d) => {
                  d.dispose();
                });
              })
            );
            quickPick.show();
          });
          if (!selected || isBackButtonClick(selected)) {
            return;
          }
          if (selected.action === "add") {
            const newModel = await _CompatibleModelManager.showVisualModelEditorForCreate();
            if (newModel) {
              await _CompatibleModelManager.addModel(newModel);
            }
          } else if (selected.action === "bulkDelete") {
            await _CompatibleModelManager.showBulkDeletePicker();
          } else if (selected.action === "edit" && selected.modelId) {
            const model = _CompatibleModelManager.models.find(
              (m) => m.id === selected.modelId
            );
            if (model) {
              const result = await _CompatibleModelManager._editModel(
                selected.modelId,
                model
              );
              if (result) {
                if (result.action === "update" && result.config) {
                  await _CompatibleModelManager.updateModel(
                    result.id,
                    result.config
                  );
                } else if (result.action === "delete") {
                  await _CompatibleModelManager.removeModel(result.id);
                }
              }
            }
          }
        }
      }
      /**
       * Show bulk delete picker - allows selecting multiple models to delete
       */
      static async showBulkDeletePicker() {
        const items = _CompatibleModelManager.models.map(
          (model) => ({
            label: model.name,
            description: model.id,
            detail: `$(chip) ${model.sdkMode === "openai" ? "OpenAI" : "Anthropic"} | Provider: ${model.provider || "compatible"}`,
            modelId: model.id
          })
        );
        if (items.length === 0) {
          vscode7.window.showInformationMessage("No models to delete");
          return;
        }
        const quickPick = vscode7.window.createQuickPick();
        quickPick.title = "Bulk Delete Models";
        quickPick.placeholder = "Select models to delete (use Space to select, Enter to confirm)";
        quickPick.items = items;
        quickPick.canSelectMany = true;
        quickPick.ignoreFocusOut = true;
        const selectedItems = await new Promise((resolve) => {
          quickPick.onDidAccept(() => {
            resolve([...quickPick.selectedItems]);
            quickPick.hide();
          });
          quickPick.onDidHide(() => {
            resolve(void 0);
          });
          quickPick.show();
        });
        if (!selectedItems || selectedItems.length === 0) {
          return;
        }
        const confirmMessage = selectedItems.length === 1 ? `Are you sure you want to delete "${selectedItems[0].label}"?` : `Are you sure you want to delete ${selectedItems.length} models?`;
        const confirm = await vscode7.window.showWarningMessage(
          confirmMessage,
          { modal: true },
          "Delete"
        );
        if (confirm !== "Delete") {
          return;
        }
        const idsToDelete = selectedItems.map((item) => item.modelId);
        const result = await _CompatibleModelManager.removeModels(idsToDelete);
        if (result.success > 0) {
          const message = result.failed > 0 ? `Deleted ${result.success} model(s), ${result.failed} failed` : `Successfully deleted ${result.success} model(s)`;
          vscode7.window.showInformationMessage(message);
        } else {
          vscode7.window.showErrorMessage("Failed to delete models");
        }
      }
      static async _editModel(modelId, currentConfig) {
        const rawConfig = _CompatibleModelManager.getRawModelFromConfig(modelId);
        const configToEdit = rawConfig || currentConfig;
        const updatedConfig = await _CompatibleModelManager.showVisualModelEditor(configToEdit);
        if (updatedConfig) {
          return { action: "update", id: modelId, config: updatedConfig };
        }
        return void 0;
      }
      /**
       * Show visual model editor (create mode)
       * @returns New model configuration, or undefined if cancelled
       */
      static async showVisualModelEditorForCreate() {
        const defaultModel = {
          id: "",
          // Will be filled by user in form
          name: "",
          // Will be filled by user in form
          provider: "",
          // Will be selected and filled by user in form
          sdkMode: "openai",
          maxInputTokens: 128e3,
          maxOutputTokens: 4096,
          capabilities: {
            toolCalling: true,
            imageInput: false
          },
          outputThinking: true,
          // Default enabled - display thinking process in response
          includeThinking: true
          // Default enabled - include thinking content in multi-turn conversations
        };
        return _CompatibleModelManager.showVisualModelEditor(defaultModel, true);
      }
      /**
       * Show visual model editor
       * @param model Model configuration to edit
       * @param isCreateMode Whether it's create mode
       * @returns Updated model configuration, or undefined if cancelled
       */
      static async showVisualModelEditor(model, isCreateMode = false) {
        const result = await ModelEditor.show(model, isCreateMode);
        if (result && "_deleteModel" in result && result._deleteModel) {
          try {
            await _CompatibleModelManager.removeModel(result.modelId);
            vscode7.window.showInformationMessage("Model deleted");
          } catch (error2) {
            vscode7.window.showErrorMessage(
              `Failed to delete model: ${error2 instanceof Error ? error2.message : "Unknown error"}`
            );
          }
          return void 0;
        }
        return result;
      }
      /**
       * Get historical custom provider list
       */
      static async getHistoricalCustomProviders() {
        try {
          const { configProviders: configProviders2 } = await Promise.resolve().then(() => (init_config(), config_exports));
          const builtinProviders = Object.keys(configProviders2);
          const knownProviders = Object.keys(KnownProviders);
          const allProviders = _CompatibleModelManager.models.map((model) => model.provider).filter((provider) => provider && provider.trim() !== "");
          const customProviders = [...new Set(allProviders)].filter(
            (provider) => provider !== "compatible" && !builtinProviders.includes(provider) && !knownProviders.includes(provider)
          );
          return customProviders;
        } catch (error2) {
          Logger.error("Failed to get historical custom providers:", error2);
          return [];
        }
      }
    };
  }
});

// src/providers/antigravity/auth.ts
var auth_exports = {};
__export(auth_exports, {
  AntigravityAuth: () => AntigravityAuth,
  antigravityLoginCommand: () => antigravityLoginCommand,
  doAntigravityLogin: () => doAntigravityLogin,
  doAntigravityLoginForNewAccount: () => doAntigravityLoginForNewAccount
});
function generateRandomState() {
  const array2 = new Uint8Array(32);
  for (let i = 0; i < array2.length; i++) {
    array2[i] = Math.floor(Math.random() * 256);
  }
  return Array.from(array2).map((b) => b.toString(16).padStart(2, "0")).join("");
}
function buildAuthURL(redirectURI, state) {
  const params = new import_node_url.URLSearchParams();
  params.set("access_type", "offline");
  params.set("client_id", ANTIGRAVITY_CLIENT_ID);
  params.set("prompt", "consent");
  params.set("redirect_uri", redirectURI);
  params.set("response_type", "code");
  params.set("scope", ANTIGRAVITY_SCOPES.join(" "));
  params.set("state", state);
  return `https://accounts.google.com/o/oauth2/v2/auth?${params.toString()}`;
}
function parseJsonSafe(text) {
  try {
    return JSON.parse(text);
  } catch {
    return null;
  }
}
async function exchangeCode(code, redirectURI) {
  const data = new import_node_url.URLSearchParams();
  data.set("code", code);
  data.set("client_id", ANTIGRAVITY_CLIENT_ID);
  data.set("client_secret", ANTIGRAVITY_CLIENT_SECRET);
  data.set("redirect_uri", redirectURI);
  data.set("grant_type", "authorization_code");
  const response = await fetch("https://oauth2.googleapis.com/token", {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: data.toString()
  });
  const body = await response.text();
  const token = parseJsonSafe(body);
  if (!token) {
    throw new Error(`Failed to parse token response: ${body}`);
  }
  if (!response.ok) {
    throw new Error(`Token exchange failed: ${body}`);
  }
  return token;
}
async function fetchUserInfo(accessToken) {
  try {
    const response = await fetch(
      "https://www.googleapis.com/oauth2/v1/userinfo?alt=json",
      {
        method: "GET",
        headers: { Authorization: `Bearer ${accessToken}` }
      }
    );
    if (!response.ok) {
      return { email: "" };
    }
    const body = await response.text();
    return parseJsonSafe(body) || { email: "" };
  } catch {
    return { email: "" };
  }
}
async function fetchProjectId(accessToken) {
  const reqBody = JSON.stringify({
    metadata: {
      ideType: "IDE_UNSPECIFIED",
      platform: "PLATFORM_UNSPECIFIED",
      pluginType: "GEMINI"
    }
  });
  try {
    const response = await fetch(
      "https://cloudcode-pa.googleapis.com/v1internal:loadCodeAssist",
      {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
          "User-Agent": "google-api-nodejs-client/9.15.1",
          "X-Goog-Api-Client": "google-cloud-sdk vscode_cloudshelleditor/0.1",
          "Client-Metadata": '{"ideType":"IDE_UNSPECIFIED","platform":"PLATFORM_UNSPECIFIED","pluginType":"GEMINI"}'
        },
        body: reqBody
      }
    );
    if (!response.ok) {
      return "";
    }
    const body = await response.text();
    const data = parseJsonSafe(body);
    if (!data) {
      return "";
    }
    if (typeof data.cloudaicompanionProject === "string") {
      return data.cloudaicompanionProject.trim();
    }
    if (data.cloudaicompanionProject?.id) {
      return data.cloudaicompanionProject.id.trim();
    }
    return "";
  } catch {
    return "";
  }
}
function startCallbackServer() {
  return new Promise((resolve, reject) => {
    let resultResolver;
    let resultRejecter;
    const resultPromise = new Promise(
      (res, rej) => {
        resultResolver = res;
        resultRejecter = rej;
      }
    );
    const server = http.createServer((req, res) => {
      if (req.url?.startsWith("/oauth-callback")) {
        const url2 = new import_node_url.URL(
          req.url,
          `http://localhost:${ANTIGRAVITY_CALLBACK_PORT}`
        );
        const code = url2.searchParams.get("code") || "";
        const state = url2.searchParams.get("state") || "";
        const error2 = url2.searchParams.get("error") || "";
        res.writeHead(200, { "Content-Type": "text/html; charset=utf-8" });
        if (error2) {
          res.end(
            `<html><head><title>Authentication Failed</title></head><body style="font-family: system-ui; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0;"><div style="text-align: center;"><h1 style="color: #dc3545;">Authentication Failed</h1><p>Error: ${error2}</p><p>You can close this window.</p></div></body></html>`
          );
          resultRejecter(new Error(`Authentication failed: ${error2}`));
        } else {
          res.end(
            '<html><head><title>Authentication Successful</title></head><body style="font-family: system-ui; display: flex; justify-content: center; align-items: center; height: 100vh; margin: 0;"><div style="text-align: center;"><h1 style="color: #28a745;">Authentication Successful</h1><p>You can close this window and return to VS Code.</p></div></body></html>'
          );
          resultResolver({ code, state });
        }
      } else {
        res.writeHead(404);
        res.end("Not Found");
      }
    });
    server.listen(
      ANTIGRAVITY_CALLBACK_PORT,
      "localhost",
      () => resolve({ server, port: ANTIGRAVITY_CALLBACK_PORT, resultPromise })
    );
    server.on(
      "error",
      (err) => reject(new Error(`Failed to start callback server: ${err.message}`))
    );
  });
}
async function doAntigravityLogin() {
  const state = generateRandomState();
  let serverInfo;
  try {
    serverInfo = await startCallbackServer();
  } catch (err) {
    vscode8.window.showErrorMessage(
      `Failed to start OAuth server: ${err instanceof Error ? err.message : "Unknown error"}`
    );
    return null;
  }
  const redirectURI = `http://localhost:${serverInfo.port}/oauth-callback`;
  const authURL = buildAuthURL(redirectURI, state);
  const opened = await vscode8.env.openExternal(vscode8.Uri.parse(authURL));
  if (!opened) {
    const action = await vscode8.window.showInformationMessage(
      "Could not open browser. Copy the authentication URL to clipboard?",
      "Copy URL",
      "Cancel"
    );
    if (action === "Copy URL") {
      await vscode8.env.clipboard.writeText(authURL);
      vscode8.window.showInformationMessage(
        "URL copied to clipboard. Paste it in your browser to continue."
      );
    } else {
      serverInfo.server.close();
      return null;
    }
  }
  vscode8.window.showInformationMessage(
    "Waiting for authentication... Please complete the login in your browser."
  );
  try {
    const timeoutPromise = new Promise(
      (_, reject) => setTimeout(
        () => reject(new Error("Authentication timed out after 5 minutes")),
        5 * 60 * 1e3
      )
    );
    const { code, state: returnedState } = await Promise.race([
      serverInfo.resultPromise,
      timeoutPromise
    ]);
    if (returnedState !== state) {
      throw new Error("Invalid state - possible CSRF attack");
    }
    if (!code) {
      throw new Error("Missing authorization code");
    }
    const tokenResp = await exchangeCode(code, redirectURI);
    let email2 = "";
    if (tokenResp.access_token) {
      const userInfo = await fetchUserInfo(tokenResp.access_token);
      email2 = userInfo.email?.trim() || "";
    }
    let projectId = "";
    if (tokenResp.access_token) {
      projectId = await fetchProjectId(tokenResp.access_token);
    }
    const expiresAt = new Date(
      Date.now() + tokenResp.expires_in * 1e3
    ).toISOString();
    return {
      accessToken: tokenResp.access_token,
      refreshToken: tokenResp.refresh_token,
      email: email2,
      projectId,
      expiresAt
    };
  } catch (err) {
    vscode8.window.showErrorMessage(
      `Authentication failed: ${err instanceof Error ? err.message : "Unknown error"}`
    );
    return null;
  } finally {
    serverInfo.server.close();
  }
}
async function addAllAntigravityModelsToCompatible(models) {
  const { CompatibleModelManager: CompatibleModelManager2 } = await Promise.resolve().then(() => (init_compatibleModelManager(), compatibleModelManager_exports));
  const baseUrlOverride = ConfigManager.getProviderOverrides().antigravity?.baseUrl || "https://cloudcode-pa.googleapis.com/v1internal";
  let addedCount = 0;
  for (const model of models) {
    try {
      await CompatibleModelManager2.addModel({
        id: `${PROVIDER_KEY}:${model.id}`,
        name: `${model.displayName} (Antigravity)`,
        provider: PROVIDER_KEY,
        sdkMode: "openai",
        baseUrl: baseUrlOverride,
        model: model.id,
        maxInputTokens: model.maxTokens || 1e6,
        maxOutputTokens: model.maxOutputTokens || 65536,
        capabilities: { toolCalling: true, imageInput: true }
      });
      addedCount++;
    } catch {
    }
  }
  if (addedCount > 0) {
    vscode8.window.showInformationMessage(
      `Automatically added ${addedCount} Antigravity model(s) to Compatible Provider`
    );
  }
}
async function doAntigravityLoginAndSave(isAddingNewAccount) {
  const result = await doAntigravityLogin();
  if (!result) {
    return;
  }
  const models = await AntigravityAuth.fetchModels(result.accessToken);
  const { AccountManager: AccountManager2 } = await Promise.resolve().then(() => (init_accountManager(), accountManager_exports));
  const accountManager = AccountManager2.getInstance();
  const existingAccounts = accountManager.getAccountsByProvider(PROVIDER_KEY);
  const existingByEmail = existingAccounts.find(
    (acc) => acc.email === result.email
  );
  const credentials = {
    accessToken: result.accessToken,
    refreshToken: result.refreshToken,
    expiresAt: result.expiresAt
  };
  if (existingByEmail && !isAddingNewAccount) {
    await accountManager.updateCredentials(existingByEmail.id, credentials);
  } else {
    const displayName = result.email ? isAddingNewAccount ? `${result.email} (${existingAccounts.length + 1})` : result.email : `Antigravity Account ${existingAccounts.length + 1}`;
    await accountManager.addOAuthAccount(
      PROVIDER_KEY,
      displayName,
      result.email || "",
      credentials,
      {
        projectId: result.projectId,
        models
      }
    );
  }
  await ApiKeyManager.setApiKey(
    PROVIDER_KEY,
    JSON.stringify({
      type: PROVIDER_KEY,
      access_token: result.accessToken,
      refresh_token: result.refreshToken,
      email: result.email,
      project_id: result.projectId,
      expires_at: result.expiresAt,
      timestamp: Date.now(),
      models
    })
  );
  const message = result.email ? `Antigravity login successful! Authenticated as ${result.email}` : "Antigravity login successful!";
  const modelsInfo = models.length > 0 ? ` | ${models.length} models available` : "";
  vscode8.window.showInformationMessage(
    result.projectId ? `${message} (Project: ${result.projectId})${modelsInfo}` : `${message}${modelsInfo}`
  );
  if (models.length > 0) {
    await addAllAntigravityModelsToCompatible(models);
  }
}
async function antigravityLoginCommand() {
  const isLoggedIn = await AntigravityAuth.isLoggedIn();
  if (isLoggedIn) {
    const action = await vscode8.window.showQuickPick(
      [
        { label: "$(add) Add Another Account", action: "addAccount" },
        { label: "$(list-unordered) Show Available Models", action: "models" },
        { label: "$(refresh) Refresh Models", action: "refresh" },
        { label: "$(sign-out) Logout", action: "logout" }
      ],
      { placeHolder: "Antigravity - Already logged in" }
    );
    if (!action) {
      return;
    }
    if (action.action === "addAccount") {
      await doAntigravityLoginAndSave(true);
      return;
    }
    if (action.action === "logout") {
      await AntigravityAuth.logout();
      return;
    }
    if (action.action === "refresh") {
      const models = await AntigravityAuth.refreshModels();
      if (models.length > 0) {
        vscode8.window.showInformationMessage(
          `Refreshed ${models.length} Antigravity models`
        );
      } else {
        vscode8.window.showWarningMessage("No models found from Antigravity");
      }
      return;
    }
    if (action.action === "models") {
      let models = await AntigravityAuth.getCachedModels();
      if (models.length === 0) {
        models = await AntigravityAuth.getModels();
      }
      if (models.length > 0) {
        const modelList = models.map((m) => `\u2022 ${m.displayName}`).join("\n");
        vscode8.window.showInformationMessage(
          `Available Antigravity models (${models.length}):
${modelList}`,
          {
            modal: false
          }
        );
      } else {
        vscode8.window.showWarningMessage(
          "No models available from Antigravity"
        );
      }
      return;
    }
    return;
  }
  await doAntigravityLoginAndSave(false);
}
async function doAntigravityLoginForNewAccount() {
  await doAntigravityLoginAndSave(true);
}
function modelName2Alias(originalName) {
  return originalName.startsWith("models/") ? originalName.substring(7) : originalName;
}
var http, import_node_url, vscode8, ANTIGRAVITY_CLIENT_ID, ANTIGRAVITY_CLIENT_SECRET, ANTIGRAVITY_CALLBACK_PORT, ANTIGRAVITY_SCOPES, PROVIDER_KEY, AntigravityAuth;
var init_auth = __esm({
  "src/providers/antigravity/auth.ts"() {
    "use strict";
    http = __toESM(require("node:http"));
    import_node_url = require("node:url");
    vscode8 = __toESM(require("vscode"));
    init_providerKeys();
    init_apiKeyManager();
    init_configManager();
    init_config();
    ANTIGRAVITY_CLIENT_ID = "1071006060591-tmhssin2h21lcre235vtolojh4g403ep.apps.googleusercontent.com";
    ANTIGRAVITY_CLIENT_SECRET = "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";
    ANTIGRAVITY_CALLBACK_PORT = 51121;
    ANTIGRAVITY_SCOPES = [
      "https://www.googleapis.com/auth/cloud-platform",
      "https://www.googleapis.com/auth/userinfo.email",
      "https://www.googleapis.com/auth/userinfo.profile",
      "https://www.googleapis.com/auth/cclog",
      "https://www.googleapis.com/auth/experimentsandconfigs"
    ];
    PROVIDER_KEY = "antigravity" /* Antigravity */;
    AntigravityAuth = class _AntigravityAuth {
      static async getProjectId() {
        const stored = await ApiKeyManager.getApiKey(PROVIDER_KEY);
        if (!stored) {
          return "";
        }
        try {
          return (JSON.parse(stored).project_id || "").trim();
        } catch {
          return "";
        }
      }
      static async ensureProjectId(accessToken) {
        const existing = await _AntigravityAuth.getProjectId();
        if (existing) {
          return existing;
        }
        const token = accessToken || await _AntigravityAuth.getAccessToken();
        if (!token) {
          return "";
        }
        const projectId = await fetchProjectId(token);
        if (!projectId) {
          return "";
        }
        const stored = await ApiKeyManager.getApiKey(PROVIDER_KEY);
        if (stored) {
          try {
            const authData = JSON.parse(stored);
            authData.project_id = projectId;
            await ApiKeyManager.setApiKey(PROVIDER_KEY, JSON.stringify(authData));
          } catch {
          }
        }
        return projectId;
      }
      static async getAccessToken() {
        const stored = await ApiKeyManager.getApiKey(PROVIDER_KEY);
        if (!stored) {
          return null;
        }
        try {
          const authData = JSON.parse(stored);
          const expiresAt = new Date(authData.expires_at);
          if (expiresAt.getTime() - Date.now() > 5 * 60 * 1e3) {
            return authData.access_token;
          }
          const newToken = await _AntigravityAuth.refreshToken(
            authData.refresh_token
          );
          return newToken?.accessToken || null;
        } catch {
          return null;
        }
      }
      static async refreshToken(refreshToken, options) {
        try {
          const data = new import_node_url.URLSearchParams();
          data.set("client_id", ANTIGRAVITY_CLIENT_ID);
          data.set("client_secret", ANTIGRAVITY_CLIENT_SECRET);
          data.set("refresh_token", refreshToken);
          data.set("grant_type", "refresh_token");
          const response = await fetch("https://oauth2.googleapis.com/token", {
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded" },
            body: data.toString()
          });
          const body = await response.text();
          const token = parseJsonSafe(body);
          if (!token || !response.ok) {
            return null;
          }
          const stored = await ApiKeyManager.getApiKey(PROVIDER_KEY);
          const expiresAt = new Date(
            Date.now() + token.expires_in * 1e3
          ).toISOString();
          if (options?.persist !== false && stored) {
            const authData = JSON.parse(stored);
            authData.access_token = token.access_token;
            authData.expires_at = expiresAt;
            authData.timestamp = Date.now();
            await ApiKeyManager.setApiKey(PROVIDER_KEY, JSON.stringify(authData));
          }
          return { accessToken: token.access_token, expiresAt };
        } catch {
          return null;
        }
      }
      static async logout() {
        await ApiKeyManager.deleteApiKey(PROVIDER_KEY);
        vscode8.window.showInformationMessage("Antigravity logged out successfully");
      }
      static async isLoggedIn() {
        return !!await ApiKeyManager.getApiKey(PROVIDER_KEY);
      }
      static async fetchModels(accessToken) {
        const antigravityConfig = configProviders[PROVIDER_KEY];
        const hardcodedModels = antigravityConfig.models.map(
          (m) => ({
            id: m.id,
            name: m.name,
            displayName: m.name,
            ownedBy: "antigravity",
            maxTokens: m.maxInputTokens,
            maxOutputTokens: m.maxOutputTokens,
            quotaInfo: void 0
          })
        );
        const endpoints = [
          "daily-cloudcode-pa.sandbox.googleapis.com",
          "cloudcode-pa.googleapis.com"
        ];
        let quotaMap = /* @__PURE__ */ new Map();
        for (const hostname2 of endpoints) {
          quotaMap = await _AntigravityAuth.tryFetchQuotaFromEndpoint(
            accessToken,
            hostname2
          );
          if (quotaMap.size > 0) {
            break;
          }
        }
        return hardcodedModels.map((model) => ({
          ...model,
          quotaInfo: quotaMap.get(model.id.toLowerCase())
        }));
      }
      static async tryFetchQuotaFromEndpoint(accessToken, hostname2) {
        try {
          const response = await fetch(
            `https://${hostname2}/v1internal:fetchAvailableModels`,
            {
              method: "POST",
              headers: {
                Authorization: `Bearer ${accessToken}`,
                "Content-Type": "application/json",
                "User-Agent": "antigravity/1.11.5"
              },
              body: JSON.stringify({})
            }
          );
          if (!response.ok) {
            return /* @__PURE__ */ new Map();
          }
          const body = await response.text();
          const data = parseJsonSafe(body);
          if (!data?.models) {
            return /* @__PURE__ */ new Map();
          }
          const quotaMap = /* @__PURE__ */ new Map();
          for (const originalName of Object.keys(data.models)) {
            const aliasName = modelName2Alias(originalName);
            const modelData = data.models[originalName];
            if (aliasName && modelData?.quotaInfo) {
              quotaMap.set(aliasName.toLowerCase(), {
                remainingFraction: modelData.quotaInfo.remainingFraction,
                resetTime: modelData.quotaInfo.resetTime
              });
            }
          }
          return quotaMap;
        } catch {
          return /* @__PURE__ */ new Map();
        }
      }
      static async getModels() {
        const token = await _AntigravityAuth.getAccessToken();
        return token ? _AntigravityAuth.fetchModels(token) : [];
      }
      static async getCachedModels() {
        const stored = await ApiKeyManager.getApiKey(PROVIDER_KEY);
        if (!stored) {
          return [];
        }
        try {
          const authData = JSON.parse(stored);
          const cachedModels = authData.models || [];
          const antigravityConfig = configProviders[PROVIDER_KEY];
          return antigravityConfig.models.map((m) => {
            const cached2 = cachedModels.find(
              (cm) => cm.id.toLowerCase() === m.id.toLowerCase()
            );
            return {
              id: m.id,
              name: m.name,
              displayName: m.name,
              ownedBy: "antigravity",
              maxTokens: m.maxInputTokens,
              maxOutputTokens: m.maxOutputTokens,
              quotaInfo: cached2?.quotaInfo
            };
          });
        } catch {
          return [];
        }
      }
      static async refreshModels() {
        const token = await _AntigravityAuth.getAccessToken();
        if (!token) {
          return [];
        }
        const models = await _AntigravityAuth.fetchModels(token);
        const stored = await ApiKeyManager.getApiKey(PROVIDER_KEY);
        if (stored) {
          try {
            const authData = JSON.parse(stored);
            authData.models = models;
            await ApiKeyManager.setApiKey(PROVIDER_KEY, JSON.stringify(authData));
          } catch {
          }
        }
        return models;
      }
    };
  }
});

// src/accounts/accountManagerPage.ts
var accountManagerPage_exports = {};
__export(accountManagerPage_exports, {
  AccountManagerPage: () => AccountManagerPage,
  registerAccountManagerPageCommand: () => registerAccountManagerPageCommand
});
function registerAccountManagerPageCommand(context) {
  return vscode9.commands.registerCommand("chp.accounts.openManager", () => {
    const page = AccountManagerPage.getInstance();
    page.show(context);
  });
}
var vscode9, AccountManagerPage;
var init_accountManagerPage = __esm({
  "src/accounts/accountManagerPage.ts"() {
    "use strict";
    vscode9 = __toESM(require("vscode"));
    init_providerKeys();
    init_accountManager2();
    init_accountManager3();
    init_logger();
    init_accountManager();
    init_accountQuotaCache();
    AccountManagerPage = class _AccountManagerPage {
      static instance;
      static antigravityQuotaNotice = null;
      panel;
      accountManager;
      disposables = [];
      /** Available providers */
      static providers = [
        { id: "antigravity", name: "Antigravity (Google)", authType: "oauth" },
        { id: "zhipu", name: "ZhipuAI (GLM Coding Plan)", authType: "apiKey" }
      ];
      constructor() {
        this.accountManager = AccountManager.getInstance();
        this.disposables.push(
          this.accountManager.onAccountChange(() => {
            this.refreshWebview().catch(
              (err) => Logger.warn("Failed to refresh account manager:", err)
            );
          })
        );
        const quotaCache = AccountQuotaCache.getInstance();
        this.disposables.push(
          quotaCache.onQuotaStateChange((event) => {
            this.sendQuotaStateUpdate(event);
          })
        );
      }
      /**
       * Send quota state update to webview
       */
      sendQuotaStateUpdate(event) {
        if (this.panel) {
          this.sendToWebview({
            command: "updateAccountQuotaState",
            accountId: event.accountId,
            provider: event.provider,
            state: {
              accountId: event.state.accountId,
              accountName: event.state.accountName,
              provider: event.state.provider,
              quotaExceeded: event.state.quotaExceeded,
              quotaResetAt: event.state.quotaResetAt,
              affectedModel: event.state.affectedModel,
              lastError: event.state.lastError,
              successCount: event.state.successCount,
              failureCount: event.state.failureCount,
              lastSuccessAt: event.state.lastSuccessAt,
              lastFailureAt: event.state.lastFailureAt,
              updatedAt: event.state.updatedAt
            }
          });
        }
      }
      /**
       * Get or create instance
       */
      static getInstance() {
        if (!_AccountManagerPage.instance) {
          _AccountManagerPage.instance = new _AccountManagerPage();
        }
        return _AccountManagerPage.instance;
      }
      /**
       * Show the Account Manager page
       */
      async show(context) {
        if (this.panel) {
          this.panel.reveal(vscode9.ViewColumn.One);
          return;
        }
        const extensionUri = context?.extensionUri || vscode9.Uri.file(`${__dirname}/../..`);
        this.panel = vscode9.window.createWebviewPanel(
          "chpAccountManager",
          "Account Manager",
          vscode9.ViewColumn.One,
          {
            enableScripts: true,
            retainContextWhenHidden: true,
            localResourceRoots: [vscode9.Uri.joinPath(extensionUri, "images")]
          }
        );
        const imageUris = this.getImageUris(this.panel.webview, extensionUri);
        this.panel.webview.html = this.generateHTML(imageUris);
        this.panel.webview.onDidReceiveMessage(
          async (message) => {
            await this.handleMessage(message);
          },
          void 0,
          this.disposables
        );
        this.panel.onDidDispose(
          () => {
            this.panel = void 0;
          },
          void 0,
          this.disposables
        );
        Logger.info("Account Manager page opened");
      }
      static updateAntigravityQuotaNotice(notice) {
        _AccountManagerPage.antigravityQuotaNotice = notice;
        if (_AccountManagerPage.instance?.panel) {
          _AccountManagerPage.instance.sendToWebview({
            command: "updateAntigravityQuota",
            notice
          });
        }
      }
      /**
       * Get webview URIs for provider images
       */
      getImageUris(webview, extensionUri) {
        const imageUris = {};
        const imageFiles = {
          codex: "codex.png",
          deepseek: "deepseek.png",
          zhipu: "z-ai.svg"
        };
        for (const [providerId, filename] of Object.entries(imageFiles)) {
          const imageUri = vscode9.Uri.joinPath(extensionUri, "images", filename);
          imageUris[providerId] = webview.asWebviewUri(imageUri).toString();
        }
        return imageUris;
      }
      /**
       * Generate HTML for the webview
       */
      generateHTML(imageUris = {}) {
        let accountsJson = "[]";
        let providersJson = "[]";
        let antigravityQuotaJson = "null";
        let accountQuotaStatesJson = "[]";
        let codexRateLimitsJson = "[]";
        try {
          const accounts = this.accountManager.getAllAccounts();
          accountsJson = JSON.stringify(accounts);
        } catch (e) {
          Logger.error("Failed to get accounts:", e);
        }
        try {
          providersJson = JSON.stringify(_AccountManagerPage.providers);
        } catch (e) {
          Logger.error("Failed to serialize providers:", e);
        }
        try {
          antigravityQuotaJson = JSON.stringify(
            _AccountManagerPage.antigravityQuotaNotice
          );
        } catch (e) {
          Logger.error("Failed to serialize antigravity quota:", e);
        }
        try {
          const accountQuotaCache = AccountQuotaCache.getInstance();
          const accountQuotaStates = accountQuotaCache.getAllStates();
          accountQuotaStatesJson = JSON.stringify(
            accountQuotaStates.map((state) => ({
              accountId: state.accountId,
              accountName: state.accountName,
              provider: state.provider,
              quotaExceeded: state.quotaExceeded,
              quotaResetAt: state.quotaResetAt,
              affectedModel: state.affectedModel,
              lastError: state.lastError,
              successCount: state.successCount,
              failureCount: state.failureCount,
              lastSuccessAt: state.lastSuccessAt,
              lastFailureAt: state.lastFailureAt,
              updatedAt: state.updatedAt
            }))
          );
        } catch (e) {
          Logger.error("Failed to get account quota states:", e);
        }
        try {
          codexRateLimitsJson = "[]";
        } catch (e) {
          Logger.error("Failed to get codex rate limits:", e);
        }
        return `<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Account Manager</title>
        <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline'; script-src 'unsafe-inline';" />
        <style>
            ${accountManager_default}
        </style>
    </head>
    <body>
        <div class="container">
            <div id="app">
                <div class="empty-state">
                    <div class="loading-spinner"></div>
                    <p>Loading...</p>
                </div>
            </div>
        </div>
        <script>
            ${accountManager_default2}

            // Initialize with data
            const initialAccounts = ${accountsJson};
            const initialProviders = ${providersJson};
            const initialAntigravityQuota = ${antigravityQuotaJson};
            const initialCodexRateLimits = ${codexRateLimitsJson};
            const initialAccountQuotaStates = ${accountQuotaStatesJson};
            const initialProviderImageUris = ${JSON.stringify(imageUris)};

            // Always wait for DOM to be fully ready
            function safeInitialize() {
                try {
                    console.log('[AccountManager] Starting initialization...');
                    initializeAccountManager(initialAccounts, initialProviders, initialAntigravityQuota, initialCodexRateLimits, initialAccountQuotaStates, initialProviderImageUris);
                    console.log('[AccountManager] Initialization complete');
                } catch (error) {
                    console.error('[AccountManager] Initialization error:', error);
                    const app = document.getElementById('app');
                    if (app) {
                        app.innerHTML = '<div class="empty-state"><p style="color: red;">Error: ' + (error.message || error) + '</p></div>';
                    }
                }
            }
            
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', safeInitialize);
            } else {
                // DOM is already ready, but use setTimeout to ensure all scripts are loaded
                setTimeout(safeInitialize, 0);
            }
        </script>
    </body>
</html>`;
      }
      /**
       * Handle messages from webview
       */
      async handleMessage(message) {
        switch (message.command) {
          case "addApiKeyAccount":
            await this.handleAddApiKeyAccount(
              message.provider,
              message.displayName,
              message.apiKey,
              message.endpoint
            );
            break;
          case "addOAuthAccount":
            await this.handleAddOAuthAccount(message.provider);
            break;
          case "setDefaultAccount":
            await this.handleSetDefaultAccount(message.accountId);
            break;
          case "deleteAccount":
            await this.handleDeleteAccount(message.accountId);
            break;
          case "refresh":
            await this.refreshWebview();
            break;
          case "openSettings":
            await vscode9.commands.executeCommand("chp.openSettings");
            break;
          case "checkQuota":
            await this.handleCheckQuota(message.accountId);
            break;
        }
      }
      /**
       * Handle adding API key account
       */
      async handleAddApiKeyAccount(provider, displayName, apiKey, endpoint) {
        try {
          const result = await this.accountManager.addApiKeyAccount(
            provider,
            displayName,
            apiKey,
            { endpoint }
          );
          if (result.success) {
            this.sendToWebview({
              command: "showToast",
              message: `Account "${displayName}" added successfully!`,
              type: "success"
            });
            await this.refreshWebview();
          } else {
            this.sendToWebview({
              command: "showToast",
              message: `Failed to add account: ${result.error}`,
              type: "error"
            });
          }
        } catch (error2) {
          Logger.error("Failed to add API key account:", error2);
          this.sendToWebview({
            command: "showToast",
            message: "Failed to add account. Please try again.",
            type: "error"
          });
        }
      }
      /**
       * Handle adding OAuth account
       */
      async handleAddOAuthAccount(provider) {
        try {
          if (provider === "antigravity" /* Antigravity */) {
            const { doAntigravityLoginForNewAccount: doAntigravityLoginForNewAccount2 } = await Promise.resolve().then(() => (init_auth(), auth_exports));
            await doAntigravityLoginForNewAccount2();
            await this.refreshWebview();
          } else if (provider === ProviderKey.Codex) {
            const { doCodexLoginForNewAccount } = await import("../providers/codex/codexAuth.js");
            await doCodexLoginForNewAccount();
            await this.refreshWebview();
          }
        } catch (error2) {
          Logger.error("OAuth login failed:", error2);
          this.sendToWebview({
            command: "showToast",
            message: "OAuth login failed. Please try again.",
            type: "error"
          });
        }
      }
      /**
       * Handle setting default account
       */
      async handleSetDefaultAccount(accountId) {
        try {
          const account = this.accountManager.getAccount(accountId);
          if (!account) {
            this.sendToWebview({
              command: "showToast",
              message: "Account not found",
              type: "error"
            });
            return;
          }
          await this.accountManager.switchAccount(account.provider, accountId);
          this.sendToWebview({
            command: "showToast",
            message: `"${account.displayName}" is now the default account`,
            type: "success"
          });
          await this.refreshWebview();
        } catch (error2) {
          Logger.error("Failed to set default account:", error2);
          this.sendToWebview({
            command: "showToast",
            message: "Failed to set default account",
            type: "error"
          });
        }
      }
      /**
       * Handle checking quota for an account
       */
      async handleCheckQuota(accountId) {
        try {
          const account = this.accountManager.getAccount(accountId);
          if (!account) {
            this.sendToWebview({
              command: "quotaCheckResult",
              accountId,
              success: false,
              error: "Account not found"
            });
            return;
          }
          if (account.provider !== "antigravity" /* Antigravity */) {
            this.sendToWebview({
              command: "quotaCheckResult",
              accountId,
              success: true,
              message: "Quota check not needed for this provider"
            });
            return;
          }
          const currentAccount = this.accountManager.getActiveAccount(
            account.provider
          );
          const currentAccountId = currentAccount?.id;
          await this.accountManager.switchAccount(account.provider, accountId);
          await vscode9.commands.executeCommand(
            "chp.antigravity.refreshAndShowQuota"
          );
          await new Promise((resolve) => setTimeout(resolve, 1e3));
          if (currentAccountId && currentAccountId !== accountId) {
            await this.accountManager.switchAccount(
              account.provider,
              currentAccountId
            );
          }
          this.sendToWebview({
            command: "quotaCheckResult",
            accountId,
            success: true,
            message: "Quota refresh triggered"
          });
        } catch (error2) {
          Logger.error("Failed to check quota:", error2);
          this.sendToWebview({
            command: "quotaCheckResult",
            accountId,
            success: false,
            error: error2 instanceof Error ? error2.message : "Unknown error"
          });
        }
      }
      /**
       * Handle deleting account
       */
      async handleDeleteAccount(accountId) {
        try {
          const account = this.accountManager.getAccount(accountId);
          const displayName = account?.displayName || "Account";
          const success = await this.accountManager.removeAccount(accountId);
          if (success) {
            this.sendToWebview({
              command: "showToast",
              message: `"${displayName}" has been deleted`,
              type: "success"
            });
            this.refreshWebview();
          } else {
            this.sendToWebview({
              command: "showToast",
              message: "Failed to delete account",
              type: "error"
            });
          }
        } catch (error2) {
          Logger.error("Failed to delete account:", error2);
          this.sendToWebview({
            command: "showToast",
            message: "Failed to delete account",
            type: "error"
          });
        }
      }
      /**
       * Refresh webview with latest data
       */
      async refreshWebview() {
        if (!this.panel) {
          return;
        }
        const accounts = this.accountManager.getAllAccounts();
        const accountsWithEndpoints = [];
        for (const account of accounts) {
          const creds = await this.accountManager.getCredentials(account.id);
          if (creds && "endpoint" in creds && creds.endpoint) {
            accountsWithEndpoints.push({
              id: account.id,
              endpoint: creds.endpoint
            });
          }
        }
        this.sendToWebview({
          command: "updateAccounts",
          accounts,
          accountEndpoints: accountsWithEndpoints
        });
      }
      /**
       * Send message to webview
       */
      sendToWebview(message) {
        if (this.panel) {
          this.panel.webview.postMessage(message);
        }
      }
      /**
       * Dispose resources
       */
      dispose() {
        if (this.panel) {
          this.panel.dispose();
        }
        for (const d of this.disposables) {
          d.dispose();
        }
        this.disposables = [];
        _AccountManagerPage.instance = void 0;
      }
    };
  }
});

// node_modules/@microsoft/tiktokenizer/dist/bytePairEncode.js
var require_bytePairEncode = __commonJS({
  "node_modules/@microsoft/tiktokenizer/dist/bytePairEncode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bytePairEncode = exports2.BinaryMap = exports2.binaryMapKey = void 0;
    var binaryMapKey = (k, start, end) => {
      const length = end - start;
      const lowerMask = 16777215 >>> Math.max(0, (3 - length) * 8);
      const lower = (k[start + 0] | k[start + 1] << 8 | k[start + 2] << 16) & lowerMask;
      const upperMask = 16777215 >>> Math.min(31, Math.max(0, (6 - length) * 8));
      const upper = (k[start + 3] | k[start + 4] << 8 | k[start + 5] << 16) & upperMask;
      return lower + 16777216 * upper;
    };
    exports2.binaryMapKey = binaryMapKey;
    var BinaryMap = class _BinaryMap {
      constructor() {
        this.nested = /* @__PURE__ */ new Map();
        this.final = /* @__PURE__ */ new Map();
      }
      get(key, start = 0, end = key.length) {
        const isFinal = end < 6 + start;
        const mapKey = (0, exports2.binaryMapKey)(key, start, end);
        if (isFinal) {
          return this.final.get(mapKey);
        }
        return this.nested.get(mapKey)?.get(key, 6 + start, end);
      }
      set(key, value) {
        const k = (0, exports2.binaryMapKey)(key, 0, key.length);
        const isFinal = key.length < 6;
        if (isFinal) {
          this.final.set(k, value);
          return;
        }
        const existing = this.nested.get(k);
        if (existing instanceof _BinaryMap) {
          existing.set(key.subarray(
            6
            /* Constant.BytesPerLevel */
          ), value);
        } else {
          const newMap = new _BinaryMap();
          newMap.set(key.subarray(
            6
            /* Constant.BytesPerLevel */
          ), value);
          this.nested.set(k, newMap);
        }
      }
    };
    exports2.BinaryMap = BinaryMap;
    var ranksBuf = new Int32Array(128);
    var indicesBuf = new Int32Array(128);
    function bytePairEncode(mergingBytes, ranks, length) {
      if (length === 1) {
        return [ranks.get(mergingBytes)];
      }
      let minRank = 2147483647;
      let minIndex = -1;
      while (ranksBuf.length < length * 2) {
        indicesBuf = new Int32Array(indicesBuf.length * 2);
        ranksBuf = new Int32Array(ranksBuf.length * 2);
      }
      for (let i = 0; i < length - 1; i++) {
        const rank = ranks.get(mergingBytes, i, i + 2) ?? 2147483647;
        if (rank < minRank) {
          minRank = rank;
          minIndex = i;
        }
        indicesBuf[i] = i;
        ranksBuf[i] = rank;
      }
      indicesBuf[length - 1] = length - 1;
      ranksBuf[length - 1] = 2147483647;
      indicesBuf[length] = length;
      ranksBuf[length] = 2147483647;
      let maxIndex = length + 1;
      function getRank(startIndex, skip = 0) {
        if (startIndex + skip + 2 < maxIndex) {
          const rank = ranks.get(mergingBytes, indicesBuf[startIndex], indicesBuf[startIndex + skip + 2]);
          if (rank !== void 0) {
            return rank;
          }
        }
        return 2147483647;
      }
      while (minRank !== 2147483647) {
        ranksBuf[indicesBuf[minIndex]] = getRank(minIndex, 1);
        if (minIndex > 0) {
          ranksBuf[indicesBuf[minIndex - 1]] = getRank(minIndex - 1, 1);
        }
        for (let i = minIndex + 1; i < maxIndex - 1; i++) {
          indicesBuf[i] = indicesBuf[i + 1];
        }
        maxIndex--;
        minIndex = -1;
        minRank = 2147483647;
        for (let i = 0; i < maxIndex - 1; i++) {
          const rank = ranksBuf[indicesBuf[i]];
          if (ranksBuf[indicesBuf[i]] < minRank) {
            minRank = rank;
            minIndex = i;
          }
        }
      }
      const outList = [];
      for (let i = 0; i < maxIndex - 1; i++) {
        outList.push(ranks.get(mergingBytes, indicesBuf[i], indicesBuf[i + 1]));
      }
      return outList;
    }
    exports2.bytePairEncode = bytePairEncode;
  }
});

// node_modules/@microsoft/tiktokenizer/dist/textEncoder.js
var require_textEncoder = __commonJS({
  "node_modules/@microsoft/tiktokenizer/dist/textEncoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeTextEncoder = void 0;
    var UniversalTextEncoder = class {
      constructor() {
        this.length = 0;
        this.encoder = new TextEncoder();
      }
      encode(text) {
        const arr = this.encoder.encode(text);
        this.length = arr.length;
        return arr;
      }
    };
    var NodeTextEncoder = class {
      constructor() {
        this.buffer = Buffer.alloc(256);
        this.length = 0;
      }
      encode(text) {
        while (true) {
          this.length = this.buffer.write(text, "utf8");
          if (this.length < this.buffer.length - 4) {
            return this.buffer;
          }
          this.buffer = Buffer.alloc(this.length * 2);
          this.length = this.buffer.write(text);
        }
      }
    };
    var makeTextEncoder = () => typeof Buffer !== "undefined" ? new NodeTextEncoder() : new UniversalTextEncoder();
    exports2.makeTextEncoder = makeTextEncoder;
  }
});

// node_modules/@microsoft/tiktokenizer/dist/lru.js
var require_lru = __commonJS({
  "node_modules/@microsoft/tiktokenizer/dist/lru.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = void 0;
    var LRUCache2 = class {
      constructor(size) {
        this.size = size;
        this.nodes = /* @__PURE__ */ new Map();
      }
      get(key) {
        const node = this.nodes.get(key);
        if (node) {
          this.moveToHead(node);
          return node.value;
        }
        return void 0;
      }
      set(key, value) {
        const node = this.nodes.get(key);
        if (node) {
          node.value = value;
          this.moveToHead(node);
        } else {
          const newNode = new Node(key, value);
          this.nodes.set(key, newNode);
          this.addNode(newNode);
          if (this.nodes.size > this.size) {
            this.nodes.delete(this.tail.key);
            this.removeNode(this.tail);
          }
        }
      }
      moveToHead(node) {
        this.removeNode(node);
        node.next = void 0;
        node.prev = void 0;
        this.addNode(node);
      }
      addNode(node) {
        if (this.head) {
          this.head.prev = node;
          node.next = this.head;
        }
        if (!this.tail) {
          this.tail = node;
        }
        this.head = node;
      }
      removeNode(node) {
        if (node.prev) {
          node.prev.next = node.next;
        } else {
          this.head = node.next;
        }
        if (node.next) {
          node.next.prev = node.prev;
        } else {
          this.tail = node.prev;
        }
      }
    };
    exports2.LRUCache = LRUCache2;
    var Node = class {
      constructor(key, value) {
        this.key = key;
        this.value = value;
      }
    };
  }
});

// node_modules/@microsoft/tiktokenizer/dist/tikTokenizer.js
var require_tikTokenizer = __commonJS({
  "node_modules/@microsoft/tiktokenizer/dist/tikTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TikTokenizer = void 0;
    var bytePairEncode_1 = require_bytePairEncode();
    var textEncoder_1 = require_textEncoder();
    var lru_1 = require_lru();
    function loadTikTokenBpe(tikTokenBpeFile) {
      const bpeDict = /* @__PURE__ */ new Map();
      try {
        const fs8 = require("fs");
        const fileContent = fs8.readFileSync(tikTokenBpeFile, "utf-8");
        processBpeRanks(fileContent);
        return bpeDict;
      } catch (ex) {
        throw new Error(`Failed to load from BPE encoder file stream: ${ex}`);
      }
      function processBpeRanks(fileContent) {
        for (const line of fileContent.split(/[\r\n]+/)) {
          if (line.trim() === "") {
            continue;
          }
          const tokens = line.split(" ");
          if (tokens.length !== 2) {
            throw new Error("Invalid format in the BPE encoder file stream");
          }
          const tokenBytes = new Uint8Array(Buffer.from(tokens[0], "base64"));
          const rank = parseInt(tokens[1]);
          if (!isNaN(rank)) {
            bpeDict.set(tokenBytes, rank);
          } else {
            throw new Error(`Can't parse ${tokens[1]} to integer`);
          }
        }
      }
    }
    function escapeRegExp(regex) {
      return regex.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    var TikTokenizer = class {
      /**
       * Take the encoder tokens mapping from OpenAI tiktoken dump to build the encoder
       * For gpt-3.5-turbo/gpt4, you can download the BPE tokens mapping from:
       * https://openaipublic.blob.core.windows.net/encodings/cl100k_base.tiktoken
       * @param tikTokenBpeFileOrDict BPE rank file path or parsed dictionary
       * @param specialTokensEncoder special tokens encoder
       * @param regexPattern regex pattern to split the input text
       * @param cacheSize cache size
       */
      constructor(tikTokenBpeFileOrDict, specialTokensEncoder, regexPattern, cacheSize = 8192) {
        this.textEncoder = (0, textEncoder_1.makeTextEncoder)();
        this.textDecoder = new TextDecoder("utf-8");
        this.cache = new lru_1.LRUCache(cacheSize);
        const bpeDict = typeof tikTokenBpeFileOrDict === "string" ? loadTikTokenBpe(tikTokenBpeFileOrDict) : tikTokenBpeFileOrDict;
        this.init(bpeDict, specialTokensEncoder, regexPattern);
      }
      init(bpeDict, specialTokensEncoder, regexPattern) {
        this.encoder = new bytePairEncode_1.BinaryMap();
        for (const [key, value] of bpeDict) {
          this.encoder.set(key, value);
        }
        this.regex = new RegExp(regexPattern, "gu");
        this.specialTokensRegex = new RegExp(Array.from(specialTokensEncoder.keys()).map((s) => escapeRegExp(s)).join("|"));
        this.specialTokensEncoder = specialTokensEncoder;
        this.decoder = /* @__PURE__ */ new Map();
        for (const [key, value] of bpeDict) {
          this.decoder.set(value, key);
        }
        if (bpeDict.size !== this.decoder.size) {
          throw new Error("Encoder and decoder sizes do not match");
        }
        this.specialTokensDecoder = /* @__PURE__ */ new Map();
        for (const [key, value] of specialTokensEncoder) {
          this.specialTokensDecoder.set(value, key);
        }
      }
      findNextSpecialToken(text, start, allowedSpecial) {
        let startFind = start;
        let nextSpecial = null;
        if (allowedSpecial && this.specialTokensRegex) {
          while (true) {
            nextSpecial = text.slice(startFind).match(this.specialTokensRegex);
            if (!nextSpecial) {
              break;
            }
            if (allowedSpecial && allowedSpecial.includes(nextSpecial[0])) {
              break;
            }
            startFind += nextSpecial.index + 1;
          }
        }
        const end = nextSpecial ? startFind + nextSpecial.index : text.length;
        return [nextSpecial, end];
      }
      /**
       * Encode a string with a set of allowed special tokens that are not broken apart.
       * @param text text to encode
       * @param allowedSpecial allowed special tokens
       * @returns number[] encoded token ids
       */
      encode(text, allowedSpecial) {
        const tokenIds = [];
        let start = 0;
        while (true) {
          let nextSpecial;
          let end;
          [nextSpecial, end] = this.findNextSpecialToken(text, start, allowedSpecial);
          if (end > start) {
            this.encodeByIndex(text, tokenIds, start, end);
          }
          if (nextSpecial) {
            start = start + this.encodeSpecialToken(tokenIds, nextSpecial);
            if (start >= text.length) {
              break;
            }
          } else {
            break;
          }
        }
        return tokenIds;
      }
      encodeSpecialToken(tokenIds, nextSpecial) {
        const token = this.specialTokensEncoder?.get(nextSpecial[0]);
        tokenIds.push(token);
        return nextSpecial.index + nextSpecial[0].length;
      }
      encodeByIndex(text, tokenIds, start, end) {
        let match;
        const substring = text.substring(start, end);
        this.regex.lastIndex = 0;
        while (match = this.regex.exec(substring)) {
          const cached2 = this.cache.get(match[0]);
          if (cached2) {
            for (const b of cached2) {
              tokenIds.push(b);
            }
          } else {
            const bytes = this.textEncoder.encode(match[0]);
            const token = this.encoder.get(bytes, 0, this.textEncoder.length);
            if (token !== void 0) {
              tokenIds.push(token);
              this.cache.set(match[0], [token]);
            } else {
              const encodedTokens = (0, bytePairEncode_1.bytePairEncode)(bytes, this.encoder, this.textEncoder.length);
              for (const b of encodedTokens) {
                tokenIds.push(b);
              }
              this.cache.set(match[0], encodedTokens);
            }
          }
        }
      }
      encodeTrimSuffixByIndex(text, tokenIds, start, end, maxTokenCount, tokenCount, encodeLength) {
        let match;
        const substring = text.substring(start, end);
        this.regex.lastIndex = 0;
        while (match = this.regex.exec(substring)) {
          const piece = match[0];
          const cachedTokens = this.cache.get(piece);
          if (cachedTokens) {
            if (tokenCount + cachedTokens.length <= maxTokenCount) {
              tokenCount += cachedTokens.length;
              encodeLength += piece.length;
              tokenIds.push(...cachedTokens);
            } else {
              let remainingTokens = maxTokenCount - tokenCount;
              tokenCount += remainingTokens;
              encodeLength += piece.length;
              tokenIds.push(...cachedTokens.slice(0, remainingTokens));
              break;
            }
          } else {
            const bytes = this.textEncoder.encode(piece);
            const token = this.encoder.get(bytes, 0, bytes.length);
            if (token !== void 0) {
              this.cache.set(piece, [token]);
              if (tokenCount + 1 <= maxTokenCount) {
                tokenCount++;
                encodeLength += piece.length;
                tokenIds.push(token);
              } else {
                break;
              }
            } else {
              const encodedTokens = (0, bytePairEncode_1.bytePairEncode)(bytes, this.encoder, this.textEncoder.length);
              this.cache.set(piece, encodedTokens);
              if (tokenCount + encodedTokens.length <= maxTokenCount) {
                tokenCount += encodedTokens.length;
                encodeLength += piece.length;
                for (const b of encodedTokens) {
                  tokenIds.push(b);
                }
              } else {
                let remainingTokens = maxTokenCount - tokenCount;
                tokenCount += remainingTokens;
                encodeLength += piece.length;
                for (let i = 0; i < remainingTokens; i++) {
                  tokenIds.push(encodedTokens[i]);
                }
                break;
              }
            }
          }
          if (tokenCount >= maxTokenCount) {
            break;
          }
        }
        return { tokenCount, encodeLength };
      }
      /**
       * Encode a piece of text limited by max token count through trimming suffix
       * @param text text to encode
       * @param maxTokenCount max token count
       * @param allowedSpecial allowed special tokens
       * @returns { tokenIds: number[], text: string } encoded token ids and trimmed text
       */
      encodeTrimSuffix(text, maxTokenCount, allowedSpecial) {
        const tokenIds = [];
        let start = 0;
        let tokenCount = 0;
        let encodeLength = 0;
        while (true) {
          let nextSpecial;
          let end;
          [nextSpecial, end] = this.findNextSpecialToken(text, start, allowedSpecial);
          if (end > start) {
            const { tokenCount: newTokenCount, encodeLength: newEncodeLength } = this.encodeTrimSuffixByIndex(text, tokenIds, start, end, maxTokenCount, tokenCount, encodeLength);
            tokenCount = newTokenCount;
            encodeLength = newEncodeLength;
            if (tokenCount >= maxTokenCount) {
              break;
            }
          }
          if (nextSpecial !== null) {
            tokenCount++;
            if (tokenCount <= maxTokenCount) {
              start = start + this.encodeSpecialToken(tokenIds, nextSpecial);
              encodeLength += nextSpecial[0].length;
              if (start >= text.length) {
                break;
              }
            }
            if (tokenCount >= maxTokenCount) {
              break;
            }
          } else {
            break;
          }
        }
        const encodedText = encodeLength === text.length ? text : text.slice(0, encodeLength);
        return { tokenIds, text: encodedText };
      }
      /**
       * Encode a piece of text limited by max token count through trimming prefix
       * @param text text to encode
       * @param maxTokenCount max token count
       * @param allowedSpecial allowed special tokens
       * @returns { tokenIds: number[], text: string } encoded token ids and trimmed text
       */
      encodeTrimPrefix(text, maxTokenCount, allowedSpecial) {
        const tokenIds = [];
        let start = 0;
        let tokenCount = 0;
        let encodeLength = 0;
        const tokenCountMap = /* @__PURE__ */ new Map();
        tokenCountMap.set(tokenCount, encodeLength);
        while (true) {
          let nextSpecial;
          let end;
          [nextSpecial, end] = this.findNextSpecialToken(text, start, allowedSpecial);
          if (end > start) {
            let match;
            const substring = text.substring(start, end);
            this.regex.lastIndex = 0;
            while (match = this.regex.exec(substring)) {
              const piece = match[0];
              const cachedTokens = this.cache.get(piece);
              if (cachedTokens) {
                tokenCount += cachedTokens.length;
                encodeLength += piece.length;
                tokenIds.push(...cachedTokens);
                tokenCountMap.set(tokenCount, encodeLength);
              } else {
                const bytes = this.textEncoder.encode(piece);
                const token = this.encoder.get(bytes);
                if (token !== void 0) {
                  this.cache.set(piece, [token]);
                  tokenCount++;
                  encodeLength += piece.length;
                  tokenIds.push(token);
                  tokenCountMap.set(tokenCount, encodeLength);
                } else {
                  const encodedTokens = (0, bytePairEncode_1.bytePairEncode)(bytes, this.encoder, this.textEncoder.length);
                  this.cache.set(piece, encodedTokens);
                  tokenCount += encodedTokens.length;
                  encodeLength += piece.length;
                  for (const b of encodedTokens) {
                    tokenIds.push(b);
                  }
                  tokenCountMap.set(tokenCount, encodeLength);
                }
              }
            }
          }
          if (nextSpecial !== null) {
            start = start + this.encodeSpecialToken(tokenIds, nextSpecial);
            tokenCount++;
            encodeLength += nextSpecial[0].length;
            tokenCountMap.set(tokenCount, encodeLength);
            if (start >= text.length) {
              break;
            }
          } else {
            break;
          }
        }
        if (tokenCount <= maxTokenCount) {
          return { tokenIds, text };
        }
        const prefixTokenCount = tokenCount - maxTokenCount;
        let actualPrefixTokenCount = 0;
        let actualPrefixStrLength = 0;
        for (const [key, value] of tokenCountMap) {
          if (key >= prefixTokenCount) {
            actualPrefixTokenCount = key;
            actualPrefixStrLength = value;
            break;
          }
        }
        if (actualPrefixTokenCount > maxTokenCount) {
          const encodedTokens = this.encode(text, allowedSpecial);
          const slicedTokens = encodedTokens.slice(encodedTokens.length - maxTokenCount);
          return {
            tokenIds: slicedTokens,
            text: this.decode(slicedTokens)
          };
        }
        return {
          tokenIds: tokenIds.slice(actualPrefixTokenCount),
          text: text.slice(actualPrefixStrLength)
        };
      }
      /**
       * Decode an array of integer token ids
       * @param tokens array of integer token ids
       * @returns string decoded text
       */
      decode(tokens) {
        const decoded = [];
        for (const token of tokens) {
          let tokenBytes = [];
          const value = this.decoder?.get(token);
          if (value !== void 0) {
            tokenBytes = Array.from(value);
          } else {
            const specialTokenValue = this.specialTokensDecoder?.get(token);
            if (specialTokenValue !== void 0) {
              const bytes = this.textEncoder.encode(specialTokenValue);
              tokenBytes = Array.from(bytes.subarray(0, this.textEncoder.length));
            }
          }
          decoded.push(...tokenBytes);
        }
        return this.textDecoder.decode(new Uint8Array(decoded));
      }
    };
    exports2.TikTokenizer = TikTokenizer;
  }
});

// node_modules/@microsoft/tiktokenizer/dist/tokenizerBuilder.js
var require_tokenizerBuilder = __commonJS({
  "node_modules/@microsoft/tiktokenizer/dist/tokenizerBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTokenizer = exports2.createByEncoderName = exports2.createByModelName = exports2.getRegexByModel = exports2.getRegexByEncoder = exports2.getSpecialTokensByModel = exports2.getSpecialTokensByEncoder = exports2.MODEL_TO_ENCODING = void 0;
    var tikTokenizer_1 = require_tikTokenizer();
    var MODEL_PREFIX_TO_ENCODING = /* @__PURE__ */ new Map([
      // chat
      ["gpt-4o-", "o200k_base"],
      ["gpt-4-", "cl100k_base"],
      ["gpt-3.5-turbo-", "cl100k_base"],
      ["gpt-35-turbo-", "cl100k_base"]
      // Azure deployment name
    ]);
    exports2.MODEL_TO_ENCODING = /* @__PURE__ */ new Map([
      // chat
      ["gpt-4o", "o200k_base"],
      ["gpt-4", "cl100k_base"],
      ["gpt-3.5-turbo", "cl100k_base"],
      // text
      ["text-davinci-003", "p50k_base"],
      ["text-davinci-002", "p50k_base"],
      ["text-davinci-001", "r50k_base"],
      ["text-curie-001", "r50k_base"],
      ["text-babbage-001", "r50k_base"],
      ["text-ada-001", "r50k_base"],
      ["davinci", "r50k_base"],
      ["curie", "r50k_base"],
      ["babbage", "r50k_base"],
      ["ada", "r50k_base"],
      // code
      ["code-davinci-002", "p50k_base"],
      ["code-davinci-001", "p50k_base"],
      ["code-cushman-002", "p50k_base"],
      ["code-cushman-001", "p50k_base"],
      ["davinci-codex", "p50k_base"],
      ["cushman-codex", "p50k_base"],
      // edit
      ["text-davinci-edit-001", "p50k_edit"],
      ["code-davinci-edit-001", "p50k_edit"],
      // embeddings
      ["text-embedding-ada-002", "cl100k_base"],
      // old embeddings
      ["text-similarity-davinci-001", "r50k_base"],
      ["text-similarity-curie-001", "r50k_base"],
      ["text-similarity-babbage-001", "r50k_base"],
      ["text-similarity-ada-001", "r50k_base"],
      ["text-search-davinci-doc-001", "r50k_base"],
      ["text-search-curie-doc-001", "r50k_base"],
      ["text-search-babbage-doc-001", "r50k_base"],
      ["text-search-ada-doc-001", "r50k_base"],
      ["code-search-babbage-code-001", "r50k_base"],
      ["code-search-ada-code-001", "r50k_base"],
      // open source
      ["gpt2", "gpt2"]
    ]);
    var ENDOFTEXT = "<|endoftext|>";
    var FIM_PREFIX = "<|fim_prefix|>";
    var FIM_MIDDLE = "<|fim_middle|>";
    var FIM_SUFFIX = "<|fim_suffix|>";
    var ENDOFPROMPT = "<|endofprompt|>";
    var REGEX_PATTERN_1 = "'s|'t|'re|'ve|'m|'ll|'d| ?\\p{L}+| ?\\p{N}+| ?[^\\s\\p{L}\\p{N}]+|\\s+(?!\\S)|\\s+";
    var REGEX_PATTERN_2 = "(?:'s|'S|'t|'T|'re|'RE|'Re|'eR|'ve|'VE|'vE|'Ve|'m|'M|'ll|'lL|'Ll|'LL|'d|'D)|[^\\r\\n\\p{L}\\p{N}]?\\p{L}+|\\p{N}{1,3}| ?[^\\s\\p{L}\\p{N}]+[\\r\\n]*|\\s*[\\r\\n]+|\\s+(?!\\S)|\\s+";
    var patterns = [
      `[^\r
\\p{L}\\p{N}]?[\\p{Lu}\\p{Lt}\\p{Lm}\\p{Lo}\\p{M}]*[\\p{Ll}\\p{Lm}\\p{Lo}\\p{M}]+(?:'s|'S|'t|'T|'re|'RE|'Re|'eR|'ve|'VE|'vE|'Ve|'m|'M|'ll|'lL|'Ll|'LL|'d|'D)?`,
      `[^\r
\\p{L}\\p{N}]?[\\p{Lu}\\p{Lt}\\p{Lm}\\p{Lo}\\p{M}]+[\\p{Ll}\\p{Lm}\\p{Lo}\\p{M}]*(?:'s|'S|'t|'T|'re|'RE|'Re|'eR|'ve|'VE|'vE|'Ve|'m|'M|'ll|'lL|'Ll|'LL|'d|'D)?`,
      `\\p{N}{1,3}`,
      ` ?[^\\s\\p{L}\\p{N}]+[\\r\\n/]*`,
      `\\s*[\\r\\n]+`,
      `\\s+(?!\\S)`,
      `\\s+`
    ];
    var REGEX_PATTERN_3 = patterns.join("|");
    function getEncoderFromModelName(modelName) {
      let encoder = "";
      if (!exports2.MODEL_TO_ENCODING.has(modelName)) {
        for (const [prefix, encoding] of MODEL_PREFIX_TO_ENCODING) {
          if (modelName.startsWith(prefix)) {
            encoder = encoding;
            break;
          }
        }
      } else {
        encoder = exports2.MODEL_TO_ENCODING.get(modelName);
      }
      return encoder;
    }
    async function fetchAndSaveFile(mergeableRanksFileUrl, filePath) {
      const fs8 = require("fs");
      const response = await fetch(mergeableRanksFileUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch file from ${mergeableRanksFileUrl}. Status code: ${response.status}`);
      }
      const text = await response.text();
      fs8.writeFileSync(filePath, text);
    }
    function getSpecialTokensByEncoder2(encoder) {
      let specialTokens = /* @__PURE__ */ new Map([[ENDOFTEXT, 50256]]);
      switch (encoder) {
        case "o200k_base":
          specialTokens = /* @__PURE__ */ new Map([
            [ENDOFTEXT, 199999],
            [ENDOFPROMPT, 200018]
          ]);
          break;
        case "cl100k_base":
          specialTokens = /* @__PURE__ */ new Map([
            [ENDOFTEXT, 100257],
            [FIM_PREFIX, 100258],
            [FIM_MIDDLE, 100259],
            [FIM_SUFFIX, 100260],
            [ENDOFPROMPT, 100276]
          ]);
          break;
        case "p50k_edit":
          specialTokens = /* @__PURE__ */ new Map([
            [ENDOFTEXT, 50256],
            [FIM_PREFIX, 50281],
            [FIM_MIDDLE, 50282],
            [FIM_SUFFIX, 50283]
          ]);
          break;
        default:
          break;
      }
      return specialTokens;
    }
    exports2.getSpecialTokensByEncoder = getSpecialTokensByEncoder2;
    function getSpecialTokensByModel(modelName) {
      const encoderName = getEncoderFromModelName(modelName);
      const specialTokens = getSpecialTokensByEncoder2(encoderName);
      return specialTokens;
    }
    exports2.getSpecialTokensByModel = getSpecialTokensByModel;
    function getRegexByEncoder2(encoder) {
      switch (encoder) {
        case "o200k_base":
          return REGEX_PATTERN_3;
        case "cl100k_base":
          return REGEX_PATTERN_2;
        default:
          break;
      }
      return REGEX_PATTERN_1;
    }
    exports2.getRegexByEncoder = getRegexByEncoder2;
    function getRegexByModel(modelName) {
      const encoderName = getEncoderFromModelName(modelName);
      const regexPattern = getRegexByEncoder2(encoderName);
      return regexPattern;
    }
    exports2.getRegexByModel = getRegexByModel;
    async function createByModelName(modelName, extraSpecialTokens = null) {
      return createByEncoderName(getEncoderFromModelName(modelName), extraSpecialTokens);
    }
    exports2.createByModelName = createByModelName;
    async function createByEncoderName(encoderName, extraSpecialTokens = null) {
      let regexPattern;
      let mergeableRanksFileUrl;
      let specialTokens = getSpecialTokensByEncoder2(encoderName);
      switch (encoderName) {
        case "o200k_base":
          regexPattern = REGEX_PATTERN_3;
          mergeableRanksFileUrl = `https://openaipublic.blob.core.windows.net/encodings/o200k_base.tiktoken`;
          break;
        case "cl100k_base":
          regexPattern = REGEX_PATTERN_2;
          mergeableRanksFileUrl = `https://openaipublic.blob.core.windows.net/encodings/cl100k_base.tiktoken`;
          break;
        case "p50k_base":
          regexPattern = REGEX_PATTERN_1;
          mergeableRanksFileUrl = `https://openaipublic.blob.core.windows.net/encodings/p50k_base.tiktoken`;
          break;
        case "p50k_edit":
          regexPattern = REGEX_PATTERN_1;
          mergeableRanksFileUrl = `https://openaipublic.blob.core.windows.net/encodings/p50k_base.tiktoken`;
          break;
        case "r50k_base":
          regexPattern = REGEX_PATTERN_1;
          mergeableRanksFileUrl = `https://openaipublic.blob.core.windows.net/encodings/r50k_base.tiktoken`;
          break;
        case "gpt2":
          regexPattern = REGEX_PATTERN_1;
          mergeableRanksFileUrl = `https://raw.githubusercontent.com/microsoft/Tokenizer/main/model/gpt2.tiktoken`;
          break;
        default:
          throw new Error(`Doesn't support this encoder [${encoderName}]`);
      }
      if (extraSpecialTokens !== null) {
        specialTokens = new Map([...specialTokens, ...extraSpecialTokens]);
      }
      const fs8 = require("fs");
      const path10 = require("path");
      const fileName = path10.basename(mergeableRanksFileUrl);
      const dirPath = path10.resolve(__dirname, "..", "model");
      if (!fs8.existsSync(dirPath)) {
        fs8.mkdirSync(dirPath, { recursive: true });
      }
      const filePath = path10.resolve(dirPath, fileName);
      if (!fs8.existsSync(filePath)) {
        console.log(`Downloading file from ${mergeableRanksFileUrl}`);
        await fetchAndSaveFile(mergeableRanksFileUrl, filePath);
        console.log(`Saved file to ${filePath}`);
      }
      return createTokenizer2(filePath, specialTokens, regexPattern);
    }
    exports2.createByEncoderName = createByEncoderName;
    function createTokenizer2(tikTokenBpeFileOrDict, specialTokensEncoder, regexPattern, cacheSize = 8192) {
      const tikTokenizer = new tikTokenizer_1.TikTokenizer(tikTokenBpeFileOrDict, specialTokensEncoder, regexPattern, cacheSize);
      return tikTokenizer;
    }
    exports2.createTokenizer = createTokenizer2;
  }
});

// node_modules/@microsoft/tiktokenizer/dist/index.js
var require_dist = __commonJS({
  "node_modules/@microsoft/tiktokenizer/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createTokenizer = exports2.createByEncoderName = exports2.createByModelName = exports2.getSpecialTokensByModel = exports2.getSpecialTokensByEncoder = exports2.getRegexByModel = exports2.getRegexByEncoder = exports2.MODEL_TO_ENCODING = exports2.TikTokenizer = void 0;
    var tikTokenizer_1 = require_tikTokenizer();
    Object.defineProperty(exports2, "TikTokenizer", { enumerable: true, get: function() {
      return tikTokenizer_1.TikTokenizer;
    } });
    var tokenizerBuilder_1 = require_tokenizerBuilder();
    Object.defineProperty(exports2, "MODEL_TO_ENCODING", { enumerable: true, get: function() {
      return tokenizerBuilder_1.MODEL_TO_ENCODING;
    } });
    Object.defineProperty(exports2, "getRegexByEncoder", { enumerable: true, get: function() {
      return tokenizerBuilder_1.getRegexByEncoder;
    } });
    Object.defineProperty(exports2, "getRegexByModel", { enumerable: true, get: function() {
      return tokenizerBuilder_1.getRegexByModel;
    } });
    Object.defineProperty(exports2, "getSpecialTokensByEncoder", { enumerable: true, get: function() {
      return tokenizerBuilder_1.getSpecialTokensByEncoder;
    } });
    Object.defineProperty(exports2, "getSpecialTokensByModel", { enumerable: true, get: function() {
      return tokenizerBuilder_1.getSpecialTokensByModel;
    } });
    Object.defineProperty(exports2, "createByModelName", { enumerable: true, get: function() {
      return tokenizerBuilder_1.createByModelName;
    } });
    Object.defineProperty(exports2, "createByEncoderName", { enumerable: true, get: function() {
      return tokenizerBuilder_1.createByEncoderName;
    } });
    Object.defineProperty(exports2, "createTokenizer", { enumerable: true, get: function() {
      return tokenizerBuilder_1.createTokenizer;
    } });
  }
});

// node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports2.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a4;
        return (_a4 = this._str) !== null && _a4 !== void 0 ? _a4 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a4;
        return (_a4 = this._names) !== null && _a4 !== void 0 ? _a4 : this._names = this._items.reduce((names, c) => {
          if (c instanceof Name)
            names[c.str] = (names[c.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str2(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports2.str = str2;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str2`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify2(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify2;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a4, _b;
        if (((_b = (_a4 = this._parent) === null || _a4 === void 0 ? void 0 : _a4._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a4;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a4 = value.key) !== null && _a4 !== void 0 ? _a4 : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              const def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error2) {
        super();
        this.error = error2;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i].optimizeNodes();
          if (Array.isArray(n))
            nodes.splice(i, 1, ...n);
          else if (n)
            nodes[i] = n;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n = nodes[i];
          if (n.optimizeNames(names, constants))
            continue;
          subtractNames(names, n.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e = this.else;
        if (e) {
          const ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e) {
          if (cond === false)
            return e instanceof _If ? e : e.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a4;
        this.else = (_a4 = this.else) === null || _a4 === void 0 ? void 0 : _a4.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a4, _b;
        super.optimizeNodes();
        (_a4 = this.catch) === null || _a4 === void 0 ? void 0 : _a4.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a4, _b;
        super.optimizeNames(names, constants);
        (_a4 = this.catch) === null || _a4 === void 0 ? void 0 : _a4.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error2) {
        super();
        this.error = error2;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        if (typeof c == "function")
          c();
        else if (c !== code_1.nil)
          this._leafNode(new AnyCode(c));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error2 = this.name("e");
          this._currNode = node.catch = new Catch(error2);
          catchCode(error2);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error2) {
        return this._leafNode(new Throw(error2));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        while (n-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n = this._currNode;
        if (!(n instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => {
        if (c instanceof code_1.Name)
          c = replaceName(c);
        if (c instanceof code_1._Code)
          items.push(...c._items);
        else
          items.push(c);
        return items;
      }, []));
      function replaceName(n) {
        const c = constants[n.str];
        if (c === void 0 || names[n.str] !== 1)
          return n;
        delete names[n.str];
        return c;
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str2) {
      return unescapeJsonPointer(decodeURIComponent(str2));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str2) {
      return encodeURIComponent(escapeJsonPointer(str2));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str2) {
      if (typeof str2 == "number")
        return `${str2}`;
      return str2.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str2) {
      return str2.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues2, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues2(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports2.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error2 = exports2.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error2, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error2 = exports2.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error2, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error2, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error2, errorPaths);
    }
    function errorObject(cxt, error2, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error2, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      const group = self.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a4;
      return schema[rule.keyword] !== void 0 || ((_a4 = rule.definition.implements) === null || _a4 === void 0 ? void 0 : _a4.some((kwd) => schema[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t of coerceTo) {
        if (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports2.validateUnion = validateUnion;
  }
});

// node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a4;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a4 = def.valid) !== null && _a4 !== void 0 ? _a4 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, false).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a5;
        gen.if((0, codegen_1.not)((_a5 = def.valid) !== null && _a5 !== void 0 ? _a5 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str2) {
      return str2.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit2 = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit2 === true)
        return !hasRef(schema);
      if (!limit2)
        return false;
      return countKeys(schema) <= limit2;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize2) {
      if (normalize2 !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self } = it;
      const { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t) => {
        if (!includesType(it.dataTypes, t)) {
          strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t) => hasApplicableType(ts, t))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t of it.dataTypes) {
        if (includesType(withTypes, t))
          ts.push(t);
        else if (withTypes.includes("integer") && t === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports2.default = ValidationError;
  }
});

// node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env3) {
        var _a4;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env3.schema == "object")
          schema = env3.schema;
        this.schema = env3.schema;
        this.schemaId = env3.schemaId;
        this.root = env3.root || this;
        this.baseId = (_a4 = env3.baseId) !== null && _a4 !== void 0 ? _a4 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env3.schemaId || "$id"]);
        this.schemaPath = env3.schemaPath;
        this.localRefs = env3.localRefs;
        this.meta = env3.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a4;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a4 = root.localRefs) === null || _a4 === void 0 ? void 0 : _a4[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a4;
      if (((_a4 = parsedRef.fragment) === null || _a4 === void 0 ? void 0 : _a4[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env3;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env3 = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env3 = env3 || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env3.schema !== env3.root.schema)
        return env3;
      return void 0;
    }
  }
});

// node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports2, module2) {
    "use strict";
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
    var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "";
      let code = 0;
      let i = 0;
      for (i = 0; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (code === 48) {
          continue;
        }
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
        break;
      }
      for (i += 1; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      buffer.length = 0;
      return true;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== "") {
          address.push(hex);
        } else {
          output.error = true;
          return false;
        }
        buffer.length = 0;
      }
      return true;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let endipv6Encountered = false;
      let endIpv6 = false;
      let consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume(buffer, address, output)) {
            break;
          }
          if (++tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i > 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          address.push(":");
          continue;
        } else if (cursor === "%") {
          if (!consume(buffer, address, output)) {
            break;
          }
          consume = consumeIsZone;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (consume === consumeIsZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv62 = getIPV6(host);
      if (!ipv62.error) {
        let newHost = ipv62.address;
        let escapedHost = ipv62.address;
        if (ipv62.zone) {
          newHost += "%" + ipv62.zone;
          escapedHost += "%25" + ipv62.zone;
        }
        return { host: newHost, isIPV6: true, escapedHost };
      } else {
        return { host, isIPV6: false };
      }
    }
    function findToken(str2, token) {
      let ind = 0;
      for (let i = 0; i < str2.length; i++) {
        if (str2[i] === token) ind++;
      }
      return ind;
    }
    function removeDotSegments(path10) {
      let input = path10;
      const output = [];
      let nextSlash = -1;
      let len = 0;
      while (len = input.length) {
        if (len === 1) {
          if (input === ".") {
            break;
          } else if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".") {
              break;
            } else if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/") {
            if (input[1] === "." || input[1] === "/") {
              output.push("/");
              break;
            }
          }
        } else if (len === 3) {
          if (input === "/..") {
            if (output.length !== 0) {
              output.pop();
            }
            output.push("/");
            break;
          }
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(2);
              continue;
            } else if (input[2] === ".") {
              if (input[3] === "/") {
                input = input.slice(3);
                if (output.length !== 0) {
                  output.pop();
                }
                continue;
              }
            }
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else {
          output.push(input.slice(0, nextSlash));
          input = input.slice(nextSlash);
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc2) {
      const func = esc2 !== true ? escape : unescape;
      if (component.scheme !== void 0) {
        component.scheme = func(component.scheme);
      }
      if (component.userinfo !== void 0) {
        component.userinfo = func(component.userinfo);
      }
      if (component.host !== void 0) {
        component.host = func(component.host);
      }
      if (component.path !== void 0) {
        component.path = func(component.path);
      }
      if (component.query !== void 0) {
        component.query = func(component.query);
      }
      if (component.fragment !== void 0) {
        component.fragment = func(component.fragment);
      }
      return component;
    }
    function recomposeAuthority(component) {
      const uriTokens = [];
      if (component.userinfo !== void 0) {
        uriTokens.push(component.userinfo);
        uriTokens.push("@");
      }
      if (component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          const ipV6res = normalizeIPv6(host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = component.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof component.port === "number" || typeof component.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(component.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module2.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports2, module2) {
    "use strict";
    var { isUUID } = require_utils();
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    var supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      if (wsComponent.secure === true) {
        return true;
      } else if (wsComponent.secure === false) {
        return false;
      } else if (wsComponent.scheme) {
        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
      } else {
        return false;
      }
    }
    function httpParse(component) {
      if (!component.host) {
        component.error = component.error || "HTTP URIs must have a host.";
      }
      return component;
    }
    function httpSerialize(component) {
      const secure = String(component.scheme).toLowerCase() === "https";
      if (component.port === (secure ? 443 : 80) || component.port === "") {
        component.port = void 0;
      }
      if (!component.path) {
        component.path = "/";
      }
      return component;
    }
    function wsParse(wsComponent) {
      wsComponent.secure = wsIsSecure(wsComponent);
      wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
      wsComponent.path = void 0;
      wsComponent.query = void 0;
      return wsComponent;
    }
    function wsSerialize(wsComponent) {
      if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
        wsComponent.port = void 0;
      }
      if (typeof wsComponent.secure === "boolean") {
        wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
        wsComponent.secure = void 0;
      }
      if (wsComponent.resourceName) {
        const [path10, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path10 && path10 !== "/" ? path10 : void 0;
        wsComponent.query = query;
        wsComponent.resourceName = void 0;
      }
      wsComponent.fragment = void 0;
      return wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path) {
        urnComponent.error = "URN can not be parsed";
        return urnComponent;
      }
      const matches = urnComponent.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase();
        urnComponent.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
        const schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0;
        if (schemeHandler) {
          urnComponent = schemeHandler.parse(urnComponent, options);
        }
      } else {
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      }
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0) {
        throw new Error("URN without nid cannot be serialized");
      }
      const scheme = options.scheme || urnComponent.scheme || "urn";
      const nid = urnComponent.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      if (schemeHandler) {
        urnComponent = schemeHandler.serialize(urnComponent, options);
      }
      const uriComponent = urnComponent;
      const nss = urnComponent.nss;
      uriComponent.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      const uuidComponent = urnComponent;
      uuidComponent.uuid = uuidComponent.nss;
      uuidComponent.nss = void 0;
      if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
        uuidComponent.error = uuidComponent.error || "UUID is not valid.";
      }
      return uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      const urnComponent = uuidComponent;
      urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
      return urnComponent;
    }
    var http2 = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var https3 = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http2.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      }
    );
    var wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    );
    var urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      }
    );
    var urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      }
    );
    var SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http: http2,
        https: https3,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module2.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports2, module2) {
    "use strict";
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
    var { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize2(uri, options) {
      if (typeof uri === "string") {
        uri = /** @type {T} */
        serialize(parse3(uri, options), options);
      } else if (typeof uri === "object") {
        uri = /** @type {T} */
        parse3(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
      const resolved = resolveComponent(parse3(baseURI, schemelessOptions), parse3(relativeURI, schemelessOptions), schemelessOptions, true);
      schemelessOptions.skipEscape = true;
      return serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse3(serialize(base, options), options);
        relative = parse3(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path[0] === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse3(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse3(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
      if (component.path !== void 0) {
        if (!options.skipEscape) {
          component.path = escape(component.path);
          if (component.scheme !== void 0) {
            component.path = component.path.split("%3A").join(":");
          }
        } else {
          component.path = unescape(component.path);
        }
      }
      if (options.reference !== "suffix" && component.scheme) {
        uriTokens.push(component.scheme, ":");
      }
      const authority = recomposeAuthority(component);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (component.path && component.path[0] !== "/") {
          uriTokens.push("/");
        }
      }
      if (component.path !== void 0) {
        let s = component.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0 && s[0] === "/" && s[1] === "/") {
          s = "/%2F" + s.slice(2);
        }
        uriTokens.push(s);
      }
      if (component.query !== void 0) {
        uriTokens.push("?", component.query);
      }
      if (component.fragment !== void 0) {
        uriTokens.push("#", component.fragment);
      }
      return uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse3(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let isIP = false;
      if (options.reference === "suffix") {
        if (options.scheme) {
          uri = options.scheme + ":" + uri;
        } else {
          uri = "//" + uri;
        }
      }
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = isIPv4(parsed.host);
          if (ipv4result === false) {
            const ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (uri.indexOf("%") !== -1) {
            if (parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize: normalize2,
      resolve,
      resolveComponent,
      equal,
      serialize,
      parse: parse3
    };
    module2.exports = fastUri;
    module2.exports.default = fastUri;
    module2.exports.fastUri = fastUri;
  }
});

// node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str2, flags) => new RegExp(str2, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a4, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a4 = o.code) === null || _a4 === void 0 ? void 0 : _a4.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            checkLoaded.call(this, e);
            await loadMissingSchema.call(this, e.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports2.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a4;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a4 = definition.implements) === null || _a4 === void 0 ? void 0 : _a4.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env3, validateName, opts, self } = it;
        const { root } = env3;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env3 === root)
            return callRef(cxt, validateName, env3, env3.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env3, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env3.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e));
          addErrorsFrom(e);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a4;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a4 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a4 === void 0 ? void 0 : _a4.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error2 = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error: error2,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error: error2,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function ucs2length(str2) {
      const len = str2.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str2.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str2.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error2 = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error: error2,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error: error2,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error2 = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error: error2,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error2 = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error: error2,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error2 = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error: error2,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error2 = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error: error2,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error2 = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error: error2,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error2 = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error: error2,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error2 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: error2,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error2 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: error2,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error2 = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error: error2,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error2 = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: error2,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error2 = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error: error2,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error2 = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error: error2,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error2 = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error: error2,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports2.default = getApplicator;
  }
});

// node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error: error2,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports2.default = format;
  }
});

// node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports2.default = draft7Vocabularies;
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error2 = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: error2,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a4;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a4 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a4 === void 0 ? void 0 : _a4[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv = Ajv2;
    module2.exports = exports2 = Ajv2;
    module2.exports.Ajv = Ajv2;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports2.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date4, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports2.fastFormats = {
      ...exports2.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports2.formatNames = Object.keys(exports2.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date4(str2) {
      const matches = DATE.exec(str2);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function time3(str2) {
        const matches = TIME.exec(str2);
        if (!matches)
          return false;
        const hr = +matches[1];
        const min = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr <= 23 && min <= 59 && sec < 60)
          return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time3 = getTime(strictTimeZone);
      return function date_time(str2) {
        const dateTime = str2.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date4(dateTime[0]) && time3(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d2 = new Date(dt2).valueOf();
      if (!(d1 && d2))
        return void 0;
      return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str2) {
      return NOT_URI_FRAGMENT.test(str2) && URI.test(str2);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str2) {
      BYTE.lastIndex = 0;
      return BYTE.test(str2);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str2) {
      if (Z_ANCHOR.test(str2))
        return false;
      try {
        new RegExp(str2);
        return true;
      } catch (e) {
        return false;
      }
    }
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv();
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error2 = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports2.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error: error2,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format = fCxt.schema;
          const fmtDef = self.formats[format];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports2.formatLimitDefinition);
      return ajv;
    };
    exports2.default = formatLimitPlugin;
  }
});

// node_modules/ajv-formats/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv, list, formats, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs8, exportName) {
      var _a4;
      var _b;
      (_a4 = (_b = ajv.opts.code).formats) !== null && _a4 !== void 0 ? _a4 : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv.addFormat(f, fs8[f]);
    }
    module2.exports = exports2 = formatsPlugin;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = formatsPlugin;
  }
});

// src/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate,
  deactivate: () => deactivate
});
module.exports = __toCommonJS(extension_exports);
var vscode57 = __toESM(require("vscode"));

// src/accounts/index.ts
init_accountManager();
init_accountManagerPage();
init_accountQuotaCache();

// src/accounts/accountSyncAdapter.ts
init_providerKeys();
init_apiKeyManager();
init_logger();
init_accountManager();
var AccountSyncAdapter = class _AccountSyncAdapter {
  static instance;
  accountManager;
  disposables = [];
  constructor() {
    this.accountManager = AccountManager.getInstance();
    this.disposables.push(
      this.accountManager.onAccountChange(async (event) => {
        try {
          if (event.type === "added" || event.type === "switched" || event.type === "updated") {
            await this.syncToApiKeyManager(event.provider);
          } else if (event.type === "removed") {
            await this.handleAccountRemoval(event.provider);
          }
        } catch (error2) {
          Logger.warn(
            `Failed to sync ${event.provider} to ApiKeyManager:`,
            error2
          );
        }
      })
    );
  }
  /**
   * Initialize adapter
   */
  static initialize() {
    if (!_AccountSyncAdapter.instance) {
      _AccountSyncAdapter.instance = new _AccountSyncAdapter();
    }
    return _AccountSyncAdapter.instance;
  }
  /**
   * Get instance
   */
  static getInstance() {
    if (!_AccountSyncAdapter.instance) {
      throw new Error("AccountSyncAdapter not initialized");
    }
    return _AccountSyncAdapter.instance;
  }
  /**
   * Sync Antigravity account from ApiKeyManager
   */
  async syncAntigravityAccount() {
    try {
      const stored = await ApiKeyManager.getApiKey("antigravity" /* Antigravity */);
      if (!stored) {
        return;
      }
      const authData = JSON.parse(stored);
      const existingAccounts = this.accountManager.getAccountsByProvider(
        "antigravity" /* Antigravity */
      );
      const existingByEmail = existingAccounts.find(
        (acc) => acc.email === authData.email
      );
      if (existingByEmail) {
        const credentials = {
          accessToken: authData.access_token,
          refreshToken: authData.refresh_token,
          expiresAt: authData.expires_at
        };
        await this.accountManager.updateCredentials(
          existingByEmail.id,
          credentials
        );
        Logger.debug(`Updated Antigravity account: ${authData.email}`);
      } else {
        const displayName = authData.email || "Antigravity Account";
        const credentials = {
          accessToken: authData.access_token,
          refreshToken: authData.refresh_token,
          expiresAt: authData.expires_at
        };
        await this.accountManager.addOAuthAccount(
          "antigravity" /* Antigravity */,
          displayName,
          authData.email || "",
          credentials,
          { projectId: authData.project_id }
        );
        Logger.info(`Synced Antigravity account: ${displayName}`);
      }
    } catch (error2) {
      Logger.error("Failed to sync Antigravity account:", error2);
    }
  }
  /**
   * Sync Codex account from ApiKeyManager
   */
  async syncCodexAccount() {
    try {
      const stored = await ApiKeyManager.getApiKey("codex");
      if (!stored) {
        return;
      }
      const authData = JSON.parse(stored);
      const existingAccounts = this.accountManager.getAccountsByProvider("codex");
      const existingByEmail = existingAccounts.find(
        (acc) => acc.email === authData.email
      );
      if (existingByEmail) {
        const credentials = {
          accessToken: authData.access_token,
          refreshToken: authData.refresh_token,
          expiresAt: authData.expires_at
        };
        await this.accountManager.updateCredentials(
          existingByEmail.id,
          credentials
        );
        Logger.debug(`Updated Codex account: ${authData.email}`);
      } else {
        const displayName = authData.email || "Codex Account";
        const credentials = {
          accessToken: authData.access_token,
          refreshToken: authData.refresh_token,
          expiresAt: authData.expires_at
        };
        await this.accountManager.addOAuthAccount(
          "codex",
          displayName,
          authData.email || "",
          credentials
        );
        Logger.info(`Synced Codex account: ${displayName}`);
      }
    } catch (error2) {
      Logger.error("Failed to sync Codex account:", error2);
    }
  }
  /**
   * Sync API Key account from ApiKeyManager
   */
  async syncApiKeyAccount(provider, displayName) {
    try {
      const apiKey = await ApiKeyManager.getApiKey(provider);
      if (!apiKey) {
        return;
      }
      const existingAccounts = this.accountManager.getAccountsByProvider(provider);
      if (existingAccounts.length === 0) {
        const name = displayName || `${provider} Account`;
        await this.accountManager.addApiKeyAccount(provider, name, apiKey);
        Logger.info(`Synced ${provider} account from ApiKeyManager`);
      }
    } catch (error2) {
      Logger.error(`Failed to sync ${provider} account:`, error2);
    }
  }
  /**
   * Sync all accounts from ApiKeyManager
   */
  async syncAllAccounts() {
    const providers2 = ["zhipu", "moonshot", "minimax", "deepseek"];
    await this.syncAntigravityAccount();
    await this.syncCodexAccount();
    for (const provider of providers2) {
      await this.syncApiKeyAccount(provider);
    }
    const allProviders = [
      "antigravity" /* Antigravity */,
      ProviderKey.Codex,
      ...providers2
    ];
    for (const provider of allProviders) {
      await this.syncToApiKeyManager(provider);
    }
  }
  /**
   * When a new account is added via AccountManager,
   * update ApiKeyManager for backward compatibility
   */
  async syncToApiKeyManager(provider) {
    const activeCredentials = await this.accountManager.getActiveCredentials(provider);
    if (!activeCredentials) {
      return;
    }
    if ("apiKey" in activeCredentials) {
      await ApiKeyManager.setApiKey(provider, activeCredentials.apiKey);
    } else if ("accessToken" in activeCredentials && provider === "antigravity" /* Antigravity */) {
      const account = this.accountManager.getActiveAccount(provider);
      const authData = {
        type: "antigravity" /* Antigravity */,
        access_token: activeCredentials.accessToken,
        refresh_token: activeCredentials.refreshToken,
        email: account?.email || "",
        project_id: account?.metadata?.projectId || "",
        expires_at: activeCredentials.expiresAt,
        timestamp: Date.now()
      };
      await ApiKeyManager.setApiKey(
        "antigravity" /* Antigravity */,
        JSON.stringify(authData)
      );
    } else if ("accessToken" in activeCredentials && provider === ProviderKey.Codex) {
      const account = this.accountManager.getActiveAccount(provider);
      const existingData = await ApiKeyManager.getApiKey("codex");
      let existingParsed = {};
      if (existingData) {
        try {
          existingParsed = JSON.parse(existingData);
        } catch (_e) {
        }
      }
      const authData = {
        type: "codex",
        access_token: activeCredentials.accessToken,
        refresh_token: activeCredentials.refreshToken,
        email: account?.email || "",
        // IMPORTANT: Preserve these fields from existing storage
        account_id: existingParsed.account_id || account?.metadata?.accountId,
        organization_id: existingParsed.organization_id,
        project_id: existingParsed.project_id,
        organizations: existingParsed.organizations,
        expires_at: activeCredentials.expiresAt,
        timestamp: Date.now()
      };
      Logger.info(
        "[accountSync] Preserving Codex account/org data during sync"
      );
      await ApiKeyManager.setApiKey("codex", JSON.stringify(authData));
    }
  }
  /**
   * When an account is removed, update or delete ApiKeyManager to avoid reverse sync
   */
  async handleAccountRemoval(provider) {
    const remainingAccounts = this.accountManager.getAccountsByProvider(provider);
    if (remainingAccounts.length === 0) {
      await ApiKeyManager.deleteApiKey(provider);
      return;
    }
    await this.syncToApiKeyManager(provider);
  }
  /**
   * Dispose
   */
  dispose() {
    for (const disposable of this.disposables) {
      disposable.dispose();
    }
  }
};

// src/accounts/accountUI.ts
var vscode10 = __toESM(require("vscode"));
init_auth();
init_providerKeys();
init_logger();
init_accountManager();
var AccountUI = class _AccountUI {
  static instance;
  accountManager;
  constructor() {
    this.accountManager = AccountManager.getInstance();
  }
  /**
   * Get instance
   */
  static getInstance() {
    if (!_AccountUI.instance) {
      _AccountUI.instance = new _AccountUI();
    }
    return _AccountUI.instance;
  }
  /**
   * Show main account management menu
   */
  async showAccountManager() {
    const items = [
      {
        label: "$(window) Open Account Manager",
        description: "Open full account management page",
        detail: "Visual interface for managing all accounts"
      },
      {
        label: "$(add) Add New Account",
        description: "Add a new account for any provider",
        detail: "Add API Key or OAuth account"
      },
      {
        label: "$(list-unordered) View All Accounts",
        description: "View and manage all accounts",
        detail: `${this.accountManager.getAllAccounts().length} accounts configured`
      },
      {
        label: "$(arrow-swap) Switch Account",
        description: "Switch active account for a provider",
        detail: "Change which account is used for requests"
      },
      {
        label: "$(trash) Remove Account",
        description: "Remove an existing account",
        detail: "Delete account and its credentials"
      },
      {
        label: "$(settings) Antigravity Model Routing",
        description: "Assign Antigravity models to accounts",
        detail: "Choose which account handles each model"
      },
      {
        label: "$(pulse) Antigravity Load Balance",
        description: this.accountManager.getLoadBalanceEnabled(
          "antigravity" /* Antigravity */
        ) ? "Enabled" : "Disabled",
        detail: "Auto switch accounts when quota is hit"
      }
    ];
    const selected = await vscode10.window.showQuickPick(items, {
      title: "Account Manager",
      placeHolder: "Select an action"
    });
    if (!selected) {
      return;
    }
    switch (selected.label) {
      case "$(window) Open Account Manager":
        await vscode10.commands.executeCommand("chp.accounts.openManager");
        break;
      case "$(add) Add New Account":
        await this.showAddAccountFlow();
        break;
      case "$(list-unordered) View All Accounts":
        await this.showAllAccounts();
        break;
      case "$(arrow-swap) Switch Account":
        await this.showSwitchAccountFlow();
        break;
      case "$(trash) Remove Account":
        await this.showRemoveAccountFlow();
        break;
      case "$(settings) Antigravity Model Routing":
        await this.showAntigravityModelRouting();
        break;
      case "$(pulse) Antigravity Load Balance":
        await this.showAntigravityLoadBalanceToggle();
        break;
    }
  }
  /**
   * Add account flow
   */
  async showAddAccountFlow() {
    const providers2 = [
      {
        label: "Antigravity (Google)",
        value: "antigravity" /* Antigravity */,
        authType: "oauth"
      },
      {
        label: "Codex (OpenAI)",
        value: ProviderKey.Codex,
        authType: "oauth"
      },
      {
        label: "ZhipuAI",
        value: "zhipu" /* Zhipu */,
        authType: "apiKey"
      },
      {
        label: "Moonshot",
        value: "moonshot" /* Moonshot */,
        authType: "apiKey"
      },
      {
        label: "MiniMax",
        value: "minimax" /* MiniMax */,
        authType: "apiKey"
      },
      { label: "DeepSeek", value: "deepseek", authType: "apiKey" },
      { label: "DeepInfra", value: "deepinfra", authType: "apiKey" },
      {
        label: "Compatible (Custom)",
        value: "compatible" /* Compatible */,
        authType: "apiKey"
      }
    ];
    const providerItems = providers2.map((p) => ({
      label: p.label,
      description: p.authType === "oauth" ? "OAuth Login" : "API Key",
      provider: p.value,
      authType: p.authType
    }));
    const selectedProvider = await vscode10.window.showQuickPick(providerItems, {
      title: "Add Account - Select Provider",
      placeHolder: "Choose a provider"
    });
    if (!selectedProvider) {
      return;
    }
    if (selectedProvider.authType === "oauth") {
      await this.addOAuthAccount(selectedProvider.provider);
    } else {
      await this.addApiKeyAccount(
        selectedProvider.provider,
        selectedProvider.label
      );
    }
  }
  /**
   * Add API Key account
   */
  async addApiKeyAccount(provider, providerLabel) {
    const displayName = await vscode10.window.showInputBox({
      title: `Add ${providerLabel} Account`,
      prompt: "Enter a display name for this account",
      placeHolder: "e.g., Work Account, Personal, etc.",
      validateInput: (value) => {
        if (!value || value.trim().length === 0) {
          return "Display name is required";
        }
        return void 0;
      }
    });
    if (!displayName) {
      return;
    }
    const apiKey = await vscode10.window.showInputBox({
      title: `Add ${providerLabel} Account`,
      prompt: `Enter your ${providerLabel} API Key`,
      password: true,
      placeHolder: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      validateInput: (value) => {
        if (!value || value.trim().length === 0) {
          return "API Key is required";
        }
        return void 0;
      }
    });
    if (!apiKey) {
      return;
    }
    const endpoint = await vscode10.window.showInputBox({
      title: `Add ${providerLabel} Account`,
      prompt: "Enter custom base URL or proxy endpoint (optional)",
      placeHolder: "http://154.53.47.9:8000/v1 or https://proxy.example.com/v1",
      validateInput: (value) => {
        if (value && value.trim().length > 0) {
          if (!value.startsWith("http://") && !value.startsWith("https://")) {
            return "Base URL must start with http:// or https://";
          }
        }
        return void 0;
      }
    });
    const result = await this.accountManager.addApiKeyAccount(
      provider,
      displayName.trim(),
      apiKey.trim(),
      {
        endpoint: endpoint ? endpoint.trim() : void 0
      }
    );
    if (result.success) {
      vscode10.window.showInformationMessage(
        `Account "${displayName}" added successfully for ${providerLabel}`
      );
    } else {
      vscode10.window.showErrorMessage(`Failed to add account: ${result.error}`);
    }
  }
  /**
   * Add OAuth account (Antigravity)
   */
  async addOAuthAccount(provider) {
    if (provider === "antigravity" /* Antigravity */) {
      try {
        const { doAntigravityLoginForNewAccount: doAntigravityLoginForNewAccount2 } = await Promise.resolve().then(() => (init_auth(), auth_exports));
        await doAntigravityLoginForNewAccount2();
      } catch (error2) {
        Logger.error("OAuth login failed:", error2);
        vscode10.window.showErrorMessage("OAuth login failed. Please try again.");
      }
    } else if (provider === ProviderKey.Codex) {
      try {
        const { doCodexLoginForNewAccount } = await import("../providers/codex/codexAuth.js");
        await doCodexLoginForNewAccount();
      } catch (error2) {
        Logger.error("Codex OAuth login failed:", error2);
        vscode10.window.showErrorMessage(
          "Codex OAuth login failed. Please try again."
        );
      }
    }
  }
  /**
   * Show all accounts
   */
  async showAllAccounts() {
    const accounts = this.accountManager.getAllAccounts();
    if (accounts.length === 0) {
      const action = await vscode10.window.showInformationMessage(
        "No accounts configured yet.",
        "Add Account"
      );
      if (action === "Add Account") {
        await this.showAddAccountFlow();
      }
      return;
    }
    const accountsByProvider = /* @__PURE__ */ new Map();
    for (const account of accounts) {
      const list = accountsByProvider.get(account.provider) || [];
      list.push(account);
      accountsByProvider.set(account.provider, list);
    }
    const items = [];
    for (const [provider, providerAccounts] of accountsByProvider) {
      items.push({
        label: provider.toUpperCase(),
        kind: vscode10.QuickPickItemKind.Separator
      });
      for (const account of providerAccounts) {
        const isActive = account.isDefault;
        const statusIcon = this.getStatusIcon(account.status);
        const activeIcon = isActive ? "$(check) " : "";
        items.push({
          label: `${activeIcon}${statusIcon} ${account.displayName}`,
          description: account.email || account.authType,
          detail: `Created: ${new Date(account.createdAt).toLocaleDateString()} | Status: ${account.status}`
        });
      }
    }
    await vscode10.window.showQuickPick(items, {
      title: "All Accounts",
      placeHolder: "View your configured accounts"
    });
  }
  /**
   * Flow to switch account
   */
  async showSwitchAccountFlow() {
    const accounts = this.accountManager.getAllAccounts();
    const providerCounts = /* @__PURE__ */ new Map();
    for (const account of accounts) {
      providerCounts.set(
        account.provider,
        (providerCounts.get(account.provider) || 0) + 1
      );
    }
    const providersWithMultiple = Array.from(providerCounts.entries()).filter(([_, count]) => count > 1).map(([provider]) => provider);
    if (providersWithMultiple.length === 0) {
      vscode10.window.showInformationMessage(
        "No providers have multiple accounts. Add more accounts first."
      );
      return;
    }
    const providerItems = providersWithMultiple.map((p) => ({
      label: p.charAt(0).toUpperCase() + p.slice(1),
      description: `${providerCounts.get(p)} accounts`,
      provider: p
    }));
    const selectedProvider = await vscode10.window.showQuickPick(providerItems, {
      title: "Switch Account - Select Provider",
      placeHolder: "Choose a provider"
    });
    if (!selectedProvider) {
      return;
    }
    const providerAccounts = this.accountManager.getAccountsByProvider(
      selectedProvider.provider
    );
    const accountItems = providerAccounts.map(
      (account) => ({
        label: `${account.isDefault ? "$(check) " : ""}${account.displayName}`,
        description: account.email || account.authType,
        detail: account.isDefault ? "Currently active" : "Click to switch",
        account
      })
    );
    const selectedAccount = await vscode10.window.showQuickPick(accountItems, {
      title: `Switch ${selectedProvider.label} Account`,
      placeHolder: "Select an account to switch to"
    });
    if (!selectedAccount || selectedAccount.account.isDefault) {
      return;
    }
    const success = await this.accountManager.switchAccount(
      selectedProvider.provider,
      selectedAccount.account.id
    );
    if (success) {
      vscode10.window.showInformationMessage(
        `Switched to "${selectedAccount.account.displayName}"`
      );
    } else {
      vscode10.window.showErrorMessage(
        `Failed to switch to "${selectedAccount.account.displayName}"`
      );
    }
  }
  /**
   * Flow to remove account
   */
  async showRemoveAccountFlow() {
    const accounts = this.accountManager.getAllAccounts();
    if (accounts.length === 0) {
      vscode10.window.showInformationMessage("No accounts to remove.");
      return;
    }
    const accountItems = accounts.map((account) => ({
      label: `${account.displayName}`,
      description: `${account.provider} - ${account.email || account.authType}`,
      detail: account.isDefault ? "This is the active account" : void 0,
      account
    }));
    const selectedAccount = await vscode10.window.showQuickPick(accountItems, {
      title: "Remove Account",
      placeHolder: "Select an account to remove"
    });
    if (!selectedAccount) {
      return;
    }
    const confirm = await vscode10.window.showWarningMessage(
      `Are you sure you want to remove "${selectedAccount.account.displayName}"?`,
      { modal: true },
      "Remove"
    );
    if (confirm !== "Remove") {
      return;
    }
    const success = await this.accountManager.removeAccount(
      selectedAccount.account.id
    );
    if (success) {
      vscode10.window.showInformationMessage(
        `Account "${selectedAccount.account.displayName}" removed`
      );
    } else {
      vscode10.window.showErrorMessage("Failed to remove account");
    }
  }
  /**
   * Show quick pick to select an account for a provider
   */
  async showAccountPicker(provider) {
    const accounts = this.accountManager.getAccountsByProvider(provider);
    if (accounts.length === 0) {
      const action = await vscode10.window.showInformationMessage(
        `No ${provider} accounts configured.`,
        "Add Account"
      );
      if (action === "Add Account") {
        await this.addApiKeyAccount(provider, provider);
        return this.accountManager.getActiveAccount(provider);
      }
      return void 0;
    }
    if (accounts.length === 1) {
      return accounts[0];
    }
    const accountItems = accounts.map((account) => ({
      label: `${account.isDefault ? "$(check) " : ""}${account.displayName}`,
      description: account.email || account.authType,
      account
    }));
    const selected = await vscode10.window.showQuickPick(accountItems, {
      title: `Select ${provider} Account`,
      placeHolder: "Choose an account"
    });
    return selected?.account;
  }
  /**
   * Choose account per Antigravity model
   */
  async showAntigravityModelRouting() {
    const provider = "antigravity" /* Antigravity */;
    const accounts = this.accountManager.getAccountsByProvider(provider);
    if (accounts.length === 0) {
      vscode10.window.showInformationMessage(
        "No Antigravity accounts configured. Add an account first."
      );
      return;
    }
    let models = await AntigravityAuth.getCachedModels();
    if (models.length === 0) {
      models = await AntigravityAuth.getModels();
    }
    if (models.length === 0) {
      vscode10.window.showWarningMessage(
        "No Antigravity models available. Please login and refresh models."
      );
      return;
    }
    const assignments = this.accountManager.getModelAccountAssignments(provider);
    const modelItems = models.map((model) => {
      const assignedId = assignments[model.id];
      const assignedAccount = accounts.find((acc) => acc.id === assignedId);
      return {
        label: model.displayName || model.name,
        description: model.id,
        detail: assignedAccount ? `Assigned to ${assignedAccount.displayName}` : "Auto (use active account or load balance)",
        modelId: model.id
      };
    });
    const selectedModel = await vscode10.window.showQuickPick(modelItems, {
      title: "Antigravity Model Routing",
      placeHolder: "Select a model to assign"
    });
    if (!selectedModel) {
      return;
    }
    const accountItems = [
      {
        label: "$(circle-outline) Auto",
        description: "Use active account or load balance",
        accountId: void 0
      },
      ...accounts.map((account) => ({
        label: `${account.isDefault ? "$(check) " : ""}${account.displayName}`,
        description: account.email || account.authType,
        detail: account.status === "active" ? void 0 : `Status: ${account.status}`,
        accountId: account.id
      }))
    ];
    const selectedAccount = await vscode10.window.showQuickPick(accountItems, {
      title: `Assign Account for ${selectedModel.label}`,
      placeHolder: "Select an account"
    });
    if (!selectedAccount) {
      return;
    }
    await this.accountManager.setAccountForModel(
      provider,
      selectedModel.modelId,
      selectedAccount.accountId
    );
    const resultLabel = selectedAccount.accountId ? selectedAccount.label.replace(/^\$\(check\)\s*/, "") : "Auto";
    vscode10.window.showInformationMessage(
      `Updated routing for ${selectedModel.label}: ${resultLabel}`
    );
  }
  /**
   * Toggle load balance for Antigravity
   */
  async showAntigravityLoadBalanceToggle() {
    const provider = "antigravity" /* Antigravity */;
    const enabled = this.accountManager.getLoadBalanceEnabled(provider);
    const action = await vscode10.window.showQuickPick(
      [
        {
          label: enabled ? "Disable Load Balance" : "Enable Load Balance",
          description: enabled ? "Keep current account selection" : "Auto switch on quota limits"
        }
      ],
      {
        title: "Antigravity Load Balance",
        placeHolder: "Toggle load balance"
      }
    );
    if (!action) {
      return;
    }
    await this.accountManager.setLoadBalanceEnabled(provider, !enabled);
    vscode10.window.showInformationMessage(
      `Antigravity load balance ${!enabled ? "enabled" : "disabled"}.`
    );
  }
  /**
   * Quick Switch - Fast account switch with one click
   * Show all accounts by provider, allow immediate switching
   */
  async showQuickSwitch() {
    const accounts = this.accountManager.getAllAccounts();
    if (accounts.length === 0) {
      const action = await vscode10.window.showInformationMessage(
        "No accounts configured. Add your first account?",
        "Add Account"
      );
      if (action === "Add Account") {
        await this.showAddAccountFlow();
      }
      return;
    }
    const accountsByProvider = /* @__PURE__ */ new Map();
    for (const account of accounts) {
      const list = accountsByProvider.get(account.provider) || [];
      list.push(account);
      accountsByProvider.set(account.provider, list);
    }
    const quickPick = vscode10.window.createQuickPick();
    quickPick.title = "Quick Switch Account";
    quickPick.placeholder = "Select an account to switch to (or type to filter)";
    quickPick.matchOnDescription = true;
    quickPick.matchOnDetail = true;
    const items = [];
    for (const [provider, providerAccounts] of accountsByProvider) {
      items.push({
        label: `$(folder) ${this.getProviderDisplayName(provider)}`,
        kind: vscode10.QuickPickItemKind.Separator,
        account: null,
        provider
      });
      for (const account of providerAccounts) {
        const isActive = account.isDefault;
        const statusIcon = this.getStatusIcon(account.status);
        items.push({
          label: `${isActive ? "$(check) " : "    "}${statusIcon} ${account.displayName}`,
          description: `${provider}${account.email ? ` \u2022 ${account.email}` : ""}`,
          detail: isActive ? "$(star-full) Currently active" : "$(arrow-right) Click to switch",
          account,
          provider,
          buttons: isActive ? [] : [
            {
              iconPath: new vscode10.ThemeIcon("arrow-swap"),
              tooltip: "Switch to this account"
            }
          ]
        });
      }
    }
    items.push({
      label: "",
      kind: vscode10.QuickPickItemKind.Separator,
      account: null
    });
    items.push({
      label: "$(add) Add New Account",
      description: "Add a new account for any provider",
      account: null,
      alwaysShow: true
    });
    items.push({
      label: "$(settings-gear) Open Account Manager",
      description: "Full account management interface",
      account: null,
      alwaysShow: true
    });
    items.push({
      label: "$(gear) Open Settings",
      description: "Configure Copilot ++ extension settings",
      account: null,
      alwaysShow: true
    });
    quickPick.items = items;
    quickPick.onDidAccept(async () => {
      const selected = quickPick.selectedItems[0];
      quickPick.hide();
      if (!selected) {
        return;
      }
      if (selected.label === "$(add) Add New Account") {
        await this.showAddAccountFlow();
        return;
      }
      if (selected.label === "$(settings-gear) Open Account Manager") {
        await vscode10.commands.executeCommand("chp.accounts.openManager");
        return;
      }
      if (selected.label === "$(gear) Open Settings") {
        await vscode10.commands.executeCommand("chp.openSettings");
        return;
      }
      if (selected.account && !selected.account.isDefault) {
        await this.switchToAccount(selected.account);
      }
    });
    quickPick.onDidTriggerItemButton(async (e) => {
      const item = e.item;
      if (item.account && !item.account.isDefault) {
        quickPick.hide();
        await this.switchToAccount(item.account);
      }
    });
    quickPick.onDidHide(() => quickPick.dispose());
    quickPick.show();
  }
  /**
   * Quick Switch for a specific provider
   * Show only accounts for that provider
   */
  async showQuickSwitchForProvider(provider) {
    const accounts = this.accountManager.getAccountsByProvider(provider);
    if (accounts.length === 0) {
      const action = await vscode10.window.showInformationMessage(
        `No ${this.getProviderDisplayName(provider)} accounts configured.`,
        "Add Account"
      );
      if (action === "Add Account") {
        await this.showAddAccountFlow();
      }
      return;
    }
    if (accounts.length === 1) {
      vscode10.window.showInformationMessage(
        `Only one ${this.getProviderDisplayName(provider)} account configured: ${accounts[0].displayName}`
      );
      return;
    }
    const quickPick = vscode10.window.createQuickPick();
    quickPick.title = `Switch ${this.getProviderDisplayName(provider)} Account`;
    quickPick.placeholder = "Select an account to switch to";
    const items = accounts.map((account) => {
      const isActive = account.isDefault;
      const statusIcon = this.getStatusIcon(account.status);
      return {
        label: `${isActive ? "$(check) " : ""}${statusIcon} ${account.displayName}`,
        description: account.email || account.authType,
        detail: isActive ? "$(star-full) Currently active" : "$(arrow-right) Click to switch",
        account
      };
    });
    quickPick.items = items;
    quickPick.onDidAccept(async () => {
      const selected = quickPick.selectedItems[0];
      quickPick.hide();
      if (selected?.account && !selected.account.isDefault) {
        await this.switchToAccount(selected.account);
      }
    });
    quickPick.onDidHide(() => quickPick.dispose());
    quickPick.show();
  }
  /**
   * Switch to the selected account
   */
  async switchToAccount(account) {
    const success = await this.accountManager.switchAccount(
      account.provider,
      account.id
    );
    if (success) {
      vscode10.window.showInformationMessage(
        `Now using: ${account.displayName} (${this.getProviderDisplayName(account.provider)})`
      );
    } else {
      vscode10.window.showErrorMessage(
        `Failed to switch to "${account.displayName}"`
      );
    }
  }
  /**
   * Get provider display name
   */
  getProviderDisplayName(provider) {
    const names = {
      antigravity: "Antigravity (Google)",
      codex: "Codex (OpenAI)",
      zhipu: "ZhipuAI",
      moonshot: "Moonshot",
      minimax: "MiniMax",
      deepseek: "DeepSeek",
      deepinfra: "DeepInfra",
      compatible: "Compatible"
    };
    return names[provider] || provider.charAt(0).toUpperCase() + provider.slice(1);
  }
  /**
   * Get status icon
   */
  getStatusIcon(status) {
    switch (status) {
      case "active":
        return "$(pass-filled)";
      case "inactive":
        return "$(circle-outline)";
      case "expired":
        return "$(warning)";
      case "error":
        return "$(error)";
      default:
        return "$(question)";
    }
  }
};
function registerAccountCommands(_context) {
  const disposables = [];
  disposables.push(
    vscode10.commands.registerCommand("chp.accounts.manage", async () => {
      const ui = AccountUI.getInstance();
      await ui.showAccountManager();
    })
  );
  disposables.push(
    vscode10.commands.registerCommand("chp.accounts.add", async () => {
      const ui = AccountUI.getInstance();
      await ui.showAddAccountFlow();
    })
  );
  disposables.push(
    vscode10.commands.registerCommand("chp.accounts.switch", async () => {
      const ui = AccountUI.getInstance();
      await ui.showSwitchAccountFlow();
    })
  );
  disposables.push(
    vscode10.commands.registerCommand("chp.accounts.remove", async () => {
      const ui = AccountUI.getInstance();
      await ui.showRemoveAccountFlow();
    })
  );
  disposables.push(
    vscode10.commands.registerCommand("chp.accounts.list", async () => {
      const ui = AccountUI.getInstance();
      await ui.showAllAccounts();
    })
  );
  disposables.push(
    vscode10.commands.registerCommand("chp.accounts.openManager", async () => {
      const { AccountManagerPage: AccountManagerPage2 } = await Promise.resolve().then(() => (init_accountManagerPage(), accountManagerPage_exports));
      const page = AccountManagerPage2.getInstance();
      await page.show();
    })
  );
  disposables.push(
    vscode10.commands.registerCommand("chp.accounts.quickSwitch", async () => {
      const ui = AccountUI.getInstance();
      await ui.showQuickSwitch();
    })
  );
  disposables.push(
    vscode10.commands.registerCommand(
      "chp.accounts.quickSwitchProvider",
      async (provider) => {
        const ui = AccountUI.getInstance();
        if (provider) {
          await ui.showQuickSwitchForProvider(provider);
        } else {
          await ui.showQuickSwitch();
        }
      }
    )
  );
  return disposables;
}

// src/copilot/inlineCompletionShim.ts
var vscode12 = __toESM(require("vscode"));

// src/copilot/singletons.ts
init_apiKeyManager();

// src/utils/completionLogger.ts
var vscode11 = __toESM(require("vscode"));
var CompletionLogger = class _CompletionLogger {
  static outputChannel;
  /**
   * Initialize high-frequency status logger manager
   */
  static initialize(channelName = "CHP-Completion") {
    _CompletionLogger.outputChannel = vscode11.window.createOutputChannel(
      channelName,
      { log: true }
    );
  }
  /**
   * Trace level log (VS Code LogLevel.Trace = 1)
   */
  static trace(message, ...args) {
    if (_CompletionLogger.outputChannel) {
      _CompletionLogger.outputChannel.trace(message, ...args);
    }
  }
  /**
   * Debug level log (VS Code LogLevel.Debug = 2)
   */
  static debug(message, ...args) {
    if (_CompletionLogger.outputChannel) {
      _CompletionLogger.outputChannel.debug(message, ...args);
    }
  }
  /**
   * Info level log (VS Code LogLevel.Info = 3)
   */
  static info(message, ...args) {
    if (_CompletionLogger.outputChannel) {
      _CompletionLogger.outputChannel.info(message, ...args);
    }
  }
  /**
   * Warning level log (VS Code LogLevel.Warning = 4)
   */
  static warn(message, ...args) {
    if (_CompletionLogger.outputChannel) {
      _CompletionLogger.outputChannel.warn(message, ...args);
    }
  }
  /**
   * Error level log (VS Code LogLevel.Error = 5)
   */
  static error(message, ...args) {
    if (_CompletionLogger.outputChannel) {
      _CompletionLogger.outputChannel.error(message, ...args);
    }
  }
  /**
   * Dispose logger manager
   */
  static dispose() {
    if (_CompletionLogger.outputChannel) {
      _CompletionLogger.outputChannel.dispose();
    }
  }
};

// src/copilot/singletons.ts
init_configManager();
function getCompletionLogger() {
  return globalThis.__chp_singletons?.CompletionLogger || CompletionLogger;
}

// src/copilot/inlineCompletionShim.ts
var InlineCompletionShim = class _InlineCompletionShim {
  constructor(context) {
    this.context = context;
    this.disposables.push(this.onDidChangeEmitter);
  }
  disposables = [];
  onDidChangeEmitter = new vscode12.EventEmitter();
  onDidChange = this.onDidChangeEmitter.event;
  // Complete InlineCompletionProvider instance (lazy loaded)
  _realProvider = null;
  _loadingPromise = null;
  // ========================================================================
  // Configuration detection
  // ========================================================================
  /**
   * Check if FIM is enabled
   */
  isFIMEnabled() {
    const config2 = vscode12.workspace.getConfiguration("chp.fimCompletion");
    return config2.get("enabled", false);
  }
  /**
   * Check if NES is enabled
   */
  isNESEnabled() {
    const config2 = vscode12.workspace.getConfiguration("chp.nesCompletion");
    return config2.get("enabled", false);
  }
  // ========================================================================
  // Lazy loading
  // ========================================================================
  /**
   * Lazy load the complete copilot module
   */
  async loadRealProvider() {
    if (this._realProvider) {
      return this._realProvider;
    }
    if (this._loadingPromise) {
      return this._loadingPromise;
    }
    this._loadingPromise = (async () => {
      try {
        const CompletionLogger2 = getCompletionLogger();
        const startTime = Date.now();
        CompletionLogger2.trace(
          "[InlineCompletionShim] Starting to load copilot module..."
        );
        const copilotModule = require("../dist/copilot.bundle.js");
        const { InlineCompletionProvider } = copilotModule;
        this._realProvider = new InlineCompletionProvider(this.context);
        this._realProvider.activate();
        const forwardDisposable = this._realProvider.onDidChange(() => {
          this.onDidChangeEmitter.fire();
        });
        this.disposables.push(forwardDisposable);
        const loadTime = Date.now() - startTime;
        CompletionLogger2.info(
          `[InlineCompletionShim] copilot module loading complete (elapsed: ${loadTime}ms)`
        );
        return this._realProvider;
      } catch (error2) {
        const CompletionLogger2 = getCompletionLogger();
        CompletionLogger2.error(
          "[InlineCompletionShim] Failed to load copilot module:",
          error2
        );
        this._loadingPromise = null;
        return null;
      }
    })();
    return this._loadingPromise;
  }
  // ========================================================================
  // Activation and initialization
  // ========================================================================
  activate() {
    const CompletionLogger2 = getCompletionLogger();
    CompletionLogger2.trace(
      "[InlineCompletionShim] Activate lightweight proxy (lazy loading mode)"
    );
    try {
      const provider = vscode12.languages.registerInlineCompletionItemProvider(
        { pattern: "**/*" },
        this
      );
      this.disposables.push(provider);
      this.disposables.push(
        vscode12.commands.registerCommand(
          "chp.nesCompletion.toggleManual",
          async () => {
            const CompletionLogger3 = getCompletionLogger();
            const config2 = vscode12.workspace.getConfiguration("chp.nesCompletion");
            const currentState = config2.get("manualOnly", false);
            const newState = !currentState;
            await vscode12.workspace.getConfiguration("chp.nesCompletion").update(
              "manualOnly",
              newState,
              vscode12.ConfigurationTarget.Global
            );
            vscode12.window.showInformationMessage(
              `Copilot ++: Next Edit Suggestion Trigger Mode: ${newState ? "Manual Trigger" : "Auto Trigger"}`
            );
            CompletionLogger3.info(
              `[InlineCompletionShim] NES manual trigger mode ${newState ? "enabled" : "disabled"}`
            );
          }
        )
      );
      CompletionLogger2.info(
        "[InlineCompletionShim] Activated (using lazy loading strategy)"
      );
    } catch (error2) {
      CompletionLogger2.error(
        "[InlineCompletionShim] Activation failed:",
        error2
      );
      throw error2;
    }
  }
  // ========================================================================
  // InlineCompletionItemProvider implementation
  // ========================================================================
  async provideInlineCompletionItems(document, position, context, token) {
    if (!this.isFIMEnabled() && !this.isNESEnabled()) {
      return void 0;
    }
    const realProvider = await this.loadRealProvider();
    if (realProvider && !token.isCancellationRequested) {
      try {
        const result = await realProvider.provideInlineCompletionItems(
          document,
          position,
          context,
          token
        );
        return result ?? void 0;
      } catch (error2) {
        const CompletionLogger2 = getCompletionLogger();
        CompletionLogger2.error(
          "[InlineCompletionShim] Completion request failed:",
          error2
        );
        return void 0;
      }
    }
    return void 0;
  }
  // ========================================================================
  // Resource cleanup
  // ========================================================================
  dispose() {
    const CompletionLogger2 = getCompletionLogger();
    CompletionLogger2.trace("[InlineCompletionShim] Start releasing resources");
    if (this._realProvider) {
      this._realProvider.dispose();
      this._realProvider = null;
    }
    this.disposables.forEach((d) => {
      try {
        d.dispose();
      } catch (error2) {
        const CompletionLogger3 = getCompletionLogger();
        CompletionLogger3.warn(
          "[InlineCompletionShim] Error releasing resources:",
          error2
        );
      }
    });
    this.disposables.length = 0;
    CompletionLogger2.info("[InlineCompletionShim] All resources released");
  }
  /**
   * Create and activate Shim
   */
  static createAndActivate(context) {
    const provider = new _InlineCompletionShim(context);
    provider.activate();
    return { provider, disposables: provider.disposables };
  }
};

// src/providers/antigravity/provider.ts
var vscode33 = __toESM(require("vscode"));
init_providerKeys();

// node_modules/@anthropic-ai/sdk/internal/tslib.mjs
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/@anthropic-ai/sdk/internal/utils/uuid.mjs
var uuid4 = function() {
  const { crypto: crypto6 } = globalThis;
  if (crypto6?.randomUUID) {
    uuid4 = crypto6.randomUUID.bind(crypto6);
    return crypto6.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto6 ? () => crypto6.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
};

// node_modules/@anthropic-ai/sdk/internal/errors.mjs
function isAbortError(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error2 = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error2.stack = err.stack;
        if (err.cause && !error2.cause)
          error2.cause = err.cause;
        if (err.name)
          error2.name = err.name;
        return error2;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};

// node_modules/@anthropic-ai/sdk/core/error.mjs
var AnthropicError = class extends Error {
};
var APIError = class _APIError extends AnthropicError {
  constructor(status, error2, message, headers) {
    super(`${_APIError.makeMessage(status, error2, message)}`);
    this.status = status;
    this.headers = headers;
    this.requestID = headers?.get("request-id");
    this.error = error2;
  }
  static makeMessage(status, error2, message) {
    const msg = error2?.message ? typeof error2.message === "string" ? error2.message : JSON.stringify(error2.message) : error2 ? JSON.stringify(error2) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error2 = errorResponse;
    if (status === 400) {
      return new BadRequestError(status, error2, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error2, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error2, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error2, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error2, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error2, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error2, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error2, message, headers);
    }
    return new _APIError(status, error2, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
};
var AuthenticationError = class extends APIError {
};
var PermissionDeniedError = class extends APIError {
};
var NotFoundError = class extends APIError {
};
var ConflictError = class extends APIError {
};
var UnprocessableEntityError = class extends APIError {
};
var RateLimitError = class extends APIError {
};
var InternalServerError = class extends APIError {
};

// node_modules/@anthropic-ai/sdk/internal/utils/values.mjs
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url2) => {
  return startsWithSchemeRegexp.test(url2);
};
var isArray = (val) => (isArray = Array.isArray, isArray(val));
var isReadonlyArray = isArray;
function maybeObj(x) {
  if (typeof x !== "object") {
    return {};
  }
  return x ?? {};
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new AnthropicError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new AnthropicError(`${name} must be a positive integer`);
  }
  return n;
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};

// node_modules/@anthropic-ai/sdk/internal/utils/sleep.mjs
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// node_modules/@anthropic-ai/sdk/version.mjs
var VERSION = "0.67.0";

// node_modules/@anthropic-ai/sdk/internal/detect-platform.mjs
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
var getPlatformProperties = () => {
  const detectedPlatform = getDetectedPlatform();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": normalizeArch(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};

// node_modules/@anthropic-ai/sdk/internal/shims.mjs
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new Anthropic({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream(...args) {
  const ReadableStream2 = globalThis.ReadableStream;
  if (typeof ReadableStream2 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream2(...args);
}
function ReadableStreamFrom(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      await iter.return?.();
    }
  });
}
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream(stream) {
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await stream[Symbol.asyncIterator]().return?.();
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}

// node_modules/@anthropic-ai/sdk/internal/request-options.mjs
var FallbackEncoder = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};

// node_modules/@anthropic-ai/sdk/internal/utils/bytes.mjs
function concatBytes(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
var encodeUTF8_;
function encodeUTF8(str2) {
  let encoder;
  return (encodeUTF8_ ?? (encoder = new globalThis.TextEncoder(), encodeUTF8_ = encoder.encode.bind(encoder)))(str2);
}
var decodeUTF8_;
function decodeUTF8(bytes) {
  let decoder;
  return (decodeUTF8_ ?? (decoder = new globalThis.TextDecoder(), decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);
}

// node_modules/@anthropic-ai/sdk/internal/decoders/line.mjs
var _LineDecoder_buffer;
var _LineDecoder_carriageReturnIndex;
var LineDecoder = class {
  constructor() {
    _LineDecoder_buffer.set(this, void 0);
    _LineDecoder_carriageReturnIndex.set(this, void 0);
    __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array(), "f");
    __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    __classPrivateFieldSet(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), binaryChunk]), "f");
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f")), "f");
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, endIndex));
      lines.push(line);
      __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(patternIndex.index), "f");
      __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet(this, _LineDecoder_buffer, "f").length) {
      return [];
    }
    return this.decode("\n");
  }
};
_LineDecoder_buffer = /* @__PURE__ */ new WeakMap(), _LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0; i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}

// node_modules/@anthropic-ai/sdk/internal/utils/log.mjs
var levelNumbers = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
var parseLogLevel = (maybeLevel, sourceName, client) => {
  if (!maybeLevel) {
    return void 0;
  }
  if (hasOwn(levelNumbers, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
  return void 0;
};
function noop() {
}
function makeLogFn(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
var noopLogger = {
  error: noop,
  warn: noop,
  info: noop,
  debug: noop
};
var cachedLoggers = /* @__PURE__ */ new WeakMap();
function loggerFor(client) {
  const logger = client.logger;
  const logLevel = client.logLevel ?? "off";
  if (!logger) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger, logLevel),
    warn: makeLogFn("warn", logger, logLevel),
    info: makeLogFn("info", logger, logLevel),
    debug: makeLogFn("debug", logger, logLevel)
  };
  cachedLoggers.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
var formatRequestDetails = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "x-api-key" || name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};

// node_modules/@anthropic-ai/sdk/core/streaming.mjs
var _Stream_client;
var Stream = class _Stream {
  constructor(iterator, controller, client) {
    this.iterator = iterator;
    _Stream_client.set(this, void 0);
    this.controller = controller;
    __classPrivateFieldSet(this, _Stream_client, client, "f");
  }
  static fromSSEResponse(response, controller, client) {
    let consumed = false;
    const logger = client ? loggerFor(client) : console;
    async function* iterator() {
      if (consumed) {
        throw new AnthropicError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          if (sse.event === "completion") {
            try {
              yield JSON.parse(sse.data);
            } catch (e) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e;
            }
          }
          if (sse.event === "message_start" || sse.event === "message_delta" || sse.event === "message_stop" || sse.event === "content_block_start" || sse.event === "content_block_delta" || sse.event === "content_block_stop") {
            try {
              yield JSON.parse(sse.data);
            } catch (e) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e;
            }
          }
          if (sse.event === "ping") {
            continue;
          }
          if (sse.event === "error") {
            throw new APIError(void 0, safeJSON(sse.data) ?? sse.data, void 0, response.headers);
          }
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller, client) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new AnthropicError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (isAbortError(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  [(_Stream_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet(this, _Stream_client, "f")),
      new _Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet(this, _Stream_client, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self = this;
    let iter;
    return makeReadableStream({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encodeUTF8(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new AnthropicError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new AnthropicError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}

// node_modules/@anthropic-ai/sdk/internal/parse.mjs
async function defaultParseResponse(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    if (props.options.stream) {
      loggerFor(client).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller);
      }
      return Stream.fromSSEResponse(response, props.controller);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = contentType?.split(";")[0]?.trim();
    const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
    if (isJSON) {
      const json = await response.json();
      return addRequestID(json, response);
    }
    const text = await response.text();
    return text;
  })();
  loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
function addRequestID(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("request-id"),
    enumerable: false
  });
}

// node_modules/@anthropic-ai/sdk/core/api-promise.mjs
var _APIPromise_client;
var APIPromise = class _APIPromise extends Promise {
  constructor(client, responsePromise, parseResponse2 = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
    _APIPromise_client.set(this, void 0);
    __classPrivateFieldSet(this, _APIPromise_client, client, "f");
  }
  _thenUnwrap(transform2) {
    return new _APIPromise(__classPrivateFieldGet(this, _APIPromise_client, "f"), this.responsePromise, async (client, props) => addRequestID(transform2(await this.parseResponse(client, props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet(this, _APIPromise_client, "f"), data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
_APIPromise_client = /* @__PURE__ */ new WeakMap();

// node_modules/@anthropic-ai/sdk/core/pagination.mjs
var _AbstractPage_client;
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageRequestOptions() != null;
  }
  async getNextPage() {
    const nextOptions = this.nextPageRequestOptions();
    if (!nextOptions) {
      throw new AnthropicError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request3, Page3) {
    super(client, request3, async (client2, props) => new Page3(client2, props.response, await defaultParseResponse(client2, props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var Page = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.first_id = body.first_id || null;
    this.last_id = body.last_id || null;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    if (this.options.query?.["before_id"]) {
      const first_id = this.first_id;
      if (!first_id) {
        return null;
      }
      return {
        ...this.options,
        query: {
          ...maybeObj(this.options.query),
          before_id: first_id
        }
      };
    }
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        after_id: cursor
      }
    };
  }
};
var PageCursor = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.next_page = body.next_page || null;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const cursor = this.next_page;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj(this.options.query),
        page: cursor
      }
    };
  }
};

// node_modules/@anthropic-ai/sdk/internal/uploads.mjs
var checkFileSupport = () => {
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof process2?.versions?.node === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile(fileBits, fileName, options) {
  checkFileSupport();
  return new File(fileBits, fileName ?? "unknown_file", options);
}
function getName(value) {
  return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
}
var isAsyncIterable = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var multipartFormRequestOptions = async (opts, fetch2) => {
  return { ...opts, body: await createForm(opts.body, fetch2) };
};
var supportsFormDataMap = /* @__PURE__ */ new WeakMap();
function supportsFormData(fetchObject) {
  const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached2 = supportsFormDataMap.get(fetch2);
  if (cached2)
    return cached2;
  const promise = (async () => {
    try {
      const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
      const data = new FormData();
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap.set(fetch2, promise);
  return promise;
}
var createForm = async (body, fetch2) => {
  if (!await supportsFormData(fetch2)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var isNamedBlob = (value) => value instanceof Blob && "name" in value;
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    let options = {};
    const contentType = value.headers.get("Content-Type");
    if (contentType) {
      options = { type: contentType };
    }
    form.append(key, makeFile([await value.blob()], getName(value), options));
  } else if (isAsyncIterable(value)) {
    form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));
  } else if (isNamedBlob(value)) {
    form.append(key, makeFile([value], getName(value), { type: value.type }));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/@anthropic-ai/sdk/internal/to-file.mjs
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile(value, name, options) {
  checkFileSupport();
  value = await value;
  name || (name = getName(value));
  if (isFileLike(value)) {
    if (value instanceof File && name == null && options == null) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], name ?? value.name, {
      type: value.type,
      lastModified: value.lastModified,
      ...options
    });
  }
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes(blob), name, options);
  }
  const parts = await getBytes(value);
  if (!options?.type) {
    const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile(parts, name, options);
}
async function getBytes(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes(chunk));
    }
  } else {
    const constructor = value?.constructor?.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}

// node_modules/@anthropic-ai/sdk/core/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/@anthropic-ai/sdk/internal/headers.mjs
var brand_privateNullableHeaders = Symbol.for("brand.privateNullableHeaders");
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var buildHeaders = (newHeaders) => {
  const targetHeaders = new Headers();
  const nullHeaders = /* @__PURE__ */ new Set();
  for (const headers of newHeaders) {
    const seenHeaders = /* @__PURE__ */ new Set();
    for (const [name, value] of iterateHeaders(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
};

// node_modules/@anthropic-ai/sdk/internal/utils/path.mjs
function encodeURIPath(str2) {
  return str2.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
var createPathTagFunction = (pathEncoder = encodeURIPath) => function path10(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path11 = statics.reduce((previousValue, currentValue, index) => {
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && // handle values from other realms
    value.toString === Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)?.toString)) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path11.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length,
      error: `Value "${match[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b) => a.start - b.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new AnthropicError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join("\n")}
${path11}
${underline}`);
  }
  return path11;
};
var path = /* @__PURE__ */ createPathTagFunction(encodeURIPath);

// node_modules/@anthropic-ai/sdk/resources/beta/files.mjs
var Files = class extends APIResource {
  /**
   * List Files
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fileMetadata of client.beta.files.list()) {
   *   // ...
   * }
   * ```
   */
  list(params = {}, options) {
    const { betas, ...query } = params ?? {};
    return this._client.getAPIList("/v1/files", Page, {
      query,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Delete File
   *
   * @example
   * ```ts
   * const deletedFile = await client.beta.files.delete(
   *   'file_id',
   * );
   * ```
   */
  delete(fileID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.delete(path`/v1/files/${fileID}`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Download File
   *
   * @example
   * ```ts
   * const response = await client.beta.files.download(
   *   'file_id',
   * );
   *
   * const content = await response.blob();
   * console.log(content);
   * ```
   */
  download(fileID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.get(path`/v1/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders([
        {
          "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString(),
          Accept: "application/binary"
        },
        options?.headers
      ]),
      __binaryResponse: true
    });
  }
  /**
   * Get File Metadata
   *
   * @example
   * ```ts
   * const fileMetadata =
   *   await client.beta.files.retrieveMetadata('file_id');
   * ```
   */
  retrieveMetadata(fileID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.get(path`/v1/files/${fileID}`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Upload File
   *
   * @example
   * ```ts
   * const fileMetadata = await client.beta.files.upload({
   *   file: fs.createReadStream('path/to/file'),
   * });
   * ```
   */
  upload(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/files", multipartFormRequestOptions({
      body,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "files-api-2025-04-14"].toString() },
        options?.headers
      ])
    }, this._client));
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/models.mjs
var Models = class extends APIResource {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   *
   * @example
   * ```ts
   * const betaModelInfo = await client.beta.models.retrieve(
   *   'model_id',
   * );
   * ```
   */
  retrieve(modelID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.get(path`/v1/models/${modelID}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0 },
        options?.headers
      ])
    });
  }
  /**
   * List available models.
   *
   * The Models API response can be used to determine which models are available for
   * use in the API. More recently released models are listed first.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const betaModelInfo of client.beta.models.list()) {
   *   // ...
   * }
   * ```
   */
  list(params = {}, options) {
    const { betas, ...query } = params ?? {};
    return this._client.getAPIList("/v1/models?beta=true", Page, {
      query,
      ...options,
      headers: buildHeaders([
        { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0 },
        options?.headers
      ])
    });
  }
};

// node_modules/@anthropic-ai/sdk/internal/decoders/jsonl.mjs
var JSONLDecoder = class _JSONLDecoder {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  async *decoder() {
    const lineDecoder = new LineDecoder();
    for await (const chunk of this.iterator) {
      for (const line of lineDecoder.decode(chunk)) {
        yield JSON.parse(line);
      }
    }
    for (const line of lineDecoder.flush()) {
      yield JSON.parse(line);
    }
  }
  [Symbol.asyncIterator]() {
    return this.decoder();
  }
  static fromResponse(response, controller) {
    if (!response.body) {
      controller.abort();
      if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
        throw new AnthropicError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
      }
      throw new AnthropicError(`Attempted to iterate over a response with no body`);
    }
    return new _JSONLDecoder(ReadableStreamToAsyncIterable(response.body), controller);
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/messages/batches.mjs
var Batches = class extends APIResource {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.create({
   *     requests: [
   *       {
   *         custom_id: 'my-custom-id-1',
   *         params: {
   *           max_tokens: 1024,
   *           messages: [
   *             { content: 'Hello, world', role: 'user' },
   *           ],
   *           model: 'claude-sonnet-4-5-20250929',
   *         },
   *       },
   *     ],
   *   });
   * ```
   */
  create(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/messages/batches?beta=true", {
      body,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.retrieve(
   *     'message_batch_id',
   *   );
   * ```
   */
  retrieve(messageBatchID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.get(path`/v1/messages/batches/${messageBatchID}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * List all Message Batches within a Workspace. Most recently created batches are
   * returned first.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const betaMessageBatch of client.beta.messages.batches.list()) {
   *   // ...
   * }
   * ```
   */
  list(params = {}, options) {
    const { betas, ...query } = params ?? {};
    return this._client.getAPIList("/v1/messages/batches?beta=true", Page, {
      query,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they've finished processing. If you'd
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaDeletedMessageBatch =
   *   await client.beta.messages.batches.delete(
   *     'message_batch_id',
   *   );
   * ```
   */
  delete(messageBatchID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.delete(path`/v1/messages/batches/${messageBatchID}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatch =
   *   await client.beta.messages.batches.cancel(
   *     'message_batch_id',
   *   );
   * ```
   */
  cancel(messageBatchID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.post(path`/v1/messages/batches/${messageBatchID}/cancel?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const betaMessageBatchIndividualResponse =
   *   await client.beta.messages.batches.results(
   *     'message_batch_id',
   *   );
   * ```
   */
  async results(messageBatchID, params = {}, options) {
    const batch = await this.retrieve(messageBatchID);
    if (!batch.results_url) {
      throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
    }
    const { betas } = params ?? {};
    return this._client.get(batch.results_url, {
      ...options,
      headers: buildHeaders([
        {
          "anthropic-beta": [...betas ?? [], "message-batches-2024-09-24"].toString(),
          Accept: "application/binary"
        },
        options?.headers
      ]),
      stream: true,
      __binaryResponse: true
    })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
  }
};

// node_modules/@anthropic-ai/sdk/_vendor/partial-json-parser/parser.mjs
var tokenize = (input) => {
  let current = 0;
  let tokens = [];
  while (current < input.length) {
    let char = input[current];
    if (char === "\\") {
      current++;
      continue;
    }
    if (char === "{") {
      tokens.push({
        type: "brace",
        value: "{"
      });
      current++;
      continue;
    }
    if (char === "}") {
      tokens.push({
        type: "brace",
        value: "}"
      });
      current++;
      continue;
    }
    if (char === "[") {
      tokens.push({
        type: "paren",
        value: "["
      });
      current++;
      continue;
    }
    if (char === "]") {
      tokens.push({
        type: "paren",
        value: "]"
      });
      current++;
      continue;
    }
    if (char === ":") {
      tokens.push({
        type: "separator",
        value: ":"
      });
      current++;
      continue;
    }
    if (char === ",") {
      tokens.push({
        type: "delimiter",
        value: ","
      });
      current++;
      continue;
    }
    if (char === '"') {
      let value = "";
      let danglingQuote = false;
      char = input[++current];
      while (char !== '"') {
        if (current === input.length) {
          danglingQuote = true;
          break;
        }
        if (char === "\\") {
          current++;
          if (current === input.length) {
            danglingQuote = true;
            break;
          }
          value += char + input[current];
          char = input[++current];
        } else {
          value += char;
          char = input[++current];
        }
      }
      char = input[++current];
      if (!danglingQuote) {
        tokens.push({
          type: "string",
          value
        });
      }
      continue;
    }
    let WHITESPACE = /\s/;
    if (char && WHITESPACE.test(char)) {
      current++;
      continue;
    }
    let NUMBERS = /[0-9]/;
    if (char && NUMBERS.test(char) || char === "-" || char === ".") {
      let value = "";
      if (char === "-") {
        value += char;
        char = input[++current];
      }
      while (char && NUMBERS.test(char) || char === ".") {
        value += char;
        char = input[++current];
      }
      tokens.push({
        type: "number",
        value
      });
      continue;
    }
    let LETTERS = /[a-z]/i;
    if (char && LETTERS.test(char)) {
      let value = "";
      while (char && LETTERS.test(char)) {
        if (current === input.length) {
          break;
        }
        value += char;
        char = input[++current];
      }
      if (value == "true" || value == "false" || value === "null") {
        tokens.push({
          type: "name",
          value
        });
      } else {
        current++;
        continue;
      }
      continue;
    }
    current++;
  }
  return tokens;
};
var strip = (tokens) => {
  if (tokens.length === 0) {
    return tokens;
  }
  let lastToken = tokens[tokens.length - 1];
  switch (lastToken.type) {
    case "separator":
      tokens = tokens.slice(0, tokens.length - 1);
      return strip(tokens);
      break;
    case "number":
      let lastCharacterOfLastToken = lastToken.value[lastToken.value.length - 1];
      if (lastCharacterOfLastToken === "." || lastCharacterOfLastToken === "-") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      }
    case "string":
      let tokenBeforeTheLastToken = tokens[tokens.length - 2];
      if (tokenBeforeTheLastToken?.type === "delimiter") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      } else if (tokenBeforeTheLastToken?.type === "brace" && tokenBeforeTheLastToken.value === "{") {
        tokens = tokens.slice(0, tokens.length - 1);
        return strip(tokens);
      }
      break;
    case "delimiter":
      tokens = tokens.slice(0, tokens.length - 1);
      return strip(tokens);
      break;
  }
  return tokens;
};
var unstrip = (tokens) => {
  let tail = [];
  tokens.map((token) => {
    if (token.type === "brace") {
      if (token.value === "{") {
        tail.push("}");
      } else {
        tail.splice(tail.lastIndexOf("}"), 1);
      }
    }
    if (token.type === "paren") {
      if (token.value === "[") {
        tail.push("]");
      } else {
        tail.splice(tail.lastIndexOf("]"), 1);
      }
    }
  });
  if (tail.length > 0) {
    tail.reverse().map((item) => {
      if (item === "}") {
        tokens.push({
          type: "brace",
          value: "}"
        });
      } else if (item === "]") {
        tokens.push({
          type: "paren",
          value: "]"
        });
      }
    });
  }
  return tokens;
};
var generate = (tokens) => {
  let output = "";
  tokens.map((token) => {
    switch (token.type) {
      case "string":
        output += '"' + token.value + '"';
        break;
      default:
        output += token.value;
        break;
    }
  });
  return output;
};
var partialParse = (input) => JSON.parse(generate(unstrip(strip(tokenize(input)))));

// node_modules/@anthropic-ai/sdk/lib/BetaMessageStream.mjs
var _BetaMessageStream_instances;
var _BetaMessageStream_currentMessageSnapshot;
var _BetaMessageStream_connectedPromise;
var _BetaMessageStream_resolveConnectedPromise;
var _BetaMessageStream_rejectConnectedPromise;
var _BetaMessageStream_endPromise;
var _BetaMessageStream_resolveEndPromise;
var _BetaMessageStream_rejectEndPromise;
var _BetaMessageStream_listeners;
var _BetaMessageStream_ended;
var _BetaMessageStream_errored;
var _BetaMessageStream_aborted;
var _BetaMessageStream_catchingPromiseCreated;
var _BetaMessageStream_response;
var _BetaMessageStream_request_id;
var _BetaMessageStream_getFinalMessage;
var _BetaMessageStream_getFinalText;
var _BetaMessageStream_handleError;
var _BetaMessageStream_beginRequest;
var _BetaMessageStream_addStreamEvent;
var _BetaMessageStream_endRequest;
var _BetaMessageStream_accumulateMessage;
var JSON_BUF_PROPERTY = "__json_buf";
function tracksToolInput(content) {
  return content.type === "tool_use" || content.type === "server_tool_use" || content.type === "mcp_tool_use";
}
var BetaMessageStream = class _BetaMessageStream {
  constructor() {
    _BetaMessageStream_instances.add(this);
    this.messages = [];
    this.receivedMessages = [];
    _BetaMessageStream_currentMessageSnapshot.set(this, void 0);
    this.controller = new AbortController();
    _BetaMessageStream_connectedPromise.set(this, void 0);
    _BetaMessageStream_resolveConnectedPromise.set(this, () => {
    });
    _BetaMessageStream_rejectConnectedPromise.set(this, () => {
    });
    _BetaMessageStream_endPromise.set(this, void 0);
    _BetaMessageStream_resolveEndPromise.set(this, () => {
    });
    _BetaMessageStream_rejectEndPromise.set(this, () => {
    });
    _BetaMessageStream_listeners.set(this, {});
    _BetaMessageStream_ended.set(this, false);
    _BetaMessageStream_errored.set(this, false);
    _BetaMessageStream_aborted.set(this, false);
    _BetaMessageStream_catchingPromiseCreated.set(this, false);
    _BetaMessageStream_response.set(this, void 0);
    _BetaMessageStream_request_id.set(this, void 0);
    _BetaMessageStream_handleError.set(this, (error2) => {
      __classPrivateFieldSet(this, _BetaMessageStream_errored, true, "f");
      if (isAbortError(error2)) {
        error2 = new APIUserAbortError();
      }
      if (error2 instanceof APIUserAbortError) {
        __classPrivateFieldSet(this, _BetaMessageStream_aborted, true, "f");
        return this._emit("abort", error2);
      }
      if (error2 instanceof AnthropicError) {
        return this._emit("error", error2);
      }
      if (error2 instanceof Error) {
        const anthropicError = new AnthropicError(error2.message);
        anthropicError.cause = error2;
        return this._emit("error", anthropicError);
      }
      return this._emit("error", new AnthropicError(String(error2)));
    });
    __classPrivateFieldSet(this, _BetaMessageStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _BetaMessageStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet(this, _BetaMessageStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet(this, _BetaMessageStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _BetaMessageStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet(this, _BetaMessageStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet(this, _BetaMessageStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet(this, _BetaMessageStream_endPromise, "f").catch(() => {
    });
  }
  get response() {
    return __classPrivateFieldGet(this, _BetaMessageStream_response, "f");
  }
  get request_id() {
    return __classPrivateFieldGet(this, _BetaMessageStream_request_id, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    const response = await __classPrivateFieldGet(this, _BetaMessageStream_connectedPromise, "f");
    if (!response) {
      throw new Error("Could not resolve a `Response` object");
    }
    return {
      data: this,
      response,
      request_id: response.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _BetaMessageStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createMessage(messages, params, options) {
    const runner = new _BetaMessageStream();
    for (const message of params.messages) {
      runner._addMessageParam(message);
    }
    runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  _run(executor) {
    executor().then(() => {
      this._emitFinal();
      this._emit("end");
    }, __classPrivateFieldGet(this, _BetaMessageStream_handleError, "f"));
  }
  _addMessageParam(message) {
    this.messages.push(message);
  }
  _addMessage(message, emit = true) {
    this.receivedMessages.push(message);
    if (emit) {
      this._emit("message", message);
    }
  }
  async _createMessage(messages, params, options) {
    const signal = options?.signal;
    let abortHandler;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      abortHandler = this.controller.abort.bind(this.controller);
      signal.addEventListener("abort", abortHandler);
    }
    try {
      __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
      const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
      this._connected(response);
      for await (const event of stream) {
        __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
      }
      if (stream.controller.signal?.aborted) {
        throw new APIUserAbortError();
      }
      __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
    } finally {
      if (signal && abortHandler) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  _connected(response) {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _BetaMessageStream_response, response, "f");
    __classPrivateFieldSet(this, _BetaMessageStream_request_id, response?.headers.get("request-id"), "f");
    __classPrivateFieldGet(this, _BetaMessageStream_resolveConnectedPromise, "f").call(this, response);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet(this, _BetaMessageStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet(this, _BetaMessageStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet(this, _BetaMessageStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet(this, _BetaMessageStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet(this, _BetaMessageStream_endPromise, "f");
  }
  get currentMessage() {
    return __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    await this.done();
    return __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalText).call(this);
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet(this, _BetaMessageStream_ended, "f"))
      return;
    if (event === "end") {
      __classPrivateFieldSet(this, _BetaMessageStream_ended, true, "f");
      __classPrivateFieldGet(this, _BetaMessageStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet(this, _BetaMessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error2 = args[0];
      if (!__classPrivateFieldGet(this, _BetaMessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error2);
      }
      __classPrivateFieldGet(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error2);
      __classPrivateFieldGet(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error2);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error2 = args[0];
      if (!__classPrivateFieldGet(this, _BetaMessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error2);
      }
      __classPrivateFieldGet(this, _BetaMessageStream_rejectConnectedPromise, "f").call(this, error2);
      __classPrivateFieldGet(this, _BetaMessageStream_rejectEndPromise, "f").call(this, error2);
      this._emit("end");
    }
  }
  _emitFinal() {
    const finalMessage = this.receivedMessages.at(-1);
    if (finalMessage) {
      this._emit("finalMessage", __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_getFinalMessage).call(this));
    }
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    let abortHandler;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      abortHandler = this.controller.abort.bind(this.controller);
      signal.addEventListener("abort", abortHandler);
    }
    try {
      __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_beginRequest).call(this);
      this._connected(null);
      const stream = Stream.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_addStreamEvent).call(this, event);
      }
      if (stream.controller.signal?.aborted) {
        throw new APIUserAbortError();
      }
      __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_endRequest).call(this);
    } finally {
      if (signal && abortHandler) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  [(_BetaMessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_listeners = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_ended = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_errored = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_aborted = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_response = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_request_id = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_handleError = /* @__PURE__ */ new WeakMap(), _BetaMessageStream_instances = /* @__PURE__ */ new WeakSet(), _BetaMessageStream_getFinalMessage = function _BetaMessageStream_getFinalMessage2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    return this.receivedMessages.at(-1);
  }, _BetaMessageStream_getFinalText = function _BetaMessageStream_getFinalText2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
    if (textBlocks.length === 0) {
      throw new AnthropicError("stream ended without producing a content block with type=text");
    }
    return textBlocks.join(" ");
  }, _BetaMessageStream_beginRequest = function _BetaMessageStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
  }, _BetaMessageStream_addStreamEvent = function _BetaMessageStream_addStreamEvent2(event) {
    if (this.ended)
      return;
    const messageSnapshot = __classPrivateFieldGet(this, _BetaMessageStream_instances, "m", _BetaMessageStream_accumulateMessage).call(this, event);
    this._emit("streamEvent", event, messageSnapshot);
    switch (event.type) {
      case "content_block_delta": {
        const content = messageSnapshot.content.at(-1);
        switch (event.delta.type) {
          case "text_delta": {
            if (content.type === "text") {
              this._emit("text", event.delta.text, content.text || "");
            }
            break;
          }
          case "citations_delta": {
            if (content.type === "text") {
              this._emit("citation", event.delta.citation, content.citations ?? []);
            }
            break;
          }
          case "input_json_delta": {
            if (tracksToolInput(content) && content.input) {
              this._emit("inputJson", event.delta.partial_json, content.input);
            }
            break;
          }
          case "thinking_delta": {
            if (content.type === "thinking") {
              this._emit("thinking", event.delta.thinking, content.thinking);
            }
            break;
          }
          case "signature_delta": {
            if (content.type === "thinking") {
              this._emit("signature", content.signature);
            }
            break;
          }
          default:
            checkNever(event.delta);
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(messageSnapshot);
        this._addMessage(messageSnapshot, true);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", messageSnapshot.content.at(-1));
        break;
      }
      case "message_start": {
        __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, messageSnapshot, "f");
        break;
      }
      case "content_block_start":
      case "message_delta":
        break;
    }
  }, _BetaMessageStream_endRequest = function _BetaMessageStream_endRequest2() {
    if (this.ended) {
      throw new AnthropicError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, "f");
    if (!snapshot) {
      throw new AnthropicError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet(this, _BetaMessageStream_currentMessageSnapshot, void 0, "f");
    return snapshot;
  }, _BetaMessageStream_accumulateMessage = function _BetaMessageStream_accumulateMessage2(event) {
    let snapshot = __classPrivateFieldGet(this, _BetaMessageStream_currentMessageSnapshot, "f");
    if (event.type === "message_start") {
      if (snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
      }
      return event.message;
    }
    if (!snapshot) {
      throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
    }
    switch (event.type) {
      case "message_stop":
        return snapshot;
      case "message_delta":
        snapshot.container = event.delta.container;
        snapshot.stop_reason = event.delta.stop_reason;
        snapshot.stop_sequence = event.delta.stop_sequence;
        snapshot.usage.output_tokens = event.usage.output_tokens;
        snapshot.context_management = event.context_management;
        if (event.usage.input_tokens != null) {
          snapshot.usage.input_tokens = event.usage.input_tokens;
        }
        if (event.usage.cache_creation_input_tokens != null) {
          snapshot.usage.cache_creation_input_tokens = event.usage.cache_creation_input_tokens;
        }
        if (event.usage.cache_read_input_tokens != null) {
          snapshot.usage.cache_read_input_tokens = event.usage.cache_read_input_tokens;
        }
        if (event.usage.server_tool_use != null) {
          snapshot.usage.server_tool_use = event.usage.server_tool_use;
        }
        return snapshot;
      case "content_block_start":
        snapshot.content.push(event.content_block);
        return snapshot;
      case "content_block_delta": {
        const snapshotContent = snapshot.content.at(event.index);
        switch (event.delta.type) {
          case "text_delta": {
            if (snapshotContent?.type === "text") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                text: (snapshotContent.text || "") + event.delta.text
              };
            }
            break;
          }
          case "citations_delta": {
            if (snapshotContent?.type === "text") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                citations: [...snapshotContent.citations ?? [], event.delta.citation]
              };
            }
            break;
          }
          case "input_json_delta": {
            if (snapshotContent && tracksToolInput(snapshotContent)) {
              let jsonBuf = snapshotContent[JSON_BUF_PROPERTY] || "";
              jsonBuf += event.delta.partial_json;
              const newContent = { ...snapshotContent };
              Object.defineProperty(newContent, JSON_BUF_PROPERTY, {
                value: jsonBuf,
                enumerable: false,
                writable: true
              });
              if (jsonBuf) {
                try {
                  newContent.input = partialParse(jsonBuf);
                } catch (err) {
                  const error2 = new AnthropicError(`Unable to parse tool parameter JSON from model. Please retry your request or adjust your prompt. Error: ${err}. JSON: ${jsonBuf}`);
                  __classPrivateFieldGet(this, _BetaMessageStream_handleError, "f").call(this, error2);
                }
              }
              snapshot.content[event.index] = newContent;
            }
            break;
          }
          case "thinking_delta": {
            if (snapshotContent?.type === "thinking") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                thinking: snapshotContent.thinking + event.delta.thinking
              };
            }
            break;
          }
          case "signature_delta": {
            if (snapshotContent?.type === "thinking") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                signature: event.delta.signature
              };
            }
            break;
          }
          default:
            checkNever(event.delta);
        }
        return snapshot;
      }
      case "content_block_stop":
        return snapshot;
    }
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("streamEvent", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function checkNever(x) {
}

// node_modules/@anthropic-ai/sdk/internal/constants.mjs
var MODEL_NONSTREAMING_TOKENS = {
  "claude-opus-4-20250514": 8192,
  "claude-opus-4-0": 8192,
  "claude-4-opus-20250514": 8192,
  "anthropic.claude-opus-4-20250514-v1:0": 8192,
  "claude-opus-4@20250514": 8192,
  "claude-opus-4-1-20250805": 8192,
  "anthropic.claude-opus-4-1-20250805-v1:0": 8192,
  "claude-opus-4-1@20250805": 8192
};

// node_modules/@anthropic-ai/sdk/lib/tools/BetaToolRunner.mjs
var _BetaToolRunner_instances;
var _BetaToolRunner_consumed;
var _BetaToolRunner_mutated;
var _BetaToolRunner_state;
var _BetaToolRunner_options;
var _BetaToolRunner_message;
var _BetaToolRunner_toolResponse;
var _BetaToolRunner_completion;
var _BetaToolRunner_iterationCount;
var _BetaToolRunner_generateToolResponse;
function promiseWithResolvers() {
  let resolve;
  let reject;
  const promise = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  return { promise, resolve, reject };
}
var BetaToolRunner = class {
  constructor(client, params, options) {
    _BetaToolRunner_instances.add(this);
    this.client = client;
    _BetaToolRunner_consumed.set(this, false);
    _BetaToolRunner_mutated.set(this, false);
    _BetaToolRunner_state.set(this, void 0);
    _BetaToolRunner_options.set(this, void 0);
    _BetaToolRunner_message.set(this, void 0);
    _BetaToolRunner_toolResponse.set(this, void 0);
    _BetaToolRunner_completion.set(this, void 0);
    _BetaToolRunner_iterationCount.set(this, 0);
    __classPrivateFieldSet(this, _BetaToolRunner_state, {
      params: {
        // You can't clone the entire params since there are functions as handlers.
        // You also don't really need to clone params.messages, but it probably will prevent a foot gun
        // somewhere.
        ...params,
        messages: structuredClone(params.messages)
      }
    }, "f");
    __classPrivateFieldSet(this, _BetaToolRunner_options, {
      ...options,
      headers: buildHeaders([{ "x-stainless-helper": "BetaToolRunner" }, options?.headers])
    }, "f");
    __classPrivateFieldSet(this, _BetaToolRunner_completion, promiseWithResolvers(), "f");
  }
  async *[(_BetaToolRunner_consumed = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_mutated = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_state = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_options = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_message = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_toolResponse = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_completion = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_iterationCount = /* @__PURE__ */ new WeakMap(), _BetaToolRunner_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    var _a4;
    if (__classPrivateFieldGet(this, _BetaToolRunner_consumed, "f")) {
      throw new AnthropicError("Cannot iterate over a consumed stream");
    }
    __classPrivateFieldSet(this, _BetaToolRunner_consumed, true, "f");
    __classPrivateFieldSet(this, _BetaToolRunner_mutated, true, "f");
    __classPrivateFieldSet(this, _BetaToolRunner_toolResponse, void 0, "f");
    try {
      while (true) {
        let stream;
        try {
          if (__classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.max_iterations && __classPrivateFieldGet(this, _BetaToolRunner_iterationCount, "f") >= __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.max_iterations) {
            break;
          }
          __classPrivateFieldSet(this, _BetaToolRunner_mutated, false, "f");
          __classPrivateFieldSet(this, _BetaToolRunner_message, void 0, "f");
          __classPrivateFieldSet(this, _BetaToolRunner_toolResponse, void 0, "f");
          __classPrivateFieldSet(this, _BetaToolRunner_iterationCount, (_a4 = __classPrivateFieldGet(this, _BetaToolRunner_iterationCount, "f"), _a4++, _a4), "f");
          const { max_iterations, ...params } = __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params;
          if (params.stream) {
            stream = this.client.beta.messages.stream({ ...params }, __classPrivateFieldGet(this, _BetaToolRunner_options, "f"));
            __classPrivateFieldSet(this, _BetaToolRunner_message, stream.finalMessage(), "f");
            __classPrivateFieldGet(this, _BetaToolRunner_message, "f").catch(() => {
            });
            yield stream;
          } else {
            __classPrivateFieldSet(this, _BetaToolRunner_message, this.client.beta.messages.create({ ...params, stream: false }, __classPrivateFieldGet(this, _BetaToolRunner_options, "f")), "f");
            yield __classPrivateFieldGet(this, _BetaToolRunner_message, "f");
          }
          if (!__classPrivateFieldGet(this, _BetaToolRunner_mutated, "f")) {
            const { role, content } = await __classPrivateFieldGet(this, _BetaToolRunner_message, "f");
            __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages.push({ role, content });
          }
          const toolMessage = await __classPrivateFieldGet(this, _BetaToolRunner_instances, "m", _BetaToolRunner_generateToolResponse).call(this, __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages.at(-1));
          if (toolMessage) {
            __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params.messages.push(toolMessage);
          }
          if (!toolMessage && !__classPrivateFieldGet(this, _BetaToolRunner_mutated, "f")) {
            break;
          }
        } finally {
          if (stream) {
            stream.abort();
          }
        }
      }
      if (!__classPrivateFieldGet(this, _BetaToolRunner_message, "f")) {
        throw new AnthropicError("ToolRunner concluded without a message from the server");
      }
      __classPrivateFieldGet(this, _BetaToolRunner_completion, "f").resolve(await __classPrivateFieldGet(this, _BetaToolRunner_message, "f"));
    } catch (error2) {
      __classPrivateFieldSet(this, _BetaToolRunner_consumed, false, "f");
      __classPrivateFieldGet(this, _BetaToolRunner_completion, "f").promise.catch(() => {
      });
      __classPrivateFieldGet(this, _BetaToolRunner_completion, "f").reject(error2);
      __classPrivateFieldSet(this, _BetaToolRunner_completion, promiseWithResolvers(), "f");
      throw error2;
    }
  }
  setMessagesParams(paramsOrMutator) {
    if (typeof paramsOrMutator === "function") {
      __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params = paramsOrMutator(__classPrivateFieldGet(this, _BetaToolRunner_state, "f").params);
    } else {
      __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params = paramsOrMutator;
    }
    __classPrivateFieldSet(this, _BetaToolRunner_mutated, true, "f");
    __classPrivateFieldSet(this, _BetaToolRunner_toolResponse, void 0, "f");
  }
  /**
   * Get the tool response for the last message from the assistant.
   * Avoids redundant tool executions by caching results.
   *
   * @returns A promise that resolves to a BetaMessageParam containing tool results, or null if no tools need to be executed
   *
   * @example
   * const toolResponse = await runner.generateToolResponse();
   * if (toolResponse) {
   *   console.log('Tool results:', toolResponse.content);
   * }
   */
  async generateToolResponse() {
    const message = await __classPrivateFieldGet(this, _BetaToolRunner_message, "f") ?? this.params.messages.at(-1);
    if (!message) {
      return null;
    }
    return __classPrivateFieldGet(this, _BetaToolRunner_instances, "m", _BetaToolRunner_generateToolResponse).call(this, message);
  }
  /**
   * Wait for the async iterator to complete. This works even if the async iterator hasn't yet started, and
   * will wait for an instance to start and go to completion.
   *
   * @returns A promise that resolves to the final BetaMessage when the iterator completes
   *
   * @example
   * // Start consuming the iterator
   * for await (const message of runner) {
   *   console.log('Message:', message.content);
   * }
   *
   * // Meanwhile, wait for completion from another part of the code
   * const finalMessage = await runner.done();
   * console.log('Final response:', finalMessage.content);
   */
  done() {
    return __classPrivateFieldGet(this, _BetaToolRunner_completion, "f").promise;
  }
  /**
   * Returns a promise indicating that the stream is done. Unlike .done(), this will eagerly read the stream:
   * * If the iterator has not been consumed, consume the entire iterator and return the final message from the
   * assistant.
   * * If the iterator has been consumed, waits for it to complete and returns the final message.
   *
   * @returns A promise that resolves to the final BetaMessage from the conversation
   * @throws {AnthropicError} If no messages were processed during the conversation
   *
   * @example
   * const finalMessage = await runner.runUntilDone();
   * console.log('Final response:', finalMessage.content);
   */
  async runUntilDone() {
    if (!__classPrivateFieldGet(this, _BetaToolRunner_consumed, "f")) {
      for await (const _ of this) {
      }
    }
    return this.done();
  }
  /**
   * Get the current parameters being used by the ToolRunner.
   *
   * @returns A readonly view of the current ToolRunnerParams
   *
   * @example
   * const currentParams = runner.params;
   * console.log('Current model:', currentParams.model);
   * console.log('Message count:', currentParams.messages.length);
   */
  get params() {
    return __classPrivateFieldGet(this, _BetaToolRunner_state, "f").params;
  }
  /**
   * Add one or more messages to the conversation history.
   *
   * @param messages - One or more BetaMessageParam objects to add to the conversation
   *
   * @example
   * runner.pushMessages(
   *   { role: 'user', content: 'Also, what about the weather in NYC?' }
   * );
   *
   * @example
   * // Adding multiple messages
   * runner.pushMessages(
   *   { role: 'user', content: 'What about NYC?' },
   *   { role: 'user', content: 'And Boston?' }
   * );
   */
  pushMessages(...messages) {
    this.setMessagesParams((params) => ({
      ...params,
      messages: [...params.messages, ...messages]
    }));
  }
  /**
   * Makes the ToolRunner directly awaitable, equivalent to calling .runUntilDone()
   * This allows using `await runner` instead of `await runner.runUntilDone()`
   */
  then(onfulfilled, onrejected) {
    return this.runUntilDone().then(onfulfilled, onrejected);
  }
};
_BetaToolRunner_generateToolResponse = async function _BetaToolRunner_generateToolResponse2(lastMessage) {
  if (__classPrivateFieldGet(this, _BetaToolRunner_toolResponse, "f") !== void 0) {
    return __classPrivateFieldGet(this, _BetaToolRunner_toolResponse, "f");
  }
  __classPrivateFieldSet(this, _BetaToolRunner_toolResponse, generateToolResponse(__classPrivateFieldGet(this, _BetaToolRunner_state, "f").params, lastMessage), "f");
  return __classPrivateFieldGet(this, _BetaToolRunner_toolResponse, "f");
};
async function generateToolResponse(params, lastMessage = params.messages.at(-1)) {
  if (!lastMessage || lastMessage.role !== "assistant" || !lastMessage.content || typeof lastMessage.content === "string") {
    return null;
  }
  const toolUseBlocks = lastMessage.content.filter((content) => content.type === "tool_use");
  if (toolUseBlocks.length === 0) {
    return null;
  }
  const toolResults = await Promise.all(toolUseBlocks.map(async (toolUse) => {
    const tool = params.tools.find((t) => t.name === toolUse.name);
    if (!tool || !("run" in tool)) {
      return {
        type: "tool_result",
        tool_use_id: toolUse.id,
        content: `Error: Tool '${toolUse.name}' not found`,
        is_error: true
      };
    }
    try {
      let input = toolUse.input;
      if ("parse" in tool && tool.parse) {
        input = tool.parse(input);
      }
      const result = await tool.run(input);
      return {
        type: "tool_result",
        tool_use_id: toolUse.id,
        content: result
      };
    } catch (error2) {
      return {
        type: "tool_result",
        tool_use_id: toolUse.id,
        content: `Error: ${error2 instanceof Error ? error2.message : String(error2)}`,
        is_error: true
      };
    }
  }));
  return {
    role: "user",
    content: toolResults
  };
}

// node_modules/@anthropic-ai/sdk/resources/beta/messages/messages.mjs
var DEPRECATED_MODELS = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-3-opus-20240229": "January 5th, 2026",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025",
  "claude-3-5-sonnet-20241022": "October 22, 2025",
  "claude-3-5-sonnet-20240620": "October 22, 2025"
};
var Messages = class extends APIResource {
  constructor() {
    super(...arguments);
    this.batches = new Batches(this._client);
  }
  create(params, options) {
    const { betas, ...body } = params;
    if (body.model in DEPRECATED_MODELS) {
      console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
    }
    let timeout = this._client._options.timeout;
    if (!body.stream && timeout == null) {
      const maxNonstreamingTokens = MODEL_NONSTREAMING_TOKENS[body.model] ?? void 0;
      timeout = this._client.calculateNonstreamingTimeout(body.max_tokens, maxNonstreamingTokens);
    }
    return this._client.post("/v1/messages?beta=true", {
      body,
      timeout: timeout ?? 6e5,
      ...options,
      headers: buildHeaders([
        { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0 },
        options?.headers
      ]),
      stream: params.stream ?? false
    });
  }
  /**
   * Create a Message stream
   */
  stream(body, options) {
    return BetaMessageStream.createMessage(this, body, options);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](/en/docs/build-with-claude/token-counting)
   *
   * @example
   * ```ts
   * const betaMessageTokensCount =
   *   await client.beta.messages.countTokens({
   *     messages: [{ content: 'string', role: 'user' }],
   *     model: 'claude-3-7-sonnet-latest',
   *   });
   * ```
   */
  countTokens(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/messages/count_tokens?beta=true", {
      body,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "token-counting-2024-11-01"].toString() },
        options?.headers
      ])
    });
  }
  toolRunner(body, options) {
    return new BetaToolRunner(this._client, body, options);
  }
};
Messages.Batches = Batches;
Messages.BetaToolRunner = BetaToolRunner;

// node_modules/@anthropic-ai/sdk/resources/beta/skills/versions.mjs
var Versions = class extends APIResource {
  /**
   * Create Skill Version
   *
   * @example
   * ```ts
   * const version = await client.beta.skills.versions.create(
   *   'skill_id',
   * );
   * ```
   */
  create(skillID, params = {}, options) {
    const { betas, ...body } = params ?? {};
    return this._client.post(path`/v1/skills/${skillID}/versions?beta=true`, multipartFormRequestOptions({
      body,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    }, this._client));
  }
  /**
   * Get Skill Version
   *
   * @example
   * ```ts
   * const version = await client.beta.skills.versions.retrieve(
   *   'version',
   *   { skill_id: 'skill_id' },
   * );
   * ```
   */
  retrieve(version9, params, options) {
    const { skill_id, betas } = params;
    return this._client.get(path`/v1/skills/${skill_id}/versions/${version9}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * List Skill Versions
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const versionListResponse of client.beta.skills.versions.list(
   *   'skill_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(skillID, params = {}, options) {
    const { betas, ...query } = params ?? {};
    return this._client.getAPIList(path`/v1/skills/${skillID}/versions?beta=true`, PageCursor, {
      query,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Delete Skill Version
   *
   * @example
   * ```ts
   * const version = await client.beta.skills.versions.delete(
   *   'version',
   *   { skill_id: 'skill_id' },
   * );
   * ```
   */
  delete(version9, params, options) {
    const { skill_id, betas } = params;
    return this._client.delete(path`/v1/skills/${skill_id}/versions/${version9}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    });
  }
};

// node_modules/@anthropic-ai/sdk/resources/beta/skills/skills.mjs
var Skills = class extends APIResource {
  constructor() {
    super(...arguments);
    this.versions = new Versions(this._client);
  }
  /**
   * Create Skill
   *
   * @example
   * ```ts
   * const skill = await client.beta.skills.create();
   * ```
   */
  create(params = {}, options) {
    const { betas, ...body } = params ?? {};
    return this._client.post("/v1/skills?beta=true", multipartFormRequestOptions({
      body,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    }, this._client));
  }
  /**
   * Get Skill
   *
   * @example
   * ```ts
   * const skill = await client.beta.skills.retrieve('skill_id');
   * ```
   */
  retrieve(skillID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.get(path`/v1/skills/${skillID}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * List Skills
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const skillListResponse of client.beta.skills.list()) {
   *   // ...
   * }
   * ```
   */
  list(params = {}, options) {
    const { betas, ...query } = params ?? {};
    return this._client.getAPIList("/v1/skills?beta=true", PageCursor, {
      query,
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    });
  }
  /**
   * Delete Skill
   *
   * @example
   * ```ts
   * const skill = await client.beta.skills.delete('skill_id');
   * ```
   */
  delete(skillID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.delete(path`/v1/skills/${skillID}?beta=true`, {
      ...options,
      headers: buildHeaders([
        { "anthropic-beta": [...betas ?? [], "skills-2025-10-02"].toString() },
        options?.headers
      ])
    });
  }
};
Skills.Versions = Versions;

// node_modules/@anthropic-ai/sdk/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.models = new Models(this._client);
    this.messages = new Messages(this._client);
    this.files = new Files(this._client);
    this.skills = new Skills(this._client);
  }
};
Beta.Models = Models;
Beta.Messages = Messages;
Beta.Files = Files;
Beta.Skills = Skills;

// node_modules/@anthropic-ai/sdk/resources/completions.mjs
var Completions = class extends APIResource {
  create(params, options) {
    const { betas, ...body } = params;
    return this._client.post("/v1/complete", {
      body,
      timeout: this._client._options.timeout ?? 6e5,
      ...options,
      headers: buildHeaders([
        { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0 },
        options?.headers
      ]),
      stream: params.stream ?? false
    });
  }
};

// node_modules/@anthropic-ai/sdk/lib/MessageStream.mjs
var _MessageStream_instances;
var _MessageStream_currentMessageSnapshot;
var _MessageStream_connectedPromise;
var _MessageStream_resolveConnectedPromise;
var _MessageStream_rejectConnectedPromise;
var _MessageStream_endPromise;
var _MessageStream_resolveEndPromise;
var _MessageStream_rejectEndPromise;
var _MessageStream_listeners;
var _MessageStream_ended;
var _MessageStream_errored;
var _MessageStream_aborted;
var _MessageStream_catchingPromiseCreated;
var _MessageStream_response;
var _MessageStream_request_id;
var _MessageStream_getFinalMessage;
var _MessageStream_getFinalText;
var _MessageStream_handleError;
var _MessageStream_beginRequest;
var _MessageStream_addStreamEvent;
var _MessageStream_endRequest;
var _MessageStream_accumulateMessage;
var JSON_BUF_PROPERTY2 = "__json_buf";
function tracksToolInput2(content) {
  return content.type === "tool_use" || content.type === "server_tool_use";
}
var MessageStream = class _MessageStream {
  constructor() {
    _MessageStream_instances.add(this);
    this.messages = [];
    this.receivedMessages = [];
    _MessageStream_currentMessageSnapshot.set(this, void 0);
    this.controller = new AbortController();
    _MessageStream_connectedPromise.set(this, void 0);
    _MessageStream_resolveConnectedPromise.set(this, () => {
    });
    _MessageStream_rejectConnectedPromise.set(this, () => {
    });
    _MessageStream_endPromise.set(this, void 0);
    _MessageStream_resolveEndPromise.set(this, () => {
    });
    _MessageStream_rejectEndPromise.set(this, () => {
    });
    _MessageStream_listeners.set(this, {});
    _MessageStream_ended.set(this, false);
    _MessageStream_errored.set(this, false);
    _MessageStream_aborted.set(this, false);
    _MessageStream_catchingPromiseCreated.set(this, false);
    _MessageStream_response.set(this, void 0);
    _MessageStream_request_id.set(this, void 0);
    _MessageStream_handleError.set(this, (error2) => {
      __classPrivateFieldSet(this, _MessageStream_errored, true, "f");
      if (isAbortError(error2)) {
        error2 = new APIUserAbortError();
      }
      if (error2 instanceof APIUserAbortError) {
        __classPrivateFieldSet(this, _MessageStream_aborted, true, "f");
        return this._emit("abort", error2);
      }
      if (error2 instanceof AnthropicError) {
        return this._emit("error", error2);
      }
      if (error2 instanceof Error) {
        const anthropicError = new AnthropicError(error2.message);
        anthropicError.cause = error2;
        return this._emit("error", anthropicError);
      }
      return this._emit("error", new AnthropicError(String(error2)));
    });
    __classPrivateFieldSet(this, _MessageStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _MessageStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet(this, _MessageStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet(this, _MessageStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _MessageStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet(this, _MessageStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet(this, _MessageStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet(this, _MessageStream_endPromise, "f").catch(() => {
    });
  }
  get response() {
    return __classPrivateFieldGet(this, _MessageStream_response, "f");
  }
  get request_id() {
    return __classPrivateFieldGet(this, _MessageStream_request_id, "f");
  }
  /**
   * Returns the `MessageStream` data, the raw `Response` instance and the ID of the request,
   * returned vie the `request-id` header which is useful for debugging requests and resporting
   * issues to Anthropic.
   *
   * This is the same as the `APIPromise.withResponse()` method.
   *
   * This method will raise an error if you created the stream using `MessageStream.fromReadableStream`
   * as no `Response` is available.
   */
  async withResponse() {
    const response = await __classPrivateFieldGet(this, _MessageStream_connectedPromise, "f");
    if (!response) {
      throw new Error("Could not resolve a `Response` object");
    }
    return {
      data: this,
      response,
      request_id: response.headers.get("request-id")
    };
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _MessageStream();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createMessage(messages, params, options) {
    const runner = new _MessageStream();
    for (const message of params.messages) {
      runner._addMessageParam(message);
    }
    runner._run(() => runner._createMessage(messages, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  _run(executor) {
    executor().then(() => {
      this._emitFinal();
      this._emit("end");
    }, __classPrivateFieldGet(this, _MessageStream_handleError, "f"));
  }
  _addMessageParam(message) {
    this.messages.push(message);
  }
  _addMessage(message, emit = true) {
    this.receivedMessages.push(message);
    if (emit) {
      this._emit("message", message);
    }
  }
  async _createMessage(messages, params, options) {
    const signal = options?.signal;
    let abortHandler;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      abortHandler = this.controller.abort.bind(this.controller);
      signal.addEventListener("abort", abortHandler);
    }
    try {
      __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
      const { response, data: stream } = await messages.create({ ...params, stream: true }, { ...options, signal: this.controller.signal }).withResponse();
      this._connected(response);
      for await (const event of stream) {
        __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
      }
      if (stream.controller.signal?.aborted) {
        throw new APIUserAbortError();
      }
      __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
    } finally {
      if (signal && abortHandler) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  _connected(response) {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _MessageStream_response, response, "f");
    __classPrivateFieldSet(this, _MessageStream_request_id, response?.headers.get("request-id"), "f");
    __classPrivateFieldGet(this, _MessageStream_resolveConnectedPromise, "f").call(this, response);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet(this, _MessageStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet(this, _MessageStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet(this, _MessageStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this MessageStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this MessageStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this MessageStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] || (__classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet(this, _MessageStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet(this, _MessageStream_endPromise, "f");
  }
  get currentMessage() {
    return __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, "f");
  }
  /**
   * @returns a promise that resolves with the the final assistant Message response,
   * or rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant Message's text response, concatenated
   * together if there are more than one text blocks.
   * Rejects if an error occurred or the stream ended prematurely without producing a Message.
   */
  async finalText() {
    await this.done();
    return __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_getFinalText).call(this);
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet(this, _MessageStream_ended, "f"))
      return;
    if (event === "end") {
      __classPrivateFieldSet(this, _MessageStream_ended, true, "f");
      __classPrivateFieldGet(this, _MessageStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet(this, _MessageStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error2 = args[0];
      if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error2);
      }
      __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, "f").call(this, error2);
      __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, "f").call(this, error2);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error2 = args[0];
      if (!__classPrivateFieldGet(this, _MessageStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error2);
      }
      __classPrivateFieldGet(this, _MessageStream_rejectConnectedPromise, "f").call(this, error2);
      __classPrivateFieldGet(this, _MessageStream_rejectEndPromise, "f").call(this, error2);
      this._emit("end");
    }
  }
  _emitFinal() {
    const finalMessage = this.receivedMessages.at(-1);
    if (finalMessage) {
      this._emit("finalMessage", __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_getFinalMessage).call(this));
    }
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    let abortHandler;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      abortHandler = this.controller.abort.bind(this.controller);
      signal.addEventListener("abort", abortHandler);
    }
    try {
      __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_beginRequest).call(this);
      this._connected(null);
      const stream = Stream.fromReadableStream(readableStream, this.controller);
      for await (const event of stream) {
        __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_addStreamEvent).call(this, event);
      }
      if (stream.controller.signal?.aborted) {
        throw new APIUserAbortError();
      }
      __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_endRequest).call(this);
    } finally {
      if (signal && abortHandler) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  [(_MessageStream_currentMessageSnapshot = /* @__PURE__ */ new WeakMap(), _MessageStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_endPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _MessageStream_listeners = /* @__PURE__ */ new WeakMap(), _MessageStream_ended = /* @__PURE__ */ new WeakMap(), _MessageStream_errored = /* @__PURE__ */ new WeakMap(), _MessageStream_aborted = /* @__PURE__ */ new WeakMap(), _MessageStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _MessageStream_response = /* @__PURE__ */ new WeakMap(), _MessageStream_request_id = /* @__PURE__ */ new WeakMap(), _MessageStream_handleError = /* @__PURE__ */ new WeakMap(), _MessageStream_instances = /* @__PURE__ */ new WeakSet(), _MessageStream_getFinalMessage = function _MessageStream_getFinalMessage2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    return this.receivedMessages.at(-1);
  }, _MessageStream_getFinalText = function _MessageStream_getFinalText2() {
    if (this.receivedMessages.length === 0) {
      throw new AnthropicError("stream ended without producing a Message with role=assistant");
    }
    const textBlocks = this.receivedMessages.at(-1).content.filter((block) => block.type === "text").map((block) => block.text);
    if (textBlocks.length === 0) {
      throw new AnthropicError("stream ended without producing a content block with type=text");
    }
    return textBlocks.join(" ");
  }, _MessageStream_beginRequest = function _MessageStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, void 0, "f");
  }, _MessageStream_addStreamEvent = function _MessageStream_addStreamEvent2(event) {
    if (this.ended)
      return;
    const messageSnapshot = __classPrivateFieldGet(this, _MessageStream_instances, "m", _MessageStream_accumulateMessage).call(this, event);
    this._emit("streamEvent", event, messageSnapshot);
    switch (event.type) {
      case "content_block_delta": {
        const content = messageSnapshot.content.at(-1);
        switch (event.delta.type) {
          case "text_delta": {
            if (content.type === "text") {
              this._emit("text", event.delta.text, content.text || "");
            }
            break;
          }
          case "citations_delta": {
            if (content.type === "text") {
              this._emit("citation", event.delta.citation, content.citations ?? []);
            }
            break;
          }
          case "input_json_delta": {
            if (tracksToolInput2(content) && content.input) {
              this._emit("inputJson", event.delta.partial_json, content.input);
            }
            break;
          }
          case "thinking_delta": {
            if (content.type === "thinking") {
              this._emit("thinking", event.delta.thinking, content.thinking);
            }
            break;
          }
          case "signature_delta": {
            if (content.type === "thinking") {
              this._emit("signature", content.signature);
            }
            break;
          }
          default:
            checkNever2(event.delta);
        }
        break;
      }
      case "message_stop": {
        this._addMessageParam(messageSnapshot);
        this._addMessage(messageSnapshot, true);
        break;
      }
      case "content_block_stop": {
        this._emit("contentBlock", messageSnapshot.content.at(-1));
        break;
      }
      case "message_start": {
        __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, messageSnapshot, "f");
        break;
      }
      case "content_block_start":
      case "message_delta":
        break;
    }
  }, _MessageStream_endRequest = function _MessageStream_endRequest2() {
    if (this.ended) {
      throw new AnthropicError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, "f");
    if (!snapshot) {
      throw new AnthropicError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet(this, _MessageStream_currentMessageSnapshot, void 0, "f");
    return snapshot;
  }, _MessageStream_accumulateMessage = function _MessageStream_accumulateMessage2(event) {
    let snapshot = __classPrivateFieldGet(this, _MessageStream_currentMessageSnapshot, "f");
    if (event.type === "message_start") {
      if (snapshot) {
        throw new AnthropicError(`Unexpected event order, got ${event.type} before receiving "message_stop"`);
      }
      return event.message;
    }
    if (!snapshot) {
      throw new AnthropicError(`Unexpected event order, got ${event.type} before "message_start"`);
    }
    switch (event.type) {
      case "message_stop":
        return snapshot;
      case "message_delta":
        snapshot.stop_reason = event.delta.stop_reason;
        snapshot.stop_sequence = event.delta.stop_sequence;
        snapshot.usage.output_tokens = event.usage.output_tokens;
        if (event.usage.input_tokens != null) {
          snapshot.usage.input_tokens = event.usage.input_tokens;
        }
        if (event.usage.cache_creation_input_tokens != null) {
          snapshot.usage.cache_creation_input_tokens = event.usage.cache_creation_input_tokens;
        }
        if (event.usage.cache_read_input_tokens != null) {
          snapshot.usage.cache_read_input_tokens = event.usage.cache_read_input_tokens;
        }
        if (event.usage.server_tool_use != null) {
          snapshot.usage.server_tool_use = event.usage.server_tool_use;
        }
        return snapshot;
      case "content_block_start":
        snapshot.content.push({ ...event.content_block });
        return snapshot;
      case "content_block_delta": {
        const snapshotContent = snapshot.content.at(event.index);
        switch (event.delta.type) {
          case "text_delta": {
            if (snapshotContent?.type === "text") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                text: (snapshotContent.text || "") + event.delta.text
              };
            }
            break;
          }
          case "citations_delta": {
            if (snapshotContent?.type === "text") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                citations: [...snapshotContent.citations ?? [], event.delta.citation]
              };
            }
            break;
          }
          case "input_json_delta": {
            if (snapshotContent && tracksToolInput2(snapshotContent)) {
              let jsonBuf = snapshotContent[JSON_BUF_PROPERTY2] || "";
              jsonBuf += event.delta.partial_json;
              const newContent = { ...snapshotContent };
              Object.defineProperty(newContent, JSON_BUF_PROPERTY2, {
                value: jsonBuf,
                enumerable: false,
                writable: true
              });
              if (jsonBuf) {
                newContent.input = partialParse(jsonBuf);
              }
              snapshot.content[event.index] = newContent;
            }
            break;
          }
          case "thinking_delta": {
            if (snapshotContent?.type === "thinking") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                thinking: snapshotContent.thinking + event.delta.thinking
              };
            }
            break;
          }
          case "signature_delta": {
            if (snapshotContent?.type === "thinking") {
              snapshot.content[event.index] = {
                ...snapshotContent,
                signature: event.delta.signature
              };
            }
            break;
          }
          default:
            checkNever2(event.delta);
        }
        return snapshot;
      }
      case "content_block_stop":
        return snapshot;
    }
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("streamEvent", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function checkNever2(x) {
}

// node_modules/@anthropic-ai/sdk/resources/messages/batches.mjs
var Batches2 = class extends APIResource {
  /**
   * Send a batch of Message creation requests.
   *
   * The Message Batches API can be used to process multiple Messages API requests at
   * once. Once a Message Batch is created, it begins processing immediately. Batches
   * can take up to 24 hours to complete.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.create({
   *   requests: [
   *     {
   *       custom_id: 'my-custom-id-1',
   *       params: {
   *         max_tokens: 1024,
   *         messages: [
   *           { content: 'Hello, world', role: 'user' },
   *         ],
   *         model: 'claude-sonnet-4-5-20250929',
   *       },
   *     },
   *   ],
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/v1/messages/batches", { body, ...options });
  }
  /**
   * This endpoint is idempotent and can be used to poll for Message Batch
   * completion. To access the results of a Message Batch, make a request to the
   * `results_url` field in the response.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.retrieve(
   *   'message_batch_id',
   * );
   * ```
   */
  retrieve(messageBatchID, options) {
    return this._client.get(path`/v1/messages/batches/${messageBatchID}`, options);
  }
  /**
   * List all Message Batches within a Workspace. Most recently created batches are
   * returned first.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const messageBatch of client.messages.batches.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/v1/messages/batches", Page, { query, ...options });
  }
  /**
   * Delete a Message Batch.
   *
   * Message Batches can only be deleted once they've finished processing. If you'd
   * like to delete an in-progress batch, you must first cancel it.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const deletedMessageBatch =
   *   await client.messages.batches.delete('message_batch_id');
   * ```
   */
  delete(messageBatchID, options) {
    return this._client.delete(path`/v1/messages/batches/${messageBatchID}`, options);
  }
  /**
   * Batches may be canceled any time before processing ends. Once cancellation is
   * initiated, the batch enters a `canceling` state, at which time the system may
   * complete any in-progress, non-interruptible requests before finalizing
   * cancellation.
   *
   * The number of canceled requests is specified in `request_counts`. To determine
   * which requests were canceled, check the individual results within the batch.
   * Note that cancellation may not result in any canceled requests if they were
   * non-interruptible.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatch = await client.messages.batches.cancel(
   *   'message_batch_id',
   * );
   * ```
   */
  cancel(messageBatchID, options) {
    return this._client.post(path`/v1/messages/batches/${messageBatchID}/cancel`, options);
  }
  /**
   * Streams the results of a Message Batch as a `.jsonl` file.
   *
   * Each line in the file is a JSON object containing the result of a single request
   * in the Message Batch. Results are not guaranteed to be in the same order as
   * requests. Use the `custom_id` field to match results to requests.
   *
   * Learn more about the Message Batches API in our
   * [user guide](/en/docs/build-with-claude/batch-processing)
   *
   * @example
   * ```ts
   * const messageBatchIndividualResponse =
   *   await client.messages.batches.results('message_batch_id');
   * ```
   */
  async results(messageBatchID, options) {
    const batch = await this.retrieve(messageBatchID);
    if (!batch.results_url) {
      throw new AnthropicError(`No batch \`results_url\`; Has it finished processing? ${batch.processing_status} - ${batch.id}`);
    }
    return this._client.get(batch.results_url, {
      ...options,
      headers: buildHeaders([{ Accept: "application/binary" }, options?.headers]),
      stream: true,
      __binaryResponse: true
    })._thenUnwrap((_, props) => JSONLDecoder.fromResponse(props.response, props.controller));
  }
};

// node_modules/@anthropic-ai/sdk/resources/messages/messages.mjs
var Messages2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.batches = new Batches2(this._client);
  }
  create(body, options) {
    if (body.model in DEPRECATED_MODELS2) {
      console.warn(`The model '${body.model}' is deprecated and will reach end-of-life on ${DEPRECATED_MODELS2[body.model]}
Please migrate to a newer model. Visit https://docs.anthropic.com/en/docs/resources/model-deprecations for more information.`);
    }
    let timeout = this._client._options.timeout;
    if (!body.stream && timeout == null) {
      const maxNonstreamingTokens = MODEL_NONSTREAMING_TOKENS[body.model] ?? void 0;
      timeout = this._client.calculateNonstreamingTimeout(body.max_tokens, maxNonstreamingTokens);
    }
    return this._client.post("/v1/messages", {
      body,
      timeout: timeout ?? 6e5,
      ...options,
      stream: body.stream ?? false
    });
  }
  /**
   * Create a Message stream
   */
  stream(body, options) {
    return MessageStream.createMessage(this, body, options);
  }
  /**
   * Count the number of tokens in a Message.
   *
   * The Token Count API can be used to count the number of tokens in a Message,
   * including tools, images, and documents, without creating it.
   *
   * Learn more about token counting in our
   * [user guide](/en/docs/build-with-claude/token-counting)
   *
   * @example
   * ```ts
   * const messageTokensCount =
   *   await client.messages.countTokens({
   *     messages: [{ content: 'string', role: 'user' }],
   *     model: 'claude-3-7-sonnet-latest',
   *   });
   * ```
   */
  countTokens(body, options) {
    return this._client.post("/v1/messages/count_tokens", { body, ...options });
  }
};
var DEPRECATED_MODELS2 = {
  "claude-1.3": "November 6th, 2024",
  "claude-1.3-100k": "November 6th, 2024",
  "claude-instant-1.1": "November 6th, 2024",
  "claude-instant-1.1-100k": "November 6th, 2024",
  "claude-instant-1.2": "November 6th, 2024",
  "claude-3-sonnet-20240229": "July 21st, 2025",
  "claude-3-opus-20240229": "January 5th, 2026",
  "claude-2.1": "July 21st, 2025",
  "claude-2.0": "July 21st, 2025",
  "claude-3-5-sonnet-20241022": "October 22, 2025",
  "claude-3-5-sonnet-20240620": "October 22, 2025"
};
Messages2.Batches = Batches2;

// node_modules/@anthropic-ai/sdk/resources/models.mjs
var Models2 = class extends APIResource {
  /**
   * Get a specific model.
   *
   * The Models API response can be used to determine information about a specific
   * model or resolve a model alias to a model ID.
   */
  retrieve(modelID, params = {}, options) {
    const { betas } = params ?? {};
    return this._client.get(path`/v1/models/${modelID}`, {
      ...options,
      headers: buildHeaders([
        { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0 },
        options?.headers
      ])
    });
  }
  /**
   * List available models.
   *
   * The Models API response can be used to determine which models are available for
   * use in the API. More recently released models are listed first.
   */
  list(params = {}, options) {
    const { betas, ...query } = params ?? {};
    return this._client.getAPIList("/v1/models", Page, {
      query,
      ...options,
      headers: buildHeaders([
        { ...betas?.toString() != null ? { "anthropic-beta": betas?.toString() } : void 0 },
        options?.headers
      ])
    });
  }
};

// node_modules/@anthropic-ai/sdk/internal/utils/env.mjs
var readEnv = (env3) => {
  if (typeof globalThis.process !== "undefined") {
    return globalThis.process.env?.[env3]?.trim() ?? void 0;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return globalThis.Deno.env?.get?.(env3)?.trim();
  }
  return void 0;
};

// node_modules/@anthropic-ai/sdk/client.mjs
var _BaseAnthropic_instances;
var _a;
var _BaseAnthropic_encoder;
var _BaseAnthropic_baseURLOverridden;
var HUMAN_PROMPT = "\\n\\nHuman:";
var AI_PROMPT = "\\n\\nAssistant:";
var BaseAnthropic = class {
  /**
   * API Client for interfacing with the Anthropic API.
   *
   * @param {string | null | undefined} [opts.apiKey=process.env['ANTHROPIC_API_KEY'] ?? null]
   * @param {string | null | undefined} [opts.authToken=process.env['ANTHROPIC_AUTH_TOKEN'] ?? null]
   * @param {string} [opts.baseURL=process.env['ANTHROPIC_BASE_URL'] ?? https://api.anthropic.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("ANTHROPIC_BASE_URL"), apiKey = readEnv("ANTHROPIC_API_KEY") ?? null, authToken = readEnv("ANTHROPIC_AUTH_TOKEN") ?? null, ...opts } = {}) {
    _BaseAnthropic_instances.add(this);
    _BaseAnthropic_encoder.set(this, void 0);
    const options = {
      apiKey,
      authToken,
      ...opts,
      baseURL: baseURL || `https://api.anthropic.com`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new AnthropicError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Anthropic({ apiKey, dangerouslyAllowBrowser: true });\n");
    }
    this.baseURL = options.baseURL;
    this.timeout = options.timeout ?? _a.DEFAULT_TIMEOUT;
    this.logger = options.logger ?? console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = parseLogLevel(options.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel(readEnv("ANTHROPIC_LOG"), "process.env['ANTHROPIC_LOG']", this) ?? defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = options.maxRetries ?? 2;
    this.fetch = options.fetch ?? getDefaultFetch();
    __classPrivateFieldSet(this, _BaseAnthropic_encoder, FallbackEncoder, "f");
    this._options = options;
    this.apiKey = apiKey;
    this.authToken = authToken;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(options) {
    const client = new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      authToken: this.authToken,
      ...options
    });
    return client;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    if (this.apiKey && values.get("x-api-key")) {
      return;
    }
    if (nulls.has("x-api-key")) {
      return;
    }
    if (this.authToken && values.get("authorization")) {
      return;
    }
    if (nulls.has("authorization")) {
      return;
    }
    throw new Error('Could not resolve authentication method. Expected either apiKey or authToken to be set. Or for one of the "X-Api-Key" or "Authorization" headers to be explicitly omitted');
  }
  async authHeaders(opts) {
    return buildHeaders([await this.apiKeyAuth(opts), await this.bearerAuth(opts)]);
  }
  async apiKeyAuth(opts) {
    if (this.apiKey == null) {
      return void 0;
    }
    return buildHeaders([{ "X-Api-Key": this.apiKey }]);
  }
  async bearerAuth(opts) {
    if (this.authToken == null) {
      return void 0;
    }
    return buildHeaders([{ Authorization: `Bearer ${this.authToken}` }]);
  }
  /**
   * Basic re-implementation of `qs.stringify` for primitive types.
   */
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new AnthropicError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  makeStatusError(status, error2, message, headers) {
    return APIError.generate(status, error2, message, headers);
  }
  buildURL(path10, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet(this, _BaseAnthropic_instances, "m", _BaseAnthropic_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url2 = isAbsoluteURL(path10) ? new URL(path10) : new URL(baseURL + (baseURL.endsWith("/") && path10.startsWith("/") ? path10.slice(1) : path10));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url2.search = this.stringifyQuery(query);
    }
    return url2.toString();
  }
  _calculateNonstreamingTimeout(maxTokens) {
    const defaultTimeout = 10 * 60;
    const expectedTimeout = 60 * 60 * maxTokens / 128e3;
    if (expectedTimeout > defaultTimeout) {
      throw new AnthropicError("Streaming is required for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#streaming-responses for more details");
    }
    return defaultTimeout * 1e3;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request3, { url: url2, options }) {
  }
  get(path10, opts) {
    return this.methodRequest("get", path10, opts);
  }
  post(path10, opts) {
    return this.methodRequest("post", path10, opts);
  }
  patch(path10, opts) {
    return this.methodRequest("patch", path10, opts);
  }
  put(path10, opts) {
    return this.methodRequest("put", path10, opts);
  }
  delete(path10, opts) {
    return this.methodRequest("delete", path10, opts);
  }
  methodRequest(method, path10, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path10, ...opts2 };
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this, this.makeRequest(options, remainingRetries, void 0));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url: url2, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url: url2, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
      retryOfRequestLogID,
      method: options.method,
      url: url2,
      options,
      headers: req.headers
    }));
    if (options.signal?.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url2, req, timeout, controller).catch(castToError);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if (options.signal?.aborted) {
        throw new APIUserAbortError();
      }
      const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
          retryOfRequestLogID,
          url: url2,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
      }
      loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
        retryOfRequestLogID,
        url: url2,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
    const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url2} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream(response.body);
        loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError(err2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor(this).info(responseInfo);
    loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  getAPIList(path10, Page3, opts) {
    return this.requestAPIList(Page3, { method: "get", path: path10, ...opts });
  }
  requestAPIList(Page3, options) {
    const request3 = this.makeRequest(options, null, void 0);
    return new PagePromise(this, request3, Page3);
  }
  async fetchWithTimeout(url2, init, ms, controller) {
    const { signal, method, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(void 0, url2, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  calculateNonstreamingTimeout(maxTokens, maxNonstreamingTokens) {
    const maxTime = 60 * 60 * 1e3;
    const defaultTime = 60 * 10 * 1e3;
    const expectedTime = maxTime * maxTokens / 128e3;
    if (expectedTime > defaultTime || maxNonstreamingTokens != null && maxTokens > maxNonstreamingTokens) {
      throw new AnthropicError("Streaming is required for operations that may take longer than 10 minutes. See https://github.com/anthropics/anthropic-sdk-typescript#long-requests for more details");
    }
    return defaultTime;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path: path10, query, defaultBaseURL } = options;
    const url2 = this.buildURL(path10, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options.signal && { signal: options.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...this.fetchOptions ?? {},
      ...options.fetchOptions ?? {}
    };
    return { req, url: url2, timeout: options.timeout };
  }
  async buildHeaders({ options, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const headers = buildHeaders([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1e3)) } : {},
        ...getPlatformHeaders(),
        ...this._options.dangerouslyAllowBrowser ? { "anthropic-dangerous-direct-browser-access": "true" } : void 0,
        "anthropic-version": "2023-06-01"
      },
      await this.authHeaders(options),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: void 0, body: void 0 };
    }
    const headers = buildHeaders([rawHeaders]);
    if (
      // Pass raw type verbatim
      ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
      headers.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && body instanceof globalThis.ReadableStream
    ) {
      return { bodyHeaders: void 0, body };
    } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
      return { bodyHeaders: void 0, body: ReadableStreamFrom(body) };
    } else {
      return __classPrivateFieldGet(this, _BaseAnthropic_encoder, "f").call(this, { body, headers });
    }
  }
};
_a = BaseAnthropic, _BaseAnthropic_encoder = /* @__PURE__ */ new WeakMap(), _BaseAnthropic_instances = /* @__PURE__ */ new WeakSet(), _BaseAnthropic_baseURLOverridden = function _BaseAnthropic_baseURLOverridden2() {
  return this.baseURL !== "https://api.anthropic.com";
};
BaseAnthropic.Anthropic = _a;
BaseAnthropic.HUMAN_PROMPT = HUMAN_PROMPT;
BaseAnthropic.AI_PROMPT = AI_PROMPT;
BaseAnthropic.DEFAULT_TIMEOUT = 6e5;
BaseAnthropic.AnthropicError = AnthropicError;
BaseAnthropic.APIError = APIError;
BaseAnthropic.APIConnectionError = APIConnectionError;
BaseAnthropic.APIConnectionTimeoutError = APIConnectionTimeoutError;
BaseAnthropic.APIUserAbortError = APIUserAbortError;
BaseAnthropic.NotFoundError = NotFoundError;
BaseAnthropic.ConflictError = ConflictError;
BaseAnthropic.RateLimitError = RateLimitError;
BaseAnthropic.BadRequestError = BadRequestError;
BaseAnthropic.AuthenticationError = AuthenticationError;
BaseAnthropic.InternalServerError = InternalServerError;
BaseAnthropic.PermissionDeniedError = PermissionDeniedError;
BaseAnthropic.UnprocessableEntityError = UnprocessableEntityError;
BaseAnthropic.toFile = toFile;
var Anthropic = class extends BaseAnthropic {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this);
    this.messages = new Messages2(this);
    this.models = new Models2(this);
    this.beta = new Beta(this);
  }
};
Anthropic.Completions = Completions;
Anthropic.Messages = Messages2;
Anthropic.Models = Models2;
Anthropic.Beta = Beta;

// src/providers/anthropic/anthropicHandler.ts
var vscode18 = __toESM(require("vscode"));
init_apiKeyManager();
init_configManager();
init_logger();

// src/utils/versionManager.ts
var vscode13 = __toESM(require("vscode"));
var VersionManager = class _VersionManager {
  static _version = null;
  /**
   * Get extension version number
   */
  static getVersion() {
    if (_VersionManager._version === null) {
      const extension = vscode13.extensions.getExtension(
        "vicanent.copilot-helper-pro"
      );
      _VersionManager._version = extension?.packageJSON?.version || "0.4.0";
    }
    return _VersionManager._version;
  }
  /**
   * Get user agent string
   */
  static getUserAgent(component) {
    return `CHP-${component}/${_VersionManager.getVersion()}`;
  }
  /**
   * Get client information
   */
  static getClientInfo() {
    return {
      name: "Copilot ++",
      version: _VersionManager.getVersion()
    };
  }
  /**
   * Reset cache (mainly for testing)
   */
  static resetCache() {
    _VersionManager._version = null;
  }
};

// node_modules/openai/internal/tslib.mjs
function __classPrivateFieldSet2(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldGet2(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/openai/internal/utils/uuid.mjs
var uuid42 = function() {
  const { crypto: crypto6 } = globalThis;
  if (crypto6?.randomUUID) {
    uuid42 = crypto6.randomUUID.bind(crypto6);
    return crypto6.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto6 ? () => crypto6.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c) => (+c ^ randomByte() & 15 >> +c / 4).toString(16));
};

// node_modules/openai/internal/errors.mjs
function isAbortError2(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError2 = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error2 = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error2.stack = err.stack;
        if (err.cause && !error2.cause)
          error2.cause = err.cause;
        if (err.name)
          error2.name = err.name;
        return error2;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};

// node_modules/openai/core/error.mjs
var OpenAIError = class extends Error {
};
var APIError2 = class _APIError extends OpenAIError {
  constructor(status, error2, message, headers) {
    super(`${_APIError.makeMessage(status, error2, message)}`);
    this.status = status;
    this.headers = headers;
    this.requestID = headers?.get("x-request-id");
    this.error = error2;
    const data = error2;
    this.code = data?.["code"];
    this.param = data?.["param"];
    this.type = data?.["type"];
  }
  static makeMessage(status, error2, message) {
    const msg = error2?.message ? typeof error2.message === "string" ? error2.message : JSON.stringify(error2.message) : error2 ? JSON.stringify(error2) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError2({ message, cause: castToError2(errorResponse) });
    }
    const error2 = errorResponse?.["error"];
    if (status === 400) {
      return new BadRequestError2(status, error2, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError2(status, error2, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError2(status, error2, message, headers);
    }
    if (status === 404) {
      return new NotFoundError2(status, error2, message, headers);
    }
    if (status === 409) {
      return new ConflictError2(status, error2, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError2(status, error2, message, headers);
    }
    if (status === 429) {
      return new RateLimitError2(status, error2, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError2(status, error2, message, headers);
    }
    return new _APIError(status, error2, message, headers);
  }
};
var APIUserAbortError2 = class extends APIError2 {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError2 = class extends APIError2 {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError2 = class extends APIConnectionError2 {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
};
var BadRequestError2 = class extends APIError2 {
};
var AuthenticationError2 = class extends APIError2 {
};
var PermissionDeniedError2 = class extends APIError2 {
};
var NotFoundError2 = class extends APIError2 {
};
var ConflictError2 = class extends APIError2 {
};
var UnprocessableEntityError2 = class extends APIError2 {
};
var RateLimitError2 = class extends APIError2 {
};
var InternalServerError2 = class extends APIError2 {
};
var LengthFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the length limit was reached`);
  }
};
var ContentFilterFinishReasonError = class extends OpenAIError {
  constructor() {
    super(`Could not parse response content as the request was rejected by the content filter`);
  }
};
var InvalidWebhookSignatureError = class extends Error {
  constructor(message) {
    super(message);
  }
};

// node_modules/openai/internal/utils/values.mjs
var startsWithSchemeRegexp2 = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL2 = (url2) => {
  return startsWithSchemeRegexp2.test(url2);
};
var isArray2 = (val) => (isArray2 = Array.isArray, isArray2(val));
var isReadonlyArray2 = isArray2;
function maybeObj2(x) {
  if (typeof x !== "object") {
    return {};
  }
  return x ?? {};
}
function isEmptyObj2(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn2(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function isObj(obj) {
  return obj != null && typeof obj === "object" && !Array.isArray(obj);
}
var validatePositiveInteger2 = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new OpenAIError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new OpenAIError(`${name} must be a positive integer`);
  }
  return n;
};
var safeJSON2 = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};

// node_modules/openai/internal/utils/sleep.mjs
var sleep2 = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// node_modules/openai/version.mjs
var VERSION2 = "6.15.0";

// node_modules/openai/internal/detect-platform.mjs
var isRunningInBrowser2 = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};
function getDetectedPlatform2() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
var getPlatformProperties2 = () => {
  const detectedPlatform = getDetectedPlatform2();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform2(Deno.build.os),
      "X-Stainless-Arch": normalizeArch2(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : Deno.version?.deno ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": normalizePlatform2(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": normalizeArch2(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  }
  const browserInfo = getBrowserInfo2();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION2,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION2,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo2() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch2 = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform2 = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders2;
var getPlatformHeaders2 = () => {
  return _platformHeaders2 ?? (_platformHeaders2 = getPlatformProperties2());
};

// node_modules/openai/internal/shims.mjs
function getDefaultFetch2() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new OpenAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream2(...args) {
  const ReadableStream2 = globalThis.ReadableStream;
  if (typeof ReadableStream2 === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream2(...args);
}
function ReadableStreamFrom2(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream2({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      await iter.return?.();
    }
  });
}
function ReadableStreamToAsyncIterable2(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result?.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream2(stream) {
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await stream[Symbol.asyncIterator]().return?.();
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}

// node_modules/openai/internal/request-options.mjs
var FallbackEncoder2 = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};

// node_modules/openai/internal/qs/formats.mjs
var default_format = "RFC3986";
var default_formatter = (v) => String(v);
var formatters = {
  RFC1738: (v) => String(v).replace(/%20/g, "+"),
  RFC3986: default_formatter
};
var RFC1738 = "RFC1738";

// node_modules/openai/internal/qs/utils.mjs
var has = (obj, key) => (has = Object.hasOwn ?? Function.prototype.call.bind(Object.prototype.hasOwnProperty), has(obj, key));
var hex_table = /* @__PURE__ */ (() => {
  const array2 = [];
  for (let i = 0; i < 256; ++i) {
    array2.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
  }
  return array2;
})();
var limit = 1024;
var encode = (str2, _defaultEncoder, charset, _kind, format) => {
  if (str2.length === 0) {
    return str2;
  }
  let string4 = str2;
  if (typeof str2 === "symbol") {
    string4 = Symbol.prototype.toString.call(str2);
  } else if (typeof str2 !== "string") {
    string4 = String(str2);
  }
  if (charset === "iso-8859-1") {
    return escape(string4).replace(/%u[0-9a-f]{4}/gi, function($0) {
      return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
    });
  }
  let out = "";
  for (let j = 0; j < string4.length; j += limit) {
    const segment = string4.length >= limit ? string4.slice(j, j + limit) : string4;
    const arr = [];
    for (let i = 0; i < segment.length; ++i) {
      let c = segment.charCodeAt(i);
      if (c === 45 || // -
      c === 46 || // .
      c === 95 || // _
      c === 126 || // ~
      c >= 48 && c <= 57 || // 0-9
      c >= 65 && c <= 90 || // a-z
      c >= 97 && c <= 122 || // A-Z
      format === RFC1738 && (c === 40 || c === 41)) {
        arr[arr.length] = segment.charAt(i);
        continue;
      }
      if (c < 128) {
        arr[arr.length] = hex_table[c];
        continue;
      }
      if (c < 2048) {
        arr[arr.length] = hex_table[192 | c >> 6] + hex_table[128 | c & 63];
        continue;
      }
      if (c < 55296 || c >= 57344) {
        arr[arr.length] = hex_table[224 | c >> 12] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
      arr[arr.length] = hex_table[240 | c >> 18] + hex_table[128 | c >> 12 & 63] + hex_table[128 | c >> 6 & 63] + hex_table[128 | c & 63];
    }
    out += arr.join("");
  }
  return out;
};
function is_buffer(obj) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
}
function maybe_map(val, fn) {
  if (isArray2(val)) {
    const mapped = [];
    for (let i = 0; i < val.length; i += 1) {
      mapped.push(fn(val[i]));
    }
    return mapped;
  }
  return fn(val);
}

// node_modules/openai/internal/qs/stringify.mjs
var array_prefix_generators = {
  brackets(prefix) {
    return String(prefix) + "[]";
  },
  comma: "comma",
  indices(prefix, key) {
    return String(prefix) + "[" + key + "]";
  },
  repeat(prefix) {
    return String(prefix);
  }
};
var push_to_array = function(arr, value_or_array) {
  Array.prototype.push.apply(arr, isArray2(value_or_array) ? value_or_array : [value_or_array]);
};
var toISOString;
var defaults = {
  addQueryPrefix: false,
  allowDots: false,
  allowEmptyArrays: false,
  arrayFormat: "indices",
  charset: "utf-8",
  charsetSentinel: false,
  delimiter: "&",
  encode: true,
  encodeDotInKeys: false,
  encoder: encode,
  encodeValuesOnly: false,
  format: default_format,
  formatter: default_formatter,
  /** @deprecated */
  indices: false,
  serializeDate(date4) {
    return (toISOString ?? (toISOString = Function.prototype.call.bind(Date.prototype.toISOString)))(date4);
  },
  skipNulls: false,
  strictNullHandling: false
};
function is_non_nullish_primitive(v) {
  return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
}
var sentinel = {};
function inner_stringify(object3, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
  let obj = object3;
  let tmp_sc = sideChannel;
  let step = 0;
  let find_flag = false;
  while ((tmp_sc = tmp_sc.get(sentinel)) !== void 0 && !find_flag) {
    const pos = tmp_sc.get(object3);
    step += 1;
    if (typeof pos !== "undefined") {
      if (pos === step) {
        throw new RangeError("Cyclic object value");
      } else {
        find_flag = true;
      }
    }
    if (typeof tmp_sc.get(sentinel) === "undefined") {
      step = 0;
    }
  }
  if (typeof filter === "function") {
    obj = filter(prefix, obj);
  } else if (obj instanceof Date) {
    obj = serializeDate?.(obj);
  } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
    obj = maybe_map(obj, function(value) {
      if (value instanceof Date) {
        return serializeDate?.(value);
      }
      return value;
    });
  }
  if (obj === null) {
    if (strictNullHandling) {
      return encoder && !encodeValuesOnly ? (
        // @ts-expect-error
        encoder(prefix, defaults.encoder, charset, "key", format)
      ) : prefix;
    }
    obj = "";
  }
  if (is_non_nullish_primitive(obj) || is_buffer(obj)) {
    if (encoder) {
      const key_value = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
      return [
        formatter?.(key_value) + "=" + // @ts-expect-error
        formatter?.(encoder(obj, defaults.encoder, charset, "value", format))
      ];
    }
    return [formatter?.(prefix) + "=" + formatter?.(String(obj))];
  }
  const values = [];
  if (typeof obj === "undefined") {
    return values;
  }
  let obj_keys;
  if (generateArrayPrefix === "comma" && isArray2(obj)) {
    if (encodeValuesOnly && encoder) {
      obj = maybe_map(obj, encoder);
    }
    obj_keys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
  } else if (isArray2(filter)) {
    obj_keys = filter;
  } else {
    const keys = Object.keys(obj);
    obj_keys = sort ? keys.sort(sort) : keys;
  }
  const encoded_prefix = encodeDotInKeys ? String(prefix).replace(/\./g, "%2E") : String(prefix);
  const adjusted_prefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? encoded_prefix + "[]" : encoded_prefix;
  if (allowEmptyArrays && isArray2(obj) && obj.length === 0) {
    return adjusted_prefix + "[]";
  }
  for (let j = 0; j < obj_keys.length; ++j) {
    const key = obj_keys[j];
    const value = (
      // @ts-ignore
      typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key]
    );
    if (skipNulls && value === null) {
      continue;
    }
    const encoded_key = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
    const key_prefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjusted_prefix, encoded_key) : adjusted_prefix : adjusted_prefix + (allowDots ? "." + encoded_key : "[" + encoded_key + "]");
    sideChannel.set(object3, step);
    const valueSideChannel = /* @__PURE__ */ new WeakMap();
    valueSideChannel.set(sentinel, sideChannel);
    push_to_array(values, inner_stringify(
      value,
      key_prefix,
      generateArrayPrefix,
      commaRoundTrip,
      allowEmptyArrays,
      strictNullHandling,
      skipNulls,
      encodeDotInKeys,
      // @ts-ignore
      generateArrayPrefix === "comma" && encodeValuesOnly && isArray2(obj) ? null : encoder,
      filter,
      sort,
      allowDots,
      serializeDate,
      format,
      formatter,
      encodeValuesOnly,
      charset,
      valueSideChannel
    ));
  }
  return values;
}
function normalize_stringify_options(opts = defaults) {
  if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
    throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
  }
  if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
    throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
  }
  if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
    throw new TypeError("Encoder has to be a function.");
  }
  const charset = opts.charset || defaults.charset;
  if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
    throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
  }
  let format = default_format;
  if (typeof opts.format !== "undefined") {
    if (!has(formatters, opts.format)) {
      throw new TypeError("Unknown format option provided.");
    }
    format = opts.format;
  }
  const formatter = formatters[format];
  let filter = defaults.filter;
  if (typeof opts.filter === "function" || isArray2(opts.filter)) {
    filter = opts.filter;
  }
  let arrayFormat;
  if (opts.arrayFormat && opts.arrayFormat in array_prefix_generators) {
    arrayFormat = opts.arrayFormat;
  } else if ("indices" in opts) {
    arrayFormat = opts.indices ? "indices" : "repeat";
  } else {
    arrayFormat = defaults.arrayFormat;
  }
  if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
    throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
  }
  const allowDots = typeof opts.allowDots === "undefined" ? !!opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
  return {
    addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
    // @ts-ignore
    allowDots,
    allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
    arrayFormat,
    charset,
    charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
    commaRoundTrip: !!opts.commaRoundTrip,
    delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
    encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
    encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
    encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
    encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
    filter,
    format,
    formatter,
    serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
    skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
    // @ts-ignore
    sort: typeof opts.sort === "function" ? opts.sort : null,
    strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
  };
}
function stringify(object3, opts = {}) {
  let obj = object3;
  const options = normalize_stringify_options(opts);
  let obj_keys;
  let filter;
  if (typeof options.filter === "function") {
    filter = options.filter;
    obj = filter("", obj);
  } else if (isArray2(options.filter)) {
    filter = options.filter;
    obj_keys = filter;
  }
  const keys = [];
  if (typeof obj !== "object" || obj === null) {
    return "";
  }
  const generateArrayPrefix = array_prefix_generators[options.arrayFormat];
  const commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
  if (!obj_keys) {
    obj_keys = Object.keys(obj);
  }
  if (options.sort) {
    obj_keys.sort(options.sort);
  }
  const sideChannel = /* @__PURE__ */ new WeakMap();
  for (let i = 0; i < obj_keys.length; ++i) {
    const key = obj_keys[i];
    if (options.skipNulls && obj[key] === null) {
      continue;
    }
    push_to_array(keys, inner_stringify(
      obj[key],
      key,
      // @ts-expect-error
      generateArrayPrefix,
      commaRoundTrip,
      options.allowEmptyArrays,
      options.strictNullHandling,
      options.skipNulls,
      options.encodeDotInKeys,
      options.encode ? options.encoder : null,
      options.filter,
      options.sort,
      options.allowDots,
      options.serializeDate,
      options.format,
      options.formatter,
      options.encodeValuesOnly,
      options.charset,
      sideChannel
    ));
  }
  const joined = keys.join(options.delimiter);
  let prefix = options.addQueryPrefix === true ? "?" : "";
  if (options.charsetSentinel) {
    if (options.charset === "iso-8859-1") {
      prefix += "utf8=%26%2310003%3B&";
    } else {
      prefix += "utf8=%E2%9C%93&";
    }
  }
  return joined.length > 0 ? prefix + joined : "";
}

// node_modules/openai/internal/utils/bytes.mjs
function concatBytes2(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
var encodeUTF8_2;
function encodeUTF82(str2) {
  let encoder;
  return (encodeUTF8_2 ?? (encoder = new globalThis.TextEncoder(), encodeUTF8_2 = encoder.encode.bind(encoder)))(str2);
}
var decodeUTF8_2;
function decodeUTF82(bytes) {
  let decoder;
  return (decodeUTF8_2 ?? (decoder = new globalThis.TextDecoder(), decodeUTF8_2 = decoder.decode.bind(decoder)))(bytes);
}

// node_modules/openai/internal/decoders/line.mjs
var _LineDecoder_buffer2;
var _LineDecoder_carriageReturnIndex2;
var LineDecoder2 = class {
  constructor() {
    _LineDecoder_buffer2.set(this, void 0);
    _LineDecoder_carriageReturnIndex2.set(this, void 0);
    __classPrivateFieldSet2(this, _LineDecoder_buffer2, new Uint8Array(), "f");
    __classPrivateFieldSet2(this, _LineDecoder_carriageReturnIndex2, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF82(chunk) : chunk;
    __classPrivateFieldSet2(this, _LineDecoder_buffer2, concatBytes2([__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f"), binaryChunk]), "f");
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex2(__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f"), __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") == null) {
        __classPrivateFieldSet2(this, _LineDecoder_carriageReturnIndex2, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") != null && (patternIndex.index !== __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF82(__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").subarray(0, __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") - 1)));
        __classPrivateFieldSet2(this, _LineDecoder_buffer2, __classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").subarray(__classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f")), "f");
        __classPrivateFieldSet2(this, _LineDecoder_carriageReturnIndex2, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet2(this, _LineDecoder_carriageReturnIndex2, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF82(__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").subarray(0, endIndex));
      lines.push(line);
      __classPrivateFieldSet2(this, _LineDecoder_buffer2, __classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").subarray(patternIndex.index), "f");
      __classPrivateFieldSet2(this, _LineDecoder_carriageReturnIndex2, null, "f");
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet2(this, _LineDecoder_buffer2, "f").length) {
      return [];
    }
    return this.decode("\n");
  }
};
_LineDecoder_buffer2 = /* @__PURE__ */ new WeakMap(), _LineDecoder_carriageReturnIndex2 = /* @__PURE__ */ new WeakMap();
LineDecoder2.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder2.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex2(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0; i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex2(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}

// node_modules/openai/internal/utils/log.mjs
var levelNumbers2 = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
var parseLogLevel2 = (maybeLevel, sourceName, client) => {
  if (!maybeLevel) {
    return void 0;
  }
  if (hasOwn2(levelNumbers2, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor2(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers2))}`);
  return void 0;
};
function noop2() {
}
function makeLogFn2(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers2[fnLevel] > levelNumbers2[logLevel]) {
    return noop2;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
var noopLogger2 = {
  error: noop2,
  warn: noop2,
  info: noop2,
  debug: noop2
};
var cachedLoggers2 = /* @__PURE__ */ new WeakMap();
function loggerFor2(client) {
  const logger = client.logger;
  const logLevel = client.logLevel ?? "off";
  if (!logger) {
    return noopLogger2;
  }
  const cachedLogger = cachedLoggers2.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn2("error", logger, logLevel),
    warn: makeLogFn2("warn", logger, logLevel),
    info: makeLogFn2("info", logger, logLevel),
    debug: makeLogFn2("debug", logger, logLevel)
  };
  cachedLoggers2.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
var formatRequestDetails2 = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};

// node_modules/openai/core/streaming.mjs
var _Stream_client2;
var Stream2 = class _Stream {
  constructor(iterator, controller, client) {
    this.iterator = iterator;
    _Stream_client2.set(this, void 0);
    this.controller = controller;
    __classPrivateFieldSet2(this, _Stream_client2, client, "f");
  }
  static fromSSEResponse(response, controller, client) {
    let consumed = false;
    const logger = client ? loggerFor2(client) : console;
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages2(response, controller)) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null || !sse.event.startsWith("thread.")) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              logger.error(`Could not parse message into JSON:`, sse.data);
              logger.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError2(void 0, data.error, void 0, response.headers);
            }
            yield data;
          } else {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (sse.event == "error") {
              throw new APIError2(void 0, data.error, data.message, void 0);
            }
            yield { event: sse.event, data };
          }
        }
        done = true;
      } catch (e) {
        if (isAbortError2(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller, client) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder2();
      const iter = ReadableStreamToAsyncIterable2(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new OpenAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (isAbortError2(e))
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  [(_Stream_client2 = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet2(this, _Stream_client2, "f")),
      new _Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet2(this, _Stream_client2, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self = this;
    let iter;
    return makeReadableStream2({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encodeUTF82(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        await iter.return?.();
      }
    });
  }
};
async function* _iterSSEMessages2(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new OpenAIError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new OpenAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder2();
  const lineDecoder = new LineDecoder2();
  const iter = ReadableStreamToAsyncIterable2(response.body);
  for await (const sseChunk of iterSSEChunks2(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks2(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF82(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex2(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
var SSEDecoder2 = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition2(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition2(str2, delimiter) {
  const index = str2.indexOf(delimiter);
  if (index !== -1) {
    return [str2.substring(0, index), delimiter, str2.substring(index + delimiter.length)];
  }
  return [str2, "", ""];
}

// node_modules/openai/internal/parse.mjs
async function defaultParseResponse2(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    if (props.options.stream) {
      loggerFor2(client).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller, client);
      }
      return Stream2.fromSSEResponse(response, props.controller, client);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = contentType?.split(";")[0]?.trim();
    const isJSON = mediaType?.includes("application/json") || mediaType?.endsWith("+json");
    if (isJSON) {
      const json = await response.json();
      return addRequestID2(json, response);
    }
    const text = await response.text();
    return text;
  })();
  loggerFor2(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails2({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}
function addRequestID2(value, response) {
  if (!value || typeof value !== "object" || Array.isArray(value)) {
    return value;
  }
  return Object.defineProperty(value, "_request_id", {
    value: response.headers.get("x-request-id"),
    enumerable: false
  });
}

// node_modules/openai/core/api-promise.mjs
var _APIPromise_client2;
var APIPromise2 = class _APIPromise extends Promise {
  constructor(client, responsePromise, parseResponse2 = defaultParseResponse2) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse2;
    _APIPromise_client2.set(this, void 0);
    __classPrivateFieldSet2(this, _APIPromise_client2, client, "f");
  }
  _thenUnwrap(transform2) {
    return new _APIPromise(__classPrivateFieldGet2(this, _APIPromise_client2, "f"), this.responsePromise, async (client, props) => addRequestID2(transform2(await this.parseResponse(client, props), props), props.response));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data, the raw `Response` instance and the ID of the request,
   * returned via the X-Request-ID header which is useful for debugging requests and reporting
   * issues to OpenAI.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response, request_id: response.headers.get("x-request-id") };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet2(this, _APIPromise_client2, "f"), data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
_APIPromise_client2 = /* @__PURE__ */ new WeakMap();

// node_modules/openai/core/pagination.mjs
var _AbstractPage_client2;
var AbstractPage2 = class {
  constructor(client, response, body, options) {
    _AbstractPage_client2.set(this, void 0);
    __classPrivateFieldSet2(this, _AbstractPage_client2, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageRequestOptions() != null;
  }
  async getNextPage() {
    const nextOptions = this.nextPageRequestOptions();
    if (!nextOptions) {
      throw new OpenAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    return await __classPrivateFieldGet2(this, _AbstractPage_client2, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client2 = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise2 = class extends APIPromise2 {
  constructor(client, request3, Page3) {
    super(client, request3, async (client2, props) => new Page3(client2, props.response, await defaultParseResponse2(client2, props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var Page2 = class extends AbstractPage2 {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.object = body.object;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  nextPageRequestOptions() {
    return null;
  }
};
var CursorPage = class extends AbstractPage2 {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const data = this.getPaginatedItems();
    const id = data[data.length - 1]?.id;
    if (!id) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj2(this.options.query),
        after: id
      }
    };
  }
};
var ConversationCursorPage = class extends AbstractPage2 {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.data = body.data || [];
    this.has_more = body.has_more || false;
    this.last_id = body.last_id || "";
  }
  getPaginatedItems() {
    return this.data ?? [];
  }
  hasNextPage() {
    if (this.has_more === false) {
      return false;
    }
    return super.hasNextPage();
  }
  nextPageRequestOptions() {
    const cursor = this.last_id;
    if (!cursor) {
      return null;
    }
    return {
      ...this.options,
      query: {
        ...maybeObj2(this.options.query),
        after: cursor
      }
    };
  }
};

// node_modules/openai/internal/uploads.mjs
var checkFileSupport2 = () => {
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof process2?.versions?.node === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile2(fileBits, fileName, options) {
  checkFileSupport2();
  return new File(fileBits, fileName ?? "unknown_file", options);
}
function getName2(value) {
  return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
}
var isAsyncIterable2 = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var maybeMultipartFormRequestOptions = async (opts, fetch2) => {
  if (!hasUploadableValue(opts.body))
    return opts;
  return { ...opts, body: await createForm2(opts.body, fetch2) };
};
var multipartFormRequestOptions2 = async (opts, fetch2) => {
  return { ...opts, body: await createForm2(opts.body, fetch2) };
};
var supportsFormDataMap2 = /* @__PURE__ */ new WeakMap();
function supportsFormData2(fetchObject) {
  const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached2 = supportsFormDataMap2.get(fetch2);
  if (cached2)
    return cached2;
  const promise = (async () => {
    try {
      const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
      const data = new FormData();
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap2.set(fetch2, promise);
  return promise;
}
var createForm2 = async (body, fetch2) => {
  if (!await supportsFormData2(fetch2)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue2(form, key, value)));
  return form;
};
var isNamedBlob2 = (value) => value instanceof Blob && "name" in value;
var isUploadable = (value) => typeof value === "object" && value !== null && (value instanceof Response || isAsyncIterable2(value) || isNamedBlob2(value));
var hasUploadableValue = (value) => {
  if (isUploadable(value))
    return true;
  if (Array.isArray(value))
    return value.some(hasUploadableValue);
  if (value && typeof value === "object") {
    for (const k in value) {
      if (hasUploadableValue(value[k]))
        return true;
    }
  }
  return false;
};
var addFormValue2 = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    form.append(key, makeFile2([await value.blob()], getName2(value)));
  } else if (isAsyncIterable2(value)) {
    form.append(key, makeFile2([await new Response(ReadableStreamFrom2(value)).blob()], getName2(value)));
  } else if (isNamedBlob2(value)) {
    form.append(key, value, getName2(value));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue2(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue2(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/openai/internal/to-file.mjs
var isBlobLike2 = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isFileLike2 = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike2(value);
var isResponseLike2 = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile2(value, name, options) {
  checkFileSupport2();
  value = await value;
  if (isFileLike2(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile2([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike2(value)) {
    const blob = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile2(await getBytes2(blob), name, options);
  }
  const parts = await getBytes2(value);
  name || (name = getName2(value));
  if (!options?.type) {
    const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile2(parts, name, options);
}
async function getBytes2(value) {
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike2(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable2(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes2(chunk));
    }
  } else {
    const constructor = value?.constructor?.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError2(value)}`);
  }
  return parts;
}
function propsForError2(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}

// node_modules/openai/core/resource.mjs
var APIResource2 = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/openai/internal/utils/path.mjs
function encodeURIPath2(str2) {
  return str2.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.create(null));
var createPathTagFunction2 = (pathEncoder = encodeURIPath2) => function path10(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path11 = statics.reduce((previousValue, currentValue, index) => {
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && // handle values from other realms
    value.toString === Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY2) ?? EMPTY2)?.toString)) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path11.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = /(?<=^|\/)(?:\.|%2e){1,2}(?=\/|$)/gi;
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length,
      error: `Value "${match[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b) => a.start - b.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new OpenAIError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e) => e.error).join("\n")}
${path11}
${underline}`);
  }
  return path11;
};
var path2 = /* @__PURE__ */ createPathTagFunction2(encodeURIPath2);

// node_modules/openai/resources/chat/completions/messages.mjs
var Messages3 = class extends APIResource2 {
  /**
   * Get the messages in a stored chat completion. Only Chat Completions that have
   * been created with the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletionStoreMessage of client.chat.completions.messages.list(
   *   'completion_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(completionID, query = {}, options) {
    return this._client.getAPIList(path2`/chat/completions/${completionID}/messages`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/lib/parser.mjs
function isChatCompletionFunctionTool(tool) {
  return tool !== void 0 && "function" in tool && tool.function !== void 0;
}
function isAutoParsableResponseFormat(response_format) {
  return response_format?.["$brand"] === "auto-parseable-response-format";
}
function isAutoParsableTool(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function maybeParseChatCompletion(completion, params) {
  if (!params || !hasAutoParseableInput(params)) {
    return {
      ...completion,
      choices: completion.choices.map((choice) => {
        assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
        return {
          ...choice,
          message: {
            ...choice.message,
            parsed: null,
            ...choice.message.tool_calls ? {
              tool_calls: choice.message.tool_calls
            } : void 0
          }
        };
      })
    };
  }
  return parseChatCompletion(completion, params);
}
function parseChatCompletion(completion, params) {
  const choices = completion.choices.map((choice) => {
    if (choice.finish_reason === "length") {
      throw new LengthFinishReasonError();
    }
    if (choice.finish_reason === "content_filter") {
      throw new ContentFilterFinishReasonError();
    }
    assertToolCallsAreChatCompletionFunctionToolCalls(choice.message.tool_calls);
    return {
      ...choice,
      message: {
        ...choice.message,
        ...choice.message.tool_calls ? {
          tool_calls: choice.message.tool_calls?.map((toolCall) => parseToolCall(params, toolCall)) ?? void 0
        } : void 0,
        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null
      }
    };
  });
  return { ...completion, choices };
}
function parseResponseFormat(params, content) {
  if (params.response_format?.type !== "json_schema") {
    return null;
  }
  if (params.response_format?.type === "json_schema") {
    if ("$parseRaw" in params.response_format) {
      const response_format = params.response_format;
      return response_format.$parseRaw(content);
    }
    return JSON.parse(content);
  }
  return null;
}
function parseToolCall(params, toolCall) {
  const inputTool = params.tools?.find((inputTool2) => isChatCompletionFunctionTool(inputTool2) && inputTool2.function?.name === toolCall.function.name);
  return {
    ...toolCall,
    function: {
      ...toolCall.function,
      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null
    }
  };
}
function shouldParseToolCall(params, toolCall) {
  if (!params || !("tools" in params) || !params.tools) {
    return false;
  }
  const inputTool = params.tools?.find((inputTool2) => isChatCompletionFunctionTool(inputTool2) && inputTool2.function?.name === toolCall.function.name);
  return isChatCompletionFunctionTool(inputTool) && (isAutoParsableTool(inputTool) || inputTool?.function.strict || false);
}
function hasAutoParseableInput(params) {
  if (isAutoParsableResponseFormat(params.response_format)) {
    return true;
  }
  return params.tools?.some((t) => isAutoParsableTool(t) || t.type === "function" && t.function.strict === true) ?? false;
}
function assertToolCallsAreChatCompletionFunctionToolCalls(toolCalls) {
  for (const toolCall of toolCalls || []) {
    if (toolCall.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool calls are supported; Received \`${toolCall.type}\``);
    }
  }
}
function validateInputTools(tools) {
  for (const tool of tools ?? []) {
    if (tool.type !== "function") {
      throw new OpenAIError(`Currently only \`function\` tool types support auto-parsing; Received \`${tool.type}\``);
    }
    if (tool.function.strict !== true) {
      throw new OpenAIError(`The \`${tool.function.name}\` tool is not marked with \`strict: true\`. Only strict function tools can be auto-parsed`);
    }
  }
}

// node_modules/openai/lib/chatCompletionUtils.mjs
var isAssistantMessage = (message) => {
  return message?.role === "assistant";
};
var isToolMessage = (message) => {
  return message?.role === "tool";
};

// node_modules/openai/lib/EventStream.mjs
var _EventStream_instances;
var _EventStream_connectedPromise;
var _EventStream_resolveConnectedPromise;
var _EventStream_rejectConnectedPromise;
var _EventStream_endPromise;
var _EventStream_resolveEndPromise;
var _EventStream_rejectEndPromise;
var _EventStream_listeners;
var _EventStream_ended;
var _EventStream_errored;
var _EventStream_aborted;
var _EventStream_catchingPromiseCreated;
var _EventStream_handleError;
var EventStream = class {
  constructor() {
    _EventStream_instances.add(this);
    this.controller = new AbortController();
    _EventStream_connectedPromise.set(this, void 0);
    _EventStream_resolveConnectedPromise.set(this, () => {
    });
    _EventStream_rejectConnectedPromise.set(this, () => {
    });
    _EventStream_endPromise.set(this, void 0);
    _EventStream_resolveEndPromise.set(this, () => {
    });
    _EventStream_rejectEndPromise.set(this, () => {
    });
    _EventStream_listeners.set(this, {});
    _EventStream_ended.set(this, false);
    _EventStream_errored.set(this, false);
    _EventStream_aborted.set(this, false);
    _EventStream_catchingPromiseCreated.set(this, false);
    __classPrivateFieldSet2(this, _EventStream_connectedPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_resolveConnectedPromise, resolve, "f");
      __classPrivateFieldSet2(this, _EventStream_rejectConnectedPromise, reject, "f");
    }), "f");
    __classPrivateFieldSet2(this, _EventStream_endPromise, new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_resolveEndPromise, resolve, "f");
      __classPrivateFieldSet2(this, _EventStream_rejectEndPromise, reject, "f");
    }), "f");
    __classPrivateFieldGet2(this, _EventStream_connectedPromise, "f").catch(() => {
    });
    __classPrivateFieldGet2(this, _EventStream_endPromise, "f").catch(() => {
    });
  }
  _run(executor) {
    setTimeout(() => {
      executor().then(() => {
        this._emitFinal();
        this._emit("end");
      }, __classPrivateFieldGet2(this, _EventStream_instances, "m", _EventStream_handleError).bind(this));
    }, 0);
  }
  _connected() {
    if (this.ended)
      return;
    __classPrivateFieldGet2(this, _EventStream_resolveConnectedPromise, "f").call(this);
    this._emit("connect");
  }
  get ended() {
    return __classPrivateFieldGet2(this, _EventStream_ended, "f");
  }
  get errored() {
    return __classPrivateFieldGet2(this, _EventStream_errored, "f");
  }
  get aborted() {
    return __classPrivateFieldGet2(this, _EventStream_aborted, "f");
  }
  abort() {
    this.controller.abort();
  }
  /**
   * Adds the listener function to the end of the listeners array for the event.
   * No checks are made to see if the listener has already been added. Multiple calls passing
   * the same combination of event and listener will result in the listener being added, and
   * called, multiple times.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  on(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener });
    return this;
  }
  /**
   * Removes the specified listener from the listener array for the event.
   * off() will remove, at most, one instance of a listener from the listener array. If any single
   * listener has been added multiple times to the listener array for the specified event, then
   * off() must be called multiple times to remove each instance.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  off(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event];
    if (!listeners)
      return this;
    const index = listeners.findIndex((l) => l.listener === listener);
    if (index >= 0)
      listeners.splice(index, 1);
    return this;
  }
  /**
   * Adds a one-time listener function for the event. The next time the event is triggered,
   * this listener is removed and then invoked.
   * @returns this ChatCompletionStream, so that calls can be chained
   */
  once(event, listener) {
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] || (__classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = []);
    listeners.push({ listener, once: true });
    return this;
  }
  /**
   * This is similar to `.once()`, but returns a Promise that resolves the next time
   * the event is triggered, instead of calling a listener callback.
   * @returns a Promise that resolves the next time given event is triggered,
   * or rejects if an error is emitted.  (If you request the 'error' event,
   * returns a promise that resolves with the error).
   *
   * Example:
   *
   *   const message = await stream.emitted('message') // rejects if the stream errors
   */
  emitted(event) {
    return new Promise((resolve, reject) => {
      __classPrivateFieldSet2(this, _EventStream_catchingPromiseCreated, true, "f");
      if (event !== "error")
        this.once("error", reject);
      this.once(event, resolve);
    });
  }
  async done() {
    __classPrivateFieldSet2(this, _EventStream_catchingPromiseCreated, true, "f");
    await __classPrivateFieldGet2(this, _EventStream_endPromise, "f");
  }
  _emit(event, ...args) {
    if (__classPrivateFieldGet2(this, _EventStream_ended, "f")) {
      return;
    }
    if (event === "end") {
      __classPrivateFieldSet2(this, _EventStream_ended, true, "f");
      __classPrivateFieldGet2(this, _EventStream_resolveEndPromise, "f").call(this);
    }
    const listeners = __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event];
    if (listeners) {
      __classPrivateFieldGet2(this, _EventStream_listeners, "f")[event] = listeners.filter((l) => !l.once);
      listeners.forEach(({ listener }) => listener(...args));
    }
    if (event === "abort") {
      const error2 = args[0];
      if (!__classPrivateFieldGet2(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error2);
      }
      __classPrivateFieldGet2(this, _EventStream_rejectConnectedPromise, "f").call(this, error2);
      __classPrivateFieldGet2(this, _EventStream_rejectEndPromise, "f").call(this, error2);
      this._emit("end");
      return;
    }
    if (event === "error") {
      const error2 = args[0];
      if (!__classPrivateFieldGet2(this, _EventStream_catchingPromiseCreated, "f") && !listeners?.length) {
        Promise.reject(error2);
      }
      __classPrivateFieldGet2(this, _EventStream_rejectConnectedPromise, "f").call(this, error2);
      __classPrivateFieldGet2(this, _EventStream_rejectEndPromise, "f").call(this, error2);
      this._emit("end");
    }
  }
  _emitFinal() {
  }
};
_EventStream_connectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectConnectedPromise = /* @__PURE__ */ new WeakMap(), _EventStream_endPromise = /* @__PURE__ */ new WeakMap(), _EventStream_resolveEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_rejectEndPromise = /* @__PURE__ */ new WeakMap(), _EventStream_listeners = /* @__PURE__ */ new WeakMap(), _EventStream_ended = /* @__PURE__ */ new WeakMap(), _EventStream_errored = /* @__PURE__ */ new WeakMap(), _EventStream_aborted = /* @__PURE__ */ new WeakMap(), _EventStream_catchingPromiseCreated = /* @__PURE__ */ new WeakMap(), _EventStream_instances = /* @__PURE__ */ new WeakSet(), _EventStream_handleError = function _EventStream_handleError2(error2) {
  __classPrivateFieldSet2(this, _EventStream_errored, true, "f");
  if (error2 instanceof Error && error2.name === "AbortError") {
    error2 = new APIUserAbortError2();
  }
  if (error2 instanceof APIUserAbortError2) {
    __classPrivateFieldSet2(this, _EventStream_aborted, true, "f");
    return this._emit("abort", error2);
  }
  if (error2 instanceof OpenAIError) {
    return this._emit("error", error2);
  }
  if (error2 instanceof Error) {
    const openAIError = new OpenAIError(error2.message);
    openAIError.cause = error2;
    return this._emit("error", openAIError);
  }
  return this._emit("error", new OpenAIError(String(error2)));
};

// node_modules/openai/lib/RunnableFunction.mjs
function isRunnableFunctionWithParse(fn) {
  return typeof fn.parse === "function";
}

// node_modules/openai/lib/AbstractChatCompletionRunner.mjs
var _AbstractChatCompletionRunner_instances;
var _AbstractChatCompletionRunner_getFinalContent;
var _AbstractChatCompletionRunner_getFinalMessage;
var _AbstractChatCompletionRunner_getFinalFunctionToolCall;
var _AbstractChatCompletionRunner_getFinalFunctionToolCallResult;
var _AbstractChatCompletionRunner_calculateTotalUsage;
var _AbstractChatCompletionRunner_validateParams;
var _AbstractChatCompletionRunner_stringifyFunctionCallResult;
var DEFAULT_MAX_CHAT_COMPLETIONS = 10;
var AbstractChatCompletionRunner = class extends EventStream {
  constructor() {
    super(...arguments);
    _AbstractChatCompletionRunner_instances.add(this);
    this._chatCompletions = [];
    this.messages = [];
  }
  _addChatCompletion(chatCompletion) {
    this._chatCompletions.push(chatCompletion);
    this._emit("chatCompletion", chatCompletion);
    const message = chatCompletion.choices[0]?.message;
    if (message)
      this._addMessage(message);
    return chatCompletion;
  }
  _addMessage(message, emit = true) {
    if (!("content" in message))
      message.content = null;
    this.messages.push(message);
    if (emit) {
      this._emit("message", message);
      if (isToolMessage(message) && message.content) {
        this._emit("functionToolCallResult", message.content);
      } else if (isAssistantMessage(message) && message.tool_calls) {
        for (const tool_call of message.tool_calls) {
          if (tool_call.type === "function") {
            this._emit("functionToolCall", tool_call.function);
          }
        }
      }
    }
  }
  /**
   * @returns a promise that resolves with the final ChatCompletion, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletion.
   */
  async finalChatCompletion() {
    await this.done();
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (!completion)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return completion;
  }
  /**
   * @returns a promise that resolves with the content of the final ChatCompletionMessage, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalContent() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
  }
  /**
   * @returns a promise that resolves with the the final assistant ChatCompletionMessage response,
   * or rejects if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalMessage() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
  }
  /**
   * @returns a promise that resolves with the content of the final FunctionCall, or rejects
   * if an error occurred or the stream ended prematurely without producing a ChatCompletionMessage.
   */
  async finalFunctionToolCall() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
  }
  async finalFunctionToolCallResult() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
  }
  async totalUsage() {
    await this.done();
    return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this);
  }
  allChatCompletions() {
    return [...this._chatCompletions];
  }
  _emitFinal() {
    const completion = this._chatCompletions[this._chatCompletions.length - 1];
    if (completion)
      this._emit("finalChatCompletion", completion);
    const finalMessage = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this);
    if (finalMessage)
      this._emit("finalMessage", finalMessage);
    const finalContent = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalContent).call(this);
    if (finalContent)
      this._emit("finalContent", finalContent);
    const finalFunctionCall = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCall).call(this);
    if (finalFunctionCall)
      this._emit("finalFunctionToolCall", finalFunctionCall);
    const finalFunctionCallResult = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalFunctionToolCallResult).call(this);
    if (finalFunctionCallResult != null)
      this._emit("finalFunctionToolCallResult", finalFunctionCallResult);
    if (this._chatCompletions.some((c) => c.usage)) {
      this._emit("totalUsage", __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_calculateTotalUsage).call(this));
    }
  }
  async _createChatCompletion(client, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_validateParams).call(this, params);
    const chatCompletion = await client.chat.completions.create({ ...params, stream: false }, { ...options, signal: this.controller.signal });
    this._connected();
    return this._addChatCompletion(parseChatCompletion(chatCompletion, params));
  }
  async _runChatCompletion(client, params, options) {
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    return await this._createChatCompletion(client, params, options);
  }
  async _runTools(client, params, options) {
    const role = "tool";
    const { tool_choice = "auto", stream, ...restParams } = params;
    const singleFunctionToCall = typeof tool_choice !== "string" && tool_choice.type === "function" && tool_choice?.function?.name;
    const { maxChatCompletions = DEFAULT_MAX_CHAT_COMPLETIONS } = options || {};
    const inputTools = params.tools.map((tool) => {
      if (isAutoParsableTool(tool)) {
        if (!tool.$callback) {
          throw new OpenAIError("Tool given to `.runTools()` that does not have an associated function");
        }
        return {
          type: "function",
          function: {
            function: tool.$callback,
            name: tool.function.name,
            description: tool.function.description || "",
            parameters: tool.function.parameters,
            parse: tool.$parseRaw,
            strict: true
          }
        };
      }
      return tool;
    });
    const functionsByName = {};
    for (const f of inputTools) {
      if (f.type === "function") {
        functionsByName[f.function.name || f.function.function.name] = f.function;
      }
    }
    const tools = "tools" in params ? inputTools.map((t) => t.type === "function" ? {
      type: "function",
      function: {
        name: t.function.name || t.function.function.name,
        parameters: t.function.parameters,
        description: t.function.description,
        strict: t.function.strict
      }
    } : t) : void 0;
    for (const message of params.messages) {
      this._addMessage(message, false);
    }
    for (let i = 0; i < maxChatCompletions; ++i) {
      const chatCompletion = await this._createChatCompletion(client, {
        ...restParams,
        tool_choice,
        tools,
        messages: [...this.messages]
      }, options);
      const message = chatCompletion.choices[0]?.message;
      if (!message) {
        throw new OpenAIError(`missing message in ChatCompletion response`);
      }
      if (!message.tool_calls?.length) {
        return;
      }
      for (const tool_call of message.tool_calls) {
        if (tool_call.type !== "function")
          continue;
        const tool_call_id = tool_call.id;
        const { name, arguments: args } = tool_call.function;
        const fn = functionsByName[name];
        if (!fn) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. Available options are: ${Object.keys(functionsByName).map((name2) => JSON.stringify(name2)).join(", ")}. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        } else if (singleFunctionToCall && singleFunctionToCall !== name) {
          const content2 = `Invalid tool_call: ${JSON.stringify(name)}. ${JSON.stringify(singleFunctionToCall)} requested. Please try again`;
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        let parsed;
        try {
          parsed = isRunnableFunctionWithParse(fn) ? await fn.parse(args) : args;
        } catch (error2) {
          const content2 = error2 instanceof Error ? error2.message : String(error2);
          this._addMessage({ role, tool_call_id, content: content2 });
          continue;
        }
        const rawContent = await fn.function(parsed, this);
        const content = __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_stringifyFunctionCallResult).call(this, rawContent);
        this._addMessage({ role, tool_call_id, content });
        if (singleFunctionToCall) {
          return;
        }
      }
    }
    return;
  }
};
_AbstractChatCompletionRunner_instances = /* @__PURE__ */ new WeakSet(), _AbstractChatCompletionRunner_getFinalContent = function _AbstractChatCompletionRunner_getFinalContent2() {
  return __classPrivateFieldGet2(this, _AbstractChatCompletionRunner_instances, "m", _AbstractChatCompletionRunner_getFinalMessage).call(this).content ?? null;
}, _AbstractChatCompletionRunner_getFinalMessage = function _AbstractChatCompletionRunner_getFinalMessage2() {
  let i = this.messages.length;
  while (i-- > 0) {
    const message = this.messages[i];
    if (isAssistantMessage(message)) {
      const ret = {
        ...message,
        content: message.content ?? null,
        refusal: message.refusal ?? null
      };
      return ret;
    }
  }
  throw new OpenAIError("stream ended without producing a ChatCompletionMessage with role=assistant");
}, _AbstractChatCompletionRunner_getFinalFunctionToolCall = function _AbstractChatCompletionRunner_getFinalFunctionToolCall2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isAssistantMessage(message) && message?.tool_calls?.length) {
      return message.tool_calls.filter((x) => x.type === "function").at(-1)?.function;
    }
  }
  return;
}, _AbstractChatCompletionRunner_getFinalFunctionToolCallResult = function _AbstractChatCompletionRunner_getFinalFunctionToolCallResult2() {
  for (let i = this.messages.length - 1; i >= 0; i--) {
    const message = this.messages[i];
    if (isToolMessage(message) && message.content != null && typeof message.content === "string" && this.messages.some((x) => x.role === "assistant" && x.tool_calls?.some((y) => y.type === "function" && y.id === message.tool_call_id))) {
      return message.content;
    }
  }
  return;
}, _AbstractChatCompletionRunner_calculateTotalUsage = function _AbstractChatCompletionRunner_calculateTotalUsage2() {
  const total = {
    completion_tokens: 0,
    prompt_tokens: 0,
    total_tokens: 0
  };
  for (const { usage } of this._chatCompletions) {
    if (usage) {
      total.completion_tokens += usage.completion_tokens;
      total.prompt_tokens += usage.prompt_tokens;
      total.total_tokens += usage.total_tokens;
    }
  }
  return total;
}, _AbstractChatCompletionRunner_validateParams = function _AbstractChatCompletionRunner_validateParams2(params) {
  if (params.n != null && params.n > 1) {
    throw new OpenAIError("ChatCompletion convenience helpers only support n=1 at this time. To use n>1, please use chat.completions.create() directly.");
  }
}, _AbstractChatCompletionRunner_stringifyFunctionCallResult = function _AbstractChatCompletionRunner_stringifyFunctionCallResult2(rawContent) {
  return typeof rawContent === "string" ? rawContent : rawContent === void 0 ? "undefined" : JSON.stringify(rawContent);
};

// node_modules/openai/lib/ChatCompletionRunner.mjs
var ChatCompletionRunner = class _ChatCompletionRunner extends AbstractChatCompletionRunner {
  static runTools(client, params, options) {
    const runner = new _ChatCompletionRunner();
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
  _addMessage(message, emit = true) {
    super._addMessage(message, emit);
    if (isAssistantMessage(message) && message.content) {
      this._emit("content", message.content);
    }
  }
};

// node_modules/openai/_vendor/partial-json-parser/parser.mjs
var STR = 1;
var NUM = 2;
var ARR = 4;
var OBJ = 8;
var NULL = 16;
var BOOL = 32;
var NAN = 64;
var INFINITY = 128;
var MINUS_INFINITY = 256;
var INF = INFINITY | MINUS_INFINITY;
var SPECIAL = NULL | BOOL | INF | NAN;
var ATOM = STR | NUM | SPECIAL;
var COLLECTION = ARR | OBJ;
var ALL = ATOM | COLLECTION;
var Allow = {
  STR,
  NUM,
  ARR,
  OBJ,
  NULL,
  BOOL,
  NAN,
  INFINITY,
  MINUS_INFINITY,
  INF,
  SPECIAL,
  ATOM,
  COLLECTION,
  ALL
};
var PartialJSON = class extends Error {
};
var MalformedJSON = class extends Error {
};
function parseJSON(jsonString, allowPartial = Allow.ALL) {
  if (typeof jsonString !== "string") {
    throw new TypeError(`expecting str, got ${typeof jsonString}`);
  }
  if (!jsonString.trim()) {
    throw new Error(`${jsonString} is empty`);
  }
  return _parseJSON(jsonString.trim(), allowPartial);
}
var _parseJSON = (jsonString, allow) => {
  const length = jsonString.length;
  let index = 0;
  const markPartialJSON = (msg) => {
    throw new PartialJSON(`${msg} at position ${index}`);
  };
  const throwMalformedError = (msg) => {
    throw new MalformedJSON(`${msg} at position ${index}`);
  };
  const parseAny = () => {
    skipBlank();
    if (index >= length)
      markPartialJSON("Unexpected end of input");
    if (jsonString[index] === '"')
      return parseStr();
    if (jsonString[index] === "{")
      return parseObj();
    if (jsonString[index] === "[")
      return parseArr();
    if (jsonString.substring(index, index + 4) === "null" || Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
      index += 4;
      return null;
    }
    if (jsonString.substring(index, index + 4) === "true" || Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
      index += 4;
      return true;
    }
    if (jsonString.substring(index, index + 5) === "false" || Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
      index += 5;
      return false;
    }
    if (jsonString.substring(index, index + 8) === "Infinity" || Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
      index += 8;
      return Infinity;
    }
    if (jsonString.substring(index, index + 9) === "-Infinity" || Allow.MINUS_INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
      index += 9;
      return -Infinity;
    }
    if (jsonString.substring(index, index + 3) === "NaN" || Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
      index += 3;
      return NaN;
    }
    return parseNum();
  };
  const parseStr = () => {
    const start = index;
    let escape2 = false;
    index++;
    while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
      escape2 = jsonString[index] === "\\" ? !escape2 : false;
      index++;
    }
    if (jsonString.charAt(index) == '"') {
      try {
        return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
      } catch (e) {
        throwMalformedError(String(e));
      }
    } else if (Allow.STR & allow) {
      try {
        return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
      } catch (e) {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
      }
    }
    markPartialJSON("Unterminated string literal");
  };
  const parseObj = () => {
    index++;
    skipBlank();
    const obj = {};
    try {
      while (jsonString[index] !== "}") {
        skipBlank();
        if (index >= length && Allow.OBJ & allow)
          return obj;
        const key = parseStr();
        skipBlank();
        index++;
        try {
          const value = parseAny();
          Object.defineProperty(obj, key, { value, writable: true, enumerable: true, configurable: true });
        } catch (e) {
          if (Allow.OBJ & allow)
            return obj;
          else
            throw e;
        }
        skipBlank();
        if (jsonString[index] === ",")
          index++;
      }
    } catch (e) {
      if (Allow.OBJ & allow)
        return obj;
      else
        markPartialJSON("Expected '}' at end of object");
    }
    index++;
    return obj;
  };
  const parseArr = () => {
    index++;
    const arr = [];
    try {
      while (jsonString[index] !== "]") {
        arr.push(parseAny());
        skipBlank();
        if (jsonString[index] === ",") {
          index++;
        }
      }
    } catch (e) {
      if (Allow.ARR & allow) {
        return arr;
      }
      markPartialJSON("Expected ']' at end of array");
    }
    index++;
    return arr;
  };
  const parseNum = () => {
    if (index === 0) {
      if (jsonString === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString);
      } catch (e) {
        if (Allow.NUM & allow) {
          try {
            if ("." === jsonString[jsonString.length - 1])
              return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf(".")));
            return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
          } catch (e2) {
          }
        }
        throwMalformedError(String(e));
      }
    }
    const start = index;
    if (jsonString[index] === "-")
      index++;
    while (jsonString[index] && !",]}".includes(jsonString[index]))
      index++;
    if (index == length && !(Allow.NUM & allow))
      markPartialJSON("Unterminated number literal");
    try {
      return JSON.parse(jsonString.substring(start, index));
    } catch (e) {
      if (jsonString.substring(start, index) === "-" && Allow.NUM & allow)
        markPartialJSON("Not sure what '-' is");
      try {
        return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
      } catch (e2) {
        throwMalformedError(String(e2));
      }
    }
  };
  const skipBlank = () => {
    while (index < length && " \n\r	".includes(jsonString[index])) {
      index++;
    }
  };
  return parseAny();
};
var partialParse2 = (input) => parseJSON(input, Allow.ALL ^ Allow.NUM);

// node_modules/openai/lib/ChatCompletionStream.mjs
var _ChatCompletionStream_instances;
var _ChatCompletionStream_params;
var _ChatCompletionStream_choiceEventStates;
var _ChatCompletionStream_currentChatCompletionSnapshot;
var _ChatCompletionStream_beginRequest;
var _ChatCompletionStream_getChoiceEventState;
var _ChatCompletionStream_addChunk;
var _ChatCompletionStream_emitToolCallDoneEvent;
var _ChatCompletionStream_emitContentDoneEvents;
var _ChatCompletionStream_endRequest;
var _ChatCompletionStream_getAutoParseableResponseFormat;
var _ChatCompletionStream_accumulateChatCompletion;
var ChatCompletionStream = class _ChatCompletionStream extends AbstractChatCompletionRunner {
  constructor(params) {
    super();
    _ChatCompletionStream_instances.add(this);
    _ChatCompletionStream_params.set(this, void 0);
    _ChatCompletionStream_choiceEventStates.set(this, void 0);
    _ChatCompletionStream_currentChatCompletionSnapshot.set(this, void 0);
    __classPrivateFieldSet2(this, _ChatCompletionStream_params, params, "f");
    __classPrivateFieldSet2(this, _ChatCompletionStream_choiceEventStates, [], "f");
  }
  get currentChatCompletionSnapshot() {
    return __classPrivateFieldGet2(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
  }
  /**
   * Intended for use on the frontend, consuming a stream produced with
   * `.toReadableStream()` on the backend.
   *
   * Note that messages sent to the model do not appear in `.on('message')`
   * in this context.
   */
  static fromReadableStream(stream) {
    const runner = new _ChatCompletionStream(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static createChatCompletion(client, params, options) {
    const runner = new _ChatCompletionStream(params);
    runner._run(() => runner._runChatCompletion(client, { ...params, stream: true }, { ...options, headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" } }));
    return runner;
  }
  async _createChatCompletion(client, params, options) {
    super._createChatCompletion;
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    const stream = await client.chat.completions.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const chunk of stream) {
      __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return this._addChatCompletion(__classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_beginRequest).call(this);
    this._connected();
    const stream = Stream2.fromReadableStream(readableStream, this.controller);
    let chatId;
    for await (const chunk of stream) {
      if (chatId && chatId !== chunk.id) {
        this._addChatCompletion(__classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
      }
      __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_addChunk).call(this, chunk);
      chatId = chunk.id;
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return this._addChatCompletion(__classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_endRequest).call(this));
  }
  [(_ChatCompletionStream_params = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_choiceEventStates = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_currentChatCompletionSnapshot = /* @__PURE__ */ new WeakMap(), _ChatCompletionStream_instances = /* @__PURE__ */ new WeakSet(), _ChatCompletionStream_beginRequest = function _ChatCompletionStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet2(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
  }, _ChatCompletionStream_getChoiceEventState = function _ChatCompletionStream_getChoiceEventState2(choice) {
    let state = __classPrivateFieldGet2(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index];
    if (state) {
      return state;
    }
    state = {
      content_done: false,
      refusal_done: false,
      logprobs_content_done: false,
      logprobs_refusal_done: false,
      done_tool_calls: /* @__PURE__ */ new Set(),
      current_tool_call_index: null
    };
    __classPrivateFieldGet2(this, _ChatCompletionStream_choiceEventStates, "f")[choice.index] = state;
    return state;
  }, _ChatCompletionStream_addChunk = function _ChatCompletionStream_addChunk2(chunk) {
    if (this.ended)
      return;
    const completion = __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_accumulateChatCompletion).call(this, chunk);
    this._emit("chunk", chunk, completion);
    for (const choice of chunk.choices) {
      const choiceSnapshot = completion.choices[choice.index];
      if (choice.delta.content != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.content) {
        this._emit("content", choice.delta.content, choiceSnapshot.message.content);
        this._emit("content.delta", {
          delta: choice.delta.content,
          snapshot: choiceSnapshot.message.content,
          parsed: choiceSnapshot.message.parsed
        });
      }
      if (choice.delta.refusal != null && choiceSnapshot.message?.role === "assistant" && choiceSnapshot.message?.refusal) {
        this._emit("refusal.delta", {
          delta: choice.delta.refusal,
          snapshot: choiceSnapshot.message.refusal
        });
      }
      if (choice.logprobs?.content != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.content.delta", {
          content: choice.logprobs?.content,
          snapshot: choiceSnapshot.logprobs?.content ?? []
        });
      }
      if (choice.logprobs?.refusal != null && choiceSnapshot.message?.role === "assistant") {
        this._emit("logprobs.refusal.delta", {
          refusal: choice.logprobs?.refusal,
          snapshot: choiceSnapshot.logprobs?.refusal ?? []
        });
      }
      const state = __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
      if (choiceSnapshot.finish_reason) {
        __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
        if (state.current_tool_call_index != null) {
          __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
        }
      }
      for (const toolCall of choice.delta.tool_calls ?? []) {
        if (state.current_tool_call_index !== toolCall.index) {
          __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitContentDoneEvents).call(this, choiceSnapshot);
          if (state.current_tool_call_index != null) {
            __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_emitToolCallDoneEvent).call(this, choiceSnapshot, state.current_tool_call_index);
          }
        }
        state.current_tool_call_index = toolCall.index;
      }
      for (const toolCallDelta of choice.delta.tool_calls ?? []) {
        const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallDelta.index];
        if (!toolCallSnapshot?.type) {
          continue;
        }
        if (toolCallSnapshot?.type === "function") {
          this._emit("tool_calls.function.arguments.delta", {
            name: toolCallSnapshot.function?.name,
            index: toolCallDelta.index,
            arguments: toolCallSnapshot.function.arguments,
            parsed_arguments: toolCallSnapshot.function.parsed_arguments,
            arguments_delta: toolCallDelta.function?.arguments ?? ""
          });
        } else {
          assertNever(toolCallSnapshot?.type);
        }
      }
    }
  }, _ChatCompletionStream_emitToolCallDoneEvent = function _ChatCompletionStream_emitToolCallDoneEvent2(choiceSnapshot, toolCallIndex) {
    const state = __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (state.done_tool_calls.has(toolCallIndex)) {
      return;
    }
    const toolCallSnapshot = choiceSnapshot.message.tool_calls?.[toolCallIndex];
    if (!toolCallSnapshot) {
      throw new Error("no tool call snapshot");
    }
    if (!toolCallSnapshot.type) {
      throw new Error("tool call snapshot missing `type`");
    }
    if (toolCallSnapshot.type === "function") {
      const inputTool = __classPrivateFieldGet2(this, _ChatCompletionStream_params, "f")?.tools?.find((tool) => isChatCompletionFunctionTool(tool) && tool.function.name === toolCallSnapshot.function.name);
      this._emit("tool_calls.function.arguments.done", {
        name: toolCallSnapshot.function.name,
        index: toolCallIndex,
        arguments: toolCallSnapshot.function.arguments,
        parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCallSnapshot.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCallSnapshot.function.arguments) : null
      });
    } else {
      assertNever(toolCallSnapshot.type);
    }
  }, _ChatCompletionStream_emitContentDoneEvents = function _ChatCompletionStream_emitContentDoneEvents2(choiceSnapshot) {
    const state = __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getChoiceEventState).call(this, choiceSnapshot);
    if (choiceSnapshot.message.content && !state.content_done) {
      state.content_done = true;
      const responseFormat = __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this);
      this._emit("content.done", {
        content: choiceSnapshot.message.content,
        parsed: responseFormat ? responseFormat.$parseRaw(choiceSnapshot.message.content) : null
      });
    }
    if (choiceSnapshot.message.refusal && !state.refusal_done) {
      state.refusal_done = true;
      this._emit("refusal.done", { refusal: choiceSnapshot.message.refusal });
    }
    if (choiceSnapshot.logprobs?.content && !state.logprobs_content_done) {
      state.logprobs_content_done = true;
      this._emit("logprobs.content.done", { content: choiceSnapshot.logprobs.content });
    }
    if (choiceSnapshot.logprobs?.refusal && !state.logprobs_refusal_done) {
      state.logprobs_refusal_done = true;
      this._emit("logprobs.refusal.done", { refusal: choiceSnapshot.logprobs.refusal });
    }
  }, _ChatCompletionStream_endRequest = function _ChatCompletionStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet2(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any chunks`);
    }
    __classPrivateFieldSet2(this, _ChatCompletionStream_currentChatCompletionSnapshot, void 0, "f");
    __classPrivateFieldSet2(this, _ChatCompletionStream_choiceEventStates, [], "f");
    return finalizeChatCompletion(snapshot, __classPrivateFieldGet2(this, _ChatCompletionStream_params, "f"));
  }, _ChatCompletionStream_getAutoParseableResponseFormat = function _ChatCompletionStream_getAutoParseableResponseFormat2() {
    const responseFormat = __classPrivateFieldGet2(this, _ChatCompletionStream_params, "f")?.response_format;
    if (isAutoParsableResponseFormat(responseFormat)) {
      return responseFormat;
    }
    return null;
  }, _ChatCompletionStream_accumulateChatCompletion = function _ChatCompletionStream_accumulateChatCompletion2(chunk) {
    var _a4, _b, _c, _d;
    let snapshot = __classPrivateFieldGet2(this, _ChatCompletionStream_currentChatCompletionSnapshot, "f");
    const { choices, ...rest } = chunk;
    if (!snapshot) {
      snapshot = __classPrivateFieldSet2(this, _ChatCompletionStream_currentChatCompletionSnapshot, {
        ...rest,
        choices: []
      }, "f");
    } else {
      Object.assign(snapshot, rest);
    }
    for (const { delta, finish_reason, index, logprobs = null, ...other } of chunk.choices) {
      let choice = snapshot.choices[index];
      if (!choice) {
        choice = snapshot.choices[index] = { finish_reason, index, message: {}, logprobs, ...other };
      }
      if (logprobs) {
        if (!choice.logprobs) {
          choice.logprobs = Object.assign({}, logprobs);
        } else {
          const { content: content2, refusal: refusal2, ...rest3 } = logprobs;
          assertIsEmpty(rest3);
          Object.assign(choice.logprobs, rest3);
          if (content2) {
            (_a4 = choice.logprobs).content ?? (_a4.content = []);
            choice.logprobs.content.push(...content2);
          }
          if (refusal2) {
            (_b = choice.logprobs).refusal ?? (_b.refusal = []);
            choice.logprobs.refusal.push(...refusal2);
          }
        }
      }
      if (finish_reason) {
        choice.finish_reason = finish_reason;
        if (__classPrivateFieldGet2(this, _ChatCompletionStream_params, "f") && hasAutoParseableInput(__classPrivateFieldGet2(this, _ChatCompletionStream_params, "f"))) {
          if (finish_reason === "length") {
            throw new LengthFinishReasonError();
          }
          if (finish_reason === "content_filter") {
            throw new ContentFilterFinishReasonError();
          }
        }
      }
      Object.assign(choice, other);
      if (!delta)
        continue;
      const { content, refusal, function_call, role, tool_calls, ...rest2 } = delta;
      assertIsEmpty(rest2);
      Object.assign(choice.message, rest2);
      if (refusal) {
        choice.message.refusal = (choice.message.refusal || "") + refusal;
      }
      if (role)
        choice.message.role = role;
      if (function_call) {
        if (!choice.message.function_call) {
          choice.message.function_call = function_call;
        } else {
          if (function_call.name)
            choice.message.function_call.name = function_call.name;
          if (function_call.arguments) {
            (_c = choice.message.function_call).arguments ?? (_c.arguments = "");
            choice.message.function_call.arguments += function_call.arguments;
          }
        }
      }
      if (content) {
        choice.message.content = (choice.message.content || "") + content;
        if (!choice.message.refusal && __classPrivateFieldGet2(this, _ChatCompletionStream_instances, "m", _ChatCompletionStream_getAutoParseableResponseFormat).call(this)) {
          choice.message.parsed = partialParse2(choice.message.content);
        }
      }
      if (tool_calls) {
        if (!choice.message.tool_calls)
          choice.message.tool_calls = [];
        for (const { index: index2, id, type, function: fn, ...rest3 } of tool_calls) {
          const tool_call = (_d = choice.message.tool_calls)[index2] ?? (_d[index2] = {});
          Object.assign(tool_call, rest3);
          if (id)
            tool_call.id = id;
          if (type)
            tool_call.type = type;
          if (fn)
            tool_call.function ?? (tool_call.function = { name: fn.name ?? "", arguments: "" });
          if (fn?.name)
            tool_call.function.name = fn.name;
          if (fn?.arguments) {
            tool_call.function.arguments += fn.arguments;
            if (shouldParseToolCall(__classPrivateFieldGet2(this, _ChatCompletionStream_params, "f"), tool_call)) {
              tool_call.function.parsed_arguments = partialParse2(tool_call.function.arguments);
            }
          }
        }
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("chunk", (chunk) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(chunk);
      } else {
        pushQueue.push(chunk);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  toReadableStream() {
    const stream = new Stream2(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
};
function finalizeChatCompletion(snapshot, params) {
  const { id, choices, created, model, system_fingerprint, ...rest } = snapshot;
  const completion = {
    ...rest,
    id,
    choices: choices.map(({ message, finish_reason, index, logprobs, ...choiceRest }) => {
      if (!finish_reason) {
        throw new OpenAIError(`missing finish_reason for choice ${index}`);
      }
      const { content = null, function_call, tool_calls, ...messageRest } = message;
      const role = message.role;
      if (!role) {
        throw new OpenAIError(`missing role for choice ${index}`);
      }
      if (function_call) {
        const { arguments: args, name } = function_call;
        if (args == null) {
          throw new OpenAIError(`missing function_call.arguments for choice ${index}`);
        }
        if (!name) {
          throw new OpenAIError(`missing function_call.name for choice ${index}`);
        }
        return {
          ...choiceRest,
          message: {
            content,
            function_call: { arguments: args, name },
            role,
            refusal: message.refusal ?? null
          },
          finish_reason,
          index,
          logprobs
        };
      }
      if (tool_calls) {
        return {
          ...choiceRest,
          index,
          finish_reason,
          logprobs,
          message: {
            ...messageRest,
            role,
            content,
            refusal: message.refusal ?? null,
            tool_calls: tool_calls.map((tool_call, i) => {
              const { function: fn, type, id: id2, ...toolRest } = tool_call;
              const { arguments: args, name, ...fnRest } = fn || {};
              if (id2 == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].id
${str(snapshot)}`);
              }
              if (type == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].type
${str(snapshot)}`);
              }
              if (name == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.name
${str(snapshot)}`);
              }
              if (args == null) {
                throw new OpenAIError(`missing choices[${index}].tool_calls[${i}].function.arguments
${str(snapshot)}`);
              }
              return { ...toolRest, id: id2, type, function: { ...fnRest, name, arguments: args } };
            })
          }
        };
      }
      return {
        ...choiceRest,
        message: { ...messageRest, content, role, refusal: message.refusal ?? null },
        finish_reason,
        index,
        logprobs
      };
    }),
    created,
    model,
    object: "chat.completion",
    ...system_fingerprint ? { system_fingerprint } : {}
  };
  return maybeParseChatCompletion(completion, params);
}
function str(x) {
  return JSON.stringify(x);
}
function assertIsEmpty(obj) {
  return;
}
function assertNever(_x) {
}

// node_modules/openai/lib/ChatCompletionStreamingRunner.mjs
var ChatCompletionStreamingRunner = class _ChatCompletionStreamingRunner extends ChatCompletionStream {
  static fromReadableStream(stream) {
    const runner = new _ChatCompletionStreamingRunner(null);
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  static runTools(client, params, options) {
    const runner = new _ChatCompletionStreamingRunner(
      // @ts-expect-error TODO these types are incompatible
      params
    );
    const opts = {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "runTools" }
    };
    runner._run(() => runner._runTools(client, params, opts));
    return runner;
  }
};

// node_modules/openai/resources/chat/completions/completions.mjs
var Completions2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.messages = new Messages3(this._client);
  }
  create(body, options) {
    return this._client.post("/chat/completions", { body, ...options, stream: body.stream ?? false });
  }
  /**
   * Get a stored chat completion. Only Chat Completions that have been created with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * const chatCompletion =
   *   await client.chat.completions.retrieve('completion_id');
   * ```
   */
  retrieve(completionID, options) {
    return this._client.get(path2`/chat/completions/${completionID}`, options);
  }
  /**
   * Modify a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be modified. Currently, the only
   * supported modification is to update the `metadata` field.
   *
   * @example
   * ```ts
   * const chatCompletion = await client.chat.completions.update(
   *   'completion_id',
   *   { metadata: { foo: 'string' } },
   * );
   * ```
   */
  update(completionID, body, options) {
    return this._client.post(path2`/chat/completions/${completionID}`, { body, ...options });
  }
  /**
   * List stored Chat Completions. Only Chat Completions that have been stored with
   * the `store` parameter set to `true` will be returned.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatCompletion of client.chat.completions.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/chat/completions", CursorPage, { query, ...options });
  }
  /**
   * Delete a stored chat completion. Only Chat Completions that have been created
   * with the `store` parameter set to `true` can be deleted.
   *
   * @example
   * ```ts
   * const chatCompletionDeleted =
   *   await client.chat.completions.delete('completion_id');
   * ```
   */
  delete(completionID, options) {
    return this._client.delete(path2`/chat/completions/${completionID}`, options);
  }
  parse(body, options) {
    validateInputTools(body.tools);
    return this._client.chat.completions.create(body, {
      ...options,
      headers: {
        ...options?.headers,
        "X-Stainless-Helper-Method": "chat.completions.parse"
      }
    })._thenUnwrap((completion) => parseChatCompletion(completion, body));
  }
  runTools(body, options) {
    if (body.stream) {
      return ChatCompletionStreamingRunner.runTools(this._client, body, options);
    }
    return ChatCompletionRunner.runTools(this._client, body, options);
  }
  /**
   * Creates a chat completion stream
   */
  stream(body, options) {
    return ChatCompletionStream.createChatCompletion(this._client, body, options);
  }
};
Completions2.Messages = Messages3;

// node_modules/openai/resources/chat/chat.mjs
var Chat = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.completions = new Completions2(this._client);
  }
};
Chat.Completions = Completions2;

// node_modules/openai/internal/headers.mjs
var brand_privateNullableHeaders2 = /* @__PURE__ */ Symbol("brand.privateNullableHeaders");
function* iterateHeaders2(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders2 in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray2(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray2(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var buildHeaders2 = (newHeaders) => {
  const targetHeaders = new Headers();
  const nullHeaders = /* @__PURE__ */ new Set();
  for (const headers of newHeaders) {
    const seenHeaders = /* @__PURE__ */ new Set();
    for (const [name, value] of iterateHeaders2(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders2]: true, values: targetHeaders, nulls: nullHeaders };
};

// node_modules/openai/resources/audio/speech.mjs
var Speech = class extends APIResource2 {
  /**
   * Generates audio from the input text.
   *
   * @example
   * ```ts
   * const speech = await client.audio.speech.create({
   *   input: 'input',
   *   model: 'string',
   *   voice: 'ash',
   * });
   *
   * const content = await speech.blob();
   * console.log(content);
   * ```
   */
  create(body, options) {
    return this._client.post("/audio/speech", {
      body,
      ...options,
      headers: buildHeaders2([{ Accept: "application/octet-stream" }, options?.headers]),
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/audio/transcriptions", multipartFormRequestOptions2({
      body,
      ...options,
      stream: body.stream ?? false,
      __metadata: { model: body.model }
    }, this._client));
  }
};

// node_modules/openai/resources/audio/translations.mjs
var Translations = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/audio/translations", multipartFormRequestOptions2({ body, ...options, __metadata: { model: body.model } }, this._client));
  }
};

// node_modules/openai/resources/audio/audio.mjs
var Audio = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
    this.speech = new Speech(this._client);
  }
};
Audio.Transcriptions = Transcriptions;
Audio.Translations = Translations;
Audio.Speech = Speech;

// node_modules/openai/resources/batches.mjs
var Batches3 = class extends APIResource2 {
  /**
   * Creates and executes a batch from an uploaded file of requests
   */
  create(body, options) {
    return this._client.post("/batches", { body, ...options });
  }
  /**
   * Retrieves a batch.
   */
  retrieve(batchID, options) {
    return this._client.get(path2`/batches/${batchID}`, options);
  }
  /**
   * List your organization's batches.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/batches", CursorPage, { query, ...options });
  }
  /**
   * Cancels an in-progress batch. The batch will be in status `cancelling` for up to
   * 10 minutes, before changing to `cancelled`, where it will have partial results
   * (if any) available in the output file.
   */
  cancel(batchID, options) {
    return this._client.post(path2`/batches/${batchID}/cancel`, options);
  }
};

// node_modules/openai/resources/beta/assistants.mjs
var Assistants = class extends APIResource2 {
  /**
   * Create an assistant with a model and instructions.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.create({
   *   model: 'gpt-4o',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/assistants", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.retrieve(
   *   'assistant_id',
   * );
   * ```
   */
  retrieve(assistantID, options) {
    return this._client.get(path2`/assistants/${assistantID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies an assistant.
   *
   * @example
   * ```ts
   * const assistant = await client.beta.assistants.update(
   *   'assistant_id',
   * );
   * ```
   */
  update(assistantID, body, options) {
    return this._client.post(path2`/assistants/${assistantID}`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of assistants.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const assistant of client.beta.assistants.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/assistants", CursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Delete an assistant.
   *
   * @example
   * ```ts
   * const assistantDeleted =
   *   await client.beta.assistants.delete('assistant_id');
   * ```
   */
  delete(assistantID, options) {
    return this._client.delete(path2`/assistants/${assistantID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/realtime/sessions.mjs
var Sessions = class extends APIResource2 {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API. Can be configured with the same session parameters as the
   * `session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const session =
   *   await client.beta.realtime.sessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/sessions", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/realtime/transcription-sessions.mjs
var TranscriptionSessions = class extends APIResource2 {
  /**
   * Create an ephemeral API token for use in client-side applications with the
   * Realtime API specifically for realtime transcriptions. Can be configured with
   * the same session parameters as the `transcription_session.update` client event.
   *
   * It responds with a session object, plus a `client_secret` key which contains a
   * usable ephemeral API token that can be used to authenticate browser clients for
   * the Realtime API.
   *
   * @example
   * ```ts
   * const transcriptionSession =
   *   await client.beta.realtime.transcriptionSessions.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/transcription_sessions", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/realtime/realtime.mjs
var Realtime = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions(this._client);
    this.transcriptionSessions = new TranscriptionSessions(this._client);
  }
};
Realtime.Sessions = Sessions;
Realtime.TranscriptionSessions = TranscriptionSessions;

// node_modules/openai/resources/beta/chatkit/sessions.mjs
var Sessions2 = class extends APIResource2 {
  /**
   * Create a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.create({
   *     user: 'x',
   *     workflow: { id: 'id' },
   *   });
   * ```
   */
  create(body, options) {
    return this._client.post("/chatkit/sessions", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  /**
   * Cancel a ChatKit session
   *
   * @example
   * ```ts
   * const chatSession =
   *   await client.beta.chatkit.sessions.cancel('cksess_123');
   * ```
   */
  cancel(sessionID, options) {
    return this._client.post(path2`/chatkit/sessions/${sessionID}/cancel`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/chatkit/threads.mjs
var Threads = class extends APIResource2 {
  /**
   * Retrieve a ChatKit thread
   *
   * @example
   * ```ts
   * const chatkitThread =
   *   await client.beta.chatkit.threads.retrieve('cthr_123');
   * ```
   */
  retrieve(threadID, options) {
    return this._client.get(path2`/chatkit/threads/${threadID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  /**
   * List ChatKit threads
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const chatkitThread of client.beta.chatkit.threads.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/chatkit/threads", ConversationCursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  /**
   * Delete a ChatKit thread
   *
   * @example
   * ```ts
   * const thread = await client.beta.chatkit.threads.delete(
   *   'cthr_123',
   * );
   * ```
   */
  delete(threadID, options) {
    return this._client.delete(path2`/chatkit/threads/${threadID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers])
    });
  }
  /**
   * List ChatKit thread items
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const thread of client.beta.chatkit.threads.listItems(
   *   'cthr_123',
   * )) {
   *   // ...
   * }
   * ```
   */
  listItems(threadID, query = {}, options) {
    return this._client.getAPIList(path2`/chatkit/threads/${threadID}/items`, ConversationCursorPage, { query, ...options, headers: buildHeaders2([{ "OpenAI-Beta": "chatkit_beta=v1" }, options?.headers]) });
  }
};

// node_modules/openai/resources/beta/chatkit/chatkit.mjs
var ChatKit = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.sessions = new Sessions2(this._client);
    this.threads = new Threads(this._client);
  }
};
ChatKit.Sessions = Sessions2;
ChatKit.Threads = Threads;

// node_modules/openai/resources/beta/threads/messages.mjs
var Messages4 = class extends APIResource2 {
  /**
   * Create a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(threadID, body, options) {
    return this._client.post(path2`/threads/${threadID}/messages`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieve a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(messageID, params, options) {
    const { thread_id } = params;
    return this._client.get(path2`/threads/${thread_id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(messageID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path2`/threads/${thread_id}/messages/${messageID}`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of messages for a given thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(threadID, query = {}, options) {
    return this._client.getAPIList(path2`/threads/${threadID}/messages`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Deletes a message.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(messageID, params, options) {
    const { thread_id } = params;
    return this._client.delete(path2`/threads/${thread_id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/beta/threads/runs/steps.mjs
var Steps = class extends APIResource2 {
  /**
   * Retrieves a run step.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(stepID, params, options) {
    const { thread_id, run_id, ...query } = params;
    return this._client.get(path2`/threads/${thread_id}/runs/${run_id}/steps/${stepID}`, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of run steps belonging to a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(runID, params, options) {
    const { thread_id, ...query } = params;
    return this._client.getAPIList(path2`/threads/${thread_id}/runs/${runID}/steps`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};

// node_modules/openai/internal/utils/base64.mjs
var toFloat32Array = (base64Str) => {
  if (typeof Buffer !== "undefined") {
    const buf = Buffer.from(base64Str, "base64");
    return Array.from(new Float32Array(buf.buffer, buf.byteOffset, buf.length / Float32Array.BYTES_PER_ELEMENT));
  } else {
    const binaryStr = atob(base64Str);
    const len = binaryStr.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binaryStr.charCodeAt(i);
    }
    return Array.from(new Float32Array(bytes.buffer));
  }
};

// node_modules/openai/internal/utils/env.mjs
var readEnv2 = (env3) => {
  if (typeof globalThis.process !== "undefined") {
    return globalThis.process.env?.[env3]?.trim() ?? void 0;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return globalThis.Deno.env?.get?.(env3)?.trim();
  }
  return void 0;
};

// node_modules/openai/lib/AssistantStream.mjs
var _AssistantStream_instances;
var _a2;
var _AssistantStream_events;
var _AssistantStream_runStepSnapshots;
var _AssistantStream_messageSnapshots;
var _AssistantStream_messageSnapshot;
var _AssistantStream_finalRun;
var _AssistantStream_currentContentIndex;
var _AssistantStream_currentContent;
var _AssistantStream_currentToolCallIndex;
var _AssistantStream_currentToolCall;
var _AssistantStream_currentEvent;
var _AssistantStream_currentRunSnapshot;
var _AssistantStream_currentRunStepSnapshot;
var _AssistantStream_addEvent;
var _AssistantStream_endRequest;
var _AssistantStream_handleMessage;
var _AssistantStream_handleRunStep;
var _AssistantStream_handleEvent;
var _AssistantStream_accumulateRunStep;
var _AssistantStream_accumulateMessage;
var _AssistantStream_accumulateContent;
var _AssistantStream_handleRun;
var AssistantStream = class extends EventStream {
  constructor() {
    super(...arguments);
    _AssistantStream_instances.add(this);
    _AssistantStream_events.set(this, []);
    _AssistantStream_runStepSnapshots.set(this, {});
    _AssistantStream_messageSnapshots.set(this, {});
    _AssistantStream_messageSnapshot.set(this, void 0);
    _AssistantStream_finalRun.set(this, void 0);
    _AssistantStream_currentContentIndex.set(this, void 0);
    _AssistantStream_currentContent.set(this, void 0);
    _AssistantStream_currentToolCallIndex.set(this, void 0);
    _AssistantStream_currentToolCall.set(this, void 0);
    _AssistantStream_currentEvent.set(this, void 0);
    _AssistantStream_currentRunSnapshot.set(this, void 0);
    _AssistantStream_currentRunStepSnapshot.set(this, void 0);
  }
  [(_AssistantStream_events = /* @__PURE__ */ new WeakMap(), _AssistantStream_runStepSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshots = /* @__PURE__ */ new WeakMap(), _AssistantStream_messageSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_finalRun = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContentIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentContent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCallIndex = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentToolCall = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentEvent = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_currentRunStepSnapshot = /* @__PURE__ */ new WeakMap(), _AssistantStream_instances = /* @__PURE__ */ new WeakSet(), Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((chunk2) => chunk2 ? { value: chunk2, done: false } : { value: void 0, done: true });
        }
        const chunk = pushQueue.shift();
        return { value: chunk, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  static fromReadableStream(stream) {
    const runner = new _a2();
    runner._run(() => runner._fromReadableStream(stream));
    return runner;
  }
  async _fromReadableStream(readableStream, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    this._connected();
    const stream = Stream2.fromReadableStream(readableStream, this.controller);
    for await (const event of stream) {
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return this._addRun(__classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  toReadableStream() {
    const stream = new Stream2(this[Symbol.asyncIterator].bind(this), this.controller);
    return stream.toReadableStream();
  }
  static createToolAssistantStream(runId, runs, params, options) {
    const runner = new _a2();
    runner._run(() => runner._runToolAssistantStream(runId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createToolAssistantStream(run, runId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.submitToolOutputs(runId, body, {
      ...options,
      signal: this.controller.signal
    });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return this._addRun(__classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static createThreadAssistantStream(params, thread, options) {
    const runner = new _a2();
    runner._run(() => runner._threadAssistantStream(params, thread, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  static createAssistantStream(threadId, runs, params, options) {
    const runner = new _a2();
    runner._run(() => runner._runAssistantStream(threadId, runs, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  currentEvent() {
    return __classPrivateFieldGet2(this, _AssistantStream_currentEvent, "f");
  }
  currentRun() {
    return __classPrivateFieldGet2(this, _AssistantStream_currentRunSnapshot, "f");
  }
  currentMessageSnapshot() {
    return __classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f");
  }
  currentRunStepSnapshot() {
    return __classPrivateFieldGet2(this, _AssistantStream_currentRunStepSnapshot, "f");
  }
  async finalRunSteps() {
    await this.done();
    return Object.values(__classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f"));
  }
  async finalMessages() {
    await this.done();
    return Object.values(__classPrivateFieldGet2(this, _AssistantStream_messageSnapshots, "f"));
  }
  async finalRun() {
    await this.done();
    if (!__classPrivateFieldGet2(this, _AssistantStream_finalRun, "f"))
      throw Error("Final run was not received.");
    return __classPrivateFieldGet2(this, _AssistantStream_finalRun, "f");
  }
  async _createThreadAssistantStream(thread, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await thread.createAndRun(body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return this._addRun(__classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  async _createAssistantStream(run, threadId, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    const body = { ...params, stream: true };
    const stream = await run.create(threadId, body, { ...options, signal: this.controller.signal });
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_addEvent).call(this, event);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return this._addRun(__classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_endRequest).call(this));
  }
  static accumulateDelta(acc, delta) {
    for (const [key, deltaValue] of Object.entries(delta)) {
      if (!acc.hasOwnProperty(key)) {
        acc[key] = deltaValue;
        continue;
      }
      let accValue = acc[key];
      if (accValue === null || accValue === void 0) {
        acc[key] = deltaValue;
        continue;
      }
      if (key === "index" || key === "type") {
        acc[key] = deltaValue;
        continue;
      }
      if (typeof accValue === "string" && typeof deltaValue === "string") {
        accValue += deltaValue;
      } else if (typeof accValue === "number" && typeof deltaValue === "number") {
        accValue += deltaValue;
      } else if (isObj(accValue) && isObj(deltaValue)) {
        accValue = this.accumulateDelta(accValue, deltaValue);
      } else if (Array.isArray(accValue) && Array.isArray(deltaValue)) {
        if (accValue.every((x) => typeof x === "string" || typeof x === "number")) {
          accValue.push(...deltaValue);
          continue;
        }
        for (const deltaEntry of deltaValue) {
          if (!isObj(deltaEntry)) {
            throw new Error(`Expected array delta entry to be an object but got: ${deltaEntry}`);
          }
          const index = deltaEntry["index"];
          if (index == null) {
            console.error(deltaEntry);
            throw new Error("Expected array delta entry to have an `index` property");
          }
          if (typeof index !== "number") {
            throw new Error(`Expected array delta entry \`index\` property to be a number but got ${index}`);
          }
          const accEntry = accValue[index];
          if (accEntry == null) {
            accValue.push(deltaEntry);
          } else {
            accValue[index] = this.accumulateDelta(accEntry, deltaEntry);
          }
        }
        continue;
      } else {
        throw Error(`Unhandled record type: ${key}, deltaValue: ${deltaValue}, accValue: ${accValue}`);
      }
      acc[key] = accValue;
    }
    return acc;
  }
  _addRun(run) {
    return run;
  }
  async _threadAssistantStream(params, thread, options) {
    return await this._createThreadAssistantStream(thread, params, options);
  }
  async _runAssistantStream(threadId, runs, params, options) {
    return await this._createAssistantStream(runs, threadId, params, options);
  }
  async _runToolAssistantStream(runId, runs, params, options) {
    return await this._createToolAssistantStream(runs, runId, params, options);
  }
};
_a2 = AssistantStream, _AssistantStream_addEvent = function _AssistantStream_addEvent2(event) {
  if (this.ended)
    return;
  __classPrivateFieldSet2(this, _AssistantStream_currentEvent, event, "f");
  __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_handleEvent).call(this, event);
  switch (event.event) {
    case "thread.created":
      break;
    case "thread.run.created":
    case "thread.run.queued":
    case "thread.run.in_progress":
    case "thread.run.requires_action":
    case "thread.run.completed":
    case "thread.run.incomplete":
    case "thread.run.failed":
    case "thread.run.cancelling":
    case "thread.run.cancelled":
    case "thread.run.expired":
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_handleRun).call(this, event);
      break;
    case "thread.run.step.created":
    case "thread.run.step.in_progress":
    case "thread.run.step.delta":
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_handleRunStep).call(this, event);
      break;
    case "thread.message.created":
    case "thread.message.in_progress":
    case "thread.message.delta":
    case "thread.message.completed":
    case "thread.message.incomplete":
      __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_handleMessage).call(this, event);
      break;
    case "error":
      throw new Error("Encountered an error event in event processing - errors should be processed earlier");
    default:
      assertNever2(event);
  }
}, _AssistantStream_endRequest = function _AssistantStream_endRequest2() {
  if (this.ended) {
    throw new OpenAIError(`stream has ended, this shouldn't happen`);
  }
  if (!__classPrivateFieldGet2(this, _AssistantStream_finalRun, "f"))
    throw Error("Final run has not been received");
  return __classPrivateFieldGet2(this, _AssistantStream_finalRun, "f");
}, _AssistantStream_handleMessage = function _AssistantStream_handleMessage2(event) {
  const [accumulatedMessage, newContent] = __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_accumulateMessage).call(this, event, __classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f"));
  __classPrivateFieldSet2(this, _AssistantStream_messageSnapshot, accumulatedMessage, "f");
  __classPrivateFieldGet2(this, _AssistantStream_messageSnapshots, "f")[accumulatedMessage.id] = accumulatedMessage;
  for (const content of newContent) {
    const snapshotContent = accumulatedMessage.content[content.index];
    if (snapshotContent?.type == "text") {
      this._emit("textCreated", snapshotContent.text);
    }
  }
  switch (event.event) {
    case "thread.message.created":
      this._emit("messageCreated", event.data);
      break;
    case "thread.message.in_progress":
      break;
    case "thread.message.delta":
      this._emit("messageDelta", event.data.delta, accumulatedMessage);
      if (event.data.delta.content) {
        for (const content of event.data.delta.content) {
          if (content.type == "text" && content.text) {
            let textDelta = content.text;
            let snapshot = accumulatedMessage.content[content.index];
            if (snapshot && snapshot.type == "text") {
              this._emit("textDelta", textDelta, snapshot.text);
            } else {
              throw Error("The snapshot associated with this text delta is not text or missing");
            }
          }
          if (content.index != __classPrivateFieldGet2(this, _AssistantStream_currentContentIndex, "f")) {
            if (__classPrivateFieldGet2(this, _AssistantStream_currentContent, "f")) {
              switch (__classPrivateFieldGet2(this, _AssistantStream_currentContent, "f").type) {
                case "text":
                  this._emit("textDone", __classPrivateFieldGet2(this, _AssistantStream_currentContent, "f").text, __classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f"));
                  break;
                case "image_file":
                  this._emit("imageFileDone", __classPrivateFieldGet2(this, _AssistantStream_currentContent, "f").image_file, __classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f"));
                  break;
              }
            }
            __classPrivateFieldSet2(this, _AssistantStream_currentContentIndex, content.index, "f");
          }
          __classPrivateFieldSet2(this, _AssistantStream_currentContent, accumulatedMessage.content[content.index], "f");
        }
      }
      break;
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (__classPrivateFieldGet2(this, _AssistantStream_currentContentIndex, "f") !== void 0) {
        const currentContent = event.data.content[__classPrivateFieldGet2(this, _AssistantStream_currentContentIndex, "f")];
        if (currentContent) {
          switch (currentContent.type) {
            case "image_file":
              this._emit("imageFileDone", currentContent.image_file, __classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f"));
              break;
            case "text":
              this._emit("textDone", currentContent.text, __classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f"));
              break;
          }
        }
      }
      if (__classPrivateFieldGet2(this, _AssistantStream_messageSnapshot, "f")) {
        this._emit("messageDone", event.data);
      }
      __classPrivateFieldSet2(this, _AssistantStream_messageSnapshot, void 0, "f");
  }
}, _AssistantStream_handleRunStep = function _AssistantStream_handleRunStep2(event) {
  const accumulatedRunStep = __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_accumulateRunStep).call(this, event);
  __classPrivateFieldSet2(this, _AssistantStream_currentRunStepSnapshot, accumulatedRunStep, "f");
  switch (event.event) {
    case "thread.run.step.created":
      this._emit("runStepCreated", event.data);
      break;
    case "thread.run.step.delta":
      const delta = event.data.delta;
      if (delta.step_details && delta.step_details.type == "tool_calls" && delta.step_details.tool_calls && accumulatedRunStep.step_details.type == "tool_calls") {
        for (const toolCall of delta.step_details.tool_calls) {
          if (toolCall.index == __classPrivateFieldGet2(this, _AssistantStream_currentToolCallIndex, "f")) {
            this._emit("toolCallDelta", toolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index]);
          } else {
            if (__classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f")) {
              this._emit("toolCallDone", __classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f"));
            }
            __classPrivateFieldSet2(this, _AssistantStream_currentToolCallIndex, toolCall.index, "f");
            __classPrivateFieldSet2(this, _AssistantStream_currentToolCall, accumulatedRunStep.step_details.tool_calls[toolCall.index], "f");
            if (__classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f"))
              this._emit("toolCallCreated", __classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f"));
          }
        }
      }
      this._emit("runStepDelta", event.data.delta, accumulatedRunStep);
      break;
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
      __classPrivateFieldSet2(this, _AssistantStream_currentRunStepSnapshot, void 0, "f");
      const details = event.data.step_details;
      if (details.type == "tool_calls") {
        if (__classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f")) {
          this._emit("toolCallDone", __classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f"));
          __classPrivateFieldSet2(this, _AssistantStream_currentToolCall, void 0, "f");
        }
      }
      this._emit("runStepDone", event.data, accumulatedRunStep);
      break;
    case "thread.run.step.in_progress":
      break;
  }
}, _AssistantStream_handleEvent = function _AssistantStream_handleEvent2(event) {
  __classPrivateFieldGet2(this, _AssistantStream_events, "f").push(event);
  this._emit("event", event);
}, _AssistantStream_accumulateRunStep = function _AssistantStream_accumulateRunStep2(event) {
  switch (event.event) {
    case "thread.run.step.created":
      __classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      return event.data;
    case "thread.run.step.delta":
      let snapshot = __classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
      if (!snapshot) {
        throw Error("Received a RunStepDelta before creation of a snapshot");
      }
      let data = event.data;
      if (data.delta) {
        const accumulated = _a2.accumulateDelta(snapshot, data.delta);
        __classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = accumulated;
      }
      return __classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
    case "thread.run.step.completed":
    case "thread.run.step.failed":
    case "thread.run.step.cancelled":
    case "thread.run.step.expired":
    case "thread.run.step.in_progress":
      __classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id] = event.data;
      break;
  }
  if (__classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id])
    return __classPrivateFieldGet2(this, _AssistantStream_runStepSnapshots, "f")[event.data.id];
  throw new Error("No snapshot available");
}, _AssistantStream_accumulateMessage = function _AssistantStream_accumulateMessage2(event, snapshot) {
  let newContent = [];
  switch (event.event) {
    case "thread.message.created":
      return [event.data, newContent];
    case "thread.message.delta":
      if (!snapshot) {
        throw Error("Received a delta with no existing snapshot (there should be one from message creation)");
      }
      let data = event.data;
      if (data.delta.content) {
        for (const contentElement of data.delta.content) {
          if (contentElement.index in snapshot.content) {
            let currentContent = snapshot.content[contentElement.index];
            snapshot.content[contentElement.index] = __classPrivateFieldGet2(this, _AssistantStream_instances, "m", _AssistantStream_accumulateContent).call(this, contentElement, currentContent);
          } else {
            snapshot.content[contentElement.index] = contentElement;
            newContent.push(contentElement);
          }
        }
      }
      return [snapshot, newContent];
    case "thread.message.in_progress":
    case "thread.message.completed":
    case "thread.message.incomplete":
      if (snapshot) {
        return [snapshot, newContent];
      } else {
        throw Error("Received thread message event with no existing snapshot");
      }
  }
  throw Error("Tried to accumulate a non-message event");
}, _AssistantStream_accumulateContent = function _AssistantStream_accumulateContent2(contentElement, currentContent) {
  return _a2.accumulateDelta(currentContent, contentElement);
}, _AssistantStream_handleRun = function _AssistantStream_handleRun2(event) {
  __classPrivateFieldSet2(this, _AssistantStream_currentRunSnapshot, event.data, "f");
  switch (event.event) {
    case "thread.run.created":
      break;
    case "thread.run.queued":
      break;
    case "thread.run.in_progress":
      break;
    case "thread.run.requires_action":
    case "thread.run.cancelled":
    case "thread.run.failed":
    case "thread.run.completed":
    case "thread.run.expired":
    case "thread.run.incomplete":
      __classPrivateFieldSet2(this, _AssistantStream_finalRun, event.data, "f");
      if (__classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f")) {
        this._emit("toolCallDone", __classPrivateFieldGet2(this, _AssistantStream_currentToolCall, "f"));
        __classPrivateFieldSet2(this, _AssistantStream_currentToolCall, void 0, "f");
      }
      break;
    case "thread.run.cancelling":
      break;
  }
};
function assertNever2(_x) {
}

// node_modules/openai/resources/beta/threads/runs/runs.mjs
var Runs = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.steps = new Steps(this._client);
  }
  create(threadID, params, options) {
    const { include, ...body } = params;
    return this._client.post(path2`/threads/${threadID}/runs`, {
      query: { include },
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: params.stream ?? false
    });
  }
  /**
   * Retrieves a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(runID, params, options) {
    const { thread_id } = params;
    return this._client.get(path2`/threads/${thread_id}/runs/${runID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies a run.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(runID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path2`/threads/${thread_id}/runs/${runID}`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of runs belonging to a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  list(threadID, query = {}, options) {
    return this._client.getAPIList(path2`/threads/${threadID}/runs`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Cancels a run that is `in_progress`.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  cancel(runID, params, options) {
    const { thread_id } = params;
    return this._client.post(path2`/threads/${thread_id}/runs/${runID}/cancel`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * A helper to create a run an poll for a terminal state. More information on Run
   * lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndPoll(threadId, body, options) {
    const run = await this.create(threadId, body, options);
    return await this.poll(run.id, { thread_id: threadId }, options);
  }
  /**
   * Create a Run stream
   *
   * @deprecated use `stream` instead
   */
  createAndStream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  /**
   * A helper to poll a run status until it reaches a terminal state. More
   * information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async poll(runId, params, options) {
    const headers = buildHeaders2([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? void 0
      }
    ]);
    while (true) {
      const { data: run, response } = await this.retrieve(runId, params, {
        ...options,
        headers: { ...options?.headers, ...headers }
      }).withResponse();
      switch (run.status) {
        //If we are in any sort of intermediate state we poll
        case "queued":
        case "in_progress":
        case "cancelling":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        //We return the run in any terminal state.
        case "requires_action":
        case "incomplete":
        case "cancelled":
        case "completed":
        case "failed":
        case "expired":
          return run;
      }
    }
  }
  /**
   * Create a Run stream
   */
  stream(threadId, body, options) {
    return AssistantStream.createAssistantStream(threadId, this._client.beta.threads.runs, body, options);
  }
  submitToolOutputs(runID, params, options) {
    const { thread_id, ...body } = params;
    return this._client.post(path2`/threads/${thread_id}/runs/${runID}/submit_tool_outputs`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: params.stream ?? false
    });
  }
  /**
   * A helper to submit a tool output to a run and poll for a terminal run state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async submitToolOutputsAndPoll(runId, params, options) {
    const run = await this.submitToolOutputs(runId, params, options);
    return await this.poll(run.id, params, options);
  }
  /**
   * Submit the tool outputs from a previous run and stream the run to a terminal
   * state. More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  submitToolOutputsStream(runId, params, options) {
    return AssistantStream.createToolAssistantStream(runId, this._client.beta.threads.runs, params, options);
  }
};
Runs.Steps = Steps;

// node_modules/openai/resources/beta/threads/threads.mjs
var Threads2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.runs = new Runs(this._client);
    this.messages = new Messages4(this._client);
  }
  /**
   * Create a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  create(body = {}, options) {
    return this._client.post("/threads", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  retrieve(threadID, options) {
    return this._client.get(path2`/threads/${threadID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  update(threadID, body, options) {
    return this._client.post(path2`/threads/${threadID}`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Delete a thread.
   *
   * @deprecated The Assistants API is deprecated in favor of the Responses API
   */
  delete(threadID, options) {
    return this._client.delete(path2`/threads/${threadID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  createAndRun(body, options) {
    return this._client.post("/threads/runs", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]),
      stream: body.stream ?? false
    });
  }
  /**
   * A helper to create a thread, start a run and then poll for a terminal state.
   * More information on Run lifecycles can be found here:
   * https://platform.openai.com/docs/assistants/how-it-works/runs-and-run-steps
   */
  async createAndRunPoll(body, options) {
    const run = await this.createAndRun(body, options);
    return await this.runs.poll(run.id, { thread_id: run.thread_id }, options);
  }
  /**
   * Create a thread and stream the run back
   */
  createAndRunStream(body, options) {
    return AssistantStream.createThreadAssistantStream(body, this._client.beta.threads, options);
  }
};
Threads2.Runs = Runs;
Threads2.Messages = Messages4;

// node_modules/openai/resources/beta/beta.mjs
var Beta2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.realtime = new Realtime(this._client);
    this.chatkit = new ChatKit(this._client);
    this.assistants = new Assistants(this._client);
    this.threads = new Threads2(this._client);
  }
};
Beta2.Realtime = Realtime;
Beta2.ChatKit = ChatKit;
Beta2.Assistants = Assistants;
Beta2.Threads = Threads2;

// node_modules/openai/resources/completions.mjs
var Completions3 = class extends APIResource2 {
  create(body, options) {
    return this._client.post("/completions", { body, ...options, stream: body.stream ?? false });
  }
};

// node_modules/openai/resources/containers/files/content.mjs
var Content = class extends APIResource2 {
  /**
   * Retrieve Container File Content
   */
  retrieve(fileID, params, options) {
    const { container_id } = params;
    return this._client.get(path2`/containers/${container_id}/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders2([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
};

// node_modules/openai/resources/containers/files/files.mjs
var Files2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.content = new Content(this._client);
  }
  /**
   * Create a Container File
   *
   * You can send either a multipart/form-data request with the raw file content, or
   * a JSON request with a file ID.
   */
  create(containerID, body, options) {
    return this._client.post(path2`/containers/${containerID}/files`, multipartFormRequestOptions2({ body, ...options }, this._client));
  }
  /**
   * Retrieve Container File
   */
  retrieve(fileID, params, options) {
    const { container_id } = params;
    return this._client.get(path2`/containers/${container_id}/files/${fileID}`, options);
  }
  /**
   * List Container files
   */
  list(containerID, query = {}, options) {
    return this._client.getAPIList(path2`/containers/${containerID}/files`, CursorPage, {
      query,
      ...options
    });
  }
  /**
   * Delete Container File
   */
  delete(fileID, params, options) {
    const { container_id } = params;
    return this._client.delete(path2`/containers/${container_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
};
Files2.Content = Content;

// node_modules/openai/resources/containers/containers.mjs
var Containers = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.files = new Files2(this._client);
  }
  /**
   * Create Container
   */
  create(body, options) {
    return this._client.post("/containers", { body, ...options });
  }
  /**
   * Retrieve Container
   */
  retrieve(containerID, options) {
    return this._client.get(path2`/containers/${containerID}`, options);
  }
  /**
   * List Containers
   */
  list(query = {}, options) {
    return this._client.getAPIList("/containers", CursorPage, { query, ...options });
  }
  /**
   * Delete Container
   */
  delete(containerID, options) {
    return this._client.delete(path2`/containers/${containerID}`, {
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
};
Containers.Files = Files2;

// node_modules/openai/resources/conversations/items.mjs
var Items = class extends APIResource2 {
  /**
   * Create items in a conversation with the given ID.
   */
  create(conversationID, params, options) {
    const { include, ...body } = params;
    return this._client.post(path2`/conversations/${conversationID}/items`, {
      query: { include },
      body,
      ...options
    });
  }
  /**
   * Get a single item from a conversation with the given IDs.
   */
  retrieve(itemID, params, options) {
    const { conversation_id, ...query } = params;
    return this._client.get(path2`/conversations/${conversation_id}/items/${itemID}`, { query, ...options });
  }
  /**
   * List all items for a conversation with the given ID.
   */
  list(conversationID, query = {}, options) {
    return this._client.getAPIList(path2`/conversations/${conversationID}/items`, ConversationCursorPage, { query, ...options });
  }
  /**
   * Delete an item from a conversation with the given IDs.
   */
  delete(itemID, params, options) {
    const { conversation_id } = params;
    return this._client.delete(path2`/conversations/${conversation_id}/items/${itemID}`, options);
  }
};

// node_modules/openai/resources/conversations/conversations.mjs
var Conversations = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.items = new Items(this._client);
  }
  /**
   * Create a conversation.
   */
  create(body = {}, options) {
    return this._client.post("/conversations", { body, ...options });
  }
  /**
   * Get a conversation
   */
  retrieve(conversationID, options) {
    return this._client.get(path2`/conversations/${conversationID}`, options);
  }
  /**
   * Update a conversation
   */
  update(conversationID, body, options) {
    return this._client.post(path2`/conversations/${conversationID}`, { body, ...options });
  }
  /**
   * Delete a conversation. Items in the conversation will not be deleted.
   */
  delete(conversationID, options) {
    return this._client.delete(path2`/conversations/${conversationID}`, options);
  }
};
Conversations.Items = Items;

// node_modules/openai/resources/embeddings.mjs
var Embeddings = class extends APIResource2 {
  /**
   * Creates an embedding vector representing the input text.
   *
   * @example
   * ```ts
   * const createEmbeddingResponse =
   *   await client.embeddings.create({
   *     input: 'The quick brown fox jumped over the lazy dog',
   *     model: 'text-embedding-3-small',
   *   });
   * ```
   */
  create(body, options) {
    const hasUserProvidedEncodingFormat = !!body.encoding_format;
    let encoding_format = hasUserProvidedEncodingFormat ? body.encoding_format : "base64";
    if (hasUserProvidedEncodingFormat) {
      loggerFor2(this._client).debug("embeddings/user defined encoding_format:", body.encoding_format);
    }
    const response = this._client.post("/embeddings", {
      body: {
        ...body,
        encoding_format
      },
      ...options
    });
    if (hasUserProvidedEncodingFormat) {
      return response;
    }
    loggerFor2(this._client).debug("embeddings/decoding base64 embeddings from base64");
    return response._thenUnwrap((response2) => {
      if (response2 && response2.data) {
        response2.data.forEach((embeddingBase64Obj) => {
          const embeddingBase64Str = embeddingBase64Obj.embedding;
          embeddingBase64Obj.embedding = toFloat32Array(embeddingBase64Str);
        });
      }
      return response2;
    });
  }
};

// node_modules/openai/resources/evals/runs/output-items.mjs
var OutputItems = class extends APIResource2 {
  /**
   * Get an evaluation run output item by ID.
   */
  retrieve(outputItemID, params, options) {
    const { eval_id, run_id } = params;
    return this._client.get(path2`/evals/${eval_id}/runs/${run_id}/output_items/${outputItemID}`, options);
  }
  /**
   * Get a list of output items for an evaluation run.
   */
  list(runID, params, options) {
    const { eval_id, ...query } = params;
    return this._client.getAPIList(path2`/evals/${eval_id}/runs/${runID}/output_items`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/resources/evals/runs/runs.mjs
var Runs2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.outputItems = new OutputItems(this._client);
  }
  /**
   * Kicks off a new run for a given evaluation, specifying the data source, and what
   * model configuration to use to test. The datasource will be validated against the
   * schema specified in the config of the evaluation.
   */
  create(evalID, body, options) {
    return this._client.post(path2`/evals/${evalID}/runs`, { body, ...options });
  }
  /**
   * Get an evaluation run by ID.
   */
  retrieve(runID, params, options) {
    const { eval_id } = params;
    return this._client.get(path2`/evals/${eval_id}/runs/${runID}`, options);
  }
  /**
   * Get a list of runs for an evaluation.
   */
  list(evalID, query = {}, options) {
    return this._client.getAPIList(path2`/evals/${evalID}/runs`, CursorPage, {
      query,
      ...options
    });
  }
  /**
   * Delete an eval run.
   */
  delete(runID, params, options) {
    const { eval_id } = params;
    return this._client.delete(path2`/evals/${eval_id}/runs/${runID}`, options);
  }
  /**
   * Cancel an ongoing evaluation run.
   */
  cancel(runID, params, options) {
    const { eval_id } = params;
    return this._client.post(path2`/evals/${eval_id}/runs/${runID}`, options);
  }
};
Runs2.OutputItems = OutputItems;

// node_modules/openai/resources/evals/evals.mjs
var Evals = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.runs = new Runs2(this._client);
  }
  /**
   * Create the structure of an evaluation that can be used to test a model's
   * performance. An evaluation is a set of testing criteria and the config for a
   * data source, which dictates the schema of the data used in the evaluation. After
   * creating an evaluation, you can run it on different models and model parameters.
   * We support several types of graders and datasources. For more information, see
   * the [Evals guide](https://platform.openai.com/docs/guides/evals).
   */
  create(body, options) {
    return this._client.post("/evals", { body, ...options });
  }
  /**
   * Get an evaluation by ID.
   */
  retrieve(evalID, options) {
    return this._client.get(path2`/evals/${evalID}`, options);
  }
  /**
   * Update certain properties of an evaluation.
   */
  update(evalID, body, options) {
    return this._client.post(path2`/evals/${evalID}`, { body, ...options });
  }
  /**
   * List evaluations for a project.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/evals", CursorPage, { query, ...options });
  }
  /**
   * Delete an evaluation.
   */
  delete(evalID, options) {
    return this._client.delete(path2`/evals/${evalID}`, options);
  }
};
Evals.Runs = Runs2;

// node_modules/openai/resources/files.mjs
var Files3 = class extends APIResource2 {
  /**
   * Upload a file that can be used across various endpoints. Individual files can be
   * up to 512 MB, and the size of all files uploaded by one organization can be up
   * to 1 TB.
   *
   * - The Assistants API supports files up to 2 million tokens and of specific file
   *   types. See the
   *   [Assistants Tools guide](https://platform.openai.com/docs/assistants/tools)
   *   for details.
   * - The Fine-tuning API only supports `.jsonl` files. The input also has certain
   *   required formats for fine-tuning
   *   [chat](https://platform.openai.com/docs/api-reference/fine-tuning/chat-input)
   *   or
   *   [completions](https://platform.openai.com/docs/api-reference/fine-tuning/completions-input)
   *   models.
   * - The Batch API only supports `.jsonl` files up to 200 MB in size. The input
   *   also has a specific required
   *   [format](https://platform.openai.com/docs/api-reference/batch/request-input).
   *
   * Please [contact us](https://help.openai.com/) if you need to increase these
   * storage limits.
   */
  create(body, options) {
    return this._client.post("/files", multipartFormRequestOptions2({ body, ...options }, this._client));
  }
  /**
   * Returns information about a specific file.
   */
  retrieve(fileID, options) {
    return this._client.get(path2`/files/${fileID}`, options);
  }
  /**
   * Returns a list of files.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/files", CursorPage, { query, ...options });
  }
  /**
   * Delete a file and remove it from all vector stores.
   */
  delete(fileID, options) {
    return this._client.delete(path2`/files/${fileID}`, options);
  }
  /**
   * Returns the contents of the specified file.
   */
  content(fileID, options) {
    return this._client.get(path2`/files/${fileID}/content`, {
      ...options,
      headers: buildHeaders2([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
  /**
   * Waits for the given file to be processed, default timeout is 30 mins.
   */
  async waitForProcessing(id, { pollInterval = 5e3, maxWait = 30 * 60 * 1e3 } = {}) {
    const TERMINAL_STATES = /* @__PURE__ */ new Set(["processed", "error", "deleted"]);
    const start = Date.now();
    let file = await this.retrieve(id);
    while (!file.status || !TERMINAL_STATES.has(file.status)) {
      await sleep2(pollInterval);
      file = await this.retrieve(id);
      if (Date.now() - start > maxWait) {
        throw new APIConnectionTimeoutError2({
          message: `Giving up on waiting for file ${id} to finish processing after ${maxWait} milliseconds.`
        });
      }
    }
    return file;
  }
};

// node_modules/openai/resources/fine-tuning/methods.mjs
var Methods = class extends APIResource2 {
};

// node_modules/openai/resources/fine-tuning/alpha/graders.mjs
var Graders = class extends APIResource2 {
  /**
   * Run a grader.
   *
   * @example
   * ```ts
   * const response = await client.fineTuning.alpha.graders.run({
   *   grader: {
   *     input: 'input',
   *     name: 'name',
   *     operation: 'eq',
   *     reference: 'reference',
   *     type: 'string_check',
   *   },
   *   model_sample: 'model_sample',
   * });
   * ```
   */
  run(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/run", { body, ...options });
  }
  /**
   * Validate a grader.
   *
   * @example
   * ```ts
   * const response =
   *   await client.fineTuning.alpha.graders.validate({
   *     grader: {
   *       input: 'input',
   *       name: 'name',
   *       operation: 'eq',
   *       reference: 'reference',
   *       type: 'string_check',
   *     },
   *   });
   * ```
   */
  validate(body, options) {
    return this._client.post("/fine_tuning/alpha/graders/validate", { body, ...options });
  }
};

// node_modules/openai/resources/fine-tuning/alpha/alpha.mjs
var Alpha = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.graders = new Graders(this._client);
  }
};
Alpha.Graders = Graders;

// node_modules/openai/resources/fine-tuning/checkpoints/permissions.mjs
var Permissions = class extends APIResource2 {
  /**
   * **NOTE:** Calling this endpoint requires an [admin API key](../admin-api-keys).
   *
   * This enables organization owners to share fine-tuned models with other projects
   * in their organization.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const permissionCreateResponse of client.fineTuning.checkpoints.permissions.create(
   *   'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *   { project_ids: ['string'] },
   * )) {
   *   // ...
   * }
   * ```
   */
  create(fineTunedModelCheckpoint, body, options) {
    return this._client.getAPIList(path2`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, Page2, { body, method: "post", ...options });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to view all permissions for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.retrieve(
   *     'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   *   );
   * ```
   */
  retrieve(fineTunedModelCheckpoint, query = {}, options) {
    return this._client.get(path2`/fine_tuning/checkpoints/${fineTunedModelCheckpoint}/permissions`, {
      query,
      ...options
    });
  }
  /**
   * **NOTE:** This endpoint requires an [admin API key](../admin-api-keys).
   *
   * Organization owners can use this endpoint to delete a permission for a
   * fine-tuned model checkpoint.
   *
   * @example
   * ```ts
   * const permission =
   *   await client.fineTuning.checkpoints.permissions.delete(
   *     'cp_zc4Q7MP6XxulcVzj4MZdwsAB',
   *     {
   *       fine_tuned_model_checkpoint:
   *         'ft:gpt-4o-mini-2024-07-18:org:weather:B7R9VjQd',
   *     },
   *   );
   * ```
   */
  delete(permissionID, params, options) {
    const { fine_tuned_model_checkpoint } = params;
    return this._client.delete(path2`/fine_tuning/checkpoints/${fine_tuned_model_checkpoint}/permissions/${permissionID}`, options);
  }
};

// node_modules/openai/resources/fine-tuning/checkpoints/checkpoints.mjs
var Checkpoints = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.permissions = new Permissions(this._client);
  }
};
Checkpoints.Permissions = Permissions;

// node_modules/openai/resources/fine-tuning/jobs/checkpoints.mjs
var Checkpoints2 = class extends APIResource2 {
  /**
   * List checkpoints for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobCheckpoint of client.fineTuning.jobs.checkpoints.list(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(fineTuningJobID, query = {}, options) {
    return this._client.getAPIList(path2`/fine_tuning/jobs/${fineTuningJobID}/checkpoints`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/resources/fine-tuning/jobs/jobs.mjs
var Jobs = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.checkpoints = new Checkpoints2(this._client);
  }
  /**
   * Creates a fine-tuning job which begins the process of creating a new model from
   * a given dataset.
   *
   * Response includes details of the enqueued job including job status and the name
   * of the fine-tuned models once complete.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.create({
   *   model: 'gpt-4o-mini',
   *   training_file: 'file-abc123',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/fine_tuning/jobs", { body, ...options });
  }
  /**
   * Get info about a fine-tuning job.
   *
   * [Learn more about fine-tuning](https://platform.openai.com/docs/guides/model-optimization)
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.retrieve(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  retrieve(fineTuningJobID, options) {
    return this._client.get(path2`/fine_tuning/jobs/${fineTuningJobID}`, options);
  }
  /**
   * List your organization's fine-tuning jobs
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJob of client.fineTuning.jobs.list()) {
   *   // ...
   * }
   * ```
   */
  list(query = {}, options) {
    return this._client.getAPIList("/fine_tuning/jobs", CursorPage, { query, ...options });
  }
  /**
   * Immediately cancel a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.cancel(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  cancel(fineTuningJobID, options) {
    return this._client.post(path2`/fine_tuning/jobs/${fineTuningJobID}/cancel`, options);
  }
  /**
   * Get status updates for a fine-tuning job.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const fineTuningJobEvent of client.fineTuning.jobs.listEvents(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * )) {
   *   // ...
   * }
   * ```
   */
  listEvents(fineTuningJobID, query = {}, options) {
    return this._client.getAPIList(path2`/fine_tuning/jobs/${fineTuningJobID}/events`, CursorPage, { query, ...options });
  }
  /**
   * Pause a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.pause(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  pause(fineTuningJobID, options) {
    return this._client.post(path2`/fine_tuning/jobs/${fineTuningJobID}/pause`, options);
  }
  /**
   * Resume a fine-tune job.
   *
   * @example
   * ```ts
   * const fineTuningJob = await client.fineTuning.jobs.resume(
   *   'ft-AF1WoRqd3aJAHsqc9NY7iL8F',
   * );
   * ```
   */
  resume(fineTuningJobID, options) {
    return this._client.post(path2`/fine_tuning/jobs/${fineTuningJobID}/resume`, options);
  }
};
Jobs.Checkpoints = Checkpoints2;

// node_modules/openai/resources/fine-tuning/fine-tuning.mjs
var FineTuning = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.methods = new Methods(this._client);
    this.jobs = new Jobs(this._client);
    this.checkpoints = new Checkpoints(this._client);
    this.alpha = new Alpha(this._client);
  }
};
FineTuning.Methods = Methods;
FineTuning.Jobs = Jobs;
FineTuning.Checkpoints = Checkpoints;
FineTuning.Alpha = Alpha;

// node_modules/openai/resources/graders/grader-models.mjs
var GraderModels = class extends APIResource2 {
};

// node_modules/openai/resources/graders/graders.mjs
var Graders2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.graderModels = new GraderModels(this._client);
  }
};
Graders2.GraderModels = GraderModels;

// node_modules/openai/resources/images.mjs
var Images = class extends APIResource2 {
  /**
   * Creates a variation of a given image. This endpoint only supports `dall-e-2`.
   *
   * @example
   * ```ts
   * const imagesResponse = await client.images.createVariation({
   *   image: fs.createReadStream('otter.png'),
   * });
   * ```
   */
  createVariation(body, options) {
    return this._client.post("/images/variations", multipartFormRequestOptions2({ body, ...options }, this._client));
  }
  edit(body, options) {
    return this._client.post("/images/edits", multipartFormRequestOptions2({ body, ...options, stream: body.stream ?? false }, this._client));
  }
  generate(body, options) {
    return this._client.post("/images/generations", { body, ...options, stream: body.stream ?? false });
  }
};

// node_modules/openai/resources/models.mjs
var Models3 = class extends APIResource2 {
  /**
   * Retrieves a model instance, providing basic information about the model such as
   * the owner and permissioning.
   */
  retrieve(model, options) {
    return this._client.get(path2`/models/${model}`, options);
  }
  /**
   * Lists the currently available models, and provides basic information about each
   * one such as the owner and availability.
   */
  list(options) {
    return this._client.getAPIList("/models", Page2, options);
  }
  /**
   * Delete a fine-tuned model. You must have the Owner role in your organization to
   * delete a model.
   */
  delete(model, options) {
    return this._client.delete(path2`/models/${model}`, options);
  }
};

// node_modules/openai/resources/moderations.mjs
var Moderations = class extends APIResource2 {
  /**
   * Classifies if text and/or image inputs are potentially harmful. Learn more in
   * the [moderation guide](https://platform.openai.com/docs/guides/moderation).
   */
  create(body, options) {
    return this._client.post("/moderations", { body, ...options });
  }
};

// node_modules/openai/resources/realtime/calls.mjs
var Calls = class extends APIResource2 {
  /**
   * Accept an incoming SIP call and configure the realtime session that will handle
   * it.
   *
   * @example
   * ```ts
   * await client.realtime.calls.accept('call_id', {
   *   type: 'realtime',
   * });
   * ```
   */
  accept(callID, body, options) {
    return this._client.post(path2`/realtime/calls/${callID}/accept`, {
      body,
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
  /**
   * End an active Realtime API call, whether it was initiated over SIP or WebRTC.
   *
   * @example
   * ```ts
   * await client.realtime.calls.hangup('call_id');
   * ```
   */
  hangup(callID, options) {
    return this._client.post(path2`/realtime/calls/${callID}/hangup`, {
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
  /**
   * Transfer an active SIP call to a new destination using the SIP REFER verb.
   *
   * @example
   * ```ts
   * await client.realtime.calls.refer('call_id', {
   *   target_uri: 'tel:+14155550123',
   * });
   * ```
   */
  refer(callID, body, options) {
    return this._client.post(path2`/realtime/calls/${callID}/refer`, {
      body,
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
  /**
   * Decline an incoming SIP call by returning a SIP status code to the caller.
   *
   * @example
   * ```ts
   * await client.realtime.calls.reject('call_id');
   * ```
   */
  reject(callID, body = {}, options) {
    return this._client.post(path2`/realtime/calls/${callID}/reject`, {
      body,
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
};

// node_modules/openai/resources/realtime/client-secrets.mjs
var ClientSecrets = class extends APIResource2 {
  /**
   * Create a Realtime client secret with an associated session configuration.
   *
   * @example
   * ```ts
   * const clientSecret =
   *   await client.realtime.clientSecrets.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/realtime/client_secrets", { body, ...options });
  }
};

// node_modules/openai/resources/realtime/realtime.mjs
var Realtime2 = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.clientSecrets = new ClientSecrets(this._client);
    this.calls = new Calls(this._client);
  }
};
Realtime2.ClientSecrets = ClientSecrets;
Realtime2.Calls = Calls;

// node_modules/openai/lib/ResponsesParser.mjs
function maybeParseResponse(response, params) {
  if (!params || !hasAutoParseableInput2(params)) {
    return {
      ...response,
      output_parsed: null,
      output: response.output.map((item) => {
        if (item.type === "function_call") {
          return {
            ...item,
            parsed_arguments: null
          };
        }
        if (item.type === "message") {
          return {
            ...item,
            content: item.content.map((content) => ({
              ...content,
              parsed: null
            }))
          };
        } else {
          return item;
        }
      })
    };
  }
  return parseResponse(response, params);
}
function parseResponse(response, params) {
  const output = response.output.map((item) => {
    if (item.type === "function_call") {
      return {
        ...item,
        parsed_arguments: parseToolCall2(params, item)
      };
    }
    if (item.type === "message") {
      const content = item.content.map((content2) => {
        if (content2.type === "output_text") {
          return {
            ...content2,
            parsed: parseTextFormat(params, content2.text)
          };
        }
        return content2;
      });
      return {
        ...item,
        content
      };
    }
    return item;
  });
  const parsed = Object.assign({}, response, { output });
  if (!Object.getOwnPropertyDescriptor(response, "output_text")) {
    addOutputText(parsed);
  }
  Object.defineProperty(parsed, "output_parsed", {
    enumerable: true,
    get() {
      for (const output2 of parsed.output) {
        if (output2.type !== "message") {
          continue;
        }
        for (const content of output2.content) {
          if (content.type === "output_text" && content.parsed !== null) {
            return content.parsed;
          }
        }
      }
      return null;
    }
  });
  return parsed;
}
function parseTextFormat(params, content) {
  if (params.text?.format?.type !== "json_schema") {
    return null;
  }
  if ("$parseRaw" in params.text?.format) {
    const text_format = params.text?.format;
    return text_format.$parseRaw(content);
  }
  return JSON.parse(content);
}
function hasAutoParseableInput2(params) {
  if (isAutoParsableResponseFormat(params.text?.format)) {
    return true;
  }
  return false;
}
function isAutoParsableTool2(tool) {
  return tool?.["$brand"] === "auto-parseable-tool";
}
function getInputToolByName(input_tools, name) {
  return input_tools.find((tool) => tool.type === "function" && tool.name === name);
}
function parseToolCall2(params, toolCall) {
  const inputTool = getInputToolByName(params.tools ?? [], toolCall.name);
  return {
    ...toolCall,
    ...toolCall,
    parsed_arguments: isAutoParsableTool2(inputTool) ? inputTool.$parseRaw(toolCall.arguments) : inputTool?.strict ? JSON.parse(toolCall.arguments) : null
  };
}
function addOutputText(rsp) {
  const texts = [];
  for (const output of rsp.output) {
    if (output.type !== "message") {
      continue;
    }
    for (const content of output.content) {
      if (content.type === "output_text") {
        texts.push(content.text);
      }
    }
  }
  rsp.output_text = texts.join("");
}

// node_modules/openai/lib/responses/ResponseStream.mjs
var _ResponseStream_instances;
var _ResponseStream_params;
var _ResponseStream_currentResponseSnapshot;
var _ResponseStream_finalResponse;
var _ResponseStream_beginRequest;
var _ResponseStream_addEvent;
var _ResponseStream_endRequest;
var _ResponseStream_accumulateResponse;
var ResponseStream = class _ResponseStream extends EventStream {
  constructor(params) {
    super();
    _ResponseStream_instances.add(this);
    _ResponseStream_params.set(this, void 0);
    _ResponseStream_currentResponseSnapshot.set(this, void 0);
    _ResponseStream_finalResponse.set(this, void 0);
    __classPrivateFieldSet2(this, _ResponseStream_params, params, "f");
  }
  static createResponse(client, params, options) {
    const runner = new _ResponseStream(params);
    runner._run(() => runner._createOrRetrieveResponse(client, params, {
      ...options,
      headers: { ...options?.headers, "X-Stainless-Helper-Method": "stream" }
    }));
    return runner;
  }
  async _createOrRetrieveResponse(client, params, options) {
    const signal = options?.signal;
    if (signal) {
      if (signal.aborted)
        this.controller.abort();
      signal.addEventListener("abort", () => this.controller.abort());
    }
    __classPrivateFieldGet2(this, _ResponseStream_instances, "m", _ResponseStream_beginRequest).call(this);
    let stream;
    let starting_after = null;
    if ("response_id" in params) {
      stream = await client.responses.retrieve(params.response_id, { stream: true }, { ...options, signal: this.controller.signal, stream: true });
      starting_after = params.starting_after ?? null;
    } else {
      stream = await client.responses.create({ ...params, stream: true }, { ...options, signal: this.controller.signal });
    }
    this._connected();
    for await (const event of stream) {
      __classPrivateFieldGet2(this, _ResponseStream_instances, "m", _ResponseStream_addEvent).call(this, event, starting_after);
    }
    if (stream.controller.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    return __classPrivateFieldGet2(this, _ResponseStream_instances, "m", _ResponseStream_endRequest).call(this);
  }
  [(_ResponseStream_params = /* @__PURE__ */ new WeakMap(), _ResponseStream_currentResponseSnapshot = /* @__PURE__ */ new WeakMap(), _ResponseStream_finalResponse = /* @__PURE__ */ new WeakMap(), _ResponseStream_instances = /* @__PURE__ */ new WeakSet(), _ResponseStream_beginRequest = function _ResponseStream_beginRequest2() {
    if (this.ended)
      return;
    __classPrivateFieldSet2(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
  }, _ResponseStream_addEvent = function _ResponseStream_addEvent2(event, starting_after) {
    if (this.ended)
      return;
    const maybeEmit = (name, event2) => {
      if (starting_after == null || event2.sequence_number > starting_after) {
        this._emit(name, event2);
      }
    };
    const response = __classPrivateFieldGet2(this, _ResponseStream_instances, "m", _ResponseStream_accumulateResponse).call(this, event);
    maybeEmit("event", event);
    switch (event.type) {
      case "response.output_text.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          maybeEmit("response.output_text.delta", {
            ...event,
            snapshot: content.text
          });
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = response.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          maybeEmit("response.function_call_arguments.delta", {
            ...event,
            snapshot: output.arguments
          });
        }
        break;
      }
      default:
        maybeEmit(event.type, event);
        break;
    }
  }, _ResponseStream_endRequest = function _ResponseStream_endRequest2() {
    if (this.ended) {
      throw new OpenAIError(`stream has ended, this shouldn't happen`);
    }
    const snapshot = __classPrivateFieldGet2(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      throw new OpenAIError(`request ended without sending any events`);
    }
    __classPrivateFieldSet2(this, _ResponseStream_currentResponseSnapshot, void 0, "f");
    const parsedResponse = finalizeResponse(snapshot, __classPrivateFieldGet2(this, _ResponseStream_params, "f"));
    __classPrivateFieldSet2(this, _ResponseStream_finalResponse, parsedResponse, "f");
    return parsedResponse;
  }, _ResponseStream_accumulateResponse = function _ResponseStream_accumulateResponse2(event) {
    let snapshot = __classPrivateFieldGet2(this, _ResponseStream_currentResponseSnapshot, "f");
    if (!snapshot) {
      if (event.type !== "response.created") {
        throw new OpenAIError(`When snapshot hasn't been set yet, expected 'response.created' event, got ${event.type}`);
      }
      snapshot = __classPrivateFieldSet2(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
      return snapshot;
    }
    switch (event.type) {
      case "response.output_item.added": {
        snapshot.output.push(event.item);
        break;
      }
      case "response.content_part.added": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        const type = output.type;
        const part = event.part;
        if (type === "message" && part.type !== "reasoning_text") {
          output.content.push(part);
        } else if (type === "reasoning" && part.type === "reasoning_text") {
          if (!output.content) {
            output.content = [];
          }
          output.content.push(part);
        }
        break;
      }
      case "response.output_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "message") {
          const content = output.content[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "output_text") {
            throw new OpenAIError(`expected content to be 'output_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.function_call_arguments.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "function_call") {
          output.arguments += event.delta;
        }
        break;
      }
      case "response.reasoning_text.delta": {
        const output = snapshot.output[event.output_index];
        if (!output) {
          throw new OpenAIError(`missing output at index ${event.output_index}`);
        }
        if (output.type === "reasoning") {
          const content = output.content?.[event.content_index];
          if (!content) {
            throw new OpenAIError(`missing content at index ${event.content_index}`);
          }
          if (content.type !== "reasoning_text") {
            throw new OpenAIError(`expected content to be 'reasoning_text', got ${content.type}`);
          }
          content.text += event.delta;
        }
        break;
      }
      case "response.completed": {
        __classPrivateFieldSet2(this, _ResponseStream_currentResponseSnapshot, event.response, "f");
        break;
      }
    }
    return snapshot;
  }, Symbol.asyncIterator)]() {
    const pushQueue = [];
    const readQueue = [];
    let done = false;
    this.on("event", (event) => {
      const reader = readQueue.shift();
      if (reader) {
        reader.resolve(event);
      } else {
        pushQueue.push(event);
      }
    });
    this.on("end", () => {
      done = true;
      for (const reader of readQueue) {
        reader.resolve(void 0);
      }
      readQueue.length = 0;
    });
    this.on("abort", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    this.on("error", (err) => {
      done = true;
      for (const reader of readQueue) {
        reader.reject(err);
      }
      readQueue.length = 0;
    });
    return {
      next: async () => {
        if (!pushQueue.length) {
          if (done) {
            return { value: void 0, done: true };
          }
          return new Promise((resolve, reject) => readQueue.push({ resolve, reject })).then((event2) => event2 ? { value: event2, done: false } : { value: void 0, done: true });
        }
        const event = pushQueue.shift();
        return { value: event, done: false };
      },
      return: async () => {
        this.abort();
        return { value: void 0, done: true };
      }
    };
  }
  /**
   * @returns a promise that resolves with the final Response, or rejects
   * if an error occurred or the stream ended prematurely without producing a REsponse.
   */
  async finalResponse() {
    await this.done();
    const response = __classPrivateFieldGet2(this, _ResponseStream_finalResponse, "f");
    if (!response)
      throw new OpenAIError("stream ended without producing a ChatCompletion");
    return response;
  }
};
function finalizeResponse(snapshot, params) {
  return maybeParseResponse(snapshot, params);
}

// node_modules/openai/resources/responses/input-items.mjs
var InputItems = class extends APIResource2 {
  /**
   * Returns a list of input items for a given response.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const responseItem of client.responses.inputItems.list(
   *   'response_id',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(responseID, query = {}, options) {
    return this._client.getAPIList(path2`/responses/${responseID}/input_items`, CursorPage, { query, ...options });
  }
};

// node_modules/openai/resources/responses/input-tokens.mjs
var InputTokens = class extends APIResource2 {
  /**
   * Get input token counts
   *
   * @example
   * ```ts
   * const response = await client.responses.inputTokens.count();
   * ```
   */
  count(body = {}, options) {
    return this._client.post("/responses/input_tokens", { body, ...options });
  }
};

// node_modules/openai/resources/responses/responses.mjs
var Responses = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.inputItems = new InputItems(this._client);
    this.inputTokens = new InputTokens(this._client);
  }
  create(body, options) {
    return this._client.post("/responses", { body, ...options, stream: body.stream ?? false })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  retrieve(responseID, query = {}, options) {
    return this._client.get(path2`/responses/${responseID}`, {
      query,
      ...options,
      stream: query?.stream ?? false
    })._thenUnwrap((rsp) => {
      if ("object" in rsp && rsp.object === "response") {
        addOutputText(rsp);
      }
      return rsp;
    });
  }
  /**
   * Deletes a model response with the given ID.
   *
   * @example
   * ```ts
   * await client.responses.delete(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  delete(responseID, options) {
    return this._client.delete(path2`/responses/${responseID}`, {
      ...options,
      headers: buildHeaders2([{ Accept: "*/*" }, options?.headers])
    });
  }
  parse(body, options) {
    return this._client.responses.create(body, options)._thenUnwrap((response) => parseResponse(response, body));
  }
  /**
   * Creates a model response stream
   */
  stream(body, options) {
    return ResponseStream.createResponse(this._client, body, options);
  }
  /**
   * Cancels a model response with the given ID. Only responses created with the
   * `background` parameter set to `true` can be cancelled.
   * [Learn more](https://platform.openai.com/docs/guides/background).
   *
   * @example
   * ```ts
   * const response = await client.responses.cancel(
   *   'resp_677efb5139a88190b512bc3fef8e535d',
   * );
   * ```
   */
  cancel(responseID, options) {
    return this._client.post(path2`/responses/${responseID}/cancel`, options);
  }
  /**
   * Compact conversation
   *
   * @example
   * ```ts
   * const compactedResponse = await client.responses.compact({
   *   model: 'gpt-5.2',
   * });
   * ```
   */
  compact(body, options) {
    return this._client.post("/responses/compact", { body, ...options });
  }
};
Responses.InputItems = InputItems;
Responses.InputTokens = InputTokens;

// node_modules/openai/resources/uploads/parts.mjs
var Parts = class extends APIResource2 {
  /**
   * Adds a
   * [Part](https://platform.openai.com/docs/api-reference/uploads/part-object) to an
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object.
   * A Part represents a chunk of bytes from the file you are trying to upload.
   *
   * Each Part can be at most 64 MB, and you can add Parts until you hit the Upload
   * maximum of 8 GB.
   *
   * It is possible to add multiple Parts in parallel. You can decide the intended
   * order of the Parts when you
   * [complete the Upload](https://platform.openai.com/docs/api-reference/uploads/complete).
   */
  create(uploadID, body, options) {
    return this._client.post(path2`/uploads/${uploadID}/parts`, multipartFormRequestOptions2({ body, ...options }, this._client));
  }
};

// node_modules/openai/resources/uploads/uploads.mjs
var Uploads = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.parts = new Parts(this._client);
  }
  /**
   * Creates an intermediate
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object) object
   * that you can add
   * [Parts](https://platform.openai.com/docs/api-reference/uploads/part-object) to.
   * Currently, an Upload can accept at most 8 GB in total and expires after an hour
   * after you create it.
   *
   * Once you complete the Upload, we will create a
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * contains all the parts you uploaded. This File is usable in the rest of our
   * platform as a regular File object.
   *
   * For certain `purpose` values, the correct `mime_type` must be specified. Please
   * refer to documentation for the
   * [supported MIME types for your use case](https://platform.openai.com/docs/assistants/tools/file-search#supported-files).
   *
   * For guidance on the proper filename extensions for each purpose, please follow
   * the documentation on
   * [creating a File](https://platform.openai.com/docs/api-reference/files/create).
   */
  create(body, options) {
    return this._client.post("/uploads", { body, ...options });
  }
  /**
   * Cancels the Upload. No Parts may be added after an Upload is cancelled.
   */
  cancel(uploadID, options) {
    return this._client.post(path2`/uploads/${uploadID}/cancel`, options);
  }
  /**
   * Completes the
   * [Upload](https://platform.openai.com/docs/api-reference/uploads/object).
   *
   * Within the returned Upload object, there is a nested
   * [File](https://platform.openai.com/docs/api-reference/files/object) object that
   * is ready to use in the rest of the platform.
   *
   * You can specify the order of the Parts by passing in an ordered list of the Part
   * IDs.
   *
   * The number of bytes uploaded upon completion must match the number of bytes
   * initially specified when creating the Upload object. No Parts may be added after
   * an Upload is completed.
   */
  complete(uploadID, body, options) {
    return this._client.post(path2`/uploads/${uploadID}/complete`, { body, ...options });
  }
};
Uploads.Parts = Parts;

// node_modules/openai/lib/Util.mjs
var allSettledWithThrow = async (promises) => {
  const results = await Promise.allSettled(promises);
  const rejected = results.filter((result) => result.status === "rejected");
  if (rejected.length) {
    for (const result of rejected) {
      console.error(result.reason);
    }
    throw new Error(`${rejected.length} promise(s) failed - see the above errors`);
  }
  const values = [];
  for (const result of results) {
    if (result.status === "fulfilled") {
      values.push(result.value);
    }
  }
  return values;
};

// node_modules/openai/resources/vector-stores/file-batches.mjs
var FileBatches = class extends APIResource2 {
  /**
   * Create a vector store file batch.
   */
  create(vectorStoreID, body, options) {
    return this._client.post(path2`/vector_stores/${vectorStoreID}/file_batches`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves a vector store file batch.
   */
  retrieve(batchID, params, options) {
    const { vector_store_id } = params;
    return this._client.get(path2`/vector_stores/${vector_store_id}/file_batches/${batchID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Cancel a vector store file batch. This attempts to cancel the processing of
   * files in this batch as soon as possible.
   */
  cancel(batchID, params, options) {
    const { vector_store_id } = params;
    return this._client.post(path2`/vector_stores/${vector_store_id}/file_batches/${batchID}/cancel`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Create a vector store batch and poll until all files have been processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const batch = await this.create(vectorStoreId, body);
    return await this.poll(vectorStoreId, batch.id, options);
  }
  /**
   * Returns a list of vector store files in a batch.
   */
  listFiles(batchID, params, options) {
    const { vector_store_id, ...query } = params;
    return this._client.getAPIList(path2`/vector_stores/${vector_store_id}/file_batches/${batchID}/files`, CursorPage, { query, ...options, headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]) });
  }
  /**
   * Wait for the given file batch to be processed.
   *
   * Note: this will return even if one of the files failed to process, you need to
   * check batch.file_counts.failed_count to handle this case.
   */
  async poll(vectorStoreID, batchID, options) {
    const headers = buildHeaders2([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? void 0
      }
    ]);
    while (true) {
      const { data: batch, response } = await this.retrieve(batchID, { vector_store_id: vectorStoreID }, {
        ...options,
        headers
      }).withResponse();
      switch (batch.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "failed":
        case "cancelled":
        case "completed":
          return batch;
      }
    }
  }
  /**
   * Uploads the given files concurrently and then creates a vector store file batch.
   *
   * The concurrency limit is configurable using the `maxConcurrency` parameter.
   */
  async uploadAndPoll(vectorStoreId, { files, fileIds = [] }, options) {
    if (files == null || files.length == 0) {
      throw new Error(`No \`files\` provided to process. If you've already uploaded files you should use \`.createAndPoll()\` instead`);
    }
    const configuredConcurrency = options?.maxConcurrency ?? 5;
    const concurrencyLimit = Math.min(configuredConcurrency, files.length);
    const client = this._client;
    const fileIterator = files.values();
    const allFileIds = [...fileIds];
    async function processFiles(iterator) {
      for (let item of iterator) {
        const fileObj = await client.files.create({ file: item, purpose: "assistants" }, options);
        allFileIds.push(fileObj.id);
      }
    }
    const workers = Array(concurrencyLimit).fill(fileIterator).map(processFiles);
    await allSettledWithThrow(workers);
    return await this.createAndPoll(vectorStoreId, {
      file_ids: allFileIds
    });
  }
};

// node_modules/openai/resources/vector-stores/files.mjs
var Files4 = class extends APIResource2 {
  /**
   * Create a vector store file by attaching a
   * [File](https://platform.openai.com/docs/api-reference/files) to a
   * [vector store](https://platform.openai.com/docs/api-reference/vector-stores/object).
   */
  create(vectorStoreID, body, options) {
    return this._client.post(path2`/vector_stores/${vectorStoreID}/files`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves a vector store file.
   */
  retrieve(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.get(path2`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Update attributes on a vector store file.
   */
  update(fileID, params, options) {
    const { vector_store_id, ...body } = params;
    return this._client.post(path2`/vector_stores/${vector_store_id}/files/${fileID}`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of vector store files.
   */
  list(vectorStoreID, query = {}, options) {
    return this._client.getAPIList(path2`/vector_stores/${vectorStoreID}/files`, CursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Delete a vector store file. This will remove the file from the vector store but
   * the file itself will not be deleted. To delete the file, use the
   * [delete file](https://platform.openai.com/docs/api-reference/files/delete)
   * endpoint.
   */
  delete(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.delete(path2`/vector_stores/${vector_store_id}/files/${fileID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Attach a file to the given vector store and wait for it to be processed.
   */
  async createAndPoll(vectorStoreId, body, options) {
    const file = await this.create(vectorStoreId, body, options);
    return await this.poll(vectorStoreId, file.id, options);
  }
  /**
   * Wait for the vector store file to finish processing.
   *
   * Note: this will return even if the file failed to process, you need to check
   * file.last_error and file.status to handle these cases
   */
  async poll(vectorStoreID, fileID, options) {
    const headers = buildHeaders2([
      options?.headers,
      {
        "X-Stainless-Poll-Helper": "true",
        "X-Stainless-Custom-Poll-Interval": options?.pollIntervalMs?.toString() ?? void 0
      }
    ]);
    while (true) {
      const fileResponse = await this.retrieve(fileID, {
        vector_store_id: vectorStoreID
      }, { ...options, headers }).withResponse();
      const file = fileResponse.data;
      switch (file.status) {
        case "in_progress":
          let sleepInterval = 5e3;
          if (options?.pollIntervalMs) {
            sleepInterval = options.pollIntervalMs;
          } else {
            const headerInterval = fileResponse.response.headers.get("openai-poll-after-ms");
            if (headerInterval) {
              const headerIntervalMs = parseInt(headerInterval);
              if (!isNaN(headerIntervalMs)) {
                sleepInterval = headerIntervalMs;
              }
            }
          }
          await sleep2(sleepInterval);
          break;
        case "failed":
        case "completed":
          return file;
      }
    }
  }
  /**
   * Upload a file to the `files` API and then attach it to the given vector store.
   *
   * Note the file will be asynchronously processed (you can use the alternative
   * polling helper method to wait for processing to complete).
   */
  async upload(vectorStoreId, file, options) {
    const fileInfo = await this._client.files.create({ file, purpose: "assistants" }, options);
    return this.create(vectorStoreId, { file_id: fileInfo.id }, options);
  }
  /**
   * Add a file to a vector store and poll until processing is complete.
   */
  async uploadAndPoll(vectorStoreId, file, options) {
    const fileInfo = await this.upload(vectorStoreId, file, options);
    return await this.poll(vectorStoreId, fileInfo.id, options);
  }
  /**
   * Retrieve the parsed contents of a vector store file.
   */
  content(fileID, params, options) {
    const { vector_store_id } = params;
    return this._client.getAPIList(path2`/vector_stores/${vector_store_id}/files/${fileID}/content`, Page2, { ...options, headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers]) });
  }
};

// node_modules/openai/resources/vector-stores/vector-stores.mjs
var VectorStores = class extends APIResource2 {
  constructor() {
    super(...arguments);
    this.files = new Files4(this._client);
    this.fileBatches = new FileBatches(this._client);
  }
  /**
   * Create a vector store.
   */
  create(body, options) {
    return this._client.post("/vector_stores", {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Retrieves a vector store.
   */
  retrieve(vectorStoreID, options) {
    return this._client.get(path2`/vector_stores/${vectorStoreID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Modifies a vector store.
   */
  update(vectorStoreID, body, options) {
    return this._client.post(path2`/vector_stores/${vectorStoreID}`, {
      body,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Returns a list of vector stores.
   */
  list(query = {}, options) {
    return this._client.getAPIList("/vector_stores", CursorPage, {
      query,
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Delete a vector store.
   */
  delete(vectorStoreID, options) {
    return this._client.delete(path2`/vector_stores/${vectorStoreID}`, {
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
  /**
   * Search a vector store for relevant chunks based on a query and file attributes
   * filter.
   */
  search(vectorStoreID, body, options) {
    return this._client.getAPIList(path2`/vector_stores/${vectorStoreID}/search`, Page2, {
      body,
      method: "post",
      ...options,
      headers: buildHeaders2([{ "OpenAI-Beta": "assistants=v2" }, options?.headers])
    });
  }
};
VectorStores.Files = Files4;
VectorStores.FileBatches = FileBatches;

// node_modules/openai/resources/videos.mjs
var Videos = class extends APIResource2 {
  /**
   * Create a video
   */
  create(body, options) {
    return this._client.post("/videos", maybeMultipartFormRequestOptions({ body, ...options }, this._client));
  }
  /**
   * Retrieve a video
   */
  retrieve(videoID, options) {
    return this._client.get(path2`/videos/${videoID}`, options);
  }
  /**
   * List videos
   */
  list(query = {}, options) {
    return this._client.getAPIList("/videos", ConversationCursorPage, { query, ...options });
  }
  /**
   * Delete a video
   */
  delete(videoID, options) {
    return this._client.delete(path2`/videos/${videoID}`, options);
  }
  /**
   * Download video content
   */
  downloadContent(videoID, query = {}, options) {
    return this._client.get(path2`/videos/${videoID}/content`, {
      query,
      ...options,
      headers: buildHeaders2([{ Accept: "application/binary" }, options?.headers]),
      __binaryResponse: true
    });
  }
  /**
   * Create a video remix
   */
  remix(videoID, body, options) {
    return this._client.post(path2`/videos/${videoID}/remix`, maybeMultipartFormRequestOptions({ body, ...options }, this._client));
  }
};

// node_modules/openai/resources/webhooks.mjs
var _Webhooks_instances;
var _Webhooks_validateSecret;
var _Webhooks_getRequiredHeader;
var Webhooks = class extends APIResource2 {
  constructor() {
    super(...arguments);
    _Webhooks_instances.add(this);
  }
  /**
   * Validates that the given payload was sent by OpenAI and parses the payload.
   */
  async unwrap(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    await this.verifySignature(payload, headers, secret, tolerance);
    return JSON.parse(payload);
  }
  /**
   * Validates whether or not the webhook payload was sent by OpenAI.
   *
   * An error will be raised if the webhook payload was not sent by OpenAI.
   *
   * @param payload - The webhook payload
   * @param headers - The webhook headers
   * @param secret - The webhook secret (optional, will use client secret if not provided)
   * @param tolerance - Maximum age of the webhook in seconds (default: 300 = 5 minutes)
   */
  async verifySignature(payload, headers, secret = this._client.webhookSecret, tolerance = 300) {
    if (typeof crypto === "undefined" || typeof crypto.subtle.importKey !== "function" || typeof crypto.subtle.verify !== "function") {
      throw new Error("Webhook signature verification is only supported when the `crypto` global is defined");
    }
    __classPrivateFieldGet2(this, _Webhooks_instances, "m", _Webhooks_validateSecret).call(this, secret);
    const headersObj = buildHeaders2([headers]).values;
    const signatureHeader = __classPrivateFieldGet2(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-signature");
    const timestamp = __classPrivateFieldGet2(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-timestamp");
    const webhookId = __classPrivateFieldGet2(this, _Webhooks_instances, "m", _Webhooks_getRequiredHeader).call(this, headersObj, "webhook-id");
    const timestampSeconds = parseInt(timestamp, 10);
    if (isNaN(timestampSeconds)) {
      throw new InvalidWebhookSignatureError("Invalid webhook timestamp format");
    }
    const nowSeconds = Math.floor(Date.now() / 1e3);
    if (nowSeconds - timestampSeconds > tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too old");
    }
    if (timestampSeconds > nowSeconds + tolerance) {
      throw new InvalidWebhookSignatureError("Webhook timestamp is too new");
    }
    const signatures = signatureHeader.split(" ").map((part) => part.startsWith("v1,") ? part.substring(3) : part);
    const decodedSecret = secret.startsWith("whsec_") ? Buffer.from(secret.replace("whsec_", ""), "base64") : Buffer.from(secret, "utf-8");
    const signedPayload = webhookId ? `${webhookId}.${timestamp}.${payload}` : `${timestamp}.${payload}`;
    const key = await crypto.subtle.importKey("raw", decodedSecret, { name: "HMAC", hash: "SHA-256" }, false, ["verify"]);
    for (const signature of signatures) {
      try {
        const signatureBytes = Buffer.from(signature, "base64");
        const isValid = await crypto.subtle.verify("HMAC", key, signatureBytes, new TextEncoder().encode(signedPayload));
        if (isValid) {
          return;
        }
      } catch {
        continue;
      }
    }
    throw new InvalidWebhookSignatureError("The given webhook signature does not match the expected signature");
  }
};
_Webhooks_instances = /* @__PURE__ */ new WeakSet(), _Webhooks_validateSecret = function _Webhooks_validateSecret2(secret) {
  if (typeof secret !== "string" || secret.length === 0) {
    throw new Error(`The webhook secret must either be set using the env var, OPENAI_WEBHOOK_SECRET, on the client class, OpenAI({ webhookSecret: '123' }), or passed to this function`);
  }
}, _Webhooks_getRequiredHeader = function _Webhooks_getRequiredHeader2(headers, name) {
  if (!headers) {
    throw new Error(`Headers are required`);
  }
  const value = headers.get(name);
  if (value === null || value === void 0) {
    throw new Error(`Missing required header: ${name}`);
  }
  return value;
};

// node_modules/openai/client.mjs
var _OpenAI_instances;
var _a3;
var _OpenAI_encoder;
var _OpenAI_baseURLOverridden;
var OpenAI = class {
  /**
   * API Client for interfacing with the OpenAI API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['OPENAI_API_KEY'] ?? undefined]
   * @param {string | null | undefined} [opts.organization=process.env['OPENAI_ORG_ID'] ?? null]
   * @param {string | null | undefined} [opts.project=process.env['OPENAI_PROJECT_ID'] ?? null]
   * @param {string | null | undefined} [opts.webhookSecret=process.env['OPENAI_WEBHOOK_SECRET'] ?? null]
   * @param {string} [opts.baseURL=process.env['OPENAI_BASE_URL'] ?? https://api.openai.com/v1] - Override the default base URL for the API.
   * @param {number} [opts.timeout=10 minutes] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv2("OPENAI_BASE_URL"), apiKey = readEnv2("OPENAI_API_KEY"), organization = readEnv2("OPENAI_ORG_ID") ?? null, project = readEnv2("OPENAI_PROJECT_ID") ?? null, webhookSecret = readEnv2("OPENAI_WEBHOOK_SECRET") ?? null, ...opts } = {}) {
    _OpenAI_instances.add(this);
    _OpenAI_encoder.set(this, void 0);
    this.completions = new Completions3(this);
    this.chat = new Chat(this);
    this.embeddings = new Embeddings(this);
    this.files = new Files3(this);
    this.images = new Images(this);
    this.audio = new Audio(this);
    this.moderations = new Moderations(this);
    this.models = new Models3(this);
    this.fineTuning = new FineTuning(this);
    this.graders = new Graders2(this);
    this.vectorStores = new VectorStores(this);
    this.webhooks = new Webhooks(this);
    this.beta = new Beta2(this);
    this.batches = new Batches3(this);
    this.uploads = new Uploads(this);
    this.responses = new Responses(this);
    this.realtime = new Realtime2(this);
    this.conversations = new Conversations(this);
    this.evals = new Evals(this);
    this.containers = new Containers(this);
    this.videos = new Videos(this);
    if (apiKey === void 0) {
      throw new OpenAIError("Missing credentials. Please pass an `apiKey`, or set the `OPENAI_API_KEY` environment variable.");
    }
    const options = {
      apiKey,
      organization,
      project,
      webhookSecret,
      ...opts,
      baseURL: baseURL || `https://api.openai.com/v1`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser2()) {
      throw new OpenAIError("It looks like you're running in a browser-like environment.\n\nThis is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew OpenAI({ apiKey, dangerouslyAllowBrowser: true });\n\nhttps://help.openai.com/en/articles/5112595-best-practices-for-api-key-safety\n");
    }
    this.baseURL = options.baseURL;
    this.timeout = options.timeout ?? _a3.DEFAULT_TIMEOUT;
    this.logger = options.logger ?? console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = parseLogLevel2(options.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel2(readEnv2("OPENAI_LOG"), "process.env['OPENAI_LOG']", this) ?? defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = options.maxRetries ?? 2;
    this.fetch = options.fetch ?? getDefaultFetch2();
    __classPrivateFieldSet2(this, _OpenAI_encoder, FallbackEncoder2, "f");
    this._options = options;
    this.apiKey = typeof apiKey === "string" ? apiKey : "Missing Key";
    this.organization = organization;
    this.project = project;
    this.webhookSecret = webhookSecret;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(options) {
    const client = new this.constructor({
      ...this._options,
      baseURL: this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      organization: this.organization,
      project: this.project,
      webhookSecret: this.webhookSecret,
      ...options
    });
    return client;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    return;
  }
  async authHeaders(opts) {
    return buildHeaders2([{ Authorization: `Bearer ${this.apiKey}` }]);
  }
  stringifyQuery(query) {
    return stringify(query, { arrayFormat: "brackets" });
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION2}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid42()}`;
  }
  makeStatusError(status, error2, message, headers) {
    return APIError2.generate(status, error2, message, headers);
  }
  async _callApiKey() {
    const apiKey = this._options.apiKey;
    if (typeof apiKey !== "function")
      return false;
    let token;
    try {
      token = await apiKey();
    } catch (err) {
      if (err instanceof OpenAIError)
        throw err;
      throw new OpenAIError(
        `Failed to get token from 'apiKey' function: ${err.message}`,
        // @ts-ignore
        { cause: err }
      );
    }
    if (typeof token !== "string" || !token) {
      throw new OpenAIError(`Expected 'apiKey' function argument to return a string but it returned ${token}`);
    }
    this.apiKey = token;
    return true;
  }
  buildURL(path10, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet2(this, _OpenAI_instances, "m", _OpenAI_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url2 = isAbsoluteURL2(path10) ? new URL(path10) : new URL(baseURL + (baseURL.endsWith("/") && path10.startsWith("/") ? path10.slice(1) : path10));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj2(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url2.search = this.stringifyQuery(query);
    }
    return url2.toString();
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
    await this._callApiKey();
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request3, { url: url2, options }) {
  }
  get(path10, opts) {
    return this.methodRequest("get", path10, opts);
  }
  post(path10, opts) {
    return this.methodRequest("post", path10, opts);
  }
  patch(path10, opts) {
    return this.methodRequest("patch", path10, opts);
  }
  put(path10, opts) {
    return this.methodRequest("put", path10, opts);
  }
  delete(path10, opts) {
    return this.methodRequest("delete", path10, opts);
  }
  methodRequest(method, path10, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path10, ...opts2 };
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise2(this, this.makeRequest(options, remainingRetries, void 0));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url: url2, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url: url2, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor2(this).debug(`[${requestLogID}] sending request`, formatRequestDetails2({
      retryOfRequestLogID,
      method: options.method,
      url: url2,
      options,
      headers: req.headers
    }));
    if (options.signal?.aborted) {
      throw new APIUserAbortError2();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url2, req, timeout, controller).catch(castToError2);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if (options.signal?.aborted) {
        throw new APIUserAbortError2();
      }
      const isTimeout = isAbortError2(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor2(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor2(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails2({
          retryOfRequestLogID,
          url: url2,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
      }
      loggerFor2(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor2(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails2({
        retryOfRequestLogID,
        url: url2,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError2();
      }
      throw new APIConnectionError2({ cause: response });
    }
    const specialHeaders = [...response.headers.entries()].filter(([name]) => name === "x-request-id").map(([name, value]) => ", " + name + ": " + JSON.stringify(value)).join("");
    const responseInfo = `[${requestLogID}${retryLogStr}${specialHeaders}] ${req.method} ${url2} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream2(response.body);
        loggerFor2(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor2(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails2({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor2(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError2(err2).message);
      const errJSON = safeJSON2(errText);
      const errMessage = errJSON ? void 0 : errText;
      loggerFor2(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails2({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor2(this).info(responseInfo);
    loggerFor2(this).debug(`[${requestLogID}] response start`, formatRequestDetails2({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  getAPIList(path10, Page3, opts) {
    return this.requestAPIList(Page3, { method: "get", path: path10, ...opts });
  }
  requestAPIList(Page3, options) {
    const request3 = this.makeRequest(options, null, void 0);
    return new PagePromise2(this, request3, Page3);
  }
  async fetchWithTimeout(url2, init, ms, controller) {
    const { signal, method, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(void 0, url2, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders?.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders?.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep2(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path: path10, query, defaultBaseURL } = options;
    const url2 = this.buildURL(path10, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger2("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options.signal && { signal: options.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...this.fetchOptions ?? {},
      ...options.fetchOptions ?? {}
    };
    return { req, url: url2, timeout: options.timeout };
  }
  async buildHeaders({ options, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const headers = buildHeaders2([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1e3)) } : {},
        ...getPlatformHeaders2(),
        "OpenAI-Organization": this.organization,
        "OpenAI-Project": this.project
      },
      await this.authHeaders(options),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: void 0, body: void 0 };
    }
    const headers = buildHeaders2([rawHeaders]);
    if (
      // Pass raw type verbatim
      ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
      headers.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && body instanceof globalThis.ReadableStream
    ) {
      return { bodyHeaders: void 0, body };
    } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
      return { bodyHeaders: void 0, body: ReadableStreamFrom2(body) };
    } else {
      return __classPrivateFieldGet2(this, _OpenAI_encoder, "f").call(this, { body, headers });
    }
  }
};
_a3 = OpenAI, _OpenAI_encoder = /* @__PURE__ */ new WeakMap(), _OpenAI_instances = /* @__PURE__ */ new WeakSet(), _OpenAI_baseURLOverridden = function _OpenAI_baseURLOverridden2() {
  return this.baseURL !== "https://api.openai.com/v1";
};
OpenAI.OpenAI = _a3;
OpenAI.DEFAULT_TIMEOUT = 6e5;
OpenAI.OpenAIError = OpenAIError;
OpenAI.APIError = APIError2;
OpenAI.APIConnectionError = APIConnectionError2;
OpenAI.APIConnectionTimeoutError = APIConnectionTimeoutError2;
OpenAI.APIUserAbortError = APIUserAbortError2;
OpenAI.NotFoundError = NotFoundError2;
OpenAI.ConflictError = ConflictError2;
OpenAI.RateLimitError = RateLimitError2;
OpenAI.BadRequestError = BadRequestError2;
OpenAI.AuthenticationError = AuthenticationError2;
OpenAI.InternalServerError = InternalServerError2;
OpenAI.PermissionDeniedError = PermissionDeniedError2;
OpenAI.UnprocessableEntityError = UnprocessableEntityError2;
OpenAI.InvalidWebhookSignatureError = InvalidWebhookSignatureError;
OpenAI.toFile = toFile2;
OpenAI.Completions = Completions3;
OpenAI.Chat = Chat;
OpenAI.Embeddings = Embeddings;
OpenAI.Files = Files3;
OpenAI.Images = Images;
OpenAI.Audio = Audio;
OpenAI.Moderations = Moderations;
OpenAI.Models = Models3;
OpenAI.FineTuning = FineTuning;
OpenAI.Graders = Graders2;
OpenAI.VectorStores = VectorStores;
OpenAI.Webhooks = Webhooks;
OpenAI.Beta = Beta2;
OpenAI.Batches = Batches3;
OpenAI.Uploads = Uploads;
OpenAI.Responses = Responses;
OpenAI.Realtime = Realtime2;
OpenAI.Conversations = Conversations;
OpenAI.Evals = Evals;
OpenAI.Containers = Containers;
OpenAI.Videos = Videos;

// src/providers/openai/openaiHandler.ts
var vscode16 = __toESM(require("vscode"));
init_accountQuotaCache();
init_apiKeyManager();
init_configManager();
init_logger();

// src/utils/rateLimiter.ts
init_logger();
var RateLimiter = class _RateLimiter {
  static instances = /* @__PURE__ */ new Map();
  lastRequestTime = 0;
  requestCount = 0;
  maxRequests;
  windowMs;
  constructor(maxRequests = 2, windowMs = 1e3) {
    this.maxRequests = maxRequests;
    this.windowMs = windowMs;
  }
  /**
   * Get or create a RateLimiter instance for a specific key
   * @param key Unique key for the rate limiter (e.g., provider name)
   * @param maxRequests Maximum requests allowed in the window
   * @param windowMs Window duration in milliseconds
   */
  static getInstance(key, maxRequests = 2, windowMs = 1e3) {
    let instance = _RateLimiter.instances.get(key);
    if (!instance) {
      instance = new _RateLimiter(maxRequests, windowMs);
      _RateLimiter.instances.set(key, instance);
    }
    return instance;
  }
  /**
   * Wait if necessary to comply with rate limits
   * @param providerName Name of the provider for logging
   */
  async throttle(providerName) {
    const now = Date.now();
    const timeSinceLastWindow = now - this.lastRequestTime;
    if (timeSinceLastWindow >= this.windowMs) {
      this.lastRequestTime = now;
      this.requestCount = 1;
      return;
    }
    if (this.requestCount < this.maxRequests) {
      this.requestCount++;
      return;
    }
    const waitTime = this.windowMs - timeSinceLastWindow;
    Logger.info(
      `[${providerName}] Rate limit reached (${this.maxRequests} req/${this.windowMs}ms). Throttling for ${waitTime}ms...`
    );
    await new Promise((resolve) => setTimeout(resolve, waitTime));
    return this.throttle(providerName);
  }
};

// src/utils/tokenCounter.ts
var import_tiktokenizer = __toESM(require_dist());
var vscode14 = __toESM(require("vscode"));
var import_vscode = require("vscode");
init_logger();
var sharedTokenizerPromise = null;
var extensionPath = null;
var sharedTokenCounterInstance = null;
var LRUCache = class {
  constructor(maxSize) {
    this.maxSize = maxSize;
  }
  cache = /* @__PURE__ */ new Map();
  get(key) {
    const value = this.cache.get(key);
    if (value !== void 0) {
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }
  put(key, value) {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) {
        this.cache.delete(firstKey);
      }
    }
    this.cache.set(key, value);
  }
};
var TokenCounter = class _TokenCounter {
  constructor(tokenizer) {
    this.tokenizer = tokenizer;
    if (!this.tokenizer) {
      this.tokenizer = _TokenCounter.getSharedTokenizer();
    }
  }
  /**
   * Cache for text token counts (LRU, capacity 5000)
   */
  tokenCache = new LRUCache(5e3);
  /**
   * Set extension path
   * Must be called before creating a TokenCounter instance
   */
  static setExtensionPath(path10) {
    extensionPath = path10;
    Logger.trace("[TokenCounter] Extension path set");
  }
  /**
   * Get globally shared TokenCounter instance (singleton)
   */
  static getInstance() {
    if (!sharedTokenCounterInstance) {
      sharedTokenCounterInstance = new _TokenCounter();
      Logger.trace("[TokenCounter] Global instance created");
    }
    return sharedTokenCounterInstance;
  }
  /**
   * Get shared tokenizer instance (lazy loading, global singleton)
   */
  static getSharedTokenizer() {
    if (!sharedTokenizerPromise) {
      Logger.trace(
        "[TokenCounter] First request for tokenizer, initializing global shared instance..."
      );
      if (!extensionPath) {
        throw new Error(
          "[TokenCounter] Extension path not initialized, please call TokenCounter.setExtensionPath() first"
        );
      }
      const basePath = vscode14.Uri.file(extensionPath);
      const tokenizerPath = vscode14.Uri.joinPath(
        basePath,
        "dist",
        "o200k_base.tiktoken"
      ).fsPath;
      sharedTokenizerPromise = (0, import_tiktokenizer.createTokenizer)(
        tokenizerPath,
        (0, import_tiktokenizer.getSpecialTokensByEncoder)("o200k_base"),
        (0, import_tiktokenizer.getRegexByEncoder)("o200k_base")
      );
      Logger.trace("[TokenCounter] Tokenizer initialization complete");
    }
    return sharedTokenizerPromise;
  }
  /**
   * Calculate text token count (with cache)
   */
  getTextTokenLength(text) {
    if (!text) {
      return 0;
    }
    const cacheValue = this.tokenCache.get(text);
    if (cacheValue !== void 0) {
      return cacheValue;
    }
    const tokenCount = this.tokenizer?.encode(text)?.length ?? 0;
    this.tokenCache.put(text, tokenCount);
    return tokenCount;
  }
  stringifyUnknown(value) {
    if (typeof value === "string") {
      return value;
    }
    try {
      return JSON.stringify(value) || "";
    } catch {
      return String(value);
    }
  }
  async countMessagePartTokens(part) {
    if (!part) {
      return 0;
    }
    if (part instanceof vscode14.LanguageModelTextPart) {
      return this.getTextTokenLength(part.value);
    }
    if (part instanceof vscode14.LanguageModelToolCallPart) {
      const payload = `${part.callId || ""} ${part.name || ""} ${this.stringifyUnknown(part.input)}`;
      return this.getTextTokenLength(payload);
    }
    if (part instanceof vscode14.LanguageModelToolResultPart) {
      let combined = part.callId || "";
      for (const resultPart of part.content || []) {
        if (resultPart instanceof vscode14.LanguageModelTextPart) {
          combined += `
${resultPart.value}`;
        } else {
          combined += `
${this.stringifyUnknown(resultPart)}`;
        }
      }
      return this.getTextTokenLength(combined);
    }
    if (part instanceof vscode14.LanguageModelPromptTsxPart) {
      return this.getTextTokenLength(this.stringifyUnknown(part.value));
    }
    if (typeof part === "string" || typeof part === "number" || typeof part === "boolean") {
      return this.getTextTokenLength(String(part));
    }
    if (typeof part === "object") {
      return this.countMessageObjectTokens(part, 1);
    }
    return 0;
  }
  async countLanguageModelMessageTokens(message) {
    let numTokens = 3;
    numTokens += this.getTextTokenLength(String(message.role));
    if (typeof message.content === "string") {
      numTokens += this.getTextTokenLength(message.content);
      return numTokens;
    }
    if (Array.isArray(message.content)) {
      for (const part of message.content) {
        numTokens += await this.countMessagePartTokens(part);
      }
      return numTokens;
    }
    numTokens += this.getTextTokenLength(this.stringifyUnknown(message.content));
    return numTokens;
  }
  /**
   * Calculate token count for a single text or message object
   */
  async countTokens(_model, text) {
    if (typeof text === "string") {
      const stringTokens = this.tokenizer?.encode(text)?.length ?? 0;
      Logger.trace(
        `[Token Count] String: ${stringTokens} tokens (Length: ${text.length})`
      );
      return stringTokens;
    }
    try {
      const objectTokens = await this.countLanguageModelMessageTokens(text);
      return objectTokens;
    } catch (error2) {
      Logger.warn(
        "[Token Count] Failed to calculate message object tokens, using simplified calculation:",
        error2
      );
      const fallbackTokens = this.tokenizer?.encode(JSON.stringify(text))?.length ?? 0;
      Logger.trace(
        `[Token Count] Fallback calculation: ${fallbackTokens} tokens`
      );
      return fallbackTokens;
    }
  }
  /**
   * Recursively calculate token count in message objects
   * Supports text, images, tool calls, and other complex content
   */
  async countMessageObjectTokens(obj, depth = 0) {
    let numTokens = 0;
    if (depth === 0) {
      const overheadTokens = 3;
      numTokens += overheadTokens;
    }
    for (const [_key, value] of Object.entries(obj)) {
      if (!value) {
        continue;
      }
      if (typeof value === "string") {
        const tokens = this.getTextTokenLength(value);
        numTokens += tokens;
      } else if (typeof value === "number" || typeof value === "boolean") {
        const tokens = this.getTextTokenLength(String(value));
        numTokens += tokens;
      } else if (Array.isArray(value)) {
        for (const item of value) {
          if (typeof item === "string") {
            const tokens = this.getTextTokenLength(item);
            numTokens += tokens;
          } else if (typeof item === "number" || typeof item === "boolean") {
            const tokens = this.getTextTokenLength(String(item));
            numTokens += tokens;
          } else if (item && typeof item === "object") {
            const itemTokens = await this.countMessageObjectTokens(
              item,
              depth + 2
            );
            numTokens += itemTokens;
          }
        }
      } else if (typeof value === "object") {
        const nestedTokens = await this.countMessageObjectTokens(
          value,
          depth + 1
        );
        numTokens += nestedTokens;
      }
    }
    return numTokens;
  }
  /**
   * Calculate total token count for multiple messages
   * Includes regular messages, system messages, and tool definitions
   */
  async countMessagesTokens(model, messages, modelConfig, options) {
    let totalTokens = 0;
    for (let i = 0; i < messages.length; i++) {
      const message = messages[i];
      const messageTokens = await this.countTokens(
        model,
        message
      );
      totalTokens += messageTokens;
    }
    const sdkMode = modelConfig?.sdkMode || "openai";
    if (sdkMode === "anthropic") {
      const systemMessageTokens = this.countSystemMessageTokens(messages);
      if (systemMessageTokens > 0) {
        totalTokens += systemMessageTokens;
      }
      const toolsTokens = this.countToolsTokens(options?.tools);
      if (toolsTokens > 0) {
        totalTokens += toolsTokens;
      }
    } else if (sdkMode === "openai") {
      const toolsTokens = this.countToolsTokens(options?.tools);
      if (toolsTokens > 0) {
        totalTokens += toolsTokens;
      }
    }
    return totalTokens;
  }
  /**
   * Calculate system message token count
   * Extract all system messages from the message list and calculate combined
   */
  countSystemMessageTokens(messages) {
    let systemText = "";
    for (const message of messages) {
      if (message.role === import_vscode.LanguageModelChatMessageRole.System) {
        if (typeof message.content === "string") {
          systemText += message.content;
        } else if (Array.isArray(message.content)) {
          systemText += message.content.map((part) => {
            if (part instanceof vscode14.LanguageModelTextPart) {
              return part.value;
            }
            if (part instanceof vscode14.LanguageModelPromptTsxPart) {
              return this.stringifyUnknown(part.value);
            }
            return this.stringifyUnknown(part);
          }).filter(Boolean).join("\n");
        }
      }
    }
    if (!systemText) {
      return 0;
    }
    const systemTokens = this.getTextTokenLength(systemText);
    const systemOverhead = 28;
    const totalSystemTokens = systemTokens + systemOverhead;
    Logger.debug(
      `[Token Count] System message details: Content ${systemTokens} tokens + Wrapping overhead ${systemOverhead} tokens = ${totalSystemTokens} tokens`
    );
    return totalSystemTokens;
  }
  /**
   * Calculate tool definition token count
   * Follows official VS Code Copilot implementation:
   * - Base overhead: 16 tokens (tool array overhead)
   * - Each tool: 8 tokens + object content token count
   * - Finally multiplied by 1.1 safety factor (official standard)
   */
  countToolsTokens(tools) {
    const baseToolTokens = 16;
    let numTokens = 0;
    if (!tools || tools.length === 0) {
      return 0;
    }
    numTokens += baseToolTokens;
    const baseTokensPerTool = 8;
    for (const tool of tools) {
      numTokens += baseTokensPerTool;
      const toolObj = {
        name: tool.name,
        description: tool.description || "",
        input_schema: tool.inputSchema
      };
      for (const [, value] of Object.entries(toolObj)) {
        if (typeof value === "string") {
          numTokens += this.getTextTokenLength(value);
        } else if (value && typeof value === "object") {
          numTokens += this.getTextTokenLength(JSON.stringify(value));
        }
      }
    }
    return Math.floor(numTokens * 1.1);
  }
};

// src/utils/tokenTelemetryTracker.ts
var vscode15 = __toESM(require("vscode"));
var TokenTelemetryTracker = class _TokenTelemetryTracker {
  static instance;
  emitter = new vscode15.EventEmitter();
  events = [];
  maxEvents = 200;
  lastSuccessEvent;
  static getInstance() {
    if (!_TokenTelemetryTracker.instance) {
      _TokenTelemetryTracker.instance = new _TokenTelemetryTracker();
    }
    return _TokenTelemetryTracker.instance;
  }
  onEvent(listener) {
    return this.emitter.event(listener);
  }
  recordSuccess(params) {
    const totalTokens = params.totalTokens ?? params.promptTokens + params.completionTokens;
    const event = {
      eventId: this.createEventId(),
      timestamp: Date.now(),
      status: "success",
      modelId: params.modelId,
      providerId: params.providerId,
      durationMs: params.durationMs,
      responseMetrics: {
        promptTokens: params.promptTokens,
        completionTokens: params.completionTokens,
        totalTokens,
        maxInputTokens: params.maxInputTokens,
        maxOutputTokens: params.maxOutputTokens,
        modelName: params.modelName,
        providerId: params.providerId,
        estimatedPromptTokens: params.estimatedPromptTokens
      }
    };
    this.pushEvent(event);
    this.lastSuccessEvent = event;
  }
  recordError(params) {
    const event = {
      eventId: this.createEventId(),
      timestamp: Date.now(),
      status: "error",
      modelId: params.modelId,
      providerId: params.providerId,
      errorMessage: params.errorMessage,
      durationMs: params.durationMs
    };
    this.pushEvent(event);
  }
  recordCancelled(params) {
    const event = {
      eventId: this.createEventId(),
      timestamp: Date.now(),
      status: "cancelled",
      modelId: params.modelId,
      providerId: params.providerId,
      durationMs: params.durationMs
    };
    this.pushEvent(event);
  }
  getLastUsageSummary() {
    if (!this.lastSuccessEvent?.responseMetrics) {
      return null;
    }
    const metrics = this.lastSuccessEvent.responseMetrics;
    const maxInputTokens = metrics.maxInputTokens || 0;
    const percentage = maxInputTokens > 0 ? metrics.promptTokens / maxInputTokens * 100 : 0;
    return {
      modelName: metrics.modelName || this.lastSuccessEvent.modelId || "Model",
      promptTokens: metrics.promptTokens,
      completionTokens: metrics.completionTokens,
      totalTokens: metrics.totalTokens,
      maxInputTokens: metrics.maxInputTokens,
      maxOutputTokens: metrics.maxOutputTokens,
      percentage,
      providerId: metrics.providerId,
      estimatedPromptTokens: metrics.estimatedPromptTokens
    };
  }
  computeAggregateStats() {
    let totalTokens = 0;
    let totalPromptTokens = 0;
    let totalCompletionTokens = 0;
    let successfulEvents = 0;
    let cancelledEvents = 0;
    let errorEvents = 0;
    let totalDuration = 0;
    let durationCount = 0;
    for (const event of this.events) {
      if (event.status === "success" && event.responseMetrics) {
        successfulEvents++;
        totalTokens += event.responseMetrics.totalTokens;
        totalPromptTokens += event.responseMetrics.promptTokens;
        totalCompletionTokens += event.responseMetrics.completionTokens;
      } else if (event.status === "cancelled") {
        cancelledEvents++;
      } else if (event.status === "error") {
        errorEvents++;
      }
      if (typeof event.durationMs === "number") {
        totalDuration += event.durationMs;
        durationCount++;
      }
    }
    return {
      totalTokens,
      totalPromptTokens,
      totalCompletionTokens,
      successfulEvents,
      cancelledEvents,
      errorEvents,
      averageEventDuration: durationCount > 0 ? totalDuration / durationCount : 0
    };
  }
  pushEvent(event) {
    this.events.push(event);
    if (this.events.length > this.maxEvents) {
      this.events.shift();
    }
    this.emitter.fire(event);
  }
  createEventId() {
    const random2 = Math.random().toString(36).slice(2, 10);
    return `tok_${Date.now()}_${random2}`;
  }
};

// src/providers/openai/openaiHandler.ts
var OpenAIHandler = class _OpenAIHandler {
  constructor(provider, displayName, baseURL) {
    this.provider = provider;
    this.displayName = displayName;
    this.baseURL = baseURL;
    this.cleanupInterval = setInterval(
      () => this.cleanupExpiredClients(),
      6e4
    );
    this.quotaCache = AccountQuotaCache.getInstance();
  }
  // SDK event deduplication tracker (request level)
  currentRequestProcessedEvents = /* @__PURE__ */ new Set();
  // Cache client instance to avoid creating new one for each request
  clientCache = /* @__PURE__ */ new Map();
  CLIENT_CACHE_TTL = 5 * 60 * 1e3;
  // 5 minutes
  cleanupInterval;
  quotaCache;
  /**
   * Cleanup expired clients to avoid memory leak
   */
  cleanupExpiredClients() {
    const now = Date.now();
    for (const [key, value] of this.clientCache.entries()) {
      if (now - value.lastUsed > this.CLIENT_CACHE_TTL) {
        Logger.debug(
          `[${this.displayName}] Cleaning up expired OpenAI client: ${key}`
        );
        this.clientCache.delete(key);
      }
    }
  }
  /**
   * Dispose handler and cleanup resources
   */
  dispose() {
    if (this.cleanupInterval) {
      clearInterval(this.cleanupInterval);
    }
    this.clientCache.clear();
    this.currentRequestProcessedEvents.clear();
    Logger.debug(`[${this.displayName}] OpenAI Handler disposed`);
  }
  /**
   * Create new OpenAI client with caching
   */
  async createOpenAIClient(modelConfig, accountId) {
    const providerKey = modelConfig?.provider || this.provider;
    let currentApiKey = modelConfig?.apiKey;
    if (!currentApiKey) {
      currentApiKey = await ApiKeyManager.getApiKey(providerKey);
      if (!currentApiKey) {
        throw new Error(`Missing ${this.displayName} API key`);
      }
    }
    let baseURL = modelConfig?.baseUrl || this.baseURL;
    if (providerKey === "zhipu") {
      const endpoint = ConfigManager.getZhipuEndpoint();
      if (baseURL && endpoint === "api.z.ai") {
        baseURL = baseURL.replace("open.bigmodel.cn", "api.z.ai");
      }
    }
    const defaultHeaders = {
      "User-Agent": VersionManager.getUserAgent("OpenAI")
    };
    const processedCustomHeader = ApiKeyManager.processCustomHeader(
      modelConfig?.customHeader,
      currentApiKey
    );
    if (Object.keys(processedCustomHeader).length > 0) {
      Object.assign(defaultHeaders, processedCustomHeader);
      Logger.debug(
        `${this.displayName} apply custom headers: ${JSON.stringify(modelConfig?.customHeader)}`
      );
    }
    const cacheKey = `${providerKey}:${accountId || "default"}:${baseURL}:${JSON.stringify(defaultHeaders)}`;
    const cached2 = this.clientCache.get(cacheKey);
    if (cached2) {
      cached2.lastUsed = Date.now();
      Logger.debug(
        `[${this.displayName}] Reusing cached OpenAI client${accountId ? ` for account ${accountId}` : ""}`
      );
      return cached2.client;
    }
    const client = new OpenAI({
      apiKey: currentApiKey,
      baseURL,
      defaultHeaders,
      fetch: this.createCustomFetch(),
      // Use custom fetch to solve SSE format issues
      maxRetries: 2,
      // Reduce retries to avoid lag
      timeout: 6e4
      // 60s timeout
    });
    this.clientCache.set(cacheKey, { client, lastUsed: Date.now() });
    Logger.debug(
      `${this.displayName} OpenAI SDK client created, using baseURL: ${baseURL}${accountId ? ` for account ${accountId}` : ""}`
    );
    return client;
  }
  /**
   * Create custom fetch function to handle non-standard SSE format
   * Fix issue where some models output "data:" without a space
   */
  createCustomFetch() {
    return async (url2, init) => {
      const response = await fetch(url2, init);
      return await this.preprocessSSEResponse(response);
    };
  }
  /**
   * Preprocess SSE response, fix non-standard format
   * Fix issue where some models output "data:" without a space
   */
  async preprocessSSEResponse(response) {
    const contentType = response.headers.get("Content-Type");
    if (contentType?.includes("application/json")) {
      const text = await response.text();
      throw new Error(text || `HTTP ${response.status} ${response.statusText}`);
    }
    if (!contentType || !contentType.includes("text/event-stream") || !response.body) {
      return response;
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    const encoder = new TextEncoder();
    const transformedStream = new ReadableStream({
      async start(controller) {
        const seenFinishReason = /* @__PURE__ */ new Map();
        let lastChunkId = "";
        let lastModel = "";
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) {
              if (!seenFinishReason.get(0)) {
                const finalChunk = {
                  id: lastChunkId || `chatcmpl-${Date.now()}`,
                  object: "chat.completion.chunk",
                  created: Math.floor(Date.now() / 1e3),
                  model: lastModel || "unknown",
                  choices: [
                    {
                      index: 0,
                      delta: {},
                      finish_reason: "stop"
                    }
                  ]
                };
                controller.enqueue(
                  encoder.encode(`data: ${JSON.stringify(finalChunk)}

`)
                );
              }
              controller.close();
              break;
            }
            let chunk = decoder.decode(value, { stream: true });
            chunk = chunk.replace(/^data:([^\s])/gm, "data: $1");
            try {
              const dataRegex = /^data: (.*)$/gm;
              let transformed = chunk;
              const matches = Array.from(chunk.matchAll(dataRegex));
              for (const m of matches) {
                const jsonStr = m[1];
                if (jsonStr === "[DONE]") {
                  continue;
                }
                try {
                  const obj = JSON.parse(jsonStr);
                  if (obj.id) {
                    lastChunkId = obj.id;
                  }
                  if (obj.model) {
                    lastModel = obj.model;
                  }
                  let objModified = false;
                  if (obj && Array.isArray(obj.choices)) {
                    for (const ch of obj.choices) {
                      if (ch?.message && (!ch.delta || Object.keys(ch.delta).length === 0)) {
                        ch.delta = ch.message;
                        delete ch.message;
                        objModified = true;
                      }
                    }
                  }
                  if (obj.choices && obj.choices.length > 0) {
                    for (let choiceIndex = obj.choices.length - 1; choiceIndex >= 0; choiceIndex--) {
                      const choice = obj.choices[choiceIndex];
                      if (choice?.finish_reason) {
                        if (typeof choice.index === "number") {
                          seenFinishReason.set(choice.index, true);
                        }
                        if (!choice.delta || Object.keys(choice.delta).length === 0) {
                          Logger.trace(
                            `preprocessSSEResponse has only finish_reason (choice ${choiceIndex}), adding empty content to delta`
                          );
                          choice.delta = { role: "assistant", content: "" };
                          objModified = true;
                        }
                        if (!choice.delta.role) {
                          choice.delta.role = "assistant";
                          objModified = true;
                        }
                      }
                      if (choice?.delta && Object.keys(choice.delta).length === 0) {
                        if (choice?.finish_reason) {
                          continue;
                        }
                        Logger.trace(
                          `preprocessSSEResponse removing invalid delta (choice ${choiceIndex})`
                        );
                        obj.choices.splice(choiceIndex, 1);
                        objModified = true;
                      }
                    }
                    if (obj.choices.length === 1) {
                      for (const choice of obj.choices) {
                        if (choice.index == null || choice.index !== 0) {
                          choice.index = 0;
                          objModified = true;
                        }
                      }
                    }
                    for (const choice of obj.choices) {
                      if (choice.delta?.tool_calls) {
                        for (const toolCall of choice.delta.tool_calls) {
                          if (!toolCall.type) {
                            toolCall.type = "function";
                            objModified = true;
                          }
                        }
                      }
                      if (choice.message?.tool_calls) {
                        for (const toolCall of choice.message.tool_calls) {
                          if (!toolCall.type) {
                            toolCall.type = "function";
                            objModified = true;
                          }
                        }
                      }
                    }
                  }
                  if (objModified) {
                    const newJson = JSON.stringify(obj);
                    transformed = transformed.replace(m[0], `data: ${newJson}`);
                  }
                } catch {
                }
              }
              chunk = transformed;
            } catch {
            }
            controller.enqueue(encoder.encode(chunk));
          }
        } catch (error2) {
          controller.error(error2);
        } finally {
          reader.releaseLock();
        }
      }
    });
    return new Response(transformedStream, {
      status: response.status,
      statusText: response.statusText,
      headers: response.headers
    });
  }
  /**
   * Handle chat completion request - using OpenAI SDK streaming interface
   */
  async handleRequest(model, modelConfig, messages, options, progress, token, accountId) {
    await RateLimiter.getInstance(this.provider, 2, 1e3).throttle(
      this.displayName
    );
    Logger.debug(
      `${model.name} starting to process ${this.displayName} request${accountId ? ` (Account ID: ${accountId})` : ""}`
    );
    this.currentRequestProcessedEvents.clear();
    const toolCallIds = /* @__PURE__ */ new Map();
    try {
      const client = await this.createOpenAIClient(modelConfig, accountId);
      Logger.debug(
        `${model.name} sending ${messages.length} messages, using ${this.displayName}`
      );
      const requestModel = modelConfig.model || model.id;
      const createParams = {
        model: requestModel,
        messages: this.convertMessagesToOpenAI(
          messages,
          model.capabilities || void 0,
          modelConfig
        ),
        max_tokens: ConfigManager.getMaxTokensForModel(model.maxOutputTokens),
        stream: true,
        stream_options: { include_usage: true },
        temperature: ConfigManager.getTemperature(),
        top_p: ConfigManager.getTopP()
      };
      if (options.tools && options.tools.length > 0 && model.capabilities?.toolCalling) {
        createParams.tools = this.convertToolsToOpenAI([...options.tools]);
        createParams.tool_choice = "auto";
        Logger.trace(`${model.name} added ${options.tools.length} tools`);
      }
      if (modelConfig.extraBody) {
        const filteredExtraBody = _OpenAIHandler.filterExtraBodyParams(
          modelConfig.extraBody
        );
        Object.assign(createParams, filteredExtraBody);
        if (Object.keys(filteredExtraBody).length > 0) {
          Logger.trace(
            `${model.name} merged extraBody parameters: ${JSON.stringify(filteredExtraBody)}`
          );
        }
      }
      Logger.info(`${model.name} sending ${this.displayName} request`);
      let hasReceivedContent = false;
      let hasThinkingContent = false;
      let currentThinkingId = null;
      let thinkingContentBuffer = "";
      const toolCallIds2 = /* @__PURE__ */ new Map();
      let lastActivityReportTime = Date.now();
      const ACTIVITY_REPORT_INTERVAL_MS = 300;
      const reportActivity = () => {
        const now = Date.now();
        if (now - lastActivityReportTime >= ACTIVITY_REPORT_INTERVAL_MS) {
          progress.report(new vscode16.LanguageModelTextPart(""));
          lastActivityReportTime = now;
          return true;
        }
        return false;
      };
      const markActivity = () => {
        lastActivityReportTime = Date.now();
      };
      let activityInterval = null;
      const startActivityInterval = () => {
        if (activityInterval) {
          return;
        }
        activityInterval = setInterval(() => {
          if (!token.isCancellationRequested) {
            reportActivity();
          }
        }, ACTIVITY_REPORT_INTERVAL_MS);
      };
      const _stopActivityInterval = () => {
        if (activityInterval) {
          clearInterval(activityInterval);
          activityInterval = null;
        }
      };
      startActivityInterval();
      const abortController = new AbortController();
      const cancellationListener = token.onCancellationRequested(
        () => abortController.abort()
      );
      let streamError = null;
      let finalUsage;
      try {
        const stream = client.chat.completions.stream(createParams, {
          signal: abortController.signal
        });
        stream.on("content", (delta, _snapshot) => {
          if (token.isCancellationRequested) {
            Logger.warn(`${model.name} user cancelled request`);
            throw new vscode16.CancellationError();
          }
          markActivity();
          try {
            Logger.trace(
              `${model.name} received content delta: ${delta ? delta.length : 0} characters, preview=${delta}`
            );
          } catch {
          }
          const deltaVisible = typeof delta === "string" && delta.replace(/[\s\uFEFF\xA0]+/g, "").length > 0;
          if (deltaVisible && currentThinkingId) {
            if (thinkingContentBuffer.length > 0) {
              try {
                progress.report(
                  new vscode16.LanguageModelThinkingPart(
                    thinkingContentBuffer,
                    currentThinkingId
                  )
                );
                thinkingContentBuffer = "";
                hasThinkingContent = true;
              } catch (e) {
                Logger.trace(
                  `${model.name} failed to report thinking: ${String(e)}`
                );
              }
            }
            progress.report(
              new vscode16.LanguageModelThinkingPart("", currentThinkingId)
            );
            currentThinkingId = null;
          }
          if (delta && delta.length > 0) {
            progress.report(new vscode16.LanguageModelTextPart(delta));
            if (delta.trim().length > 0) {
              hasReceivedContent = true;
            }
          }
        }).on("tool_calls.function.arguments.done", (event) => {
          if (token.isCancellationRequested) {
            return;
          }
          markActivity();
          const eventKey = `tool_call_${event.name}_${event.index}_${event.arguments.length}`;
          if (this.currentRequestProcessedEvents.has(eventKey)) {
            Logger.trace(
              `Skip duplicate tool call event: ${event.name} (index: ${event.index})`
            );
            return;
          }
          this.currentRequestProcessedEvents.add(eventKey);
          let parsedArgs = {};
          if (event.parsed_arguments) {
            const result = event.parsed_arguments;
            parsedArgs = typeof result === "object" && result !== null ? result : {};
          } else {
            try {
              parsedArgs = JSON.parse(event.arguments || "{}");
            } catch (firstError) {
              Logger.trace(
                `Tool call parameter first parsing failed: ${event.name} (index: ${event.index}), trying deduplication fix...`
              );
              let cleanedArgs = event.arguments || "{}";
              try {
                const maxCheckLength = Math.min(
                  50,
                  Math.floor(cleanedArgs.length / 2)
                );
                let duplicateFound = false;
                let cutPosition = 0;
                for (let len = maxCheckLength; len >= 5; len--) {
                  const prefix = cleanedArgs.substring(0, len);
                  const restContent = cleanedArgs.substring(len);
                  const duplicateIndex = restContent.indexOf(prefix);
                  if (duplicateIndex !== -1) {
                    cutPosition = len + duplicateIndex;
                    duplicateFound = true;
                    Logger.debug(
                      `Deduplication fix: detected first ${len} characters repeat at position ${cutPosition}, prefix="${prefix}"`
                    );
                    break;
                  }
                }
                if (duplicateFound && cutPosition > 0) {
                  const originalLength = cleanedArgs.length;
                  cleanedArgs = cleanedArgs.substring(cutPosition);
                  Logger.debug(
                    `Deduplication fix: remove duplicate prefix, truncate from ${originalLength} characters to ${cleanedArgs.length} characters`
                  );
                }
              } catch {
              }
              if (cleanedArgs.includes("}{")) {
                let depth = 0;
                let firstObjEnd = -1;
                for (let i = 0; i < cleanedArgs.length; i++) {
                  if (cleanedArgs[i] === "{") {
                    depth++;
                  } else if (cleanedArgs[i] === "}") {
                    depth--;
                    if (depth === 0) {
                      firstObjEnd = i;
                      break;
                    }
                  }
                }
                if (firstObjEnd !== -1 && firstObjEnd < cleanedArgs.length - 1) {
                  const originalLength = cleanedArgs.length;
                  cleanedArgs = cleanedArgs.substring(0, firstObjEnd + 1);
                  Logger.debug(
                    `Deduplication fix: remove duplicate object, truncate from ${originalLength} characters to ${cleanedArgs.length} characters`
                  );
                }
              }
              try {
                parsedArgs = JSON.parse(cleanedArgs);
                Logger.debug(
                  `Deduplication fix successful: ${event.name} (index: ${event.index}), parsed successfully after fix`
                );
              } catch (secondError) {
                Logger.error(
                  `Failed to parse tool call parameters: ${event.name} (index: ${event.index})`
                );
                Logger.error(
                  `Original parameter string (first 100 characters): ${event.arguments?.substring(0, 100)}`
                );
                Logger.error(`First parsing error: ${firstError}`);
                Logger.error(
                  `Still failed after deduplication fix: ${secondError}`
                );
                throw firstError;
              }
            }
          }
          const originalId = toolCallIds2.get(event.index);
          const toolCallId = originalId || `tool_call_${event.index}_${Date.now()}`;
          if (!originalId) {
            Logger.warn(
              `${model.name} used generated ID for tool call (original ID not found in chunks)`
            );
          }
          progress.report(
            new vscode16.LanguageModelToolCallPart(
              toolCallId,
              event.name,
              parsedArgs
            )
          );
          hasReceivedContent = true;
        }).on("tool_calls.function.arguments.delta", (_event) => {
          markActivity();
          reportActivity();
        }).on("chunk", (chunk, _snapshot) => {
          markActivity();
          if (chunk.usage) {
            finalUsage = chunk.usage;
            Logger.debug(`[${this.displayName}] Native usage from API: ${JSON.stringify(chunk.usage)}`);
          }
          if (chunk.choices && chunk.choices.length > 0) {
            for (let choiceIndex = 0; choiceIndex < chunk.choices.length; choiceIndex++) {
              const choice = chunk.choices[choiceIndex];
              const delta = choice.delta;
              const message = choice.message;
              if (delta?.tool_calls && delta.tool_calls.length > 0) {
                for (const toolCall of delta.tool_calls) {
                  if (toolCall.id && toolCall.index !== void 0) {
                    toolCallIds2.set(toolCall.index, toolCall.id);
                    Logger.trace(
                      `${model.name} captured tool call ID: ${toolCall.id} at index ${toolCall.index}`
                    );
                  }
                  if (toolCall.index !== void 0 && !toolCall.function?.arguments) {
                    if (thinkingContentBuffer.length > 0 && currentThinkingId) {
                      try {
                        progress.report(
                          new vscode16.LanguageModelThinkingPart(
                            thinkingContentBuffer,
                            currentThinkingId
                          )
                        );
                        progress.report(
                          new vscode16.LanguageModelThinkingPart(
                            "",
                            currentThinkingId
                          )
                        );
                        thinkingContentBuffer = "";
                        hasThinkingContent = true;
                      } catch (e) {
                        Logger.trace(
                          `${model.name} failed to report thinking: ${String(e)}`
                        );
                      }
                    }
                  }
                }
              }
              const reasoningContent = delta?.reasoning ?? delta?.reasoning_content ?? message?.reasoning ?? message?.reasoning_content;
              if (reasoningContent) {
                const shouldOutputThinking = modelConfig.outputThinking !== false;
                if (shouldOutputThinking) {
                  try {
                    if (!currentThinkingId) {
                      currentThinkingId = `thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
                    }
                    thinkingContentBuffer += reasoningContent;
                    progress.report(
                      new vscode16.LanguageModelThinkingPart(
                        thinkingContentBuffer,
                        currentThinkingId
                      )
                    );
                    thinkingContentBuffer = "";
                    hasThinkingContent = true;
                  } catch (e) {
                    Logger.trace(
                      `${model.name} failed to report thinking: ${String(e)}`
                    );
                  }
                }
              }
              const messageContent = message?.content;
              if (typeof messageContent === "string" && messageContent.replace(/[\s\uFEFF\xA0]+/g, "").length > 0) {
                if (currentThinkingId) {
                  try {
                    progress.report(
                      new vscode16.LanguageModelThinkingPart(
                        "",
                        currentThinkingId
                      )
                    );
                  } catch (e) {
                    Logger.trace(
                      `${model.name} failed to end thinking: ${String(e)}`
                    );
                  }
                  currentThinkingId = null;
                }
                try {
                  progress.report(
                    new vscode16.LanguageModelTextPart(messageContent)
                  );
                  hasReceivedContent = true;
                } catch (e) {
                  Logger.trace(
                    `${model.name} failed to report message content (choice ${choiceIndex}): ${String(e)}`
                  );
                }
              }
            }
          }
        }).on("error", (error2) => {
          streamError = error2;
          abortController.abort();
        });
        await stream.done();
        if (thinkingContentBuffer.length > 0 && currentThinkingId) {
          try {
            progress.report(
              new vscode16.LanguageModelThinkingPart(
                thinkingContentBuffer,
                currentThinkingId
              )
            );
            thinkingContentBuffer = "";
            hasThinkingContent = true;
          } catch (e) {
            Logger.trace(
              `${model.name} failed to report thinking at end: ${String(e)}`
            );
          }
        }
        if (streamError) {
          throw streamError;
        }
        if (finalUsage) {
          try {
            const usage = finalUsage;
            Logger.info(
              `${model.name} Token usage: ${usage.prompt_tokens}+${usage.completion_tokens}=${usage.total_tokens}`
            );
          } catch (e) {
            Logger.trace(
              `${model.name} failed to print finalUsage: ${String(e)}`
            );
          }
        }
        let promptTokens;
        let completionTokens;
        let totalTokens;
        let estimatedPromptTokens = false;
        if (finalUsage) {
          const usage = finalUsage;
          promptTokens = usage.prompt_tokens ?? 0;
          completionTokens = usage.completion_tokens ?? 0;
          totalTokens = usage.total_tokens;
        }
        if (promptTokens === void 0) {
          try {
            promptTokens = await TokenCounter.getInstance().countMessagesTokens(
              model,
              [...messages],
              { sdkMode: modelConfig.sdkMode },
              options
            );
            completionTokens = 0;
            totalTokens = promptTokens;
            estimatedPromptTokens = true;
          } catch (e) {
            Logger.trace(
              `${model.name} failed to estimate prompt tokens: ${String(e)}`
            );
          }
        }
        if (promptTokens !== void 0 && completionTokens !== void 0) {
          TokenTelemetryTracker.getInstance().recordSuccess({
            modelId: model.id,
            modelName: model.name,
            providerId: this.provider,
            promptTokens,
            completionTokens,
            totalTokens,
            maxInputTokens: model.maxInputTokens,
            maxOutputTokens: model.maxOutputTokens,
            estimatedPromptTokens
          });
        }
        if (accountId) {
          this.quotaCache.recordSuccess(accountId, this.provider).catch(() => {
          });
        }
        Logger.debug(
          `${model.name} ${this.displayName} SDK stream processing complete`
        );
      } catch (streamError2) {
        if (accountId && !(streamError2 instanceof vscode16.CancellationError)) {
          if (this.isQuotaError(streamError2)) {
            this.quotaCache.markQuotaExceeded(accountId, this.provider, {
              error: streamError2 instanceof Error ? streamError2.message : String(streamError2),
              affectedModel: model.id
            }).catch(() => {
            });
          } else {
            this.quotaCache.recordFailure(
              accountId,
              this.provider,
              streamError2 instanceof Error ? streamError2.message : String(streamError2)
            ).catch(() => {
            });
          }
        }
        if (streamError2 instanceof vscode16.CancellationError) {
          Logger.info(`${model.name} request cancelled by user`);
          throw streamError2;
        } else {
          Logger.error(
            `${model.name} SDK stream processing error: ${streamError2}`
          );
          throw streamError2;
        }
      } finally {
        cancellationListener.dispose();
      }
      if (hasThinkingContent && !hasReceivedContent) {
        progress.report(new vscode16.LanguageModelTextPart("<think/>"));
        Logger.warn(
          `${model.name} end of message stream has only thinking content and no text content, added <think/> placeholder as output`
        );
      }
      Logger.debug(`${model.name} ${this.displayName} request complete`);
    } catch (error2) {
      if (error2 instanceof Error) {
        if (error2.cause instanceof Error) {
          const errorMessage = error2.cause.message || "Unknown error";
          Logger.error(
            `${model.name} ${this.displayName} request failed: ${errorMessage}`
          );
          throw error2.cause;
        } else {
          const errorMessage = error2.message || "Unknown error";
          Logger.error(
            `${model.name} ${this.displayName} request failed: ${errorMessage}`
          );
          if (errorMessage.includes("502") || errorMessage.includes("Bad Gateway") || errorMessage.includes("500") || errorMessage.includes("Internal Server Error") || errorMessage.includes("503") || errorMessage.includes("Service Unavailable") || errorMessage.includes("504") || errorMessage.includes("Gateway Timeout")) {
            throw new vscode16.LanguageModelError(errorMessage);
          }
          throw error2;
        }
      }
      if (error2 instanceof vscode16.CancellationError) {
        throw error2;
      } else if (error2 instanceof vscode16.LanguageModelError) {
        Logger.debug(
          `LanguageModelError details: code=${error2.code}, cause=${error2.cause}`
        );
        if (error2.code === "blocked") {
          Logger.warn("Request blocked, may contain inappropriate content");
        } else if (error2.code === "noPermissions") {
          Logger.warn(
            "Insufficient permissions, please check API key and model access permissions"
          );
        } else if (error2.code === "notFound") {
          Logger.warn("Model not found or unavailable");
        } else if (error2.code === "quotaExceeded") {
          Logger.warn("Quota exceeded, please check API usage limits");
        } else if (error2.code === "unknown") {
          Logger.warn("Unknown language model error");
        }
        throw error2;
      } else {
        throw error2;
      }
    }
  }
  isQuotaError(error2) {
    if (!(error2 instanceof Error)) {
      return false;
    }
    const msg = error2.message;
    return msg.startsWith("Quota exceeded") || msg.startsWith("Rate limited") || msg.includes("HTTP 429") || msg.includes('"code": 429') || msg.includes('"code":429') || msg.includes("RESOURCE_EXHAUSTED") || msg.includes("429") && msg.includes("Resource has been exhausted");
  }
  /**
   * Message conversion referring to official implementation - using OpenAI SDK standard mode
   * Support text, images and tool calls
   * Public method, can be reused by other Providers
   */
  convertMessagesToOpenAI(messages, capabilities, modelConfig) {
    const result = [];
    for (const message of messages) {
      const convertedMessage = this.convertSingleMessage(
        message,
        capabilities,
        modelConfig
      );
      if (convertedMessage) {
        if (Array.isArray(convertedMessage)) {
          result.push(...convertedMessage);
        } else {
          result.push(convertedMessage);
        }
      }
    }
    this.balanceFunctionCallsAndResponses(result);
    return result;
  }
  /**
   * Balance function calls and responses in OpenAI message format to prevent API errors
   * This ensures that every tool_call has a corresponding tool message and vice versa
   */
  balanceFunctionCallsAndResponses(messages) {
    const toolCallsById = /* @__PURE__ */ new Map();
    const toolMessagesById = /* @__PURE__ */ new Map();
    for (let i = 0; i < messages.length; i++) {
      const msg = messages[i];
      if (msg.role === "assistant" && "tool_calls" in msg && msg.tool_calls) {
        for (const toolCall of msg.tool_calls) {
          if (toolCall.type === "function" && toolCall.id) {
            toolCallsById.set(toolCall.id, {
              index: i,
              name: toolCall.function.name
            });
          }
        }
      } else if (msg.role === "tool" && "tool_call_id" in msg) {
        toolMessagesById.set(msg.tool_call_id, i);
      }
    }
    for (const [id, info] of toolCallsById.entries()) {
      if (!toolMessagesById.has(id)) {
        const placeholderToolMessage = {
          role: "tool",
          content: "Tool execution failed or was cancelled",
          tool_call_id: id
        };
        messages.splice(info.index + 1, 0, placeholderToolMessage);
        Logger.debug(
          `OpenAIHandler: Added placeholder tool message for call id=${id} name=${info.name || ""}`
        );
      }
    }
    for (const [id, index] of toolMessagesById.entries()) {
      if (!toolCallsById.has(id)) {
        const msg = messages[index];
        const userMessage = {
          role: "user",
          content: `Tool result (orphaned): ${msg.content}`
        };
        messages[index] = userMessage;
        Logger.warn(
          `OpenAIHandler: Converted orphaned tool message for id=${id} to user message`
        );
      }
    }
  }
  /**
   * Convert single message - refer to OpenAI SDK official pattern
   */
  convertSingleMessage(message, capabilities, modelConfig) {
    switch (message.role) {
      case vscode16.LanguageModelChatMessageRole.System:
        return this.convertSystemMessage(message);
      case vscode16.LanguageModelChatMessageRole.User:
        return this.convertUserMessage(message, capabilities);
      case vscode16.LanguageModelChatMessageRole.Assistant:
        return this.convertAssistantMessage(message, modelConfig);
      default:
        Logger.warn(`Unknown message role: ${message.role}`);
        return null;
    }
  }
  /**
   * Convert system message - refer to official ChatCompletionSystemMessageParam
   */
  convertSystemMessage(message) {
    const textContent = this.extractTextContent(message.content);
    if (!textContent) {
      return null;
    }
    return {
      role: "system",
      content: textContent
    };
  }
  /**
   * Convert user message - support multimodal and tool results
   */
  convertUserMessage(message, capabilities) {
    const results = [];
    const userMessage = this.convertUserContentMessage(message, capabilities);
    if (userMessage) {
      results.push(userMessage);
    }
    const toolMessages = this.convertToolResultMessages(message);
    results.push(...toolMessages);
    return results;
  }
  /**
   * Convert user content message (text + image)
   */
  convertUserContentMessage(message, capabilities) {
    const textParts = message.content.filter(
      (part) => part instanceof vscode16.LanguageModelTextPart
    );
    const imageParts = [];
    if (capabilities?.imageInput === true) {
      Logger.debug(
        "Model supports image input, starting to collect image parts"
      );
      for (const part of message.content) {
        if (part instanceof vscode16.LanguageModelDataPart) {
          Logger.debug(
            `Found data part: MIME=${part.mimeType}, size=${part.data.length} bytes`
          );
          if (this.isImageMimeType(part.mimeType)) {
            imageParts.push(part);
            Logger.debug(
              `Add image: MIME=${part.mimeType}, size=${part.data.length} bytes`
            );
          } else {
            if (part.mimeType === "cache_control") {
              Logger.trace("Ignore Claude cache identifier: cache_control");
            } else if (part.mimeType.startsWith("image/")) {
              Logger.warn(`Unsupported image MIME type: ${part.mimeType}`);
            } else {
              Logger.trace(`Skip non-image data: ${part.mimeType}`);
            }
          }
        } else {
          Logger.trace(`Non-data part: ${part.constructor.name}`);
        }
      }
      const allDataParts = message.content.filter(
        (part) => part instanceof vscode16.LanguageModelDataPart
      );
      const nonCacheDataParts = allDataParts.filter((part) => {
        const dataPart = part;
        return dataPart.mimeType !== "cache_control";
      });
      if (nonCacheDataParts.length > 0 && imageParts.length === 0) {
        Logger.warn(
          `Found ${nonCacheDataParts.length} non-cache_control data parts but no valid images, please check image attachment format`
        );
      }
    }
    if (textParts.length === 0 && imageParts.length === 0) {
      return null;
    }
    if (imageParts.length > 0) {
      Logger.debug(
        `Build multimodal message: ${textParts.length} text parts + ${imageParts.length} image parts`
      );
      const contentArray = [];
      if (textParts.length > 0) {
        const textContent = textParts.map((part) => part.value).join("\n");
        contentArray.push({
          type: "text",
          text: textContent
        });
        Logger.trace(`Add text content: ${textContent.length} characters`);
      }
      for (const imagePart of imageParts) {
        const dataUrl = this.createDataUrl(imagePart);
        contentArray.push({
          type: "image_url",
          image_url: { url: dataUrl }
        });
        Logger.trace(
          `Add image URL: MIME=${imagePart.mimeType}, Base64 length=${dataUrl.length} characters`
        );
      }
      Logger.debug(
        `Multimodal message construction complete: ${contentArray.length} content parts`
      );
      return { role: "user", content: contentArray };
    } else {
      return {
        role: "user",
        content: textParts.map((part) => part.value).join("\n")
      };
    }
  }
  /**
   * Convert tool result messages - use OpenAI SDK standard types
   */
  convertToolResultMessages(message) {
    const toolMessages = [];
    for (const part of message.content) {
      if (part instanceof vscode16.LanguageModelToolResultPart) {
        const toolContent = this.convertToolResultContent(part.content);
        const toolMessage = {
          role: "tool",
          content: toolContent,
          tool_call_id: part.callId
        };
        toolMessages.push(toolMessage);
      }
    }
    return toolMessages;
  }
  /**
   * Convert assistant message - handle text and tool calls
   */
  convertAssistantMessage(message, modelConfig) {
    const textContent = this.extractTextContent(message.content);
    const toolCalls = [];
    let thinkingContent = null;
    for (const part of message.content) {
      if (part instanceof vscode16.LanguageModelToolCallPart) {
        toolCalls.push({
          id: part.callId,
          type: "function",
          function: {
            name: part.name,
            arguments: JSON.stringify(part.input)
          }
        });
      }
    }
    const includeThinking = modelConfig?.includeThinking === true;
    if (includeThinking) {
      Logger.trace(
        `Check if thinking content needs to be included: includeThinking=${includeThinking}`
      );
      for (const part of message.content) {
        if (part instanceof vscode16.LanguageModelThinkingPart) {
          if (Array.isArray(part.value)) {
            thinkingContent = part.value.join("");
          } else {
            thinkingContent = part.value;
          }
          Logger.trace(
            `Extracted thinking content: ${thinkingContent.length} characters`
          );
          break;
        }
      }
    }
    if (!textContent && !thinkingContent && toolCalls.length === 0) {
      return null;
    }
    const assistantMessage = {
      role: "assistant",
      content: textContent || null
      // Contains only regular text content, no thinking content
    };
    if (thinkingContent) {
      assistantMessage.reasoning_content = thinkingContent;
      Logger.trace(
        `Add reasoning_content: ${thinkingContent.length} characters`
      );
    }
    if (toolCalls.length > 0) {
      assistantMessage.tool_calls = toolCalls;
    }
    return assistantMessage;
  }
  /**
   * Extract text content
   */
  extractTextContent(content) {
    const textParts = content.filter((part) => part instanceof vscode16.LanguageModelTextPart).map((part) => part.value);
    return textParts.length > 0 ? textParts.join("\n") : null;
  }
  /**
   * Convert tool result content
   */
  convertToolResultContent(content) {
    if (typeof content === "string") {
      return content;
    }
    if (Array.isArray(content)) {
      return content.map((resultPart) => {
        if (resultPart instanceof vscode16.LanguageModelTextPart) {
          return resultPart.value;
        }
        return JSON.stringify(resultPart);
      }).join("\n");
    }
    return JSON.stringify(content);
  }
  /**
   * Tool conversion - ensure correct parameter format
   * Public method, can be reused by other Providers
   */
  convertToolsToOpenAI(tools) {
    return tools.map((tool) => {
      const functionDef = {
        type: "function",
        function: {
          name: tool.name,
          description: tool.description || ""
        }
      };
      if (tool.inputSchema) {
        if (typeof tool.inputSchema === "object" && tool.inputSchema !== null) {
          functionDef.function.parameters = tool.inputSchema;
        } else {
          functionDef.function.parameters = {
            type: "object",
            properties: {},
            required: []
          };
        }
      } else {
        functionDef.function.parameters = {
          type: "object",
          properties: {},
          required: []
        };
      }
      return functionDef;
    });
  }
  /**
   * Check if it is an image MIME type
   */
  isImageMimeType(mimeType) {
    const normalizedMime = mimeType.toLowerCase().trim();
    const supportedTypes = [
      "image/jpeg",
      "image/jpg",
      "image/png",
      "image/gif",
      "image/webp",
      "image/bmp",
      "image/svg+xml"
    ];
    const isImageCategory = normalizedMime.startsWith("image/");
    const isSupported = supportedTypes.includes(normalizedMime);
    if (isImageCategory && !isSupported) {
      Logger.warn(
        `Image type not in support list: ${mimeType}, supported types: ${supportedTypes.join(", ")}`
      );
    } else if (!isImageCategory && normalizedMime !== "cache_control") {
      Logger.trace(`Non-image data type: ${mimeType}`);
    }
    return isImageCategory && isSupported;
  }
  /**
   * Create image data URL
   */
  createDataUrl(dataPart) {
    try {
      const base64Data = Buffer.from(dataPart.data).toString("base64");
      const dataUrl = `data:${dataPart.mimeType};base64,${base64Data}`;
      Logger.debug(
        `Create image DataURL: MIME=${dataPart.mimeType}, original size=${dataPart.data.length} bytes, Base64 size=${base64Data.length} characters`
      );
      return dataUrl;
    } catch (error2) {
      Logger.error(`Failed to create image DataURL: ${error2}`);
      throw error2;
    }
  }
  /**
   * Filter out non-modifiable core parameters in extraBody
   * @param extraBody Original extraBody parameters
   * @returns Filtered parameters, removed core parameters that cannot be modified
   */
  static filterExtraBodyParams(extraBody) {
    const coreParams = /* @__PURE__ */ new Set([
      "model",
      // Model name
      "messages",
      // Message array
      "stream",
      // Streaming switch
      "stream_options",
      // Streaming options
      "tools"
      // Tool definition
    ]);
    const filtered = {};
    for (const [key, value] of Object.entries(extraBody)) {
      if (!coreParams.has(key)) {
        filtered[key] = value;
        if (value == null) {
          filtered[key] = void 0;
        }
      }
    }
    return filtered;
  }
};

// src/providers/anthropic/anthropicConverter.ts
var vscode17 = __toESM(require("vscode"));
init_logger();

// src/providers/anthropic/anthropicTypes.ts
var CustomDataPartMimeTypes = {
  CacheControl: "cache_control"
};

// src/providers/anthropic/anthropicConverter.ts
function isDefined(value) {
  return value !== void 0;
}
function contentBlockSupportsCacheControl(block) {
  return block.type !== "thinking" && block.type !== "redacted_thinking";
}
function apiContentToAnthropicContent(content, includeThinking = false) {
  const convertedContent = [];
  for (const part of content) {
    if (includeThinking && part instanceof vscode17.LanguageModelThinkingPart) {
      const metadata = part.metadata;
      const providerHint = part.metadata?._signatureProvider;
      const signatureToSend = providerHint === "anthropic" ? metadata?.signature : void 0;
      if (metadata?.data) {
        convertedContent.push({
          type: "redacted_thinking",
          data: metadata.data
        });
      } else {
        const thinkingText = metadata?._completeThinking || (Array.isArray(part.value) ? part.value.join("") : part.value);
        if (thinkingText) {
          const thinkingBlock = {
            type: "thinking",
            thinking: thinkingText
          };
          if (signatureToSend) {
            thinkingBlock.signature = signatureToSend;
          }
          convertedContent.push(thinkingBlock);
        }
      }
    } else if (part instanceof vscode17.LanguageModelToolCallPart) {
      convertedContent.push({
        type: "tool_use",
        id: part.callId,
        input: part.input,
        name: part.name
      });
    } else if ("data" in part && "mimeType" in part) {
      const dataPart = part;
      if (dataPart.mimeType === CustomDataPartMimeTypes.CacheControl) {
        const previousBlock = convertedContent.at(-1);
        if (previousBlock && contentBlockSupportsCacheControl(previousBlock)) {
          previousBlock.cache_control = {
            type: "ephemeral"
          };
        } else {
          convertedContent.push({
            type: "text",
            text: " ",
            cache_control: { type: "ephemeral" }
          });
        }
      } else if (dataPart.mimeType.startsWith("image/")) {
        convertedContent.push({
          type: "image",
          source: {
            type: "base64",
            data: Buffer.from(dataPart.data).toString("base64"),
            media_type: dataPart.mimeType
          }
        });
      }
    } else if (part instanceof vscode17.LanguageModelToolResultPart) {
      convertedContent.push({
        type: "tool_result",
        tool_use_id: part.callId,
        content: part.content.map((p) => {
          if (p instanceof vscode17.LanguageModelTextPart) {
            return { type: "text", text: p.value };
          }
          return void 0;
        }).filter(isDefined)
      });
    } else if (part instanceof vscode17.LanguageModelTextPart) {
      if (part.value === "") {
        continue;
      }
      convertedContent.push({
        type: "text",
        text: part.value
      });
    }
  }
  return convertedContent;
}
function apiMessageToAnthropicMessage(model, messages) {
  const unmergedMessages = [];
  const systemMessage = {
    type: "text",
    text: ""
  };
  for (const message of messages) {
    if (message.role === vscode17.LanguageModelChatMessageRole.Assistant) {
      unmergedMessages.push({
        role: "assistant",
        content: apiContentToAnthropicContent(
          message.content,
          model.includeThinking
        )
      });
    } else if (message.role === vscode17.LanguageModelChatMessageRole.User) {
      unmergedMessages.push({
        role: "user",
        content: apiContentToAnthropicContent(message.content)
      });
    } else if (message.role === vscode17.LanguageModelChatMessageRole.System) {
      systemMessage.text += message.content.map((p) => {
        if (p instanceof vscode17.LanguageModelTextPart) {
          return p.value;
        } else if ("data" in p && "mimeType" in p && p.mimeType === CustomDataPartMimeTypes.CacheControl && p.data.toString() === "ephemeral") {
          systemMessage.cache_control = {
            type: "ephemeral"
          };
        }
        return "";
      }).join("");
    }
  }
  const mergedMessages = [];
  for (const message of unmergedMessages) {
    if (mergedMessages.length === 0 || mergedMessages[mergedMessages.length - 1].role !== message.role) {
      mergedMessages.push(message);
    } else {
      const prevMessage = mergedMessages[mergedMessages.length - 1];
      if (Array.isArray(prevMessage.content) && Array.isArray(message.content)) {
        prevMessage.content.push(
          ...message.content
        );
      }
    }
  }
  if (model.includeThinking) {
    for (const message of mergedMessages) {
      if (message.role === "assistant" && Array.isArray(message.content)) {
        const content = message.content;
        const thinkingBlocks = content.filter(
          (block) => block.type === "thinking" || block.type === "redacted_thinking"
        );
        const nonThinkingBlocks = content.filter(
          (block) => block.type !== "thinking" && block.type !== "redacted_thinking"
        );
        if (thinkingBlocks.length === 0) {
          content.unshift({
            type: "thinking",
            thinking: "..."
          });
          Logger.trace(
            "Assistant message missing thinking block, added default one"
          );
        } else if (content[0]?.type !== "thinking" && content[0]?.type !== "redacted_thinking") {
          message.content = [...thinkingBlocks, ...nonThinkingBlocks];
          Logger.trace(
            "Assistant message reordered to start with thinking block"
          );
        }
      }
    }
  }
  return { messages: mergedMessages, system: systemMessage };
}
function convertToAnthropicTools(tools) {
  return tools.map((tool) => {
    const inputSchema = tool.inputSchema;
    if (!inputSchema) {
      return {
        name: tool.name,
        description: tool.description || "",
        input_schema: {
          type: "object",
          properties: {},
          required: []
        }
      };
    }
    return {
      name: tool.name,
      description: tool.description || "",
      input_schema: {
        type: "object",
        properties: inputSchema.properties ?? {},
        required: inputSchema.required ?? [],
        ...inputSchema.additionalProperties !== void 0 && {
          additionalProperties: inputSchema.additionalProperties
        }
      }
    };
  });
}

// src/providers/anthropic/anthropicHandler.ts
var AnthropicHandler = class {
  constructor(provider, displayName, baseURL) {
    this.provider = provider;
    this.displayName = displayName;
    this.baseURL = baseURL;
  }
  /**
   * Create Anthropic client
   * Create a new client instance every time, consistent with OpenAIHandler
   */
  async createAnthropicClient(modelConfig) {
    const providerKey = modelConfig?.provider || this.provider;
    const currentApiKey = await ApiKeyManager.getApiKey(providerKey);
    if (!currentApiKey) {
      throw new Error(`Missing ${this.displayName} API key`);
    }
    let baseUrl = modelConfig?.baseUrl || this.baseURL;
    if (providerKey === "minimax-coding") {
      const endpoint = ConfigManager.getMinimaxEndpoint();
      if (baseUrl && endpoint === "minimax.io") {
        baseUrl = baseUrl.replace("api.minimaxi.com", "api.minimax.io");
      }
    }
    if (providerKey === "zhipu") {
      const endpoint = ConfigManager.getZhipuEndpoint();
      if (baseUrl && endpoint === "api.z.ai") {
        baseUrl = baseUrl.replace("open.bigmodel.cn", "api.z.ai");
      }
    }
    const defaultHeaders = {
      "User-Agent": VersionManager.getUserAgent(this.provider)
    };
    const processedCustomHeader = ApiKeyManager.processCustomHeader(
      modelConfig?.customHeader,
      currentApiKey
    );
    if (Object.keys(processedCustomHeader).length > 0) {
      Object.assign(defaultHeaders, processedCustomHeader);
      Logger.debug(
        `${this.displayName} apply custom headers: ${JSON.stringify(modelConfig?.customHeader)}`
      );
    }
    const client = new Anthropic({
      apiKey: currentApiKey,
      baseURL: baseUrl,
      authToken: currentApiKey,
      // Fix Minimax error: Please carry the API secret key in the 'Authorization' field of the request header
      defaultHeaders
    });
    Logger.info(`${this.displayName} Anthropic compatible client created`);
    return client;
  }
  /**
   * Process Anthropic SDK request
   */
  async handleRequest(model, modelConfig, messages, options, progress, token) {
    try {
      const client = await this.createAnthropicClient(modelConfig);
      const { messages: anthropicMessages, system } = apiMessageToAnthropicMessage(modelConfig, messages);
      const tools = options.tools ? convertToAnthropicTools([...options.tools]) : [];
      const modelId = modelConfig.model || model.id;
      const createParams = {
        model: modelId,
        max_tokens: ConfigManager.getMaxTokensForModel(model.maxOutputTokens),
        messages: anthropicMessages,
        stream: true,
        temperature: ConfigManager.getTemperature(),
        top_p: ConfigManager.getTopP()
      };
      if (modelConfig.extraBody) {
        const filteredExtraBody = OpenAIHandler.filterExtraBodyParams(
          modelConfig.extraBody
        );
        Object.assign(createParams, filteredExtraBody);
        if (Object.keys(filteredExtraBody).length > 0) {
          Logger.trace(
            `${model.name} merged extraBody parameters: ${JSON.stringify(filteredExtraBody)}`
          );
        }
      }
      if (system.text) {
        createParams.system = [system];
      }
      if (tools.length > 0) {
        createParams.tools = tools;
      }
      Logger.debug(
        `[${model.name}] Send Anthropic API request, containing ${anthropicMessages.length} messages, using model: ${modelId}`
      );
      const stream = await client.messages.create(createParams);
      const result = await this.handleAnthropicStream(
        stream,
        progress,
        token,
        modelConfig
      );
      Logger.info(`[${model.name}] Anthropic request completed`, result.usage);
    } catch (error2) {
      Logger.error(`[${model.name}] Anthropic SDK error:`, error2);
      let errorMessage = `[${model.name}] Anthropic API call failed`;
      if (error2 instanceof Error) {
        if (error2.message.includes("401")) {
          errorMessage += ": Invalid API key, please check configuration";
        } else if (error2.message.includes("429")) {
          errorMessage += ": Request rate limit, please try again later";
        } else if (error2.message.includes("500")) {
          errorMessage += ": Server error, please try again later";
        } else {
          errorMessage += `: ${error2.message}`;
        }
      }
      progress.report(new vscode18.LanguageModelTextPart(errorMessage));
      throw error2;
    }
  }
  /**
   * Handle Anthropic streaming response
   * Refer to official documentation: https://docs.anthropic.com/en/api/messages-streaming
   * Refer to official implementation: https://github.com/microsoft/vscode-copilot-chat/blob/main/src/extension/byok/vscode-node/anthropicProvider.ts
   */
  async handleAnthropicStream(stream, progress, token, modelConfig) {
    let pendingToolCall;
    let pendingThinking;
    let pendingRedactedThinking;
    let usage;
    const MAX_THINKING_BUFFER_LENGTH = 20;
    let currentThinkingId = null;
    let hasOutputContent = false;
    let hasThinkingContent = false;
    let pendingTextBuffer = "";
    let lastTextFlushTime = 0;
    const TEXT_BUFFER_WORD_THRESHOLD = 20;
    const TEXT_BUFFER_CHAR_THRESHOLD = 160;
    const TEXT_BUFFER_MAX_DELAY_MS = 200;
    const countWords = (text) => {
      const matches = text.trim().match(/\S+/g);
      return matches ? matches.length : 0;
    };
    const flushTextBuffer = (force) => {
      if (!pendingTextBuffer) {
        return;
      }
      const wordCount = countWords(pendingTextBuffer);
      const now = Date.now();
      const timeSinceFlush = now - lastTextFlushTime;
      if (force || wordCount >= TEXT_BUFFER_WORD_THRESHOLD || pendingTextBuffer.length >= TEXT_BUFFER_CHAR_THRESHOLD || timeSinceFlush >= TEXT_BUFFER_MAX_DELAY_MS) {
        progress.report(new vscode18.LanguageModelTextPart(pendingTextBuffer));
        pendingTextBuffer = "";
        lastTextFlushTime = now;
      }
    };
    Logger.debug("Start processing Anthropic streaming response");
    try {
      for await (const chunk of stream) {
        if (token.isCancellationRequested) {
          Logger.debug("Stream processing cancelled");
          flushTextBuffer(true);
          this.reportRemainingThinkingContent(
            progress,
            pendingThinking,
            currentThinkingId,
            "stream cancellation"
          );
          break;
        }
        switch (chunk.type) {
          case "message_start":
            usage = {
              inputTokens: (chunk.message.usage.input_tokens ?? 0) + (chunk.message.usage.cache_creation_input_tokens ?? 0) + (chunk.message.usage.cache_read_input_tokens ?? 0),
              outputTokens: 1,
              totalTokens: -1
            };
            Logger.trace(
              `Message stream start - initial input tokens: ${usage.inputTokens}`
            );
            break;
          case "content_block_start":
            if (chunk.content_block.type === "tool_use") {
              this.reportRemainingThinkingContent(
                progress,
                pendingThinking,
                currentThinkingId,
                "tool call start"
              );
              if (pendingThinking) {
                pendingThinking.thinking = "";
              }
              currentThinkingId = null;
              pendingToolCall = {
                toolId: chunk.content_block.id,
                name: chunk.content_block.name,
                jsonInput: ""
              };
              Logger.trace(`Tool call start: ${chunk.content_block.name}`);
            } else if (chunk.content_block.type === "thinking") {
              pendingThinking = {
                thinking: "",
                signature: ""
              };
              currentThinkingId = `thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
              hasThinkingContent = true;
              Logger.trace("Thinking block start (streaming output)");
            } else if (chunk.content_block.type === "text") {
              this.reportRemainingThinkingContent(
                progress,
                pendingThinking,
                currentThinkingId,
                "text block start"
              );
              if (pendingThinking) {
                pendingThinking.thinking = "";
              }
              currentThinkingId = null;
              Logger.trace("Text block start");
            } else if (chunk.content_block.type === "redacted_thinking") {
              const redactedBlock = chunk.content_block;
              pendingRedactedThinking = {
                data: redactedBlock.data
              };
              Logger.trace("Encrypted thinking block start");
            }
            break;
          case "content_block_delta":
            if (chunk.delta.type === "text_delta") {
              pendingTextBuffer += chunk.delta.text;
              flushTextBuffer(false);
              hasOutputContent = true;
            } else if (chunk.delta.type === "input_json_delta" && pendingToolCall) {
              pendingToolCall.jsonInput = (pendingToolCall.jsonInput || "") + chunk.delta.partial_json;
              try {
                const parsedJson = JSON.parse(pendingToolCall.jsonInput);
                progress.report(
                  new vscode18.LanguageModelToolCallPart(
                    pendingToolCall.toolId ?? "",
                    pendingToolCall.name ?? "",
                    parsedJson
                  )
                );
                pendingToolCall = void 0;
              } catch {
              }
              hasOutputContent = true;
            } else if (chunk.delta.type === "thinking_delta") {
              const thinkingDelta = chunk.delta.thinking || "";
              if (pendingThinking) {
                pendingThinking.thinking = (pendingThinking.thinking || "") + thinkingDelta;
                const shouldOutputThinking = modelConfig?.outputThinking !== false;
                if (shouldOutputThinking) {
                  const currentThinkingContent = pendingThinking.thinking || "";
                  if (currentThinkingContent.length >= MAX_THINKING_BUFFER_LENGTH) {
                    if (!currentThinkingId) {
                      currentThinkingId = `thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
                    }
                    try {
                      progress.report(
                        new vscode18.LanguageModelThinkingPart(
                          currentThinkingContent,
                          currentThinkingId
                        )
                      );
                      pendingThinking.thinking = "";
                    } catch (e) {
                      Logger.trace(
                        `Failed to report thinking content: ${String(e)}`
                      );
                    }
                  }
                } else {
                  Logger.trace(
                    "\u23ED\uFE0F Skip thinking content output: configured not to output thinking"
                  );
                }
              }
            } else if (chunk.delta.type === "signature_delta") {
              if (pendingThinking) {
                pendingThinking.signature = (pendingThinking.signature || "") + (chunk.delta.signature || "");
              }
            }
            break;
          case "content_block_stop":
            if (pendingToolCall) {
              try {
                const parsedJson = JSON.parse(
                  pendingToolCall.jsonInput || "{}"
                );
                progress.report(
                  new vscode18.LanguageModelToolCallPart(
                    pendingToolCall.toolId ?? "",
                    pendingToolCall.name ?? "",
                    parsedJson
                  )
                );
                Logger.debug(`Tool call complete: ${pendingToolCall.name}`);
              } catch (e) {
                Logger.error(
                  `Failed to parse tool call JSON (${pendingToolCall.name}):`,
                  e
                );
              }
              pendingToolCall = void 0;
            } else if (pendingThinking) {
              let hasReportedContent = false;
              const finalThinkingContent = pendingThinking.thinking || "";
              if (finalThinkingContent.length > 0 && currentThinkingId) {
                const finalThinkingPart = new vscode18.LanguageModelThinkingPart(
                  finalThinkingContent,
                  currentThinkingId
                );
                if (pendingThinking.signature) {
                  finalThinkingPart.metadata = {
                    signature: pendingThinking.signature,
                    _completeThinking: finalThinkingContent
                  };
                }
                progress.report(finalThinkingPart);
                progress.report(
                  new vscode18.LanguageModelThinkingPart("", currentThinkingId)
                );
                hasReportedContent = true;
              }
              if (!hasReportedContent && pendingThinking.signature) {
                const signaturePart = new vscode18.LanguageModelThinkingPart("");
                signaturePart.metadata = {
                  signature: pendingThinking.signature,
                  _completeThinking: finalThinkingContent
                };
                progress.report(signaturePart);
              }
              pendingThinking = void 0;
              Logger.debug("Thinking block complete");
            } else if (pendingRedactedThinking) {
              pendingRedactedThinking = void 0;
              Logger.debug("Encrypted thinking block complete");
            }
            break;
          case "message_delta":
            if (usage && chunk.usage) {
              if (chunk.usage.input_tokens !== void 0 && chunk.usage.input_tokens !== null) {
                usage.inputTokens = chunk.usage.input_tokens + (chunk.usage.cache_creation_input_tokens ?? 0) + (chunk.usage.cache_read_input_tokens ?? 0);
              }
              if (chunk.usage.output_tokens !== void 0 && chunk.usage.output_tokens !== null) {
                usage.outputTokens = chunk.usage.output_tokens;
              }
              usage.totalTokens = usage.inputTokens + usage.outputTokens;
              Logger.trace(
                `Token usage update - Input: ${usage.inputTokens}, Output: ${usage.outputTokens}, Total: ${usage.totalTokens}`
              );
            }
            if (chunk.delta.stop_reason) {
              Logger.trace(`Message stop reason: ${chunk.delta.stop_reason}`);
            }
            break;
          case "message_stop":
            flushTextBuffer(true);
            this.reportRemainingThinkingContent(
              progress,
              pendingThinking,
              currentThinkingId,
              "message stream end"
            );
            if (pendingThinking) {
              pendingThinking.thinking = "";
            }
            currentThinkingId = null;
            if (hasThinkingContent && !hasOutputContent) {
              progress.report(new vscode18.LanguageModelTextPart("<think/>"));
              Logger.warn(
                "Only thinking content and no text content at end of message stream, added <think/> placeholder as output"
              );
            }
            Logger.trace("Message stream complete");
            break;
          default:
            Logger.trace("Received other event types");
            break;
        }
      }
    } catch (error2) {
      Logger.error("Error processing Anthropic stream:", error2);
      throw error2;
    } finally {
      flushTextBuffer(true);
      this.reportRemainingThinkingContent(
        progress,
        pendingThinking,
        currentThinkingId,
        "stream processing end"
      );
    }
    if (usage) {
      Logger.debug(
        `Stream processing complete - final usage statistics: Input=${usage.inputTokens}, Output=${usage.outputTokens}, Total=${usage.totalTokens}`
      );
    } else {
      Logger.warn(
        "Stream processing complete but usage statistics not obtained"
      );
    }
    return { usage };
  }
  /**
   * Unified handling of reporting remaining thinking content
   */
  reportRemainingThinkingContent(progress, pendingThinking, currentThinkingId, context) {
    const thinkingContent = pendingThinking?.thinking || "";
    if (thinkingContent.length > 0 && currentThinkingId) {
      try {
        progress.report(
          new vscode18.LanguageModelThinkingPart(
            thinkingContent,
            currentThinkingId
          )
        );
        Logger.trace(
          `reporting remaining thinking content at ${context}: ${thinkingContent.length} characters`
        );
        progress.report(
          new vscode18.LanguageModelThinkingPart("", currentThinkingId)
        );
      } catch (e) {
        Logger.trace(
          `failed to report thinking content at ${context}: ${String(e)}`
        );
      }
    }
  }
};

// src/utils/index.ts
init_auth();

// src/providers/antigravity/handler.ts
var import_node_crypto = __toESM(require("node:crypto"));
var vscode22 = __toESM(require("vscode"));
init_accountQuotaCache();
init_configManager();
init_logger();

// src/utils/quotaNotificationManager.ts
var vscode19 = __toESM(require("vscode"));
init_accountManagerPage();
var QUOTA_NOTICE_DEDUP_MS = 3e4;
var QUOTA_COUNTDOWN_LONG_UPDATE_MS = 6e4;
var QUOTA_COUNTDOWN_SHORT_UPDATE_MS = 1e3;
var QuotaNotificationManager = class {
  quotaCountdownTimer;
  quotaCountdownEndAt = 0;
  quotaCountdownMessage;
  quotaCountdownModel;
  quotaCountdownAccountId;
  quotaCountdownAccountName;
  lastQuotaNoticeAt = 0;
  /**
   * Notify user about quota exceeded with countdown
   */
  notifyQuotaExceeded(delayMs, modelName, accountId, accountName) {
    if (delayMs <= 0) {
      return;
    }
    this.startQuotaCountdown(delayMs, modelName, accountId, accountName);
    this.updateAccountManagerQuota(delayMs, modelName, accountId, accountName);
    const now = Date.now();
    if (now - this.lastQuotaNoticeAt < QUOTA_NOTICE_DEDUP_MS) {
      return;
    }
    this.lastQuotaNoticeAt = now;
    const modelLabel = modelName ? ` (${modelName})` : "";
    const accountLabel = accountName ? ` [${accountName}]` : "";
    const _message = `Copilot ++ Antigravity quota limit reached${modelLabel}${accountLabel}. Retry in ${this.formatCountdown(delayMs)}.`;
  }
  /**
   * Show a popup when quota wait is too long.
   */
  async notifyQuotaTooLong(delayMs, modelName, _accountId, accountName) {
    if (delayMs <= 0) {
      return;
    }
    const modelLabel = modelName ? ` (${modelName})` : "";
    const accountLabel = accountName ? ` [${accountName}]` : "";
    const message = `Antigravity quota exceeded${modelLabel}${accountLabel}. Retry in ${this.formatCountdown(delayMs)}.`;
    const selection = await vscode19.window.showWarningMessage(
      message,
      "Add Account",
      "Open Account Manager",
      "Dismiss"
    );
    if (selection === "Add Account") {
      await vscode19.commands.executeCommand("chp.antigravity.login");
    } else if (selection === "Open Account Manager") {
      await vscode19.commands.executeCommand("chp.accounts.openManager");
    }
  }
  /**
   * Start quota countdown timer
   */
  startQuotaCountdown(delayMs, modelName, accountId, accountName) {
    this.quotaCountdownEndAt = Date.now() + delayMs;
    this.quotaCountdownModel = modelName;
    this.quotaCountdownAccountId = accountId;
    this.quotaCountdownAccountName = accountName;
    if (this.quotaCountdownTimer) {
      clearTimeout(this.quotaCountdownTimer);
      this.quotaCountdownTimer = void 0;
    }
    this.updateQuotaCountdown();
  }
  /**
   * Update quota countdown display
   */
  updateQuotaCountdown() {
    if (!this.quotaCountdownEndAt) {
      return;
    }
    const remaining = this.quotaCountdownEndAt - Date.now();
    if (remaining <= 0) {
      this.clearQuotaCountdown();
      return;
    }
    const modelLabel = this.quotaCountdownModel ? ` (${this.quotaCountdownModel})` : "";
    const accountLabel = this.quotaCountdownAccountName ? ` [${this.quotaCountdownAccountName}]` : "";
    const _message = `Copilot ++ Antigravity limited${modelLabel}${accountLabel}: ${this.formatCountdown(remaining)}`;
    const nextDelay = this.getCountdownUpdateInterval(remaining);
    this.quotaCountdownTimer = setTimeout(
      () => this.updateQuotaCountdown(),
      nextDelay
    );
  }
  /**
   * Clear quota countdown timer and status bar message
   */
  clearQuotaCountdown() {
    if (this.quotaCountdownTimer) {
      clearTimeout(this.quotaCountdownTimer);
      this.quotaCountdownTimer = void 0;
    }
    if (this.quotaCountdownMessage) {
      this.quotaCountdownMessage.dispose();
      this.quotaCountdownMessage = void 0;
    }
    this.quotaCountdownEndAt = 0;
    this.quotaCountdownModel = void 0;
    this.quotaCountdownAccountId = void 0;
    this.quotaCountdownAccountName = void 0;
    this.updateAccountManagerQuota(0, "");
  }
  /**
   * Update account manager with quota information
   */
  updateAccountManagerQuota(delayMs, modelName, accountId, accountName) {
    try {
      if (delayMs <= 0) {
        AccountManagerPage.updateAntigravityQuotaNotice(null);
        return;
      }
      AccountManagerPage.updateAntigravityQuotaNotice({
        resetAt: Date.now() + delayMs,
        modelName: modelName || void 0,
        accountId: accountId || this.quotaCountdownAccountId,
        accountName: accountName || this.quotaCountdownAccountName
      });
    } catch (_error) {
    }
  }
  /**
   * Format countdown in milliseconds to human-readable string
   */
  formatCountdown(ms) {
    const totalSeconds = Math.max(0, Math.floor(ms / 1e3));
    const seconds = totalSeconds % 60;
    const minutes = Math.floor(totalSeconds / 60) % 60;
    const hours = Math.floor(totalSeconds / 3600);
    if (hours > 0) {
      return `${hours}h${minutes}m${seconds}s`;
    }
    if (minutes > 0) {
      return `${minutes}m${seconds}s`;
    }
    return `${seconds}s`;
  }
  /**
   * Get countdown update interval based on remaining time
   */
  getCountdownUpdateInterval(remainingMs) {
    if (remainingMs >= 60 * 60 * 1e3) {
      return QUOTA_COUNTDOWN_LONG_UPDATE_MS;
    }
    return QUOTA_COUNTDOWN_SHORT_UPDATE_MS;
  }
  /**
   * Format duration in milliseconds to human-readable string
   */
  formatDuration(ms) {
    const seconds = Math.floor(ms / 1e3);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    if (hours > 0) {
      const remainingMinutes = minutes % 60;
      return `${hours}h${remainingMinutes}m`;
    } else if (minutes > 0) {
      const remainingSeconds = seconds % 60;
      return `${minutes}m${remainingSeconds}s`;
    } else {
      return `${seconds}s`;
    }
  }
  /**
   * Dispose all resources
   */
  dispose() {
    this.clearQuotaCountdown();
  }
};

// src/providers/openai/openaiStreamProcessor.ts
var vscode20 = __toESM(require("vscode"));
var OpenAIStreamProcessor = class _OpenAIStreamProcessor {
  textBuffer = "";
  lastTextFlushTime = 0;
  thinkingBuffer = "";
  currentThinkingId = null;
  toolCallsInProgress = /* @__PURE__ */ new Map();
  seenToolCalls = /* @__PURE__ */ new Set();
  toolCallCounter = 0;
  // Claude <thinking></thinking> tag detection state
  isInsideThinkingTag = false;
  thinkingTagBuffer = "";
  // Buffer batching thresholds for chunked rendering
  static TEXT_BUFFER_WORD_THRESHOLD = 20;
  static TEXT_BUFFER_CHAR_THRESHOLD = 160;
  static TEXT_BUFFER_MAX_DELAY_MS = 200;
  CLOSING_TAG = "</thinking>";
  CLOSING_TAG_LEN = this.CLOSING_TAG.length;
  // Activity indicator
  lastActivityReportTime = 0;
  static ACTIVITY_REPORT_INTERVAL_MS = 200;
  // Fast heartbeat to keep "Working..." visible
  // Tool call progress indicator
  toolCallProgressReported = /* @__PURE__ */ new Set();
  lastToolCallProgressTime = 0;
  static TOOL_CALL_PROGRESS_INTERVAL_MS = 300;
  // Report tool call progress frequently
  // Stop reading the stream after reporting a Gemini tool call to avoid deadlocks
  shouldStopAfterToolCall = false;
  /**
   * Process the SSE stream from a successful OpenAI format response
   */
  async processStream(options) {
    const { response, modelConfig, progress, token } = options;
    if (!response.body) {
      throw new Error("OpenAI response body is empty.");
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    let _chunkCount = 0;
    const activityInterval = setInterval(() => {
      if (!token.isCancellationRequested) {
        progress.report(new vscode20.LanguageModelTextPart(""));
      }
    }, _OpenAIStreamProcessor.ACTIVITY_REPORT_INTERVAL_MS);
    try {
      while (true) {
        if (token.isCancellationRequested) {
          throw new vscode20.CancellationError();
        }
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        _chunkCount++;
        const chunk = decoder.decode(value, { stream: true });
        buffer += chunk;
        buffer = buffer.replace(/\r\n/g, "\n");
        buffer = this.processSSELines(buffer, modelConfig, progress);
        if (this.shouldStopAfterToolCall) {
          await reader.cancel();
          break;
        }
        await new Promise((resolve) => setImmediate(resolve));
      }
    } finally {
      clearInterval(activityInterval);
      this.processRemainingBuffer(buffer, modelConfig, progress);
      this.flushPendingThinkingTagBuffer();
      this.flushTextBuffer(progress);
      this.finalizeThinkingPart(progress);
      this.finalizeToolCalls(progress);
    }
  }
  /**
   * Process SSE lines from buffer
   */
  processSSELines(buffer, modelConfig, progress) {
    let lineEndIndex = buffer.indexOf("\n");
    while (lineEndIndex !== -1) {
      const rawLine = buffer.slice(0, lineEndIndex);
      buffer = buffer.slice(lineEndIndex + 1);
      const line = rawLine.trimEnd();
      if (line.length === 0) {
        lineEndIndex = buffer.indexOf("\n");
        continue;
      }
      if (line.startsWith("data:")) {
        const dataLine = line.slice(5).trim();
        if (dataLine === "[DONE]") {
          lineEndIndex = buffer.indexOf("\n");
          continue;
        }
        if (dataLine.length > 0) {
          this.processOpenAIChunk(dataLine, modelConfig, progress);
        }
      }
      lineEndIndex = buffer.indexOf("\n");
    }
    return buffer;
  }
  /**
   * Process a single chunk - auto-detects OpenAI or Gemini format
   */
  processOpenAIChunk(data, modelConfig, progress) {
    try {
      const parsed = JSON.parse(data);
      if (Array.isArray(parsed.choices) && parsed.choices.length > 0) {
        this.processOpenAIFormat(
          parsed,
          modelConfig,
          progress
        );
      } else if (parsed.response || parsed.candidates) {
        this.processGeminiFormat(
          parsed,
          modelConfig,
          progress
        );
      }
      this.flushTextBufferIfNeeded(progress);
      this.flushThinkingBuffer(progress);
    } catch (_error) {
    }
  }
  /**
   * Process OpenAI format chunk
   */
  processOpenAIFormat(chunk, modelConfig, progress) {
    for (const choice of chunk.choices || []) {
      const delta = choice.delta;
      if (delta.content !== void 0 && delta.content !== null) {
        this.handleTextContent(delta.content, modelConfig, progress);
      }
      if (delta.tool_calls && delta.tool_calls.length > 0) {
        for (const toolCallDelta of delta.tool_calls) {
          this.handleToolCallDelta(toolCallDelta, progress);
        }
      }
      if (choice.finish_reason === "tool_calls") {
        if (this.thinkingTagBuffer.length > 0) {
          this.textBuffer += this.thinkingTagBuffer;
          this.thinkingTagBuffer = "";
        }
        this.flushTextBuffer(progress);
        this.flushThinkingBuffer(progress);
        this.finalizeToolCalls(progress);
      }
    }
  }
  /**
   * Process Gemini/Antigravity format chunk (like gcli2api's convert_antigravity_stream_to_openai)
   */
  processGeminiFormat(data, modelConfig, progress) {
    const response = data.response || data;
    const candidates = response.candidates || [];
    for (const candidate of candidates) {
      const parts = candidate.content?.parts || [];
      const _partTypes = parts.map((p) => {
        if (p.thought) {
          return "thought";
        }
        if (p.text !== void 0) {
          return "text";
        }
        if (p.functionCall) {
          return "functionCall";
        }
        if (p.inlineData) {
          return "inlineData";
        }
        return "unknown";
      });
      for (const part of parts) {
        if (part.thought === true) {
          if (modelConfig.outputThinking !== false && part.text) {
            if (!this.currentThinkingId) {
              this.currentThinkingId = this.generateThinkingId();
            }
            this.thinkingBuffer += part.text;
            this.flushThinkingBuffer(progress);
          }
          continue;
        }
        if (part.text !== void 0) {
          this.processTextWithThinkingTags(part.text, modelConfig, progress);
          this.flushTextBuffer(progress);
          this.flushThinkingBuffer(progress);
        }
        if (part.functionCall) {
          this.flushThinkingTagBufferForToolCall();
          this.flushTextBuffer(progress);
          this.flushThinkingBuffer(progress);
          this.handleGeminiFunctionCall(part.functionCall, progress);
        }
        if (part.inlineData) {
          const mimeType = part.inlineData.mimeType || "image/png";
          const base64Data = part.inlineData.data || "";
          const imageMarkdown = `

![Generated Image](data:${mimeType};base64,${base64Data})

`;
          this.textBuffer += imageMarkdown;
          this.flushTextBuffer(progress);
        }
      }
      if (candidate.finishReason) {
        if (this.thinkingTagBuffer.length > 0) {
          this.textBuffer += this.thinkingTagBuffer;
          this.thinkingTagBuffer = "";
        }
        this.flushTextBuffer(progress);
        this.flushThinkingBuffer(progress);
        this.finalizeToolCalls(progress);
      }
    }
  }
  /**
   * Handle Gemini function call (convert to VS Code tool call)
   */
  handleGeminiFunctionCall(functionCall, progress) {
    const callId = functionCall.id || `tool_call_${this.toolCallCounter++}_${Date.now()}`;
    const name = functionCall.name || "";
    if (!name) {
      return;
    }
    const dedupeKey = `${callId}:${name}`;
    if (this.seenToolCalls.has(dedupeKey)) {
      return;
    }
    this.seenToolCalls.add(dedupeKey);
    this.flushThinkingTagBufferForToolCall();
    this.flushTextBuffer(progress);
    this.flushThinkingBuffer(progress);
    const args = this.removeNullsFromArgs(functionCall.args || {});
    try {
      const toolCallPart = new vscode20.LanguageModelToolCallPart(
        callId,
        name,
        args
      );
      progress.report(toolCallPart);
      this.lastActivityReportTime = Date.now();
      this.shouldStopAfterToolCall = true;
    } catch (_error) {
    }
  }
  /**
   * Handle text content from delta - IMMEDIATELY flush to UI
   */
  handleTextContent(content, modelConfig, progress) {
    const thinkMatch = content.match(/^<think>\n?([\s\S]*?)\n?<\/think>\n?/);
    if (thinkMatch) {
      const thinkingContent = thinkMatch[1];
      if (thinkingContent && modelConfig.outputThinking !== false) {
        if (!this.currentThinkingId) {
          this.currentThinkingId = this.generateThinkingId();
        }
        this.thinkingBuffer += thinkingContent;
        this.flushThinkingBuffer(progress);
      }
      const remainingContent = content.slice(thinkMatch[0].length);
      if (remainingContent) {
        this.processTextWithThinkingTags(
          remainingContent,
          modelConfig,
          progress
        );
        this.flushTextBuffer(progress);
      }
      return;
    }
    this.processTextWithThinkingTags(content, modelConfig, progress);
    this.flushTextBuffer(progress);
  }
  /**
   * Process text content with Claude <thinking></thinking> tag detection
   */
  processTextWithThinkingTags(text, modelConfig, progress) {
    if (modelConfig.outputThinking === false) {
      const stripped = text.replace(/<thinking>[\s\S]*?<\/thinking>/g, "");
      if (stripped.length > 0) {
        this.textBuffer += stripped;
      }
      return;
    }
    let i = 0;
    while (i < text.length) {
      if (this.isInsideThinkingTag) {
        this.thinkingTagBuffer += text[i];
        if (this.thinkingTagBuffer.endsWith(this.CLOSING_TAG)) {
          const thinkingContent = this.thinkingTagBuffer.slice(
            0,
            -this.CLOSING_TAG_LEN
          );
          if (thinkingContent.length > 0) {
            if (!this.currentThinkingId) {
              this.currentThinkingId = this.generateThinkingId();
            }
            this.thinkingBuffer += thinkingContent;
            this.flushThinkingBuffer(progress);
          }
          this.isInsideThinkingTag = false;
          this.thinkingTagBuffer = "";
        } else if (this.thinkingTagBuffer.length > this.CLOSING_TAG_LEN) {
          const safeLength = this.thinkingTagBuffer.length - this.CLOSING_TAG_LEN;
          const toStream = this.thinkingTagBuffer.slice(0, safeLength);
          this.thinkingTagBuffer = this.thinkingTagBuffer.slice(safeLength);
          if (toStream.length > 0) {
            if (!this.currentThinkingId) {
              this.currentThinkingId = this.generateThinkingId();
            }
            this.thinkingBuffer += toStream;
          }
        }
        i++;
      } else {
        this.thinkingTagBuffer += text[i];
        if (this.thinkingTagBuffer.length > 10) {
          const overflow = this.thinkingTagBuffer.slice(0, -10);
          this.textBuffer += overflow;
          this.thinkingTagBuffer = this.thinkingTagBuffer.slice(-10);
        }
        if (this.thinkingTagBuffer.endsWith("<thinking>")) {
          const beforeTag = this.thinkingTagBuffer.slice(
            0,
            -"<thinking>".length
          );
          if (beforeTag.length > 0) {
            this.textBuffer += beforeTag;
          }
          this.isInsideThinkingTag = true;
          this.thinkingTagBuffer = "";
          if (!this.currentThinkingId) {
            this.currentThinkingId = this.generateThinkingId();
          }
        }
        i++;
      }
    }
    if (!this.isInsideThinkingTag && this.thinkingTagBuffer.length > 0) {
      const possibleTagStart = "<thinking>".startsWith(this.thinkingTagBuffer);
      if (!possibleTagStart) {
        this.textBuffer += this.thinkingTagBuffer;
        this.thinkingTagBuffer = "";
      } else if (this.thinkingTagBuffer.length > 0 && this.thinkingTagBuffer.length < 10) {
        const tagPrefix = "<thinking>".slice(0, this.thinkingTagBuffer.length);
        if (this.thinkingTagBuffer !== tagPrefix) {
          this.textBuffer += this.thinkingTagBuffer;
          this.thinkingTagBuffer = "";
        }
      }
    }
  }
  /**
   * Handle tool call delta from OpenAI stream
   */
  handleToolCallDelta(toolCallDelta, progress) {
    const index = toolCallDelta.index;
    let toolCall = this.toolCallsInProgress.get(index);
    if (!toolCall) {
      this.flushThinkingTagBufferForToolCall();
      this.flushTextBuffer(progress);
      this.flushThinkingBuffer(progress);
      toolCall = {
        id: toolCallDelta.id || `tool_call_${this.toolCallCounter++}_${Date.now()}`,
        name: "",
        args: ""
      };
      this.toolCallsInProgress.set(index, toolCall);
    }
    if (toolCallDelta.id) {
      toolCall.id = toolCallDelta.id;
    }
    if (toolCallDelta.function?.name) {
      toolCall.name = toolCallDelta.function.name;
      if (!this.toolCallProgressReported.has(index)) {
        this.toolCallProgressReported.add(index);
        this.reportToolCallProgress(toolCall.name, progress);
      }
    }
    if (toolCallDelta.function?.arguments) {
      toolCall.args += toolCallDelta.function.arguments;
      this.reportToolCallArgumentsProgress(
        toolCall.name,
        toolCall.args.length,
        progress
      );
    }
    this.reportActivity(progress);
  }
  /**
   * Report tool call progress to UI - shows that a tool is being prepared
   */
  reportToolCallProgress(toolName, progress) {
    const thinkingId = `tool_prep_${Date.now()}`;
    const message = `
Preparing tool: ${toolName}...
`;
    progress.report(new vscode20.LanguageModelThinkingPart(message, thinkingId));
  }
  /**
   * Report tool call arguments accumulation progress
   */
  reportToolCallArgumentsProgress(_toolName, _argsLength, progress) {
    const now = Date.now();
    if (now - this.lastToolCallProgressTime >= _OpenAIStreamProcessor.TOOL_CALL_PROGRESS_INTERVAL_MS) {
      this.lastToolCallProgressTime = now;
      progress.report(new vscode20.LanguageModelTextPart(""));
    }
  }
  /**
   * Finalize and report all tool calls
   */
  finalizeToolCalls(progress) {
    this.flushThinkingTagBufferForToolCall();
    this.flushTextBuffer(progress);
    this.flushThinkingBuffer(progress);
    for (const [, toolCall] of this.toolCallsInProgress) {
      if (!toolCall.name) {
        continue;
      }
      const dedupeKey = `${toolCall.id}:${toolCall.name}`;
      if (this.seenToolCalls.has(dedupeKey)) {
        continue;
      }
      this.seenToolCalls.add(dedupeKey);
      let args = {};
      if (toolCall.args) {
        try {
          args = JSON.parse(toolCall.args);
        } catch {
          args = { value: toolCall.args };
        }
      }
      args = this.removeNullsFromArgs(args);
      try {
        const toolCallPart = new vscode20.LanguageModelToolCallPart(
          toolCall.id,
          toolCall.name,
          args
        );
        progress.report(toolCallPart);
      } catch (_error) {
      }
    }
    this.toolCallsInProgress.clear();
    this.toolCallProgressReported.clear();
  }
  /**
   * Remove null values from args recursively (like gcli2api's _remove_nulls_for_tool_input)
   */
  removeNullsFromArgs(value) {
    if (value === null || value === void 0) {
      return {};
    }
    if (typeof value !== "object") {
      return { value };
    }
    if (Array.isArray(value)) {
      return {
        items: value.filter((item) => item !== null && item !== void 0)
      };
    }
    const result = {};
    for (const [key, val] of Object.entries(value)) {
      if (val === null || val === void 0) {
        continue;
      }
      if (typeof val === "object" && !Array.isArray(val)) {
        result[key] = this.removeNullsFromArgs(val);
      } else if (Array.isArray(val)) {
        result[key] = val.filter((item) => item !== null && item !== void 0);
      } else {
        result[key] = val;
      }
    }
    return result;
  }
  /**
   * Process remaining buffer at end of stream
   */
  processRemainingBuffer(buffer, modelConfig, progress) {
    const trailing = buffer.trim();
    if (trailing.length > 0 && trailing.startsWith("data:")) {
      const dataLine = trailing.slice(5).trim();
      if (dataLine && dataLine !== "[DONE]") {
        this.processOpenAIChunk(dataLine, modelConfig, progress);
      }
    }
  }
  /**
   * Flush text buffer to progress - IMMEDIATELY reports text to UI
   * Uses fake streaming for large chunks to improve perceived responsiveness
   */
  flushTextBuffer(progress) {
    if (this.textBuffer.length === 0) {
      return;
    }
    const textToReport = this.textBuffer;
    this.textBuffer = "";
    this.lastTextFlushTime = Date.now();
    try {
      progress.report(new vscode20.LanguageModelTextPart(textToReport));
    } catch (_error) {
    }
  }
  /**
   * Flush text buffer only if it exceeds threshold (for batching)
   */
  flushTextBufferIfNeeded(progress) {
    if (this.textBuffer.length === 0) {
      return;
    }
    const wordCount = this.countWords(this.textBuffer);
    const now = Date.now();
    const timeSinceFlush = now - this.lastTextFlushTime;
    if (wordCount >= _OpenAIStreamProcessor.TEXT_BUFFER_WORD_THRESHOLD || this.textBuffer.length >= _OpenAIStreamProcessor.TEXT_BUFFER_CHAR_THRESHOLD || timeSinceFlush >= _OpenAIStreamProcessor.TEXT_BUFFER_MAX_DELAY_MS) {
      this.flushTextBuffer(progress);
    }
  }
  countWords(text) {
    const matches = text.trim().match(/\S+/g);
    return matches ? matches.length : 0;
  }
  /**
   * Flush thinking buffer to progress - IMMEDIATELY reports thinking to UI
   */
  flushThinkingBuffer(progress) {
    if (this.thinkingBuffer.length > 0 && this.currentThinkingId) {
      const thinkingToReport = this.thinkingBuffer;
      this.thinkingBuffer = "";
      progress.report(
        new vscode20.LanguageModelThinkingPart(
          thinkingToReport,
          this.currentThinkingId
        )
      );
    }
  }
  /**
   * Finalize thinking part
   */
  finalizeThinkingPart(progress) {
    if (this.thinkingBuffer.length > 0) {
      this.flushThinkingBuffer(progress);
    }
    if (this.currentThinkingId) {
      progress.report(
        new vscode20.LanguageModelThinkingPart("", this.currentThinkingId)
      );
      this.currentThinkingId = null;
    }
  }
  /**
   * Report activity to keep UI responsive
   */
  reportActivity(progress) {
    const now = Date.now();
    if (now - this.lastActivityReportTime >= _OpenAIStreamProcessor.ACTIVITY_REPORT_INTERVAL_MS) {
      progress.report(new vscode20.LanguageModelTextPart(""));
      this.lastActivityReportTime = now;
    }
  }
  /**
   * Generate unique thinking ID
   */
  generateThinkingId() {
    return `thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
  }
  /**
   * Flush any leftover thinking tag buffer at stream end
   */
  flushPendingThinkingTagBuffer() {
    if (this.thinkingTagBuffer.length === 0) {
      return;
    }
    if (this.isInsideThinkingTag) {
      if (!this.currentThinkingId) {
        this.currentThinkingId = this.generateThinkingId();
      }
      this.thinkingBuffer += this.thinkingTagBuffer;
    } else {
      this.textBuffer += this.thinkingTagBuffer;
    }
    this.thinkingTagBuffer = "";
  }
  /**
   * Flush thinking tag buffer before tool calls to avoid truncation.
   * Tool calls indicate the stream is switching modes, so keep any pending text.
   */
  flushThinkingTagBufferForToolCall() {
    if (this.thinkingTagBuffer.length === 0) {
      return;
    }
    this.textBuffer += this.thinkingTagBuffer;
    this.thinkingTagBuffer = "";
    this.isInsideThinkingTag = false;
  }
};

// src/providers/antigravity/handler.ts
init_auth();

// src/providers/antigravity/streamProcessor.ts
var vscode21 = __toESM(require("vscode"));
var AntigravityStreamProcessor = class _AntigravityStreamProcessor {
  textBuffer = "";
  textBufferLastFlush = 0;
  thinkingBuffer = "";
  currentThinkingId = null;
  seenToolCalls = /* @__PURE__ */ new Set();
  toolCallCounter = 0;
  isInsideThinkingTag = false;
  thinkingTagBuffer = "";
  sseDataParts = [];
  CLOSING_TAG = "</thinking>";
  thinkingQueue = "";
  thinkingFlushInterval = null;
  thinkingProgress = null;
  chunkCounter = 0;
  lastChunkTime = 0;
  streamVelocity = 0;
  hasReceivedContent = false;
  hasThinkingContent = false;
  // Activity tracking  gi UI "sng" khi ang x l tool calls
  lastActivityReportTime = 0;
  activityReportInterval = null;
  pendingToolCalls = [];
  toolCallFlushInterval = null;
  static THINKING_FLUSH_INTERVAL_MS = 80;
  static THINKING_CHARS_PER_FLUSH = 150;
  static ACTIVITY_REPORT_INTERVAL_MS = 400;
  // Gim xung  report thng xuyn hn
  static TEXT_BUFFER_MIN_SIZE = 40;
  static TEXT_BUFFER_MAX_DELAY_MS = 25;
  static YIELD_EVERY_N_CHUNKS = 5;
  static HIGH_VELOCITY_THRESHOLD = 10;
  static ADAPTIVE_BUFFER_MULTIPLIER = 0.5;
  static TOOL_CALL_FLUSH_DELAY_MS = 50;
  // Delay nh trc khi flush tool call
  async processStream(options) {
    const { response, modelConfig, progress, token } = options;
    if (!response.body) {
      throw new Error("Antigravity response body is empty.");
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    this.startActivityReporting(progress);
    try {
      while (true) {
        if (token.isCancellationRequested) {
          throw new vscode21.CancellationError();
        }
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        const now = performance.now();
        if (this.lastChunkTime > 0) {
          const delta = now - this.lastChunkTime;
          this.streamVelocity = delta > 0 ? value.length / delta : this.streamVelocity;
        }
        this.lastChunkTime = now;
        buffer += decoder.decode(value, { stream: true });
        buffer = buffer.replace(/\r\n/g, "\n");
        buffer = this.processSSELines(buffer, modelConfig, progress);
        this.flushTextBufferAdaptive(progress);
        this.flushThinkingBufferIfNeeded(progress);
        this.schedulePendingToolCallsFlush(progress);
        this.chunkCounter++;
        if (this.chunkCounter % _AntigravityStreamProcessor.YIELD_EVERY_N_CHUNKS === 0) {
          await new Promise((resolve) => setTimeout(resolve, 1));
        }
      }
    } finally {
      this.stopActivityReporting();
      this.processRemainingBuffer(buffer, modelConfig, progress);
      this.flushTextBuffer(progress, true);
      this.flushPendingToolCallsImmediate(progress);
      this.finalizeThinkingPart(progress);
      if (this.hasThinkingContent && !this.hasReceivedContent) {
        progress.report(new vscode21.LanguageModelTextPart("<think/>"));
      }
    }
  }
  /**
   * Bt u report activity nh k  gi UI hin th "Working..."
   */
  startActivityReporting(progress) {
    if (this.activityReportInterval) {
      return;
    }
    this.lastActivityReportTime = Date.now();
    this.activityReportInterval = setInterval(() => {
      const now = Date.now();
      const timeSinceLastActivity = now - this.lastActivityReportTime;
      if (timeSinceLastActivity >= _AntigravityStreamProcessor.ACTIVITY_REPORT_INTERVAL_MS) {
        if (this.thinkingBuffer.length > 0) {
          this.flushThinkingBuffer(progress);
        } else if (this.textBuffer.length > 0) {
          this.flushTextBuffer(progress, true);
        }
        this.lastActivityReportTime = now;
      }
    }, _AntigravityStreamProcessor.ACTIVITY_REPORT_INTERVAL_MS / 2);
  }
  /**
   * Dng activity reporting
   */
  stopActivityReporting() {
    if (this.activityReportInterval) {
      clearInterval(this.activityReportInterval);
      this.activityReportInterval = null;
    }
    if (this.toolCallFlushInterval) {
      clearInterval(this.toolCallFlushInterval);
      this.toolCallFlushInterval = null;
    }
  }
  /**
   * nh du c activity  reset timer
   */
  markActivity() {
    this.lastActivityReportTime = Date.now();
  }
  /**
   * Schedule flush pending tool calls vi delay nh
   */
  schedulePendingToolCallsFlush(progress) {
    if (this.pendingToolCalls.length === 0 || this.toolCallFlushInterval) {
      return;
    }
    this.toolCallFlushInterval = setTimeout(() => {
      this.flushPendingToolCallsImmediate(progress);
      this.toolCallFlushInterval = null;
    }, _AntigravityStreamProcessor.TOOL_CALL_FLUSH_DELAY_MS);
  }
  /**
   * Flush tt c pending tool calls ngay lp tc
   */
  flushPendingToolCallsImmediate(progress) {
    while (this.pendingToolCalls.length > 0) {
      const toolCall = this.pendingToolCalls.shift();
      if (toolCall) {
        progress.report(
          new vscode21.LanguageModelToolCallPart(
            toolCall.callId,
            toolCall.name,
            toolCall.args
          )
        );
        this.markActivity();
      }
    }
  }
  processSSELines(buffer, modelConfig, progress) {
    let lineEndIndex = buffer.indexOf("\n");
    while (lineEndIndex !== -1) {
      const line = buffer.slice(0, lineEndIndex).trimEnd();
      buffer = buffer.slice(lineEndIndex + 1);
      if (line.length === 0) {
        this.processSSEEvent(modelConfig, progress);
        lineEndIndex = buffer.indexOf("\n");
        continue;
      }
      if (line.startsWith("data:")) {
        const dataLine = line.slice(5);
        if (dataLine.trim() === "[DONE]") {
          this.sseDataParts = [];
          lineEndIndex = buffer.indexOf("\n");
          continue;
        }
        if (dataLine.length > 0) {
          this.sseDataParts.push(dataLine.trimStart());
        }
      }
      lineEndIndex = buffer.indexOf("\n");
    }
    return buffer;
  }
  processSSEEvent(modelConfig, progress) {
    if (this.sseDataParts.length === 0) {
      return;
    }
    const eventData = this.sseDataParts.join("\n").trim();
    this.sseDataParts = [];
    if (!eventData || eventData === "[DONE]") {
      return;
    }
    const createCallId = () => `tool_call_${this.toolCallCounter++}_${Date.now()}`;
    try {
      this.handleStreamPayload(eventData, createCallId, modelConfig, progress);
      this.flushTextBufferIfNeeded(progress);
      this.flushThinkingBufferIfNeeded(progress);
    } catch (error2) {
      if (error2 instanceof SyntaxError && String(error2.message).includes("after JSON")) {
        const jsonObjects = this.splitConcatenatedJSON(eventData);
        for (const jsonStr of jsonObjects) {
          try {
            this.handleStreamPayload(
              jsonStr,
              createCallId,
              modelConfig,
              progress
            );
          } catch {
          }
        }
      }
    }
  }
  processRemainingBuffer(buffer, modelConfig, progress) {
    const trailing = buffer.trim();
    if (trailing.length > 0 && trailing.startsWith("data:")) {
      this.sseDataParts.push(trailing.slice(5).trimStart());
    }
    if (this.sseDataParts.length > 0) {
      const eventData = this.sseDataParts.join("\n").trim();
      if (eventData && eventData !== "[DONE]") {
        const createCallId = () => `tool_call_${this.toolCallCounter++}_${Date.now()}`;
        try {
          this.handleStreamPayload(
            eventData,
            createCallId,
            modelConfig,
            progress
          );
        } catch {
        }
      }
    }
  }
  handleStreamPayload(data, createCallId, modelConfig, progress) {
    const parsed = JSON.parse(data);
    const payload = parsed.response || parsed;
    const candidates = payload.candidates || [];
    for (const candidate of candidates) {
      const content = candidate.content;
      for (const part of content?.parts || []) {
        this.handlePart(part, createCallId, modelConfig, progress);
      }
    }
  }
  handlePart(part, createCallId, modelConfig, progress) {
    if (part.thought === true) {
      if (modelConfig.outputThinking !== false && typeof part.text === "string") {
        if (!this.currentThinkingId) {
          this.currentThinkingId = createCallId();
        }
        this.thinkingBuffer += part.text;
        this.hasThinkingContent = true;
        this.flushThinkingBufferIfNeeded(progress);
      }
      return;
    }
    if (typeof part.text === "string") {
      const processedText = this.processTextWithThinkingTags(
        part.text,
        modelConfig
      );
      if (this.isInsideThinkingTag) {
        this.flushThinkingBufferIfNeeded(progress);
      } else {
        this.finalizeThinkingPart(progress);
        if (processedText.length > 0) {
          this.textBuffer += processedText;
          if (processedText.trim().length > 0) {
            this.hasReceivedContent = true;
          }
          this.flushTextBufferIfNeeded(progress);
        }
      }
    }
    const functionCall = part.functionCall;
    if (functionCall?.name) {
      this.flushTextBuffer(progress, true);
      this.flushThinkingBuffer(progress);
      const toolCallInfo = extractToolCallFromGeminiResponse(part);
      if (toolCallInfo?.callId && toolCallInfo.name) {
        const dedupeKey = `${toolCallInfo.callId}:${toolCallInfo.name}`;
        if (this.seenToolCalls.has(dedupeKey)) {
          return;
        }
        this.seenToolCalls.add(dedupeKey);
        if (toolCallInfo.thoughtSignature) {
          storeThoughtSignature(
            toolCallInfo.callId,
            toolCallInfo.thoughtSignature
          );
        }
        let normalizedArgs = {};
        if (toolCallInfo.args && typeof toolCallInfo.args === "object") {
          normalizedArgs = toolCallInfo.args;
        } else if (typeof toolCallInfo.args === "string") {
          try {
            const parsed = JSON.parse(toolCallInfo.args);
            if (parsed && typeof parsed === "object") {
              normalizedArgs = parsed;
            }
          } catch {
            normalizedArgs = { value: toolCallInfo.args };
          }
        }
        this.pendingToolCalls.push({
          callId: toolCallInfo.callId,
          name: toolCallInfo.name,
          args: normalizedArgs
        });
        this.hasReceivedContent = true;
        this.markActivity();
      }
    }
  }
  processTextWithThinkingTags(text, modelConfig) {
    if (modelConfig.outputThinking === false) {
      return text.replace(/<thinking>[\s\S]*?<\/thinking>/g, "");
    }
    let result = "";
    let remaining = this.thinkingTagBuffer + text;
    this.thinkingTagBuffer = "";
    while (remaining.length > 0) {
      if (this.isInsideThinkingTag) {
        const closeIdx = remaining.indexOf(this.CLOSING_TAG);
        if (closeIdx !== -1) {
          const thinkingContent = remaining.slice(0, closeIdx);
          if (thinkingContent.length > 0) {
            if (!this.currentThinkingId) {
              this.currentThinkingId = this.generateThinkingId();
            }
            this.thinkingBuffer += thinkingContent;
            this.hasThinkingContent = true;
          }
          this.isInsideThinkingTag = false;
          remaining = remaining.slice(closeIdx + this.CLOSING_TAG.length);
        } else {
          const safeLen = Math.max(0, remaining.length - 12);
          if (safeLen > 0) {
            if (!this.currentThinkingId) {
              this.currentThinkingId = this.generateThinkingId();
            }
            this.thinkingBuffer += remaining.slice(0, safeLen);
            this.hasThinkingContent = true;
          }
          this.thinkingTagBuffer = remaining.slice(safeLen);
          remaining = "";
        }
      } else {
        const openIdx = remaining.indexOf("<thinking>");
        if (openIdx !== -1) {
          result += remaining.slice(0, openIdx);
          this.isInsideThinkingTag = true;
          if (!this.currentThinkingId) {
            this.currentThinkingId = this.generateThinkingId();
          }
          remaining = remaining.slice(openIdx + 10);
        } else {
          const safeLen = Math.max(0, remaining.length - 10);
          result += remaining.slice(0, safeLen);
          this.thinkingTagBuffer = remaining.slice(safeLen);
          remaining = "";
        }
      }
    }
    return result;
  }
  flushTextBuffer(progress, force = false) {
    if (this.textBuffer.length > 0 && (force || this.textBuffer.length >= _AntigravityStreamProcessor.TEXT_BUFFER_MIN_SIZE)) {
      progress.report(new vscode21.LanguageModelTextPart(this.textBuffer));
      this.textBuffer = "";
      this.textBufferLastFlush = Date.now();
      this.markActivity();
    }
  }
  flushTextBufferIfNeeded(progress) {
    if (this.textBuffer.length === 0) {
      return;
    }
    const timeSinceLastFlush = Date.now() - this.textBufferLastFlush;
    const shouldFlush = this.textBuffer.length >= _AntigravityStreamProcessor.TEXT_BUFFER_MIN_SIZE || timeSinceLastFlush >= _AntigravityStreamProcessor.TEXT_BUFFER_MAX_DELAY_MS;
    if (shouldFlush) {
      this.flushTextBuffer(progress, true);
    }
  }
  flushTextBufferAdaptive(progress) {
    if (this.textBuffer.length === 0) {
      return;
    }
    const isHighVelocity = this.streamVelocity > _AntigravityStreamProcessor.HIGH_VELOCITY_THRESHOLD;
    const baseSize = _AntigravityStreamProcessor.TEXT_BUFFER_MIN_SIZE;
    const baseDelay = _AntigravityStreamProcessor.TEXT_BUFFER_MAX_DELAY_MS;
    const multiplier = _AntigravityStreamProcessor.ADAPTIVE_BUFFER_MULTIPLIER;
    const adaptiveMinSize = isHighVelocity ? Math.floor(baseSize * multiplier) : baseSize;
    const adaptiveMaxDelay = isHighVelocity ? Math.floor(baseDelay * multiplier) : baseDelay;
    const timeSinceLastFlush = Date.now() - this.textBufferLastFlush;
    const shouldFlush = this.textBuffer.length >= adaptiveMinSize || timeSinceLastFlush >= adaptiveMaxDelay;
    if (shouldFlush) {
      this.flushTextBuffer(progress, true);
    }
  }
  flushThinkingBuffer(progress) {
    if (this.thinkingBuffer.length > 0 && this.currentThinkingId) {
      this.enqueueThinking(this.thinkingBuffer, progress);
      this.thinkingBuffer = "";
    }
  }
  flushThinkingBufferIfNeeded(progress) {
    this.flushThinkingBuffer(progress);
  }
  enqueueThinking(text, progress) {
    this.thinkingQueue += text;
    this.thinkingProgress = progress;
    this.markActivity();
    if (!this.thinkingFlushInterval) {
      this.thinkingFlushInterval = setInterval(
        () => this.flushThinkingChunk(),
        _AntigravityStreamProcessor.THINKING_FLUSH_INTERVAL_MS
      );
    }
  }
  flushThinkingChunk() {
    if (this.thinkingQueue.length === 0 || !this.thinkingProgress || !this.currentThinkingId) {
      return;
    }
    const chunkSize = Math.min(
      _AntigravityStreamProcessor.THINKING_CHARS_PER_FLUSH,
      this.thinkingQueue.length
    );
    const chunk = this.thinkingQueue.slice(0, chunkSize);
    this.thinkingQueue = this.thinkingQueue.slice(chunkSize);
    this.thinkingProgress.report(
      new vscode21.LanguageModelThinkingPart(chunk, this.currentThinkingId)
    );
    this.markActivity();
  }
  finalizeThinkingPart(progress) {
    if (this.thinkingFlushInterval) {
      clearInterval(this.thinkingFlushInterval);
      this.thinkingFlushInterval = null;
    }
    if (this.thinkingBuffer.length > 0) {
      this.thinkingQueue += this.thinkingBuffer;
      this.thinkingBuffer = "";
    }
    this.thinkingProgress = progress;
    while (this.thinkingQueue.length > 0) {
      const chunkSize = Math.min(
        _AntigravityStreamProcessor.THINKING_CHARS_PER_FLUSH * 2,
        this.thinkingQueue.length
      );
      const chunk = this.thinkingQueue.slice(0, chunkSize);
      this.thinkingQueue = this.thinkingQueue.slice(chunkSize);
      if (this.currentThinkingId) {
        progress.report(
          new vscode21.LanguageModelThinkingPart(chunk, this.currentThinkingId)
        );
      }
    }
    if (this.currentThinkingId) {
      progress.report(
        new vscode21.LanguageModelThinkingPart("", this.currentThinkingId)
      );
      this.currentThinkingId = null;
    }
  }
  splitConcatenatedJSON(data) {
    const results = [];
    let depth = 0;
    let start = -1;
    for (let i = 0; i < data.length; i++) {
      if (data[i] === "{") {
        if (depth === 0) {
          start = i;
        }
        depth++;
      } else if (data[i] === "}") {
        depth--;
        if (depth === 0 && start !== -1) {
          results.push(data.slice(start, i + 1));
          start = -1;
        }
      }
    }
    return results;
  }
  generateThinkingId() {
    return `thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
  }
};

// src/providers/antigravity/handler.ts
var DEFAULT_BASE_URLS = [
  "https://daily-cloudcode-pa.sandbox.googleapis.com",
  "https://cloudcode-pa.googleapis.com"
];
var DEFAULT_USER_AGENT = "antigravity/1.11.5";
var RATE_LIMIT_MAX_RETRIES = 5;
var RATE_LIMIT_BASE_DELAY_MS = 1e3;
var RATE_LIMIT_MAX_DELAY_MS = 3e4;
var QUOTA_BACKOFF_BASE_MS = 1e3;
var QUOTA_BACKOFF_MAX_MS = 30 * 60 * 1e3;
var QUOTA_EXHAUSTED_THRESHOLD_MS = 10 * 60 * 1e3;
var QUOTA_COOLDOWN_WAIT_MAX_MS = 2 * 60 * 1e3;
var GEMINI_UNSUPPORTED_FIELDS = /* @__PURE__ */ new Set([
  "$ref",
  "$defs",
  "definitions",
  "$id",
  "$anchor",
  "$dynamicRef",
  "$dynamicAnchor",
  "$schema",
  "$vocabulary",
  "$comment",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "minimum",
  "maximum",
  "multipleOf",
  "additionalProperties",
  "minLength",
  "maxLength",
  "pattern",
  "minItems",
  "maxItems",
  "uniqueItems",
  "minContains",
  "maxContains",
  "minProperties",
  "maxProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  "unevaluatedItems",
  "unevaluatedProperties",
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  "dependencies",
  "allOf",
  "anyOf",
  "oneOf",
  "not",
  "strict",
  "input_examples",
  "examples"
]);
var thoughtSignatureStore = /* @__PURE__ */ new Map();
var FALLBACK_THOUGHT_SIGNATURE = "skip_thought_signature_validator";
function storeThoughtSignature(callId, signature) {
  if (callId && signature) {
    thoughtSignatureStore.set(callId, signature);
  }
}
function categorizeHttpStatus(statusCode) {
  switch (statusCode) {
    case 400:
      return "user_error" /* UserError */;
    case 401:
      return "auth_error" /* AuthError */;
    case 402:
    case 403:
    case 429:
      return "quota_error" /* QuotaError */;
    case 404:
      return "not_found" /* NotFound */;
    case 500:
    case 502:
    case 503:
    case 504:
      return "transient" /* Transient */;
    default:
      return "unknown" /* Unknown */;
  }
}
function shouldFallback(category) {
  return category === "quota_error" /* QuotaError */ || category === "transient" /* Transient */ || category === "auth_error" /* AuthError */;
}
function isPermissionDeniedError(statusCode, bodyText) {
  if (statusCode !== 403 || !bodyText) {
    return false;
  }
  if (bodyText.toLowerCase().includes("permission denied")) {
    return true;
  }
  try {
    const parsed = JSON.parse(bodyText);
    if (parsed?.error?.status === "PERMISSION_DENIED") {
      return true;
    }
    const details = parsed?.error?.details;
    if (Array.isArray(details)) {
      for (const detail of details) {
        if (detail["@type"] === "type.googleapis.com/google.rpc.ErrorInfo" && detail.reason === "CONSUMER_INVALID") {
          return true;
        }
      }
    }
  } catch {
  }
  return false;
}
function parseSecondsDuration(duration3) {
  const match = duration3.match(/^(\d+(?:\.\d+)?)s$/);
  return match ? Math.round(parseFloat(match[1]) * 1e3) : null;
}
function parseDurationFormat(duration3) {
  const simpleSeconds = parseSecondsDuration(duration3);
  if (simpleSeconds !== null) {
    return simpleSeconds;
  }
  let totalMs = 0;
  const hourMatch = duration3.match(/(\d+)h/);
  const minMatch = duration3.match(/(\d+)m/);
  const secMatch = duration3.match(/(\d+(?:\.\d+)?)s/);
  if (hourMatch) {
    totalMs += parseInt(hourMatch[1], 10) * 60 * 60 * 1e3;
  }
  if (minMatch) {
    totalMs += parseInt(minMatch[1], 10) * 60 * 1e3;
  }
  if (secMatch) {
    totalMs += Math.round(parseFloat(secMatch[1]) * 1e3);
  }
  return totalMs > 0 ? totalMs : null;
}
function parseQuotaRetryDelay(errorBody) {
  try {
    const parsed = JSON.parse(errorBody);
    const errorObj = parsed?.error || parsed;
    const details = errorObj?.details || (Array.isArray(parsed) ? parsed[0]?.error?.details : null);
    if (!details) {
      if (errorObj?.metadata?.quotaResetDelay) {
        const d = parseDurationFormat(errorObj.metadata.quotaResetDelay);
        if (d !== null && d > 0) {
          return d;
        }
      }
      return null;
    }
    for (const detail of details) {
      if (detail["@type"] === "type.googleapis.com/google.rpc.RetryInfo" && detail.retryDelay) {
        const d = parseSecondsDuration(detail.retryDelay);
        if (d !== null && d > 0) {
          return d;
        }
      }
      if (detail["@type"] === "type.googleapis.com/google.rpc.ErrorInfo" && detail.metadata?.quotaResetDelay) {
        const d = parseDurationFormat(detail.metadata.quotaResetDelay);
        if (d !== null && d > 0) {
          return d;
        }
      }
    }
  } catch {
  }
  return null;
}
function sleepWithCancellation(ms, token) {
  return new Promise((resolve) => {
    if (ms <= 0) {
      resolve();
      return;
    }
    const timeout = setTimeout(resolve, ms);
    const disposable = token.onCancellationRequested(() => {
      clearTimeout(timeout);
      resolve();
    });
    setTimeout(() => disposable.dispose(), ms + 100);
  });
}
var QuotaStateManager = class _QuotaStateManager {
  static instance;
  modelStates = /* @__PURE__ */ new Map();
  static getInstance() {
    if (!_QuotaStateManager.instance) {
      _QuotaStateManager.instance = new _QuotaStateManager();
    }
    return _QuotaStateManager.instance;
  }
  markQuotaExceeded(modelId, retryAfterMs) {
    const existing = this.modelStates.get(modelId) || {
      isExhausted: false,
      resetsAt: 0,
      lastUpdated: 0,
      exceeded: false,
      nextRecoverAt: 0,
      backoffLevel: 0
    };
    let cooldown = QUOTA_BACKOFF_BASE_MS * 2 ** (existing.backoffLevel || 0);
    if (cooldown > QUOTA_BACKOFF_MAX_MS) {
      cooldown = QUOTA_BACKOFF_MAX_MS;
    }
    const actualCooldown = retryAfterMs && retryAfterMs > cooldown ? retryAfterMs : cooldown;
    this.modelStates.set(modelId, {
      isExhausted: true,
      resetsAt: Date.now() + actualCooldown,
      lastUpdated: Date.now(),
      exceeded: true,
      nextRecoverAt: Date.now() + actualCooldown,
      backoffLevel: (existing.backoffLevel || 0) + 1,
      lastError: `Quota exceeded, retry after ${Math.round(actualCooldown / 1e3)}s`
    });
  }
  clearQuotaExceeded(modelId) {
    const existing = this.modelStates.get(modelId);
    if (existing) {
      existing.exceeded = false;
      existing.backoffLevel = 0;
      existing.lastError = void 0;
    }
  }
  isInCooldown(modelId) {
    const state = this.modelStates.get(modelId);
    if (!state || !state.exceeded) {
      return false;
    }
    if (Date.now() >= (state.nextRecoverAt || 0)) {
      this.clearQuotaExceeded(modelId);
      return false;
    }
    return true;
  }
  getRemainingCooldown(modelId) {
    const state = this.modelStates.get(modelId);
    if (!state || !state.exceeded) {
      return 0;
    }
    const remaining = (state.nextRecoverAt || 0) - Date.now();
    return remaining > 0 ? remaining : 0;
  }
};
var RateLimitRetrier = class {
  retryCount = 0;
  async handleRateLimit(hasNextUrl, errorBody, token) {
    if (hasNextUrl) {
      return "continue" /* Continue */;
    }
    if (this.retryCount >= RATE_LIMIT_MAX_RETRIES) {
      return "max_exceeded" /* MaxExceeded */;
    }
    let delay = RATE_LIMIT_BASE_DELAY_MS * 2 ** this.retryCount;
    const serverDelay = parseQuotaRetryDelay(errorBody);
    if (serverDelay !== null) {
      delay = Math.min(serverDelay + 500, RATE_LIMIT_MAX_DELAY_MS);
    } else if (delay > RATE_LIMIT_MAX_DELAY_MS) {
      delay = RATE_LIMIT_MAX_DELAY_MS;
    }
    this.retryCount++;
    await sleepWithCancellation(delay, token);
    return token.isCancellationRequested ? "max_exceeded" /* MaxExceeded */ : "retry" /* Retry */;
  }
};
function sanitizeToolSchema(schema) {
  if (!schema || typeof schema !== "object" || Array.isArray(schema)) {
    return { type: "object", properties: {} };
  }
  let sanitized;
  try {
    sanitized = JSON.parse(JSON.stringify(schema));
  } catch {
    return { type: "object", properties: {} };
  }
  const cleanRecursive = (s) => {
    if (!s) {
      return;
    }
    if (Array.isArray(s.properties)) {
      s.properties = {};
    }
    if (Array.isArray(s.items)) {
      const firstItem = s.items[0];
      s.items = firstItem && typeof firstItem === "object" ? firstItem : void 0;
    }
    if (typeof s.type === "string") {
      s.type = s.type.toLowerCase();
    }
    for (const key of Object.keys(s)) {
      if (GEMINI_UNSUPPORTED_FIELDS.has(key)) {
        delete s[key];
      }
    }
    for (const nested of [
      s.properties,
      s.items,
      s.additionalProperties,
      s.patternProperties,
      s.propertyNames,
      s.contains
    ]) {
      if (nested && typeof nested === "object" && !Array.isArray(nested)) {
        cleanRecursive(nested);
      }
      if (Array.isArray(nested)) {
        for (const item of nested) {
          if (item && typeof item === "object") {
            cleanRecursive(item);
          }
        }
      }
    }
    if (s.properties && typeof s.properties === "object") {
      for (const v of Object.values(s.properties)) {
        if (v && typeof v === "object") {
          cleanRecursive(v);
        }
      }
    }
  };
  cleanRecursive(sanitized);
  if (typeof sanitized.type !== "string" || !sanitized.type.trim() || sanitized.type === "None") {
    sanitized.type = "object";
  }
  if (!sanitized.properties || typeof sanitized.properties !== "object") {
    sanitized.properties = {};
  }
  return sanitized;
}
function convertToolCallsToGeminiParts(toolCalls) {
  return toolCalls.map((toolCall) => {
    const storedSignature = thoughtSignatureStore.get(toolCall.callId);
    const signature = storedSignature || FALLBACK_THOUGHT_SIGNATURE;
    if (!storedSignature) {
      thoughtSignatureStore.set(toolCall.callId, signature);
    }
    return {
      functionCall: {
        name: toolCall.name,
        id: toolCall.callId,
        args: toolCall.input
      },
      thoughtSignature: signature
    };
  });
}
function extractToolCallFromGeminiResponse(part) {
  const functionCall = part.functionCall;
  if (!functionCall?.name) {
    return null;
  }
  return {
    callId: functionCall.id || `call_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`,
    name: functionCall.name,
    args: functionCall.args,
    thoughtSignature: part.thoughtSignature
  };
}
var MessageConverter = class {
  convertMessagesToGemini(messages, modelConfig, resolvedModelName) {
    const contents = [];
    let systemText = "";
    const toolIdToName = /* @__PURE__ */ new Map();
    for (const m of messages) {
      if (m.role === vscode22.LanguageModelChatMessageRole.Assistant) {
        for (const p of m.content) {
          if (p instanceof vscode22.LanguageModelToolCallPart) {
            toolIdToName.set(p.callId, p.name);
          }
        }
      }
    }
    const isThinkingEnabled = modelConfig.outputThinking !== false || modelConfig.includeThinking === true;
    const modelName = (resolvedModelName || modelConfig.model || "").toLowerCase();
    const isClaudeModel = modelName.includes("claude");
    const nonSystemMessages = messages.filter(
      (m) => m.role !== vscode22.LanguageModelChatMessageRole.System
    );
    const msgCount = nonSystemMessages.length;
    let currentMsgIndex = 0;
    for (const message of messages) {
      if (message.role === vscode22.LanguageModelChatMessageRole.System) {
        systemText = message.content.filter((p) => p instanceof vscode22.LanguageModelTextPart).map((p) => p.value).join("\n");
        continue;
      }
      currentMsgIndex++;
      if (message.role === vscode22.LanguageModelChatMessageRole.User) {
        const parts = [];
        const text = message.content.filter((p) => p instanceof vscode22.LanguageModelTextPart).map((p) => p.value).join("\n");
        if (text) {
          parts.push({ text });
        }
        for (const part of message.content) {
          if (part instanceof vscode22.LanguageModelDataPart && part.mimeType.toLowerCase().startsWith("image/")) {
            parts.push({
              inlineData: {
                mimeType: part.mimeType,
                data: Buffer.from(part.data).toString("base64")
              }
            });
          }
          if (part instanceof vscode22.LanguageModelToolResultPart) {
            const name = toolIdToName.get(part.callId) || "unknown";
            let content = "";
            if (typeof part.content === "string") {
              content = part.content;
            } else if (Array.isArray(part.content)) {
              content = part.content.map(
                (r) => r instanceof vscode22.LanguageModelTextPart ? r.value : JSON.stringify(r)
              ).join("\n");
            } else {
              content = JSON.stringify(part.content);
            }
            let response = { content };
            try {
              const parsed = JSON.parse(content.trim());
              if (parsed && typeof parsed === "object") {
                response = Array.isArray(parsed) ? { result: parsed } : parsed;
              }
            } catch {
            }
            parts.push({
              functionResponse: { name, id: part.callId, response }
            });
          }
        }
        if (parts.length > 0) {
          contents.push({
            role: "user",
            parts
          });
        }
        continue;
      }
      if (message.role === vscode22.LanguageModelChatMessageRole.Assistant) {
        let parts = [];
        const includeThinking = !isClaudeModel && (modelConfig.includeThinking === true || modelConfig.outputThinking !== false);
        if (includeThinking) {
          for (const part of message.content) {
            if (part instanceof vscode22.LanguageModelThinkingPart) {
              const value = Array.isArray(part.value) ? part.value.join("") : part.value;
              if (value) {
                parts.push({ text: value, thought: true });
              }
              break;
            }
          }
        }
        const text = message.content.filter((p) => p instanceof vscode22.LanguageModelTextPart).map((p) => p.value).join("\n");
        if (text) {
          parts.push({ text });
        }
        const toolCalls = message.content.filter(
          (p) => p instanceof vscode22.LanguageModelToolCallPart
        );
        if (toolCalls.length > 0) {
          parts.push(...convertToolCallsToGeminiParts(toolCalls));
        }
        if (isClaudeModel) {
          parts = parts.filter((p) => p.thought !== true);
        }
        if (!isClaudeModel && isThinkingEnabled && currentMsgIndex === msgCount && !parts.some((p) => p.thought === true)) {
          parts.unshift({ text: "Thinking...", thought: true });
        }
        if (parts.length > 0) {
          contents.push({
            role: "model",
            parts
          });
        }
      }
    }
    return {
      contents,
      systemInstruction: systemText ? { role: "user", parts: [{ text: systemText }] } : void 0
    };
  }
};
var FromIRTranslator = class {
  messageConverter = new MessageConverter();
  MODEL_ALIASES = {
    "gemini-2.5-computer-use-preview-10-2025": "rev19-uic3-1p",
    "gemini-3-pro-image-preview": "gemini-3-pro-image",
    "gemini-3-pro-preview": "gemini-3-pro-high",
    "gemini-claude-sonnet-4-5": "claude-sonnet-4-5",
    "claude-sonnet-4-5": "claude-sonnet-4-5",
    "gemini-claude-sonnet-4-5-thinking": "claude-sonnet-4-5-thinking",
    "claude-sonnet-4-5-thinking": "claude-sonnet-4-5-thinking",
    "gemini-claude-opus-4-5-thinking": "claude-opus-4-5-thinking",
    "claude-opus-4-5-thinking": "claude-opus-4-5-thinking"
  };
  aliasToModelName(modelName) {
    return this.MODEL_ALIASES[modelName] || modelName;
  }
  buildAntigravityPayload(model, modelConfig, messages, options, modelName, projectId) {
    const maxOutputTokens = ConfigManager.getMaxTokensForModel(
      model.maxOutputTokens
    );
    const resolvedModel = this.aliasToModelName(modelName).toLowerCase();
    const { contents, systemInstruction } = this.messageConverter.convertMessagesToGemini(
      messages,
      modelConfig,
      resolvedModel
    );
    const isClaudeThinkingModel = resolvedModel.includes("claude") && resolvedModel.includes("thinking");
    const isThinkingEnabled = modelConfig.outputThinking !== false || modelConfig.includeThinking === true;
    const generationConfig = {
      maxOutputTokens,
      temperature: ConfigManager.getTemperature(),
      topP: ConfigManager.getTopP()
    };
    const hasTools = options.tools && options.tools.length > 0 && model.capabilities?.toolCalling;
    if (isClaudeThinkingModel && isThinkingEnabled && !hasTools) {
      const thinkingBudget = modelConfig.thinkingBudget || 1e4;
      if (maxOutputTokens < thinkingBudget + 1e3) {
        generationConfig.maxOutputTokens = thinkingBudget + 1e3;
      }
      generationConfig.thinkingConfig = {
        includeThoughts: true,
        thinkingBudget
      };
    }
    const request3 = { contents, generationConfig };
    if (systemInstruction) {
      request3.systemInstruction = systemInstruction;
    }
    if (hasTools) {
      request3.tools = [
        {
          functionDeclarations: options.tools?.map((tool) => ({
            name: tool.name,
            description: tool.description || "",
            parameters: tool.inputSchema && typeof tool.inputSchema === "object" ? sanitizeToolSchema(tool.inputSchema) : { type: "object", properties: {} }
          }))
        }
      ];
      request3.toolConfig = { functionCallingConfig: { mode: "AUTO" } };
    }
    request3.safetySettings = [
      { category: "HARM_CATEGORY_HARASSMENT", threshold: "OFF" },
      { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "OFF" },
      { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "OFF" },
      { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "OFF" },
      { category: "HARM_CATEGORY_CIVIC_INTEGRITY", threshold: "BLOCK_NONE" }
    ];
    if (modelConfig.extraBody && typeof modelConfig.extraBody === "object") {
      Object.assign(request3, modelConfig.extraBody);
    }
    const uuid2 = import_node_crypto.default.randomUUID ? import_node_crypto.default.randomUUID() : import_node_crypto.default.randomBytes(16).toString("hex");
    return {
      project: projectId || this.generateProjectId(),
      model: this.aliasToModelName(modelName),
      userAgent: "antigravity",
      requestId: `agent-${uuid2}`,
      request: {
        ...request3,
        sessionId: `-${uuid2.replace(/-/g, "").slice(0, 16)}`
      }
    };
  }
  generateProjectId() {
    const adjectives = ["useful", "bright", "swift", "calm", "bold"];
    const nouns = ["fuze", "wave", "spark", "flow", "core"];
    const bytes = import_node_crypto.default.randomBytes(2);
    return `${adjectives[bytes[0] % adjectives.length]}-${nouns[bytes[1] % nouns.length]}-${(import_node_crypto.default.randomUUID ? import_node_crypto.default.randomUUID() : import_node_crypto.default.randomBytes(16).toString("hex")).replace(/-/g, "").slice(0, 5).toLowerCase()}`;
  }
};
var AntigravityHandler = class {
  constructor(displayName) {
    this.displayName = displayName;
  }
  quotaManager = QuotaStateManager.getInstance();
  accountQuotaCache = AccountQuotaCache.getInstance();
  quotaNotificationManager = new QuotaNotificationManager();
  fromIRTranslator = new FromIRTranslator();
  cacheUpdateTimers = /* @__PURE__ */ new Map();
  pendingCacheUpdates = /* @__PURE__ */ new Map();
  projectIdCache = null;
  projectIdPromise = null;
  async handleRequest(model, modelConfig, messages, options, progress, token, accessToken, accountId, loadBalanceEnabled) {
    await RateLimiter.getInstance("antigravity", 2, 1e3).throttle(
      this.displayName
    );
    const authToken = accessToken || await AntigravityAuth.getAccessToken();
    if (!authToken) {
      throw new Error("Not logged in to Antigravity. Please login first.");
    }
    const requestModel = modelConfig.model || model.id;
    const resolvedModel = this.fromIRTranslator.aliasToModelName(requestModel);
    const effectiveAccountId = accountId || "default-antigravity";
    const quotaKey = `${effectiveAccountId}:${resolvedModel}`;
    if (this.quotaManager.isInCooldown(quotaKey)) {
      const remaining = this.quotaManager.getRemainingCooldown(quotaKey);
      if (remaining > 5e3) {
        this.quotaNotificationManager.notifyQuotaExceeded(
          remaining,
          resolvedModel,
          accountId,
          this.displayName
        );
      }
      if (remaining > QUOTA_COOLDOWN_WAIT_MAX_MS) {
        this.debouncedCacheUpdate(
          `quota-${effectiveAccountId}`,
          () => this.accountQuotaCache.markQuotaExceeded(
            effectiveAccountId,
            "antigravity",
            {
              accountName: this.displayName,
              resetDelayMs: remaining,
              affectedModel: resolvedModel,
              error: "Quota cooldown exceeds max wait threshold"
            }
          ),
          50
        );
        await this.quotaNotificationManager.notifyQuotaTooLong(
          remaining,
          resolvedModel,
          accountId,
          this.displayName
        );
        throw new Error(
          `Quota wait too long (${this.quotaNotificationManager.formatDuration(remaining)}). Please add another account or try again later.`
        );
      }
      await sleepWithCancellation(remaining, token);
      if (token.isCancellationRequested) {
        throw new vscode22.CancellationError();
      }
    }
    const projectId = await this.getProjectId(authToken);
    const payload = this.fromIRTranslator.buildAntigravityPayload(
      model,
      modelConfig,
      messages,
      options,
      resolvedModel,
      projectId
    );
    const baseUrls = modelConfig.baseUrl ? [modelConfig.baseUrl.replace(/\/v1internal\/?$/, "")] : [...DEFAULT_BASE_URLS];
    const abortController = new AbortController();
    const cancelListener = token.onCancellationRequested(
      () => abortController.abort()
    );
    const retrier = new RateLimitRetrier();
    progress.report(new vscode22.LanguageModelTextPart(""));
    let lastStatus = 0, lastBody = "", lastError = null;
    try {
      for (let idx = 0; idx < baseUrls.length; idx++) {
        const url2 = `${baseUrls[idx].replace(/\/$/, "")}/v1internal:streamGenerateContent?alt=sse`;
        if (token.isCancellationRequested) {
          throw new vscode22.CancellationError();
        }
        try {
          const result = await this.streamRequest(
            url2,
            authToken,
            payload,
            modelConfig,
            progress,
            token,
            abortController
          );
          if (result.success) {
            this.quotaManager.clearQuotaExceeded(quotaKey);
            this.quotaNotificationManager.clearQuotaCountdown();
            this.debouncedCacheUpdate(
              `success-${effectiveAccountId}`,
              () => this.accountQuotaCache.recordSuccess(
                effectiveAccountId,
                "antigravity",
                this.displayName
              ),
              50
            );
            try {
              const promptTokens = await TokenCounter.getInstance().countMessagesTokens(
                model,
                [...messages],
                { sdkMode: modelConfig.sdkMode || "openai" },
                options
              );
              TokenTelemetryTracker.getInstance().recordSuccess({
                modelId: model.id,
                modelName: model.name,
                providerId: "antigravity",
                promptTokens,
                completionTokens: 0,
                totalTokens: promptTokens,
                maxInputTokens: model.maxInputTokens,
                maxOutputTokens: model.maxOutputTokens,
                estimatedPromptTokens: true
              });
            } catch (e) {
              Logger.trace(
                `[Antigravity] Failed to estimate prompt tokens: ${String(e)}`
              );
            }
            return;
          }
          if (isPermissionDeniedError(result.status, result.body)) {
            this.debouncedCacheUpdate(
              `failure-${effectiveAccountId}`,
              () => this.accountQuotaCache.recordFailure(
                effectiveAccountId,
                "antigravity",
                `HTTP ${result.status || 403}: ${result.body || "Permission denied"}`,
                this.displayName
              ),
              50
            );
            throw new Error(
              result.body || "Permission denied on Antigravity project."
            );
          }
          const category = categorizeHttpStatus(result.status || 0);
          if (category === "quota_error" /* QuotaError */) {
            lastStatus = result.status || 0;
            lastBody = result.body || "";
            const quotaDelay = parseQuotaRetryDelay(lastBody);
            this.quotaManager.markQuotaExceeded(
              quotaKey,
              quotaDelay || void 0
            );
            const cooldownRemaining = this.quotaManager.getRemainingCooldown(quotaKey);
            if (cooldownRemaining > 5e3) {
              this.quotaNotificationManager.notifyQuotaExceeded(
                cooldownRemaining,
                resolvedModel,
                effectiveAccountId,
                this.displayName
              );
            }
            this.debouncedCacheUpdate(
              `quota-${effectiveAccountId}`,
              () => this.accountQuotaCache.markQuotaExceeded(
                effectiveAccountId,
                "antigravity",
                {
                  accountName: this.displayName,
                  resetDelayMs: quotaDelay || cooldownRemaining,
                  affectedModel: resolvedModel,
                  error: `HTTP ${lastStatus}: Quota exceeded`
                }
              ),
              50
            );
            if (cooldownRemaining > QUOTA_COOLDOWN_WAIT_MAX_MS) {
              await this.quotaNotificationManager.notifyQuotaTooLong(
                cooldownRemaining,
                resolvedModel,
                effectiveAccountId,
                this.displayName
              );
              throw new Error(
                `Quota wait too long (${this.quotaNotificationManager.formatDuration(cooldownRemaining)}). Please add another account or try again later.`
              );
            }
            if (quotaDelay && quotaDelay > QUOTA_EXHAUSTED_THRESHOLD_MS) {
              throw new Error(
                `Account quota exhausted (quota resets in ${this.quotaNotificationManager.formatDuration(quotaDelay)}). Please wait or use a different account.`
              );
            }
            if (idx + 1 < baseUrls.length) {
              continue;
            }
            if (loadBalanceEnabled !== false) {
              const action = await retrier.handleRateLimit(
                false,
                lastBody,
                token
              );
              if (action === "retry" /* Retry */) {
                idx--;
                continue;
              }
            }
            throw new Error(
              `Quota exceeded${quotaDelay ? ` (quota resets in ${this.quotaNotificationManager.formatDuration(quotaDelay)})` : ""}: ${lastBody || `HTTP ${result.status}`}`
            );
          }
          if (category === "transient" /* Transient */ && shouldFallback(category) && idx + 1 < baseUrls.length) {
            lastStatus = result.status || 0;
            lastBody = result.body || "";
            continue;
          }
          if (category === "auth_error" /* AuthError */) {
            throw new Error(
              "Authentication failed. Please re-login to Antigravity."
            );
          }
          if (result.status === 404 && idx + 1 < baseUrls.length) {
            lastStatus = result.status;
            lastBody = result.body || "";
            continue;
          }
          throw new Error(
            result.body || `HTTP ${result.status} ${result.statusText}`
          );
        } catch (error2) {
          if (error2 instanceof vscode22.CancellationError) {
            throw error2;
          }
          if (error2 instanceof Error && (error2.message.startsWith("Quota exceeded") || error2.message.startsWith("Rate limited") || error2.message.startsWith("HTTP") || error2.message.startsWith("Authentication failed"))) {
            throw error2;
          }
          lastStatus = 0;
          lastBody = "";
          lastError = error2 instanceof Error ? error2 : new Error(String(error2));
          if (idx + 1 < baseUrls.length) {
            continue;
          }
          throw error2;
        }
      }
      if (lastStatus !== 0) {
        throw new Error(
          `HTTP ${lastStatus}${parseQuotaRetryDelay(lastBody) ? ` (quota resets in ${this.quotaNotificationManager.formatDuration(parseQuotaRetryDelay(lastBody))})` : ""}: ${lastBody}`
        );
      }
      if (lastError) {
        throw lastError;
      }
      throw new Error("All Antigravity endpoints unavailable");
    } finally {
      cancelListener.dispose();
    }
  }
  async streamRequest(url2, accessToken, payload, modelConfig, progress, token, abortController) {
    let response;
    try {
      response = await fetch(url2, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
          Accept: "text/event-stream",
          "User-Agent": DEFAULT_USER_AGENT
        },
        body: JSON.stringify(payload),
        signal: abortController.signal
      });
    } catch (error2) {
      if (token.isCancellationRequested || abortController.signal.aborted) {
        throw new vscode22.CancellationError();
      }
      throw error2;
    }
    if (!response.ok) {
      return {
        success: false,
        status: response.status,
        statusText: response.statusText,
        body: await response.text()
      };
    }
    if (modelConfig.sdkMode === "openai" || modelConfig.sdkMode === "openai-sse") {
      await new OpenAIStreamProcessor().processStream({
        response,
        modelConfig,
        progress,
        token
      });
    } else {
      await new AntigravityStreamProcessor().processStream({
        response,
        modelConfig,
        progress,
        token
      });
    }
    return { success: true };
  }
  async getProjectId(accessToken) {
    if (this.projectIdCache) {
      return this.projectIdCache;
    }
    if (this.projectIdPromise) {
      return this.projectIdPromise;
    }
    this.projectIdPromise = AntigravityAuth.ensureProjectId(accessToken).then((projectId) => {
      this.projectIdCache = projectId;
      this.projectIdPromise = null;
      return projectId;
    }).catch((err) => {
      this.projectIdPromise = null;
      throw err;
    });
    return this.projectIdPromise;
  }
  isInCooldown(modelId, accountId) {
    return this.quotaManager.isInCooldown(
      `${accountId || "default-antigravity"}:${this.fromIRTranslator.aliasToModelName(modelId)}`
    );
  }
  getRemainingCooldown(modelId, accountId) {
    return this.quotaManager.getRemainingCooldown(
      `${accountId || "default-antigravity"}:${this.fromIRTranslator.aliasToModelName(modelId)}`
    );
  }
  debouncedCacheUpdate(key, updateFn, delayMs) {
    const existingTimer = this.cacheUpdateTimers.get(key);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }
    this.pendingCacheUpdates.set(key, updateFn);
    const timer = setTimeout(() => {
      const fn = this.pendingCacheUpdates.get(key);
      if (fn) {
        void fn().catch(() => {
        });
        this.pendingCacheUpdates.delete(key);
      }
      this.cacheUpdateTimers.delete(key);
    }, delayMs);
    this.cacheUpdateTimers.set(key, timer);
  }
};

// src/providers/minimax/minimaxWizard.ts
var vscode24 = __toESM(require("vscode"));
init_apiKeyManager();
init_configManager();
init_logger();

// src/utils/providerWizard.ts
var vscode23 = __toESM(require("vscode"));
init_apiKeyManager();
init_configManager();
init_logger();
var ProviderWizard = class _ProviderWizard {
  static async startWizard(options) {
    const supportsApiKey = options.supportsApiKey !== false;
    const supportsBaseUrl = options.supportsBaseUrl !== false;
    const baseUrlInfo = _ProviderWizard.getBaseUrlInfo(options.providerKey);
    const actions = [];
    if (supportsApiKey) {
      actions.push({
        label: `$(key) Configure ${options.displayName} API Key`,
        detail: `Set or clear ${options.displayName} API key`,
        action: "apiKey"
      });
    }
    if (supportsBaseUrl) {
      const currentBaseUrl = baseUrlInfo.override || baseUrlInfo.defaultBaseUrl;
      actions.push({
        label: "$(globe) Configure Base URL (Proxy)",
        description: currentBaseUrl ? `Current: ${currentBaseUrl}` : "Current: Default",
        detail: `Override ${options.displayName} endpoint (optional)`,
        action: "baseUrl"
      });
    }
    if (actions.length === 0) {
      return;
    }
    const choice = await vscode23.window.showQuickPick(actions, {
      title: `${options.displayName} Configuration`,
      placeHolder: "Select an option to configure"
    });
    if (!choice) {
      return;
    }
    if (choice.action === "apiKey") {
      await _ProviderWizard.configureApiKey(options);
      return;
    }
    if (choice.action === "baseUrl") {
      await _ProviderWizard.configureBaseUrl(options.providerKey, options.displayName);
    }
  }
  static async configureApiKey(options) {
    if (!options.apiKeyTemplate) {
      return;
    }
    await ApiKeyManager.promptAndSetApiKey(
      options.providerKey,
      options.displayName,
      options.apiKeyTemplate
    );
  }
  static async configureBaseUrl(providerKey, displayName) {
    const baseUrlInfo = _ProviderWizard.getBaseUrlInfo(providerKey);
    const result = await vscode23.window.showInputBox({
      prompt: `Enter ${displayName} base URL (leave empty to clear override)`,
      title: `${displayName} Base URL`,
      value: baseUrlInfo.override ?? "",
      placeHolder: baseUrlInfo.defaultBaseUrl || "https://example.com/v1"
    });
    if (result === void 0) {
      return;
    }
    try {
      const config2 = vscode23.workspace.getConfiguration("chp");
      await config2.update(
        `${providerKey}.baseUrl`,
        result.trim(),
        vscode23.ConfigurationTarget.Global
      );
      const message = result.trim() ? `${displayName} base URL updated.` : `${displayName} base URL override cleared.`;
      vscode23.window.showInformationMessage(message);
    } catch (error2) {
      const message = `Failed to update ${displayName} base URL: ${error2 instanceof Error ? error2.message : "Unknown error"}`;
      Logger.error(message);
      vscode23.window.showErrorMessage(message);
    }
  }
  static getBaseUrlInfo(providerKey) {
    const providerConfigs = ConfigManager.getConfigProvider();
    const overrides = ConfigManager.getProviderOverrides();
    return {
      defaultBaseUrl: providerConfigs[providerKey]?.baseUrl,
      override: overrides[providerKey]?.baseUrl
    };
  }
};

// src/providers/minimax/minimaxWizard.ts
var MiniMaxWizard = class _MiniMaxWizard {
  static PROVIDER_KEY = "minimax";
  static CODING_PLAN_KEY = "minimax-coding";
  /**
   * Start MiniMax configuration wizard
   * Allows users to choose which key type to configure
   */
  static async startWizard(displayName, apiKeyTemplate) {
    try {
      const currentEndpoint = ConfigManager.getMinimaxEndpoint();
      const endpointLabel = currentEndpoint === "minimax.io" ? "International (minimax.io)" : "China (minimaxi.com)";
      const choice = await vscode24.window.showQuickPick(
        [
          {
            label: "$(key) Configure Regular API Key",
            detail: "For standard pay-as-you-go models like MiniMax-M2",
            value: "normal"
          },
          {
            label: "$(key) Configure Coding Plan Dedicated Key",
            detail: "For MiniMax-M2 (Coding Plan) model",
            value: "coding"
          },
          {
            label: "$(check-all) Configure Both Keys",
            detail: "Configure regular key and Coding Plan key in sequence",
            value: "both"
          },
          {
            label: "$(globe) Set Coding Plan Endpoint",
            description: `Current: ${endpointLabel}`,
            detail: "Set the endpoint site for Coding Plan: China (minimaxi.com) or International (minimax.io)",
            value: "endpoint"
          },
          {
            label: "$(globe) Configure Base URL (Proxy)",
            detail: "Override MiniMax endpoint (optional)",
            value: "baseUrl"
          }
        ],
        {
          title: `${displayName} Key Configuration`,
          placeHolder: "Please select an option to configure"
        }
      );
      if (!choice) {
        Logger.debug("User cancelled MiniMax configuration wizard");
        return;
      }
      if (choice.value === "normal" || choice.value === "both") {
        await _MiniMaxWizard.setNormalApiKey(displayName, apiKeyTemplate);
      }
      if (choice.value === "coding" || choice.value === "both") {
        await _MiniMaxWizard.setCodingPlanApiKey(displayName, apiKeyTemplate);
      }
      if (choice.value === "endpoint") {
        await _MiniMaxWizard.setCodingPlanEndpoint(displayName);
      }
      if (choice.value === "baseUrl") {
        await ProviderWizard.configureBaseUrl("minimax", displayName);
      }
    } catch (error2) {
      Logger.error(
        `MiniMax configuration wizard error: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
  /**
   * Set regular API key
   */
  static async setNormalApiKey(displayName, apiKeyTemplate) {
    const result = await vscode24.window.showInputBox({
      prompt: `Enter ${displayName} regular API Key (leave empty to clear)`,
      title: `Set ${displayName} Regular API Key`,
      placeHolder: apiKeyTemplate,
      password: true,
      validateInput: (value) => {
        if (!value || value.trim() === "") {
          return null;
        }
        return null;
      }
    });
    if (result === void 0) {
      return;
    }
    try {
      if (result.trim() === "") {
        Logger.info(`${displayName} regular API Key cleared`);
        await ApiKeyManager.deleteApiKey(_MiniMaxWizard.PROVIDER_KEY);
        vscode24.window.showInformationMessage(
          `${displayName} regular API Key cleared`
        );
      } else {
        await ApiKeyManager.setApiKey(
          _MiniMaxWizard.PROVIDER_KEY,
          result.trim()
        );
        Logger.info(`${displayName} regular API Key set`);
        vscode24.window.showInformationMessage(
          `${displayName} regular API Key set`
        );
      }
    } catch (error2) {
      Logger.error(
        `Regular API Key operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
      vscode24.window.showErrorMessage(
        `Setup failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
  /**
   * Set Coding Plan dedicated key
   */
  static async setCodingPlanApiKey(displayName, apiKeyTemplate) {
    const result = await vscode24.window.showInputBox({
      prompt: `Enter ${displayName} Coding Plan dedicated API Key (leave empty to clear)`,
      title: `Set ${displayName} Coding Plan Dedicated API Key`,
      placeHolder: apiKeyTemplate,
      password: true,
      validateInput: (value) => {
        if (!value || value.trim() === "") {
          return null;
        }
        return null;
      }
    });
    if (result === void 0) {
      return;
    }
    try {
      if (result.trim() === "") {
        Logger.info(`${displayName} Coding Plan dedicated API Key cleared`);
        await ApiKeyManager.deleteApiKey(_MiniMaxWizard.CODING_PLAN_KEY);
        vscode24.window.showInformationMessage(
          `${displayName} Coding Plan dedicated API Key cleared`
        );
      } else {
        await ApiKeyManager.setApiKey(
          _MiniMaxWizard.CODING_PLAN_KEY,
          result.trim()
        );
        Logger.info(`${displayName} Coding Plan dedicated API Key set`);
        vscode24.window.showInformationMessage(
          `${displayName} Coding Plan dedicated API Key set`
        );
        await _MiniMaxWizard.setCodingPlanEndpoint(displayName);
      }
    } catch (error2) {
      Logger.error(
        `Coding Plan API Key operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
      vscode24.window.showErrorMessage(
        `Setup failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
  /**
   * Select Coding Plan endpoint (China/International)
   */
  static async setCodingPlanEndpoint(displayName) {
    try {
      const choice = await vscode24.window.showQuickPick(
        [
          {
            label: "$(home) China (minimaxi.com)",
            value: "minimaxi.com"
          },
          {
            label: "$(globe) International (minimax.io)",
            value: "minimax.io"
          }
        ],
        {
          title: `${displayName} (Coding Plan) Endpoint Selection`,
          placeHolder: "Please select an endpoint",
          canPickMany: false
        }
      );
      if (!choice) {
        Logger.debug(
          `User cancelled ${displayName} Coding Plan endpoint selection`
        );
        return;
      }
      await _MiniMaxWizard.saveCodingPlanSite(choice.value);
      const siteLabel = choice.value === "minimax.io" ? "International" : "China";
      Logger.info(`${displayName} Coding Plan endpoint set to: ${siteLabel}`);
      vscode24.window.showInformationMessage(
        `${displayName} Coding Plan endpoint set to: ${siteLabel}`
      );
    } catch (error2) {
      Logger.error(
        `Coding Plan endpoint setup failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
  /**
   * Save Coding Plan endpoint configuration
   */
  static async saveCodingPlanSite(site) {
    try {
      const config2 = vscode24.workspace.getConfiguration("chp.minimax");
      await config2.update("endpoint", site, vscode24.ConfigurationTarget.Global);
      Logger.info(`Coding Plan endpoint saved: ${site}`);
    } catch (error2) {
      Logger.error(
        `Failed to save Coding Plan endpoint: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
      throw error2;
    }
  }
};

// src/providers/mistral/mistralHandler.ts
var vscode25 = __toESM(require("vscode"));
init_accountQuotaCache();
init_apiKeyManager();
init_configManager();
init_logger();
var MistralHandler = class {
  constructor(provider, displayName, baseURL = "https://api.mistral.ai/v1") {
    this.provider = provider;
    this.displayName = displayName;
    this.baseURL = baseURL;
    this.quotaCache = AccountQuotaCache.getInstance();
  }
  toolCallIdMapping = /* @__PURE__ */ new Map();
  reverseToolCallIdMapping = /* @__PURE__ */ new Map();
  quotaCache;
  /**
   * Generate a valid VS Code tool call ID (alphanumeric, exactly 9 characters)
   */
  generateToolCallId() {
    const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    let id = "";
    for (let i = 0; i < 9; i++) {
      id += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return id;
  }
  /**
   * Get or create a VS Code-compatible tool call ID from a Mistral tool call ID
   */
  getOrCreateVsCodeToolCallId(mistralId) {
    if (this.reverseToolCallIdMapping.has(mistralId)) {
      return this.reverseToolCallIdMapping.get(mistralId);
    }
    const vsCodeId = this.generateToolCallId();
    this.toolCallIdMapping.set(vsCodeId, mistralId);
    this.reverseToolCallIdMapping.set(mistralId, vsCodeId);
    return vsCodeId;
  }
  /**
   * Get the original Mistral tool call ID from a VS Code tool call ID
   */
  getMistralToolCallId(vsCodeId) {
    return this.toolCallIdMapping.get(vsCodeId);
  }
  /**
   * Clear tool call ID mappings
   */
  clearToolCallIdMappings() {
    this.toolCallIdMapping.clear();
    this.reverseToolCallIdMapping.clear();
  }
  /**
   * Handle chat completion request
   */
  async handleRequest(model, modelConfig, messages, options, progress, token, accountId) {
    await RateLimiter.getInstance(this.provider, 2, 1e3).throttle(
      this.displayName
    );
    this.clearToolCallIdMappings();
    Logger.debug(
      `${model.name} starting to process Mistral request${accountId ? ` (Account ID: ${accountId})` : ""}`
    );
    try {
      let apiKey = modelConfig.apiKey;
      if (!apiKey) {
        apiKey = await ApiKeyManager.getApiKey(this.provider);
      }
      if (!apiKey) {
        throw new Error(`Missing ${this.displayName} API key`);
      }
      const baseURL = modelConfig.baseUrl || this.baseURL;
      const requestModel = modelConfig.model || model.id;
      const mistralMessages = this.convertMessagesToMistral(messages);
      const mistralTools = options.tools && options.tools.length > 0 ? this.convertToolsToMistral([...options.tools]) : void 0;
      const body = {
        model: requestModel,
        messages: mistralMessages,
        tools: mistralTools,
        tool_choice: mistralTools ? options.toolMode === vscode25.LanguageModelChatToolMode.Required ? "any" : "auto" : void 0,
        max_tokens: ConfigManager.getMaxTokensForModel(model.maxOutputTokens),
        temperature: ConfigManager.getTemperature(),
        top_p: ConfigManager.getTopP(),
        stream: true
      };
      const response = await fetch(`${baseURL}/chat/completions`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`,
          "User-Agent": VersionManager.getUserAgent("Mistral")
        },
        body: JSON.stringify(body),
        signal: this.createAbortSignal(token)
      });
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(
          `Mistral API error: ${response.status} ${response.statusText} - ${errorText}`
        );
      }
      if (!response.body) {
        throw new Error("Mistral response body is empty");
      }
      const usage = await this.processStream(
        response.body,
        progress,
        token,
        model.name
      );
      let promptTokens = usage.promptTokens;
      let completionTokens = usage.completionTokens;
      let totalTokens = usage.totalTokens;
      let estimatedPromptTokens = false;
      if (promptTokens === void 0) {
        try {
          promptTokens = await TokenCounter.getInstance().countMessagesTokens(
            model,
            [...messages],
            { sdkMode: modelConfig.sdkMode || "openai" },
            options
          );
          completionTokens = 0;
          totalTokens = promptTokens;
          estimatedPromptTokens = true;
        } catch (e) {
          Logger.trace(
            `${model.name} failed to estimate prompt tokens: ${String(e)}`
          );
        }
      }
      if (promptTokens !== void 0 && completionTokens !== void 0) {
        TokenTelemetryTracker.getInstance().recordSuccess({
          modelId: model.id,
          modelName: model.name,
          providerId: this.provider,
          promptTokens,
          completionTokens,
          totalTokens,
          maxInputTokens: model.maxInputTokens,
          maxOutputTokens: model.maxOutputTokens,
          estimatedPromptTokens
        });
      }
      if (accountId) {
        await this.quotaCache.recordSuccess(accountId, this.provider);
      }
    } catch (error2) {
      if (accountId && !(error2 instanceof vscode25.CancellationError)) {
        if (this.isQuotaError(error2)) {
          await this.quotaCache.markQuotaExceeded(accountId, this.provider, {
            error: error2 instanceof Error ? error2.message : String(error2),
            affectedModel: model.id
          });
        } else {
          await this.quotaCache.recordFailure(
            accountId,
            this.provider,
            error2 instanceof Error ? error2.message : String(error2)
          );
        }
      }
      if (error2 instanceof vscode25.CancellationError) {
        Logger.info(`${model.name} request cancelled by user`);
        throw error2;
      }
      Logger.error(`${model.name} Mistral request failed: ${error2}`);
      throw error2;
    }
  }
  createAbortSignal(token) {
    const controller = new AbortController();
    token.onCancellationRequested(() => controller.abort());
    return controller.signal;
  }
  async processStream(body, progress, token, modelName) {
    const reader = body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    const toolCallBuffers = /* @__PURE__ */ new Map();
    const emittedToolCalls = /* @__PURE__ */ new Set();
    let hasReceivedContent = false;
    let hasThinkingContent = false;
    let finalUsage;
    try {
      while (true) {
        const { done, value } = await reader.read();
        if (done || token.isCancellationRequested) {
          break;
        }
        buffer += decoder.decode(value, { stream: true });
        const lines = buffer.split("\n");
        buffer = lines.pop() || "";
        for (const line of lines) {
          const trimmedLine = line.trim();
          if (!trimmedLine || !trimmedLine.startsWith("data:")) {
            continue;
          }
          const data = trimmedLine.slice(5).trim();
          if (data === "[DONE]") {
            break;
          }
          try {
            const chunk = JSON.parse(data);
            if (chunk.choices && chunk.choices.length > 0) {
              for (const choice of chunk.choices) {
                const toolCalls = choice.delta?.tool_calls ?? choice.message?.tool_calls;
                if (!toolCalls) {
                  continue;
                }
                for (const toolCall of toolCalls) {
                  if (!toolCall.type) {
                    toolCall.type = "function";
                  }
                }
              }
            }
            if (chunk.choices && chunk.choices.length > 0) {
              const choice = chunk.choices[0];
              const delta = choice.delta;
              const message = choice.message;
              const content = delta?.content ?? message?.content;
              const toolCalls = delta?.tool_calls ?? message?.tool_calls;
              if (content) {
                progress.report(
                  new vscode25.LanguageModelTextPart(content)
                );
                if (content.trim().length > 0) {
                  hasReceivedContent = true;
                }
              }
              if (toolCalls) {
                for (const toolCall of toolCalls) {
                  const mistralId = toolCall.id;
                  if (!mistralId) {
                    continue;
                  }
                  const vsCodeId = this.getOrCreateVsCodeToolCallId(mistralId);
                  const buf = toolCallBuffers.get(vsCodeId) ?? { argsText: "" };
                  if (toolCall.function?.name) {
                    buf.name = toolCall.function.name;
                  }
                  if (toolCall.function?.arguments) {
                    buf.argsText += toolCall.function.arguments;
                  }
                  toolCallBuffers.set(vsCodeId, buf);
                  if (!emittedToolCalls.has(vsCodeId) && buf.name && buf.argsText) {
                    try {
                      const parsedArgs = JSON.parse(buf.argsText);
                      progress.report(
                        new vscode25.LanguageModelToolCallPart(
                          vsCodeId,
                          buf.name,
                          parsedArgs
                        )
                      );
                      emittedToolCalls.add(vsCodeId);
                      hasReceivedContent = true;
                    } catch {
                    }
                  }
                }
              }
              if (choice.finish_reason === "tool_calls" || choice.finish_reason === "stop") {
                for (const [vsCodeId, buf] of toolCallBuffers) {
                  if (!emittedToolCalls.has(vsCodeId) && buf.name) {
                    let parsedArgs = {};
                    try {
                      parsedArgs = buf.argsText ? JSON.parse(buf.argsText) : {};
                    } catch {
                      parsedArgs = { raw: buf.argsText };
                    }
                    progress.report(
                      new vscode25.LanguageModelToolCallPart(
                        vsCodeId,
                        buf.name,
                        parsedArgs
                      )
                    );
                    emittedToolCalls.add(vsCodeId);
                    hasReceivedContent = true;
                  }
                }
              }
            }
            if (chunk.usage) {
              finalUsage = chunk.usage;
              Logger.info(
                `${modelName} Token usage: ${chunk.usage.prompt_tokens}+${chunk.usage.completion_tokens}=${chunk.usage.total_tokens}`
              );
            }
          } catch (e) {
            Logger.trace(`Failed to parse Mistral chunk: ${e}`);
          }
        }
      }
    } finally {
      reader.releaseLock();
    }
    if (hasThinkingContent && !hasReceivedContent) {
      progress.report(new vscode25.LanguageModelTextPart("<think/>"));
      Logger.warn(
        `${modelName} end of message stream has only thinking content and no text content, added <think/> placeholder as output`
      );
    }
    return {
      promptTokens: finalUsage?.prompt_tokens,
      completionTokens: finalUsage?.completion_tokens,
      totalTokens: finalUsage?.total_tokens
    };
  }
  convertMessagesToMistral(messages) {
    const result = [];
    for (const msg of messages) {
      const role = this.toMistralRole(msg.role);
      const content = this.extractTextContent(msg.content);
      const mistralMsg = {
        role,
        content: content || null
      };
      if (msg.role === vscode25.LanguageModelChatMessageRole.Assistant) {
        const toolCalls = [];
        for (const part of msg.content) {
          if (part instanceof vscode25.LanguageModelToolCallPart) {
            let mistralId = this.getMistralToolCallId(part.callId);
            if (!mistralId) {
              mistralId = this.generateToolCallId();
              this.toolCallIdMapping.set(part.callId, mistralId);
              this.reverseToolCallIdMapping.set(mistralId, part.callId);
            }
            toolCalls.push({
              id: mistralId,
              type: "function",
              function: {
                name: part.name,
                arguments: JSON.stringify(part.input)
              }
            });
          }
        }
        if (toolCalls.length > 0) {
          mistralMsg.tool_calls = toolCalls;
        }
      }
      if (msg.role === vscode25.LanguageModelChatMessageRole.User) {
        for (const part of msg.content) {
          if (part instanceof vscode25.LanguageModelToolResultPart) {
            let mistralId = this.getMistralToolCallId(part.callId);
            if (!mistralId) {
              mistralId = this.generateToolCallId();
              this.toolCallIdMapping.set(part.callId, mistralId);
              this.reverseToolCallIdMapping.set(mistralId, part.callId);
            }
            const toolResultContent = this.extractTextContent(part.content);
            result.push({
              role: "tool",
              content: toolResultContent || "",
              tool_call_id: mistralId,
              name: void 0
              // Mistral doesn't strictly require name here if tool_call_id is present
            });
          }
        }
      }
      if (mistralMsg.role !== "tool" && (mistralMsg.content || mistralMsg.tool_calls && mistralMsg.tool_calls.length > 0)) {
        result.push(mistralMsg);
      }
    }
    return result;
  }
  toMistralRole(role) {
    switch (role) {
      case vscode25.LanguageModelChatMessageRole.System:
        return "system";
      case vscode25.LanguageModelChatMessageRole.User:
        return "user";
      case vscode25.LanguageModelChatMessageRole.Assistant:
        return "assistant";
      default:
        return "user";
    }
  }
  isQuotaError(error2) {
    if (!(error2 instanceof Error)) {
      return false;
    }
    const msg = error2.message;
    return msg.startsWith("Quota exceeded") || msg.startsWith("Rate limited") || msg.includes("429");
  }
  extractTextContent(content) {
    const textParts = content.filter((part) => part instanceof vscode25.LanguageModelTextPart).map((part) => part.value);
    return textParts.length > 0 ? textParts.join("\n") : null;
  }
  convertToolsToMistral(tools) {
    return tools.map((tool) => ({
      type: "function",
      function: {
        name: tool.name,
        description: tool.description || "",
        parameters: tool.inputSchema || { type: "object", properties: {} }
      }
    }));
  }
};

// src/providers/moonshot/moonshotWizard.ts
var vscode26 = __toESM(require("vscode"));
init_apiKeyManager();
init_logger();
var MoonshotWizard = class _MoonshotWizard {
  static PROVIDER_KEY = "moonshot";
  static KIMI_KEY = "kimi";
  /**
   * Start the MoonshotAI configuration wizard
   * Allows users to choose which key type to configure
   */
  static async startWizard(displayName, apiKeyTemplate) {
    try {
      const choice = await vscode26.window.showQuickPick(
        [
          {
            label: "$(key) Configure Moonshot API Key",
            detail: "API key for calling Kimi-K2 series and other models on Moonshot AI Open Platform",
            value: "moonshot"
          },
          {
            label: "$(key) Configure Kimi For Coding Dedicated Key",
            detail: "Dedicated key for code development scenarios provided as a premium benefit in Kimi membership plan",
            value: "kimi"
          },
          {
            label: "$(check-all) Configure Both Keys",
            detail: "Configure Moonshot API key and Kimi For Coding dedicated key in sequence",
            value: "both"
          },
          {
            label: "$(globe) Configure Base URL (Proxy)",
            detail: "Override MoonshotAI endpoint (optional)",
            value: "baseUrl"
          }
        ],
        {
          title: `${displayName} Key Configuration`,
          placeHolder: "Please select the item to configure"
        }
      );
      if (!choice) {
        Logger.debug("User cancelled the MoonshotAI configuration wizard");
        return;
      }
      if (choice.value === "moonshot" || choice.value === "both") {
        await _MoonshotWizard.setMoonshotApiKey(displayName, apiKeyTemplate);
      }
      if (choice.value === "kimi" || choice.value === "both") {
        await _MoonshotWizard.setKimiApiKey(displayName);
      }
      if (choice.value === "baseUrl") {
        await ProviderWizard.configureBaseUrl("moonshot", displayName);
      }
    } catch (error2) {
      Logger.error(
        `MoonshotAI configuration wizard error: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
  /**
   * Set Moonshot API Key
   */
  static async setMoonshotApiKey(displayName, apiKeyTemplate) {
    const result = await vscode26.window.showInputBox({
      prompt: `Enter ${displayName} API Key (leave empty to clear)`,
      title: `Set ${displayName} API Key`,
      placeHolder: apiKeyTemplate,
      password: true,
      validateInput: (value) => {
        if (!value || value.trim() === "") {
          return null;
        }
        return null;
      }
    });
    if (result === void 0) {
      return;
    }
    try {
      if (result.trim() === "") {
        Logger.info(`${displayName} API Key cleared`);
        await ApiKeyManager.deleteApiKey(_MoonshotWizard.PROVIDER_KEY);
        vscode26.window.showInformationMessage(`${displayName} API Key cleared`);
      } else {
        await ApiKeyManager.setApiKey(
          _MoonshotWizard.PROVIDER_KEY,
          result.trim()
        );
        Logger.info(`${displayName} API Key set`);
        vscode26.window.showInformationMessage(`${displayName} API Key set`);
      }
    } catch (error2) {
      Logger.error(
        `Moonshot API Key operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
      vscode26.window.showErrorMessage(
        `Setup failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
  /**
   * Set Kimi For Coding Dedicated Key
   */
  static async setKimiApiKey(_displayName) {
    const result = await vscode26.window.showInputBox({
      prompt: "Enter Kimi For Coding dedicated API Key (leave empty to clear)",
      title: "Set Kimi For Coding Dedicated API Key",
      placeHolder: "sk-kimi-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      password: true,
      validateInput: (value) => {
        if (!value || value.trim() === "") {
          return null;
        }
        return null;
      }
    });
    if (result === void 0) {
      return;
    }
    try {
      if (result.trim() === "") {
        Logger.info("Kimi For Coding dedicated API Key cleared");
        await ApiKeyManager.deleteApiKey(_MoonshotWizard.KIMI_KEY);
        vscode26.window.showInformationMessage(
          "Kimi For Coding dedicated API Key cleared"
        );
      } else {
        await ApiKeyManager.setApiKey(_MoonshotWizard.KIMI_KEY, result.trim());
        Logger.info("Kimi For Coding dedicated API Key set");
        vscode26.window.showInformationMessage(
          "Kimi For Coding dedicated API Key set"
        );
      }
    } catch (error2) {
      Logger.error(
        `Kimi For Coding API Key operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
      vscode26.window.showErrorMessage(
        `Setup failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
};

// src/providers/zhipu/zhipuWizard.ts
var vscode27 = __toESM(require("vscode"));
init_apiKeyManager();
init_configManager();
init_logger();
var ZhipuWizard = class _ZhipuWizard {
  static PROVIDER_KEY = "zhipu";
  /**
   * Start configuration wizard
   * Directly enter settings menu, no need to check API key first
   */
  static async startWizard(displayName, apiKeyTemplate) {
    try {
      const currentMCPStatus = ConfigManager.getZhipuSearchConfig().enableMCP;
      const mcpStatusText = currentMCPStatus ? "Enabled" : "Disabled";
      const currentEndpoint = ConfigManager.getZhipuEndpoint();
      const endpointLabel = currentEndpoint === "api.z.ai" ? "International (api.z.ai)" : "Domestic (open.bigmodel.cn)";
      const currentPlan = ConfigManager.getZhipuPlan();
      const planLabel = currentPlan === "coding" ? "Coding Plan (/api/coding/paas/v4)" : "Normal (/api/paas/v4)";
      const choice = await vscode27.window.showQuickPick(
        [
          {
            label: `$(key) Configure ${displayName} API Key`,
            detail: `Set or delete ${displayName} API Key`,
            action: "updateApiKey"
          },
          {
            label: "$(plug) Enable MCP Search Mode",
            description: `Current: ${mcpStatusText}`,
            detail: "Use search quota in Coding Plan plan, Lite(100 trial)/Pro(1K searches)/Max(4K searches)",
            action: "toggleMCP"
          },
          {
            label: "$(globe) Set Endpoint",
            description: `Current: ${endpointLabel}`,
            detail: "Set ZhipuAI endpoint: Domestic (open.bigmodel.cn) or International (api.z.ai)",
            action: "endpoint"
          },
          {
            label: "$(code) Set Plan Type",
            description: `Current: ${planLabel}`,
            detail: "Coding Plan: /api/coding/paas/v4 (GLM Coding Plan), Normal: /api/paas/v4 (standard billing)",
            action: "plan"
          },
          {
            label: "$(lightbulb) Set Thinking Mode",
            description: `Current: ${ConfigManager.getZhipuThinking()}`,
            detail: "Deep thinking mode: enabled, disabled, or auto (GLM-4.5+)",
            action: "thinking"
          },
          {
            label: "$(globe) Configure Base URL (Proxy)",
            detail: "Override ZhipuAI endpoint (optional)",
            action: "baseUrl"
          }
        ],
        {
          title: `${displayName} Configuration Menu`,
          placeHolder: "Select action to perform"
        }
      );
      if (!choice) {
        Logger.debug("User cancelled ZhipuAI configuration wizard");
        return;
      }
      if (choice.action === "updateApiKey") {
        const hasApiKey = await ApiKeyManager.hasValidApiKey(
          _ZhipuWizard.PROVIDER_KEY
        );
        if (!hasApiKey) {
          Logger.debug("No API key detected, starting API key setup process");
          const apiKeySet = await _ZhipuWizard.showSetApiKeyStep(
            displayName,
            apiKeyTemplate
          );
          if (!apiKeySet) {
            Logger.debug("User cancelled API key setup");
            return;
          }
          Logger.debug(
            "API key setup successful, entering MCP search configuration"
          );
          await _ZhipuWizard.showMCPConfigStep(displayName);
        } else {
          const apiKeySet = await _ZhipuWizard.showSetApiKeyStep(
            displayName,
            apiKeyTemplate
          );
          if (!apiKeySet) {
            return;
          }
        }
      } else if (choice.action === "toggleMCP") {
        await _ZhipuWizard.showMCPConfigStep(displayName);
      } else if (choice.action === "endpoint") {
        await _ZhipuWizard.setEndpoint(displayName);
      } else if (choice.action === "plan") {
        await _ZhipuWizard.setPlan(displayName);
      } else if (choice.action === "thinking") {
        await _ZhipuWizard.setThinking(displayName);
      } else if (choice.action === "baseUrl") {
        await ProviderWizard.configureBaseUrl("zhipu", displayName);
      }
    } catch (error2) {
      Logger.error(
        `ZhipuAI configuration wizard error: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
  /**
   * Show API key setup step
   * Allows user to enter empty value to clear API key
   */
  static async showSetApiKeyStep(displayName, apiKeyTemplate) {
    const result = await vscode27.window.showInputBox({
      prompt: `Enter ${displayName} API Key (leave empty to clear)`,
      title: `Set ${displayName} API Key`,
      placeHolder: apiKeyTemplate,
      password: true,
      validateInput: (value) => {
        if (!value || value.trim() === "") {
          return null;
        }
        return null;
      }
    });
    if (result === void 0) {
      return false;
    }
    try {
      if (result.trim() === "") {
        Logger.info(`${displayName} API Key cleared`);
        await ApiKeyManager.deleteApiKey(_ZhipuWizard.PROVIDER_KEY);
      } else {
        await ApiKeyManager.setApiKey(_ZhipuWizard.PROVIDER_KEY, result.trim());
        Logger.info(`${displayName} API Key set`);
      }
      return true;
    } catch (error2) {
      Logger.error(
        `API Key operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
      return false;
    }
  }
  /**
   * Show MCP search configuration step
   */
  static async showMCPConfigStep(displayName) {
    const choice = await vscode27.window.showQuickPick(
      [
        {
          label: "$(x) Do not enable MCP Search Mode",
          detail: "Use Web Search API pay-as-you-go interface, use when plan quota is exhausted or advanced search features are needed",
          action: "disableMCP"
        },
        {
          label: "$(check) Enable MCP Search Mode",
          detail: "Use search quota in Coding Plan plan, Lite(100 trial)/Pro(1K searches)/Max(4K searches)",
          action: "enableMCP"
        }
      ],
      {
        title: `${displayName} MCP Search Service Configuration Communication Mode Settings`,
        placeHolder: "Choose whether to enable MCP communication mode for search service"
      }
    );
    if (!choice) {
      return;
    }
    try {
      if (choice.action === "enableMCP") {
        await _ZhipuWizard.setMCPConfig(true);
      } else {
        await _ZhipuWizard.setMCPConfig(false);
      }
    } catch (error2) {
      Logger.error(
        `MCP configuration failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
      vscode27.window.showErrorMessage(
        `MCP configuration failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
  /**
   * Set MCP configuration
   */
  static async setMCPConfig(enable) {
    try {
      const config2 = vscode27.workspace.getConfiguration("chp");
      await config2.update(
        "zhipu.search.enableMCP",
        enable,
        vscode27.ConfigurationTarget.Global
      );
      Logger.info(
        `Zhipu MCP search service ${enable ? "enabled" : "disabled"}`
      );
    } catch (error2) {
      const errorMessage = `Failed to set MCP configuration: ${error2 instanceof Error ? error2.message : "Unknown error"}`;
      Logger.error(errorMessage);
      throw error2;
    }
  }
  /**
   * Set endpoint
   */
  static async setEndpoint(displayName) {
    const currentEndpoint = ConfigManager.getZhipuEndpoint();
    const endpointLabel = currentEndpoint === "api.z.ai" ? "International (api.z.ai)" : "Domestic (open.bigmodel.cn)";
    const choice = await vscode27.window.showQuickPick(
      [
        {
          label: "$(home) Domestic (open.bigmodel.cn)",
          detail: "Recommended, faster domestic access",
          value: "open.bigmodel.cn"
        },
        {
          label: "$(globe) International (api.z.ai)",
          detail: "Use for overseas users or when domestic site access is restricted",
          value: "api.z.ai"
        }
      ],
      {
        title: `${displayName} Endpoint Selection`,
        placeHolder: `Current: ${endpointLabel}`
      }
    );
    if (!choice) {
      return;
    }
    try {
      const config2 = vscode27.workspace.getConfiguration("chp.zhipu");
      await config2.update(
        "endpoint",
        choice.value,
        vscode27.ConfigurationTarget.Global
      );
      Logger.info(`ZhipuAI endpoint set to ${choice.value}`);
      vscode27.window.showInformationMessage(
        `ZhipuAI endpoint set to ${choice.value === "api.z.ai" ? "International" : "Domestic"}`
      );
    } catch (error2) {
      const errorMessage = `Failed to set endpoint: ${error2 instanceof Error ? error2.message : "Unknown error"}`;
      Logger.error(errorMessage);
      vscode27.window.showErrorMessage(errorMessage);
    }
  }
  /**
   * Set plan type (coding or normal)
   */
  static async setPlan(displayName) {
    const currentPlan = ConfigManager.getZhipuPlan();
    const planLabel = currentPlan === "coding" ? "Coding Plan" : "Normal";
    const choice = await vscode27.window.showQuickPick(
      [
        {
          label: "$(code) Coding Plan",
          detail: "Use /api/coding/paas/v4 endpoint - for GLM Coding Plan subscribers",
          value: "coding"
        },
        {
          label: "$(globe) Normal",
          detail: "Use /api/paas/v4 endpoint - for standard billing (pay-per-use)",
          value: "normal"
        }
      ],
      {
        title: `${displayName} Plan Type Selection`,
        placeHolder: `Current: ${planLabel}`
      }
    );
    if (!choice) {
      return;
    }
    try {
      const config2 = vscode27.workspace.getConfiguration("chp.zhipu");
      await config2.update(
        "plan",
        choice.value,
        vscode27.ConfigurationTarget.Global
      );
      Logger.info(`ZhipuAI plan set to ${choice.value}`);
      vscode27.window.showInformationMessage(
        `ZhipuAI plan set to ${choice.value === "coding" ? "Coding Plan" : "Normal"}`
      );
    } catch (error2) {
      const errorMessage = `Failed to set plan: ${error2 instanceof Error ? error2.message : "Unknown error"}`;
      Logger.error(errorMessage);
      vscode27.window.showErrorMessage(errorMessage);
    }
  }
  /**
   * Get current MCP status
   */
  static getMCPStatus() {
    return ConfigManager.getZhipuSearchConfig().enableMCP;
  }
  /**
   * Set thinking mode (enabled, disabled, or auto)
   */
  static async setThinking(displayName) {
    const currentThinking = ConfigManager.getZhipuThinking();
    const currentClearThinking = ConfigManager.getZhipuClearThinking();
    const choice = await vscode27.window.showQuickPick(
      [
        {
          label: "$(lightbulb) Enabled",
          detail: "Always enable deep thinking (GLM-4.5+ models)",
          value: "enabled"
        },
        {
          label: "$(debug-disconnect) Disabled",
          detail: "Disable deep thinking for faster responses",
          value: "disabled"
        },
        {
          label: "$(question) Auto",
          detail: "Let the model decide when to use thinking",
          value: "auto"
        }
      ],
      {
        title: `${displayName} Thinking Mode`,
        placeHolder: `Current: ${currentThinking}`
      }
    );
    if (!choice) {
      return;
    }
    try {
      const config2 = vscode27.workspace.getConfiguration("chp.zhipu");
      await config2.update(
        "thinking",
        choice.value,
        vscode27.ConfigurationTarget.Global
      );
      const clearChoice = await vscode27.window.showQuickPick(
        [
          {
            label: "$(sparkle) Clear previous reasoning blocks",
            detail: "clear_thinking=true (recommended). Prior reasoning_content is removed from next-turn context.",
            value: true
          },
          {
            label: "$(history) Preserve previous reasoning blocks",
            detail: "clear_thinking=false. Keep prior reasoning_content in context (requires full ordered history).",
            value: false
          }
        ],
        {
          title: `${displayName} Thinking Context Handling`,
          placeHolder: `Current: ${currentClearThinking ? "Clear previous reasoning" : "Preserve previous reasoning"}`
        }
      );
      if (clearChoice) {
        await config2.update(
          "clearThinking",
          clearChoice.value,
          vscode27.ConfigurationTarget.Global
        );
      }
      Logger.info(`ZhipuAI thinking set to ${choice.value}, clearThinking: ${clearChoice?.value ?? currentClearThinking}`);
      vscode27.window.showInformationMessage(
        `ZhipuAI thinking mode: ${choice.value}`
      );
    } catch (error2) {
      const errorMessage = `Failed to set thinking: ${error2 instanceof Error ? error2.message : "Unknown error"}`;
      Logger.error(errorMessage);
      vscode27.window.showErrorMessage(errorMessage);
    }
  }
};

// src/utils/index.ts
init_apiKeyManager();
init_compatibleModelManager();
init_configManager();

// src/utils/jsonSchemaProvider.ts
var vscode28 = __toESM(require("vscode"));
init_config();
init_compatibleModelManager();
init_configManager();
init_knownProviders();
init_logger();
var JsonSchemaProvider = class _JsonSchemaProvider {
  static SCHEMA_URI = "chp-settings://root/schema.json";
  static schemaProvider = null;
  static lastSchemaHash = null;
  /**
   * Initialize JSON Schema provider
   */
  static initialize() {
    if (_JsonSchemaProvider.schemaProvider) {
      _JsonSchemaProvider.schemaProvider.dispose();
    }
    _JsonSchemaProvider.schemaProvider = vscode28.workspace.registerTextDocumentContentProvider("chp-settings", {
      provideTextDocumentContent: (uri) => {
        if (uri.toString() === _JsonSchemaProvider.SCHEMA_URI) {
          const schema = _JsonSchemaProvider.getProviderOverridesSchema();
          return JSON.stringify(schema, null, 2);
        }
        return "";
      }
    });
    vscode28.workspace.onDidOpenTextDocument((document) => {
      if (document.uri.scheme === "chp-settings") {
        _JsonSchemaProvider.updateSchema();
      }
    });
    vscode28.workspace.onDidChangeConfiguration((e) => {
      if (e.affectsConfiguration("chp")) {
        _JsonSchemaProvider.invalidateCache();
      }
    });
    Logger.info("Dynamic JSON Schema provider initialized");
  }
  /**
   * Invalidate cache, trigger schema update
   */
  static invalidateCache() {
    _JsonSchemaProvider.lastSchemaHash = null;
    _JsonSchemaProvider.updateSchema();
  }
  /**
   * Update Schema
   */
  static updateSchema() {
    try {
      const newSchema = _JsonSchemaProvider.getProviderOverridesSchema();
      const newHash = _JsonSchemaProvider.generateSchemaHash(newSchema);
      if (_JsonSchemaProvider.lastSchemaHash === newHash) {
        return;
      }
      _JsonSchemaProvider.lastSchemaHash = newHash;
      const uri = vscode28.Uri.parse(_JsonSchemaProvider.SCHEMA_URI);
      vscode28.workspace.textDocuments.forEach((doc) => {
        if (doc.uri.toString() === _JsonSchemaProvider.SCHEMA_URI) {
          const newContent = JSON.stringify(newSchema, null, 2);
          const edit = new vscode28.WorkspaceEdit();
          edit.replace(
            uri,
            new vscode28.Range(0, 0, doc.lineCount, 0),
            newContent
          );
          vscode28.workspace.applyEdit(edit);
          Logger.info("JSON Schema updated");
        }
      });
    } catch (error2) {
      Logger.error("Failed to update JSON Schema:", error2);
    }
  }
  /**
   * Generate schema hash for cache comparison
   */
  static generateSchemaHash(schema) {
    return JSON.stringify(schema, Object.keys(schema).sort());
  }
  /**
   * Get JSON Schema for provider override configuration
   */
  static getProviderOverridesSchema() {
    const providerConfigs = ConfigManager.getConfigProvider();
    const patternProperties = {};
    const propertyNames = {
      type: "string",
      description: "Provider configuration key name",
      enum: Object.keys(providerConfigs),
      enumDescriptions: Object.entries(providerConfigs).map(
        ([key, config2]) => config2.displayName || key
      )
    };
    for (const [providerKey, config2] of Object.entries(providerConfigs)) {
      patternProperties[`^${providerKey}$`] = _JsonSchemaProvider.createProviderSchema(providerKey, config2);
    }
    const { providerIds, enumDescriptions: allProviderDescriptions } = _JsonSchemaProvider.getAllAvailableProviders();
    return {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: _JsonSchemaProvider.SCHEMA_URI,
      title: "Copilot ++ Configuration Schema",
      description: "Schema for Copilot ++ configuration with dynamic model ID suggestions",
      type: "object",
      properties: {
        "chp.providerOverrides": {
          type: "object",
          description: "Provider configuration overrides. Allows overriding provider baseUrl and model configuration, supports adding new models or overriding existing model parameters.",
          patternProperties,
          propertyNames
        },
        "chp.fimCompletion.modelConfig": {
          type: "object",
          description: "FIM (Fill-in-the-Middle) completion mode configuration",
          properties: {
            provider: {
              type: "string",
              description: "Provider ID used for FIM completion",
              enum: providerIds,
              enumDescriptions: allProviderDescriptions
            }
          },
          additionalProperties: true
        },
        "chp.nesCompletion.modelConfig": {
          type: "object",
          description: "NES (Next Edit Suggestion) completion mode configuration",
          properties: {
            provider: {
              type: "string",
              description: "Provider ID used for NES completion",
              enum: providerIds,
              enumDescriptions: allProviderDescriptions
            }
          },
          additionalProperties: true
        },
        "chp.compatibleModels": {
          type: "array",
          description: "Custom model configuration for Compatible Provider.",
          default: [],
          items: {
            type: "object",
            properties: {
              id: {
                type: "string",
                description: "Model ID",
                minLength: 1
              },
              name: {
                type: "string",
                description: "Model display name",
                minLength: 1
              },
              tooltip: {
                type: "string",
                description: "Model description"
              },
              provider: {
                type: "string",
                description: "Model provider identifier. Select an existing provider ID from the dropdown list, or enter a new ID to create a custom provider.",
                anyOf: [
                  {
                    type: "string",
                    enum: providerIds,
                    description: "Select existing provider ID"
                  },
                  {
                    type: "string",
                    minLength: 3,
                    maxLength: 100,
                    pattern: "^[a-zA-Z0-9_-]+$",
                    description: "Add new custom provider ID (allows letters, numbers, underscores, hyphens)"
                  }
                ]
              },
              sdkMode: {
                type: "string",
                enum: ["openai", "openai-sse", "anthropic"],
                enumDescriptions: [
                  "OpenAI SDK standard mode, uses official OpenAI SDK for request/response processing",
                  "OpenAI SSE compatibility mode, uses in-plugin SSE parsing logic for streaming response processing",
                  "Anthropic SDK standard mode, uses official Anthropic SDK for request/response processing"
                ],
                description: "SDK mode defaults to openai.",
                default: "openai"
              },
              baseUrl: {
                type: "string",
                description: "API base URL",
                format: "uri"
              },
              model: {
                type: "string",
                description: "Model name used for API requests (optional, defaults to model ID)"
              },
              maxInputTokens: {
                type: "number",
                description: "Maximum input token count",
                minimum: 128
              },
              maxOutputTokens: {
                type: "number",
                description: "Maximum output token count",
                minimum: 8
              },
              outputThinking: {
                type: "boolean",
                description: "Whether to show thinking process in chat interface (recommended for thinking models like Claude Sonnet/Opus 4.5)",
                default: true
              },
              includeThinking: {
                type: "boolean",
                description: "Whether to inject thinking content into context for multi-turn conversations (must be enabled for thinking models)\nDefaults to true, recommended for thinking models to maintain context\nMust be set to true when the model requires tool messages in multi-turn conversations to include thinking content",
                default: true
              },
              capabilities: {
                type: "object",
                properties: {
                  toolCalling: {
                    type: "boolean",
                    description: "Whether tool calling is supported"
                  },
                  imageInput: {
                    type: "boolean",
                    description: "Whether image input is supported"
                  }
                },
                required: ["toolCalling", "imageInput"]
              },
              customHeader: {
                type: "object",
                description: "Custom HTTP header configuration, supports ${APIKEY} placeholder replacement",
                additionalProperties: {
                  type: "string",
                  description: "HTTP header value"
                }
              },
              extraBody: {
                type: "object",
                description: "Extra request body parameters, will be merged into the request body in API requests",
                additionalProperties: {
                  description: "Extra request body parameter value"
                }
              }
            },
            required: [
              "id",
              "name",
              "maxInputTokens",
              "maxOutputTokens",
              "capabilities"
            ]
          }
        }
      },
      additionalProperties: true
    };
  }
  /**
   * Create JSON Schema for a specific provider
   */
  static createProviderSchema(providerKey, config2) {
    const modelIds = config2.models?.map((model) => model.id) || [];
    const idProperty = {
      anyOf: [
        {
          type: "string",
          enum: modelIds,
          description: "Override existing model ID"
        },
        {
          type: "string",
          minLength: 3,
          maxLength: 100,
          pattern: "^[a-zA-Z0-9._-]+$",
          description: "Add new custom model ID (allows letters, numbers, underscores, hyphens, and dots)"
        }
      ],
      description: "Select an existing model ID from the dropdown list, or enter a new ID to create a custom configuration"
    };
    const modelProperty = {
      type: "string",
      minLength: 1,
      description: "Override model name or endpoint ID used for API requests"
    };
    return {
      type: "object",
      description: `${config2.displayName || providerKey} configuration overrides`,
      properties: {
        baseUrl: {
          type: "string",
          description: "Override provider-level API base URL",
          format: "uri"
        },
        customHeader: {
          type: "object",
          description: "Provider-level custom HTTP headers, supports ${APIKEY} placeholder replacement",
          additionalProperties: {
            type: "string",
            description: "HTTP header value"
          }
        },
        models: {
          type: "array",
          description: "Model override configuration list",
          minItems: 1,
          items: {
            type: "object",
            properties: {
              id: idProperty,
              model: modelProperty,
              name: {
                type: "string",
                minLength: 1,
                description: "Friendly name displayed in model selector.\r\nValid for custom model IDs, will not override preset model names."
              },
              tooltip: {
                type: "string",
                minLength: 1,
                description: "Detailed description displayed as hover tooltip.\r\nValid for custom model IDs, will not override preset model descriptions."
              },
              maxInputTokens: {
                type: "number",
                minimum: 1,
                maximum: 2e6,
                description: "Override maximum input token count"
              },
              maxOutputTokens: {
                type: "number",
                minimum: 1,
                maximum: 2e5,
                description: "Override maximum output token count"
              },
              sdkMode: {
                type: "string",
                enum: ["openai", "anthropic"],
                description: "Override SDK mode: openai (OpenAI compatible format) or anthropic (Anthropic compatible format)"
              },
              baseUrl: {
                type: "string",
                description: "Override model-level API base URL",
                format: "uri"
              },
              outputThinking: {
                type: "boolean",
                description: "Whether to show thinking process in chat interface (recommended for thinking models, default true)",
                default: true
              },
              capabilities: {
                type: "object",
                description: "Model capabilities configuration",
                properties: {
                  toolCalling: {
                    type: "boolean",
                    description: "Whether tool calling is supported"
                  },
                  imageInput: {
                    type: "boolean",
                    description: "Whether image input is supported"
                  }
                },
                required: ["toolCalling", "imageInput"],
                additionalProperties: false
              },
              customHeader: {
                type: "object",
                description: "Model custom HTTP headers, supports ${APIKEY} placeholder replacement",
                additionalProperties: {
                  type: "string",
                  description: "HTTP header value"
                }
              },
              extraBody: {
                type: "object",
                description: "Extra request body parameters (optional)",
                additionalProperties: {
                  description: "Extra request body parameter value"
                }
              }
            },
            required: ["id"],
            additionalProperties: false
          }
        }
      },
      additionalProperties: false
    };
  }
  /**
   * Get all available provider IDs (including built-in, known, custom, and historical providers)
   */
  static getAllAvailableProviders() {
    const providerIds = [];
    const enumDescriptions = [];
    try {
      for (const [providerId, config2] of Object.entries(configProviders)) {
        providerIds.push(providerId);
        enumDescriptions.push(config2.displayName || providerId);
      }
      for (const [providerId, config2] of Object.entries(KnownProviders)) {
        if (!providerIds.includes(providerId)) {
          providerIds.push(providerId);
          enumDescriptions.push(config2.displayName || providerId);
        }
      }
      const customModels = CompatibleModelManager.getModels();
      const customProviders = /* @__PURE__ */ new Set();
      for (const model of customModels) {
        if (model.provider?.trim() && !providerIds.includes(model.provider)) {
          customProviders.add(model.provider.trim());
        }
      }
      for (const providerId of Array.from(customProviders).sort()) {
        providerIds.push(providerId);
        enumDescriptions.push(`Custom Provider: ${providerId}`);
      }
    } catch (error2) {
      Logger.error("Failed to get available provider list:", error2);
    }
    return { providerIds, enumDescriptions };
  }
  /**
   * Dispose resources
   */
  static dispose() {
    if (_JsonSchemaProvider.schemaProvider) {
      _JsonSchemaProvider.schemaProvider.dispose();
      _JsonSchemaProvider.schemaProvider = null;
    }
    Logger.trace("Dynamic JSON Schema provider cleaned up");
  }
};

// src/utils/index.ts
init_knownProviders();
init_logger();

// node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    var _a4;
    Object.defineProperty(inst, "_zod", {
      value: inst._zod ?? {},
      enumerable: false
    });
    (_a4 = inst._zod).traits ?? (_a4.traits = /* @__PURE__ */ new Set());
    inst._zod.traits.add(name);
    initializer3(inst, def);
    for (const k in _.prototype) {
      if (!(k in inst))
        Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
    }
    inst._zod.constr = _;
    inst._zod.def = def;
  }
  const Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a4;
    const inst = params?.Parent ? new Definition() : this;
    init(inst, def);
    (_a4 = inst._zod).deferred ?? (_a4.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      if (params?.Parent && inst instanceof params.Parent)
        return true;
      return inst?._zod?.traits?.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever3,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  stringifyPrimitive: () => stringifyPrimitive,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever3(_x) {
  throw new Error();
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set = false;
  return {
    get value() {
      if (!set) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
function defineLazy(object3, key, getter) {
  const set = false;
  Object.defineProperty(object3, key, {
    get() {
      if (!set) {
        const value = getter();
        object3[key] = value;
        return value;
      }
      throw new Error("cached value already set");
    },
    set(v) {
      Object.defineProperty(object3, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function getElementAtPath(obj, path10) {
  if (!path10)
    return obj;
  return path10.reduce((acc, key) => acc?.[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str2 = "";
  for (let i = 0; i < length; i++) {
    str2 += chars[Math.floor(Math.random() * chars.length)];
  }
  return str2;
}
function esc(str2) {
  return JSON.stringify(str2);
}
var captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str2) {
  return str2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || params?.parent)
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const newShape = {};
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    newShape[key] = currDef.shape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function omit(schema, mask) {
  const newShape = { ...schema._zod.def.shape };
  const currDef = schema._zod.def;
  for (const key in mask) {
    if (!(key in currDef.shape)) {
      throw new Error(`Unrecognized key: "${key}"`);
    }
    if (!mask[key])
      continue;
    delete newShape[key];
  }
  return clone(schema, {
    ...schema._zod.def,
    shape: newShape,
    checks: []
  });
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
    // delete existing checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  return clone(a, {
    ...a._zod.def,
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    catchall: b._zod.def.catchall,
    checks: []
    // delete existing checks
  });
}
function partial(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in oldShape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  } else {
    for (const key in oldShape) {
      shape[key] = Class2 ? new Class2({
        type: "optional",
        innerType: oldShape[key]
      }) : oldShape[key];
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    checks: []
  });
}
function required(Class2, schema, mask) {
  const oldShape = schema._zod.def.shape;
  const shape = { ...oldShape };
  if (mask) {
    for (const key in mask) {
      if (!(key in shape)) {
        throw new Error(`Unrecognized key: "${key}"`);
      }
      if (!mask[key])
        continue;
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  } else {
    for (const key in oldShape) {
      shape[key] = new Class2({
        type: "nonoptional",
        innerType: oldShape[key]
      });
    }
  }
  return clone(schema, {
    ...schema._zod.def,
    shape,
    // optional: [],
    checks: []
  });
}
function aborted(x, startIndex = 0) {
  for (let i = startIndex; i < x.issues.length; i++) {
    if (x.issues[i]?.continue !== true)
      return true;
  }
  return false;
}
function prefixIssues(path10, issues) {
  return issues.map((iss) => {
    var _a4;
    (_a4 = iss).path ?? (_a4.path = []);
    iss.path.unshift(path10);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!ctx?.reportInput) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  Object.defineProperty(inst, "message", {
    get() {
      return JSON.stringify(def, jsonStringifyReplacer, 2);
    },
    enumerable: true
    // configurable: false,
  });
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error2, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error2.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error2, _mapper) {
  const mapper = _mapper || function(issue2) {
    return issue2.message;
  };
  const fieldErrors = { _errors: [] };
  const processError = (error3) => {
    for (const issue2 of error3.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error2);
  return fieldErrors;
}

// node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params?.callee);
    throw e;
  }
  return result.value;
};
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params?.callee);
    throw e;
  }
  return result.value;
};
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = /* @__PURE__ */ _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError);

// node_modules/zod/v4/core/regexes.js
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version9) => {
  if (!version9)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version9}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})$/;
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-]\\d{2}:\\d{2})`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^\d+n?$/;
var integer = /^\d+$/;
var number = /^-?\d+(?:\.\d+)?/i;
var boolean = /true|false/i;
var _null = /null/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;

// node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a4;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a4 = inst._zod).onattach ?? (_a4.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a4;
    (_a4 = inst2._zod.bag).multipleOf ?? (_a4.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = def.format?.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a4;
  $ZodCheck.init(inst, def);
  (_a4 = inst._zod.def).when ?? (_a4.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a4;
  $ZodCheck.init(inst, def);
  (_a4 = inst._zod.def).when ?? (_a4.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a4;
  $ZodCheck.init(inst, def);
  (_a4 = inst._zod.def).when ?? (_a4.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a4, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a4 = inst._zod).check ?? (_a4.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this?.args;
    const content = this?.content ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 0,
  patch: 0
};

// node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a4;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a4 = inst._zod).deferred ?? (_a4.deferred = []);
    inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    inst._zod.run = (payload, ctx) => {
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const orig = payload.value;
      const url2 = new URL(orig);
      const href = url2.href;
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (!orig.endsWith("/") && href.endsWith("/")) {
        payload.value = href.slice(0, -1);
      } else {
        payload.value = href;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv4`;
  });
});
var $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = `ipv6`;
  });
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const [address, prefix] = payload.value.split("/");
    try {
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base642 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base642.padEnd(Math.ceil(base642.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.contentEncoding = "base64url";
  });
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handleObjectResult(result, final, key) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  final.value[key] = result.value;
}
function handleOptionalObjectResult(result, final, key, input) {
  if (result.issues.length) {
    if (input[key] === void 0) {
      if (key in input) {
        final.value[key] = void 0;
      } else {
        final.value[key] = result.value;
      }
    } else {
      final.issues.push(...prefixIssues(key, result.issues));
    }
  } else if (result.value === void 0) {
    if (key in input)
      final.value[key] = void 0;
  } else {
    final.value[key] = result.value;
  }
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const _normalized = cached(() => {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
      if (!(def.shape[k] instanceof $ZodType)) {
        throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
      }
    }
    const okeys = optionalKeys(def.shape);
    return {
      shape: def.shape,
      keys,
      keySet: new Set(keys),
      numKeys: keys.length,
      optionalKeys: new Set(okeys)
    };
  });
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {}`);
    for (const key of normalized.keys) {
      if (normalized.optionalKeys.has(key)) {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        const k = esc(key);
        doc.write(`
        if (${id}.issues.length) {
          if (input[${k}] === undefined) {
            if (${k} in input) {
              newResult[${k}] = undefined;
            }
          } else {
            payload.issues = payload.issues.concat(
              ${id}.issues.map((iss) => ({
                ...iss,
                path: iss.path ? [${k}, ...iss.path] : [${k}],
              }))
            );
          }
        } else if (${id}.value === undefined) {
          if (${k} in input) newResult[${k}] = undefined;
        } else {
          newResult[${k}] = ${id}.value;
        }
        `);
      } else {
        const id = ids[key];
        doc.write(`const ${id} = ${parseStr(key)};`);
        doc.write(`
          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]
          })));`);
        doc.write(`newResult[${esc(key)}] = ${id}.value`);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
    } else {
      payload.value = {};
      const shape = value.shape;
      for (const key of value.keys) {
        const el = shape[key];
        const r = el._zod.run({ value: input[key], issues: [] }, ctx);
        const isOptional = el._zod.optin === "optional" && el._zod.optout === "optional";
        if (r instanceof Promise) {
          proms.push(r.then((r2) => isOptional ? handleOptionalObjectResult(r2, payload, key, input) : handleObjectResult(r2, payload, key)));
        } else if (isOptional) {
          handleOptionalObjectResult(r, payload, key, input);
        } else {
          handleObjectResult(r, payload, key);
        }
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    const unrecognized = [];
    const keySet = value.keySet;
    const _catchall = catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
      if (keySet.has(key))
        continue;
      if (t === "never") {
        unrecognized.push(key);
        continue;
      }
      const r = _catchall.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handleObjectResult(r2, payload, key)));
      } else {
        handleObjectResult(r, payload, key);
      }
    }
    if (unrecognized.length) {
      payload.issues.push({
        code: "unrecognized_keys",
        keys: unrecognized,
        input,
        inst
      });
    }
    if (!proms.length)
      return payload;
    return Promise.all(proms).then(() => {
      return payload;
    });
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    const opts = def.options;
    const map = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = o._zod.propValues[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map.set(v, o);
      }
    }
    return map;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input?.[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    if (def.keyType._zod.values) {
      const values = def.keyType._zod.values;
      payload.value = {};
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!values.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            origin: "record",
            code: "invalid_key",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  inst._zod.values = new Set(values);
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.values = new Set(def.values);
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? o.toString() : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (inst._zod.values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const _out = def.transform(payload.value, payload);
    if (_ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def, ctx));
    }
    return handlePipeResult(left, def, ctx);
  };
});
function handlePipeResult(left, def, ctx) {
  if (aborted(left)) {
    return left;
  }
  return def.out._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/zod/v4/locales/en.js
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error()
  };
}

// node_modules/zod/v4/core/registries.js
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta = _meta[0];
    this._map.set(schema, meta);
    if (meta && typeof meta === "object" && "id" in meta) {
      if (this._idmap.has(meta.id)) {
        throw new Error(`ID ${meta.id} already exists in the registry`);
      }
      this._idmap.set(meta.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new Map();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta = this._map.get(schema);
    if (meta && typeof meta === "object" && "id" in meta) {
      this._idmap.delete(meta.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      return { ...pm, ...this._map.get(schema) };
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
var globalRegistry = /* @__PURE__ */ registry();

// node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s) {
  const schema = s;
  return !!schema._zod;
}
function safeParse2(schema, data) {
  if (isZ4Schema(schema)) {
    const result2 = safeParse(schema, data);
    return result2;
  }
  const v3Schema = schema;
  const result = v3Schema.safeParse(data);
  return result;
}
function getObjectShape(schema) {
  if (!schema)
    return void 0;
  let rawShape;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    rawShape = v4Schema._zod?.def?.shape;
  } else {
    const v3Schema = schema;
    rawShape = v3Schema.shape;
  }
  if (!rawShape)
    return void 0;
  if (typeof rawShape === "function") {
    try {
      return rawShape();
    } catch {
      return void 0;
    }
  }
  return rawShape;
}
function getLiteralValue(schema) {
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    const def2 = v4Schema._zod?.def;
    if (def2) {
      if (def2.value !== void 0)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0) {
        return def2.values[0];
      }
    }
  }
  const v3Schema = schema;
  const def = v3Schema._def;
  if (def) {
    if (def.value !== void 0)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0) {
      return def.values[0];
    }
  }
  const directValue = schema.value;
  if (directValue !== void 0)
    return directValue;
  return void 0;
}

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => inst.issues.push(issue2)
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError);
var parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError);
var safeParse3 = /* @__PURE__ */ _safeParse(ZodRealError);
var safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = /* @__PURE__ */ $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = ((reg, meta) => {
    reg.add(inst, meta);
    return inst;
  });
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse3(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      return globalRegistry.get(inst)?.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
var ZodNumber = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
var ZodBoolean = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
var ZodNull = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodDate = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
var ZodArray = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
var ZodObject = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object2(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodRecord = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
var ZodDefault = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodCatch = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodReadonly = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  const ch = check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint2,
  boolean: () => boolean3,
  date: () => date3,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint2(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date3(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());

// node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2025-11-25";
var SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"];
var RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task";
var JSONRPC_VERSION = "2.0";
var AssertObjectSchema = custom((v) => v !== null && (typeof v === "object" || typeof v === "function"));
var ProgressTokenSchema = union([string2(), number2().int()]);
var CursorSchema = string2();
var TaskCreationParamsSchema = looseObject({
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number2(), _null3()]).optional(),
  /**
   * Time in milliseconds to wait between task status requests.
   */
  pollInterval: number2().optional()
});
var TaskMetadataSchema = object2({
  ttl: number2().optional()
});
var RelatedTaskMetadataSchema = object2({
  taskId: string2()
});
var RequestMetaSchema = looseObject({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: ProgressTokenSchema.optional(),
  /**
   * If specified, this request is related to the provided task.
   */
  [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
});
var BaseRequestParamsSchema = object2({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: RequestMetaSchema.optional()
});
var TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * If specified, the caller is requesting task-augmented execution for this request.
   * The request will return a CreateTaskResult immediately, and the actual result can be
   * retrieved later via tasks/result.
   *
   * Task augmentation is subject to capability negotiation - receivers MUST declare support
   * for task augmentation of specific request types in their capabilities.
   */
  task: TaskMetadataSchema.optional()
});
var isTaskAugmentedRequestParams = (value) => TaskAugmentedRequestParamsSchema.safeParse(value).success;
var RequestSchema = object2({
  method: string2(),
  params: BaseRequestParamsSchema.loose().optional()
});
var NotificationsParamsSchema = object2({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
});
var NotificationSchema = object2({
  method: string2(),
  params: NotificationsParamsSchema.loose().optional()
});
var ResultSchema = looseObject({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
});
var RequestIdSchema = union([string2(), number2().int()]);
var JSONRPCRequestSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  ...RequestSchema.shape
}).strict();
var isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;
var JSONRPCNotificationSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  ...NotificationSchema.shape
}).strict();
var isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;
var JSONRPCResultResponseSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict();
var isJSONRPCResultResponse = (value) => JSONRPCResultResponseSchema.safeParse(value).success;
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
  ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
  ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
  ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
  ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
  ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
  ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
  ErrorCode2[ErrorCode2["UrlElicitationRequired"] = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorResponseSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema.optional(),
  error: object2({
    /**
     * The error type that occurred.
     */
    code: number2().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: string2(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: unknown().optional()
  })
}).strict();
var isJSONRPCErrorResponse = (value) => JSONRPCErrorResponseSchema.safeParse(value).success;
var JSONRPCMessageSchema = union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResultResponseSchema,
  JSONRPCErrorResponseSchema
]);
var JSONRPCResponseSchema = union([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]);
var EmptyResultSchema = ResultSchema.strict();
var CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: RequestIdSchema.optional(),
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: string2().optional()
});
var CancelledNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/cancelled"),
  params: CancelledNotificationParamsSchema
});
var IconSchema = object2({
  /**
   * URL or data URI for the icon.
   */
  src: string2(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: string2().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: array(string2()).optional(),
  /**
   * Optional specifier for the theme this icon is designed for. `light` indicates
   * the icon is designed to be used with a light background, and `dark` indicates
   * the icon is designed to be used with a dark background.
   *
   * If not provided, the client should assume the icon can be used with any theme.
   */
  theme: _enum(["light", "dark"]).optional()
});
var IconsSchema = object2({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: array(IconSchema).optional()
});
var BaseMetadataSchema = object2({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: string2(),
  /**
   * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: string2().optional()
});
var ImplementationSchema = BaseMetadataSchema.extend({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  version: string2(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: string2().optional(),
  /**
   * An optional human-readable description of what this implementation does.
   *
   * This can be used by clients or servers to provide context about their purpose
   * and capabilities. For example, a server might describe the types of resources
   * or tools it provides, while a client might describe its intended use case.
   */
  description: string2().optional()
});
var FormElicitationCapabilitySchema = intersection(object2({
  applyDefaults: boolean2().optional()
}), record(string2(), unknown()));
var ElicitationCapabilitySchema = preprocess((value) => {
  if (value && typeof value === "object" && !Array.isArray(value)) {
    if (Object.keys(value).length === 0) {
      return { form: {} };
    }
  }
  return value;
}, intersection(object2({
  form: FormElicitationCapabilitySchema.optional(),
  url: AssertObjectSchema.optional()
}), record(string2(), unknown()).optional()));
var ClientTasksCapabilitySchema = looseObject({
  /**
   * Present if the client supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the client supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for sampling requests.
     */
    sampling: looseObject({
      createMessage: AssertObjectSchema.optional()
    }).optional(),
    /**
     * Task support for elicitation requests.
     */
    elicitation: looseObject({
      create: AssertObjectSchema.optional()
    }).optional()
  }).optional()
});
var ServerTasksCapabilitySchema = looseObject({
  /**
   * Present if the server supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the server supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for tool requests.
     */
    tools: looseObject({
      call: AssertObjectSchema.optional()
    }).optional()
  }).optional()
});
var ClientCapabilitiesSchema = object2({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: record(string2(), AssertObjectSchema).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: object2({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: AssertObjectSchema.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: AssertObjectSchema.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: ElicitationCapabilitySchema.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: object2({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the client supports task creation.
   */
  tasks: ClientTasksCapabilitySchema.optional()
});
var InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: string2(),
  capabilities: ClientCapabilitiesSchema,
  clientInfo: ImplementationSchema
});
var InitializeRequestSchema = RequestSchema.extend({
  method: literal("initialize"),
  params: InitializeRequestParamsSchema
});
var ServerCapabilitiesSchema = object2({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: record(string2(), AssertObjectSchema).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: AssertObjectSchema.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: AssertObjectSchema.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: object2({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server offers any resources to read.
   */
  resources: object2({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: boolean2().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: object2({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server supports task creation.
   */
  tasks: ServerTasksCapabilitySchema.optional()
});
var InitializeResultSchema = ResultSchema.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: string2(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: string2().optional()
});
var InitializedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/initialized"),
  params: NotificationsParamsSchema.optional()
});
var isInitializedNotification = (value) => InitializedNotificationSchema.safeParse(value).success;
var PingRequestSchema = RequestSchema.extend({
  method: literal("ping"),
  params: BaseRequestParamsSchema.optional()
});
var ProgressSchema = object2({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: number2(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: optional(number2()),
  /**
   * An optional message describing the current progress.
   */
  message: optional(string2())
});
var ProgressNotificationParamsSchema = object2({
  ...NotificationsParamsSchema.shape,
  ...ProgressSchema.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: ProgressTokenSchema
});
var ProgressNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/progress"),
  params: ProgressNotificationParamsSchema
});
var PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: CursorSchema.optional()
});
var PaginatedRequestSchema = RequestSchema.extend({
  params: PaginatedRequestParamsSchema.optional()
});
var PaginatedResultSchema = ResultSchema.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: CursorSchema.optional()
});
var TaskStatusSchema = _enum(["working", "input_required", "completed", "failed", "cancelled"]);
var TaskSchema = object2({
  taskId: string2(),
  status: TaskStatusSchema,
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number2(), _null3()]),
  /**
   * ISO 8601 timestamp when the task was created.
   */
  createdAt: string2(),
  /**
   * ISO 8601 timestamp when the task was last updated.
   */
  lastUpdatedAt: string2(),
  pollInterval: optional(number2()),
  /**
   * Optional diagnostic message for failed tasks or other status information.
   */
  statusMessage: optional(string2())
});
var CreateTaskResultSchema = ResultSchema.extend({
  task: TaskSchema
});
var TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema);
var TaskStatusNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tasks/status"),
  params: TaskStatusNotificationParamsSchema
});
var GetTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/get"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
});
var GetTaskResultSchema = ResultSchema.merge(TaskSchema);
var GetTaskPayloadRequestSchema = RequestSchema.extend({
  method: literal("tasks/result"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
});
var GetTaskPayloadResultSchema = ResultSchema.loose();
var ListTasksRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tasks/list")
});
var ListTasksResultSchema = PaginatedResultSchema.extend({
  tasks: array(TaskSchema)
});
var CancelTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/cancel"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
});
var CancelTaskResultSchema = ResultSchema.merge(TaskSchema);
var ResourceContentsSchema = object2({
  /**
   * The URI of this resource.
   */
  uri: string2(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string2()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: string2()
});
var Base64Schema = string2().refine((val) => {
  try {
    atob(val);
    return true;
  } catch {
    return false;
  }
}, { message: "Invalid Base64 string" });
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Base64Schema
});
var RoleSchema = _enum(["user", "assistant"]);
var AnnotationsSchema = object2({
  /**
   * Intended audience(s) for the resource.
   */
  audience: array(RoleSchema).optional(),
  /**
   * Importance hint for the resource, from 0 (least) to 1 (most).
   */
  priority: number2().min(0).max(1).optional(),
  /**
   * ISO 8601 timestamp for the most recent modification.
   */
  lastModified: iso_exports.datetime({ offset: true }).optional()
});
var ResourceSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * The URI of this resource.
   */
  uri: string2(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string2()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string2()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
var ResourceTemplateSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: string2(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string2()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: optional(string2()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
var ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/list")
});
var ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: array(ResourceSchema)
});
var ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/templates/list")
});
var ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: array(ResourceTemplateSchema)
});
var ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: string2()
});
var ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;
var ReadResourceRequestSchema = RequestSchema.extend({
  method: literal("resources/read"),
  params: ReadResourceRequestParamsSchema
});
var ReadResourceResultSchema = ResultSchema.extend({
  contents: array(union([TextResourceContentsSchema, BlobResourceContentsSchema]))
});
var ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var SubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var SubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/subscribe"),
  params: SubscribeRequestParamsSchema
});
var UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var UnsubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/unsubscribe"),
  params: UnsubscribeRequestParamsSchema
});
var ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: string2()
});
var ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/updated"),
  params: ResourceUpdatedNotificationParamsSchema
});
var PromptArgumentSchema = object2({
  /**
   * The name of the argument.
   */
  name: string2(),
  /**
   * A human-readable description of the argument.
   */
  description: optional(string2()),
  /**
   * Whether this argument must be provided.
   */
  required: optional(boolean2())
});
var PromptSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: optional(string2()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: optional(array(PromptArgumentSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
var ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("prompts/list")
});
var ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: array(PromptSchema)
});
var GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: string2(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: record(string2(), string2()).optional()
});
var GetPromptRequestSchema = RequestSchema.extend({
  method: literal("prompts/get"),
  params: GetPromptRequestParamsSchema
});
var TextContentSchema = object2({
  type: literal("text"),
  /**
   * The text content of the message.
   */
  text: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var ImageContentSchema = object2({
  type: literal("image"),
  /**
   * The base64-encoded image data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var AudioContentSchema = object2({
  type: literal("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var ToolUseContentSchema = object2({
  type: literal("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: string2(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: string2(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: record(string2(), unknown()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var EmbeddedResourceSchema = object2({
  type: literal("resource"),
  resource: union([TextResourceContentsSchema, BlobResourceContentsSchema]),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var ResourceLinkSchema = ResourceSchema.extend({
  type: literal("resource_link")
});
var ContentBlockSchema = union([
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema
]);
var PromptMessageSchema = object2({
  role: RoleSchema,
  content: ContentBlockSchema
});
var GetPromptResultSchema = ResultSchema.extend({
  /**
   * An optional description for the prompt.
   */
  description: string2().optional(),
  messages: array(PromptMessageSchema)
});
var PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/prompts/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ToolAnnotationsSchema = object2({
  /**
   * A human-readable title for the tool.
   */
  title: string2().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: boolean2().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: boolean2().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: boolean2().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: boolean2().optional()
});
var ToolExecutionSchema = object2({
  /**
   * Indicates the tool's preference for task-augmented execution.
   * - "required": Clients MUST invoke the tool as a task
   * - "optional": Clients MAY invoke the tool as a task or normal request
   * - "forbidden": Clients MUST NOT attempt to invoke the tool as a task
   *
   * If not present, defaults to "forbidden".
   */
  taskSupport: _enum(["required", "optional", "forbidden"]).optional()
});
var ToolSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A human-readable description of the tool.
   */
  description: string2().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: ToolAnnotationsSchema.optional(),
  /**
   * Execution-related properties for this tool.
   */
  execution: ToolExecutionSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tools/list")
});
var ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: array(ToolSchema)
});
var CallToolResultSchema = ResultSchema.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: array(ContentBlockSchema).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: record(string2(), unknown()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: boolean2().optional()
});
var CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
  toolResult: unknown()
}));
var CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The name of the tool to call.
   */
  name: string2(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: record(string2(), unknown()).optional()
});
var CallToolRequestSchema = RequestSchema.extend({
  method: literal("tools/call"),
  params: CallToolRequestParamsSchema
});
var ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tools/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ListChangedOptionsBaseSchema = object2({
  /**
   * If true, the list will be refreshed automatically when a list changed notification is received.
   * The callback will be called with the updated list.
   *
   * If false, the callback will be called with null items, allowing manual refresh.
   *
   * @default true
   */
  autoRefresh: boolean2().default(true),
  /**
   * Debounce time in milliseconds for list changed notification processing.
   *
   * Multiple notifications received within this timeframe will only trigger one refresh.
   * Set to 0 to disable debouncing.
   *
   * @default 300
   */
  debounceMs: number2().int().nonnegative().default(300)
});
var LoggingLevelSchema = _enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
var SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: LoggingLevelSchema
});
var SetLevelRequestSchema = RequestSchema.extend({
  method: literal("logging/setLevel"),
  params: SetLevelRequestParamsSchema
});
var LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The severity of this log message.
   */
  level: LoggingLevelSchema,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: string2().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: unknown()
});
var LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/message"),
  params: LoggingMessageNotificationParamsSchema
});
var ModelHintSchema = object2({
  /**
   * A hint for a model name.
   */
  name: string2().optional()
});
var ModelPreferencesSchema = object2({
  /**
   * Optional hints to use for model selection.
   */
  hints: array(ModelHintSchema).optional(),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: number2().min(0).max(1).optional(),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: number2().min(0).max(1).optional(),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: number2().min(0).max(1).optional()
});
var ToolChoiceSchema = object2({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: _enum(["auto", "required", "none"]).optional()
});
var ToolResultContentSchema = object2({
  type: literal("tool_result"),
  toolUseId: string2().describe("The unique identifier for the corresponding tool call."),
  content: array(ContentBlockSchema).default([]),
  structuredContent: object2({}).loose().optional(),
  isError: boolean2().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var SamplingContentSchema = discriminatedUnion("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]);
var SamplingMessageContentBlockSchema = discriminatedUnion("type", [
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ToolUseContentSchema,
  ToolResultContentSchema
]);
var SamplingMessageSchema = object2({
  role: RoleSchema,
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  messages: array(SamplingMessageSchema),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: ModelPreferencesSchema.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: string2().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: _enum(["none", "thisServer", "allServers"]).optional(),
  temperature: number2().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: number2().int(),
  stopSequences: array(string2()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: AssertObjectSchema.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: array(ToolSchema).optional(),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: ToolChoiceSchema.optional()
});
var CreateMessageRequestSchema = RequestSchema.extend({
  method: literal("sampling/createMessage"),
  params: CreateMessageRequestParamsSchema
});
var CreateMessageResultSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string2(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens"]).or(string2())),
  role: RoleSchema,
  /**
   * Response content. Single content block (text, image, or audio).
   */
  content: SamplingContentSchema
});
var CreateMessageResultWithToolsSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string2(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string2())),
  role: RoleSchema,
  /**
   * Response content. May be a single block or array. May include ToolUseContent if stopReason is "toolUse".
   */
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)])
});
var BooleanSchemaSchema = object2({
  type: literal("boolean"),
  title: string2().optional(),
  description: string2().optional(),
  default: boolean2().optional()
});
var StringSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  minLength: number2().optional(),
  maxLength: number2().optional(),
  format: _enum(["email", "uri", "date", "date-time"]).optional(),
  default: string2().optional()
});
var NumberSchemaSchema = object2({
  type: _enum(["number", "integer"]),
  title: string2().optional(),
  description: string2().optional(),
  minimum: number2().optional(),
  maximum: number2().optional(),
  default: number2().optional()
});
var UntitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  default: string2().optional()
});
var TitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  oneOf: array(object2({
    const: string2(),
    title: string2()
  })),
  default: string2().optional()
});
var LegacyTitledEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  enumNames: array(string2()).optional(),
  default: string2().optional()
});
var SingleSelectEnumSchemaSchema = union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);
var UntitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    type: literal("string"),
    enum: array(string2())
  }),
  default: array(string2()).optional()
});
var TitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    anyOf: array(object2({
      const: string2(),
      title: string2()
    }))
  }),
  default: array(string2()).optional()
});
var MultiSelectEnumSchemaSchema = union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);
var EnumSchemaSchema = union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]);
var PrimitiveSchemaDefinitionSchema = union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]);
var ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: literal("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: string2(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: object2({
    type: literal("object"),
    properties: record(string2(), PrimitiveSchemaDefinitionSchema),
    required: array(string2()).optional()
  })
});
var ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   */
  mode: literal("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: string2(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: string2(),
  /**
   * The URL that the user should navigate to.
   */
  url: string2().url()
});
var ElicitRequestParamsSchema = union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);
var ElicitRequestSchema = RequestSchema.extend({
  method: literal("elicitation/create"),
  params: ElicitRequestParamsSchema
});
var ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: string2()
});
var ElicitationCompleteNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/elicitation/complete"),
  params: ElicitationCompleteNotificationParamsSchema
});
var ElicitResultSchema = ResultSchema.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: _enum(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   * Per MCP spec, content is "typically omitted" for decline/cancel actions.
   * We normalize null to undefined for leniency while maintaining type compatibility.
   */
  content: preprocess((val) => val === null ? void 0 : val, record(string2(), union([string2(), number2(), boolean2(), array(string2())])).optional())
});
var ResourceTemplateReferenceSchema = object2({
  type: literal("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: string2()
});
var PromptReferenceSchema = object2({
  type: literal("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: string2()
});
var CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
  ref: union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
  /**
   * The argument's information
   */
  argument: object2({
    /**
     * The name of the argument
     */
    name: string2(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: string2()
  }),
  context: object2({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: record(string2(), string2()).optional()
  }).optional()
});
var CompleteRequestSchema = RequestSchema.extend({
  method: literal("completion/complete"),
  params: CompleteRequestParamsSchema
});
var CompleteResultSchema = ResultSchema.extend({
  completion: looseObject({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: array(string2()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: optional(number2().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: optional(boolean2())
  })
});
var RootSchema = object2({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: string2().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: string2().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
});
var ListRootsRequestSchema = RequestSchema.extend({
  method: literal("roots/list"),
  params: BaseRequestParamsSchema.optional()
});
var ListRootsResultSchema = ResultSchema.extend({
  roots: array(RootSchema)
});
var RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/roots/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ClientRequestSchema = union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]);
var ClientNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema,
  TaskStatusNotificationSchema
]);
var ClientResultSchema = union([
  EmptyResultSchema,
  CreateMessageResultSchema,
  CreateMessageResultWithToolsSchema,
  ElicitResultSchema,
  ListRootsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
var ServerRequestSchema = union([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ElicitRequestSchema,
  ListRootsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]);
var ServerNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema,
  TaskStatusNotificationSchema,
  ElicitationCompleteNotificationSchema
]);
var ServerResultSchema = union([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
var McpError = class _McpError extends Error {
  constructor(code, message, data) {
    super(`MCP error ${code}: ${message}`);
    this.code = code;
    this.data = data;
    this.name = "McpError";
  }
  /**
   * Factory method to create the appropriate error type based on the error code and data
   */
  static fromError(code, message, data) {
    if (code === ErrorCode.UrlElicitationRequired && data) {
      const errorData = data;
      if (errorData.elicitations) {
        return new UrlElicitationRequiredError(errorData.elicitations, message);
      }
    }
    return new _McpError(code, message, data);
  }
};
var UrlElicitationRequiredError = class extends McpError {
  constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
    super(ErrorCode.UrlElicitationRequired, message, {
      elicitations
    });
  }
  get elicitations() {
    return this.data?.elicitations ?? [];
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
function isTerminal(status) {
  return status === "completed" || status === "failed" || status === "cancelled";
}

// node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");

// node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function getMethodLiteral(schema) {
  const shape = getObjectShape(schema);
  const methodSchema = shape?.method;
  if (!methodSchema) {
    throw new Error("Schema is missing a method literal");
  }
  const value = getLiteralValue(methodSchema);
  if (typeof value !== "string") {
    throw new Error("Schema method literal must be a string");
  }
  return value;
}
function parseWithCompat(schema, data) {
  const result = safeParse2(schema, data);
  if (!result.success) {
    throw result.error;
  }
  return result.data;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
var Protocol = class {
  constructor(_options) {
    this._options = _options;
    this._requestMessageId = 0;
    this._requestHandlers = /* @__PURE__ */ new Map();
    this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
    this._notificationHandlers = /* @__PURE__ */ new Map();
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers = /* @__PURE__ */ new Map();
    this._timeoutInfo = /* @__PURE__ */ new Map();
    this._pendingDebouncedNotifications = /* @__PURE__ */ new Set();
    this._taskProgressTokens = /* @__PURE__ */ new Map();
    this._requestResolvers = /* @__PURE__ */ new Map();
    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      this._oncancel(notification);
    });
    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    });
    this.setRequestHandler(
      PingRequestSchema,
      // Automatic pong by default.
      (_request) => ({})
    );
    this._taskStore = _options?.taskStore;
    this._taskMessageQueue = _options?.taskMessageQueue;
    if (this._taskStore) {
      this.setRequestHandler(GetTaskRequestSchema, async (request3, extra) => {
        const task = await this._taskStore.getTask(request3.params.taskId, extra.sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return {
          ...task
        };
      });
      this.setRequestHandler(GetTaskPayloadRequestSchema, async (request3, extra) => {
        const handleTaskResult = async () => {
          const taskId = request3.params.taskId;
          if (this._taskMessageQueue) {
            let queuedMessage;
            while (queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId)) {
              if (queuedMessage.type === "response" || queuedMessage.type === "error") {
                const message = queuedMessage.message;
                const requestId = message.id;
                const resolver = this._requestResolvers.get(requestId);
                if (resolver) {
                  this._requestResolvers.delete(requestId);
                  if (queuedMessage.type === "response") {
                    resolver(message);
                  } else {
                    const errorMessage = message;
                    const error2 = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
                    resolver(error2);
                  }
                } else {
                  const messageType = queuedMessage.type === "response" ? "Response" : "Error";
                  this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
                }
                continue;
              }
              await this._transport?.send(queuedMessage.message, { relatedRequestId: extra.requestId });
            }
          }
          const task = await this._taskStore.getTask(taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
          }
          if (!isTerminal(task.status)) {
            await this._waitForTaskUpdate(taskId, extra.signal);
            return await handleTaskResult();
          }
          if (isTerminal(task.status)) {
            const result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
            this._clearTaskQueue(taskId);
            return {
              ...result,
              _meta: {
                ...result._meta,
                [RELATED_TASK_META_KEY]: {
                  taskId
                }
              }
            };
          }
          return await handleTaskResult();
        };
        return await handleTaskResult();
      });
      this.setRequestHandler(ListTasksRequestSchema, async (request3, extra) => {
        try {
          const { tasks, nextCursor } = await this._taskStore.listTasks(request3.params?.cursor, extra.sessionId);
          return {
            tasks,
            nextCursor,
            _meta: {}
          };
        } catch (error2) {
          throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error2 instanceof Error ? error2.message : String(error2)}`);
        }
      });
      this.setRequestHandler(CancelTaskRequestSchema, async (request3, extra) => {
        try {
          const task = await this._taskStore.getTask(request3.params.taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request3.params.taskId}`);
          }
          if (isTerminal(task.status)) {
            throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
          }
          await this._taskStore.updateTaskStatus(request3.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId);
          this._clearTaskQueue(request3.params.taskId);
          const cancelledTask = await this._taskStore.getTask(request3.params.taskId, extra.sessionId);
          if (!cancelledTask) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request3.params.taskId}`);
          }
          return {
            _meta: {},
            ...cancelledTask
          };
        } catch (error2) {
          if (error2 instanceof McpError) {
            throw error2;
          }
          throw new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error2 instanceof Error ? error2.message : String(error2)}`);
        }
      });
    }
  }
  async _oncancel(notification) {
    if (!notification.params.requestId) {
      return;
    }
    const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
    controller?.abort(notification.params.reason);
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (!info)
      return false;
    const totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
      this._timeoutInfo.delete(messageId);
      throw McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info.maxTotalTimeout,
        totalElapsed
      });
    }
    clearTimeout(info.timeoutId);
    info.timeoutId = setTimeout(info.onTimeout, info.timeout);
    return true;
  }
  _cleanupTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (info) {
      clearTimeout(info.timeoutId);
      this._timeoutInfo.delete(messageId);
    }
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    this._transport = transport;
    const _onclose = this.transport?.onclose;
    this._transport.onclose = () => {
      _onclose?.();
      this._onclose();
    };
    const _onerror = this.transport?.onerror;
    this._transport.onerror = (error2) => {
      _onerror?.(error2);
      this._onerror(error2);
    };
    const _onmessage = this._transport?.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage?.(message, extra);
      if (isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message)) {
        this._onresponse(message);
      } else if (isJSONRPCRequest(message)) {
        this._onrequest(message, extra);
      } else if (isJSONRPCNotification(message)) {
        this._onnotification(message);
      } else {
        this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
      }
    };
    await this._transport.start();
  }
  _onclose() {
    const responseHandlers = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers.clear();
    this._taskProgressTokens.clear();
    this._pendingDebouncedNotifications.clear();
    const error2 = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    this._transport = void 0;
    this.onclose?.();
    for (const handler of responseHandlers.values()) {
      handler(error2);
    }
  }
  _onerror(error2) {
    this.onerror?.(error2);
  }
  _onnotification(notification) {
    const handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;
    if (handler === void 0) {
      return;
    }
    Promise.resolve().then(() => handler(notification)).catch((error2) => this._onerror(new Error(`Uncaught error in notification handler: ${error2}`)));
  }
  _onrequest(request3, extra) {
    const handler = this._requestHandlers.get(request3.method) ?? this.fallbackRequestHandler;
    const capturedTransport = this._transport;
    const relatedTaskId = request3.params?._meta?.[RELATED_TASK_META_KEY]?.taskId;
    if (handler === void 0) {
      const errorResponse = {
        jsonrpc: "2.0",
        id: request3.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport?.sessionId).catch((error2) => this._onerror(new Error(`Failed to enqueue error response: ${error2}`)));
      } else {
        capturedTransport?.send(errorResponse).catch((error2) => this._onerror(new Error(`Failed to send an error response: ${error2}`)));
      }
      return;
    }
    const abortController = new AbortController();
    this._requestHandlerAbortControllers.set(request3.id, abortController);
    const taskCreationParams = isTaskAugmentedRequestParams(request3.params) ? request3.params.task : void 0;
    const taskStore = this._taskStore ? this.requestTaskStore(request3, capturedTransport?.sessionId) : void 0;
    const fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport?.sessionId,
      _meta: request3.params?._meta,
      sendNotification: async (notification) => {
        const notificationOptions = { relatedRequestId: request3.id };
        if (relatedTaskId) {
          notificationOptions.relatedTask = { taskId: relatedTaskId };
        }
        await this.notification(notification, notificationOptions);
      },
      sendRequest: async (r, resultSchema, options) => {
        const requestOptions = { ...options, relatedRequestId: request3.id };
        if (relatedTaskId && !requestOptions.relatedTask) {
          requestOptions.relatedTask = { taskId: relatedTaskId };
        }
        const effectiveTaskId = requestOptions.relatedTask?.taskId ?? relatedTaskId;
        if (effectiveTaskId && taskStore) {
          await taskStore.updateTaskStatus(effectiveTaskId, "input_required");
        }
        return await this.request(r, resultSchema, requestOptions);
      },
      authInfo: extra?.authInfo,
      requestId: request3.id,
      requestInfo: extra?.requestInfo,
      taskId: relatedTaskId,
      taskStore,
      taskRequestedTtl: taskCreationParams?.ttl,
      closeSSEStream: extra?.closeSSEStream,
      closeStandaloneSSEStream: extra?.closeStandaloneSSEStream
    };
    Promise.resolve().then(() => {
      if (taskCreationParams) {
        this.assertTaskHandlerCapability(request3.method);
      }
    }).then(() => handler(request3, fullExtra)).then(async (result) => {
      if (abortController.signal.aborted) {
        return;
      }
      const response = {
        result,
        jsonrpc: "2.0",
        id: request3.id
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "response",
          message: response,
          timestamp: Date.now()
        }, capturedTransport?.sessionId);
      } else {
        await capturedTransport?.send(response);
      }
    }, async (error2) => {
      if (abortController.signal.aborted) {
        return;
      }
      const errorResponse = {
        jsonrpc: "2.0",
        id: request3.id,
        error: {
          code: Number.isSafeInteger(error2["code"]) ? error2["code"] : ErrorCode.InternalError,
          message: error2.message ?? "Internal error",
          ...error2["data"] !== void 0 && { data: error2["data"] }
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport?.sessionId);
      } else {
        await capturedTransport?.send(errorResponse);
      }
    }).catch((error2) => this._onerror(new Error(`Failed to send response: ${error2}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request3.id);
    });
  }
  _onprogress(notification) {
    const { progressToken, ...params } = notification.params;
    const messageId = Number(progressToken);
    const handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    const responseHandler = this._responseHandlers.get(messageId);
    const timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
      try {
        this._resetTimeout(messageId);
      } catch (error2) {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        responseHandler(error2);
        return;
      }
    }
    handler(params);
  }
  _onresponse(response) {
    const messageId = Number(response.id);
    const resolver = this._requestResolvers.get(messageId);
    if (resolver) {
      this._requestResolvers.delete(messageId);
      if (isJSONRPCResultResponse(response)) {
        resolver(response);
      } else {
        const error2 = new McpError(response.error.code, response.error.message, response.error.data);
        resolver(error2);
      }
      return;
    }
    const handler = this._responseHandlers.get(messageId);
    if (handler === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId);
    this._cleanupTimeout(messageId);
    let isTaskResponse = false;
    if (isJSONRPCResultResponse(response) && response.result && typeof response.result === "object") {
      const result = response.result;
      if (result.task && typeof result.task === "object") {
        const task = result.task;
        if (typeof task.taskId === "string") {
          isTaskResponse = true;
          this._taskProgressTokens.set(task.taskId, messageId);
        }
      }
    }
    if (!isTaskResponse) {
      this._progressHandlers.delete(messageId);
    }
    if (isJSONRPCResultResponse(response)) {
      handler(response);
    } else {
      const error2 = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler(error2);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    await this._transport?.close();
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * @example
   * ```typescript
   * const stream = protocol.requestStream(request, resultSchema, options);
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Task created:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Task status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Final result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @experimental Use `client.experimental.tasks.requestStream()` to access this method.
   */
  async *requestStream(request3, resultSchema, options) {
    const { task } = options ?? {};
    if (!task) {
      try {
        const result = await this.request(request3, resultSchema, options);
        yield { type: "result", result };
      } catch (error2) {
        yield {
          type: "error",
          error: error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, String(error2))
        };
      }
      return;
    }
    let taskId;
    try {
      const createResult = await this.request(request3, CreateTaskResultSchema, options);
      if (createResult.task) {
        taskId = createResult.task.taskId;
        yield { type: "taskCreated", task: createResult.task };
      } else {
        throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
      }
      while (true) {
        const task2 = await this.getTask({ taskId }, options);
        yield { type: "taskStatus", task: task2 };
        if (isTerminal(task2.status)) {
          if (task2.status === "completed") {
            const result = await this.getTaskResult({ taskId }, resultSchema, options);
            yield { type: "result", result };
          } else if (task2.status === "failed") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
            };
          } else if (task2.status === "cancelled") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
            };
          }
          return;
        }
        if (task2.status === "input_required") {
          const result = await this.getTaskResult({ taskId }, resultSchema, options);
          yield { type: "result", result };
          return;
        }
        const pollInterval = task2.pollInterval ?? this._options?.defaultTaskPollInterval ?? 1e3;
        await new Promise((resolve) => setTimeout(resolve, pollInterval));
        options?.signal?.throwIfAborted();
      }
    } catch (error2) {
      yield {
        type: "error",
        error: error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, String(error2))
      };
    }
  }
  /**
   * Sends a request and waits for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(request3, resultSchema, options) {
    const { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options ?? {};
    return new Promise((resolve, reject) => {
      const earlyReject = (error2) => {
        reject(error2);
      };
      if (!this._transport) {
        earlyReject(new Error("Not connected"));
        return;
      }
      if (this._options?.enforceStrictCapabilities === true) {
        try {
          this.assertCapabilityForMethod(request3.method);
          if (task) {
            this.assertTaskCapability(request3.method);
          }
        } catch (e) {
          earlyReject(e);
          return;
        }
      }
      options?.signal?.throwIfAborted();
      const messageId = this._requestMessageId++;
      const jsonrpcRequest = {
        ...request3,
        jsonrpc: "2.0",
        id: messageId
      };
      if (options?.onprogress) {
        this._progressHandlers.set(messageId, options.onprogress);
        jsonrpcRequest.params = {
          ...request3.params,
          _meta: {
            ...request3.params?._meta || {},
            progressToken: messageId
          }
        };
      }
      if (task) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          task
        };
      }
      if (relatedTask) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          _meta: {
            ...jsonrpcRequest.params?._meta || {},
            [RELATED_TASK_META_KEY]: relatedTask
          }
        };
      }
      const cancel = (reason) => {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        this._transport?.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error3) => this._onerror(new Error(`Failed to send cancellation: ${error3}`)));
        const error2 = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
        reject(error2);
      };
      this._responseHandlers.set(messageId, (response) => {
        if (options?.signal?.aborted) {
          return;
        }
        if (response instanceof Error) {
          return reject(response);
        }
        try {
          const parseResult = safeParse2(resultSchema, response.result);
          if (!parseResult.success) {
            reject(parseResult.error);
          } else {
            resolve(parseResult.data);
          }
        } catch (error2) {
          reject(error2);
        }
      });
      options?.signal?.addEventListener("abort", () => {
        cancel(options?.signal?.reason);
      });
      const timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC;
      const timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? false);
      const relatedTaskId = relatedTask?.taskId;
      if (relatedTaskId) {
        const responseResolver = (response) => {
          const handler = this._responseHandlers.get(messageId);
          if (handler) {
            handler(response);
          } else {
            this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
          }
        };
        this._requestResolvers.set(messageId, responseResolver);
        this._enqueueTaskMessage(relatedTaskId, {
          type: "request",
          message: jsonrpcRequest,
          timestamp: Date.now()
        }).catch((error2) => {
          this._cleanupTimeout(messageId);
          reject(error2);
        });
      } else {
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error2) => {
          this._cleanupTimeout(messageId);
          reject(error2);
        });
      }
    });
  }
  /**
   * Gets the current status of a task.
   *
   * @experimental Use `client.experimental.tasks.getTask()` to access this method.
   */
  async getTask(params, options) {
    return this.request({ method: "tasks/get", params }, GetTaskResultSchema, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
   */
  async getTaskResult(params, resultSchema, options) {
    return this.request({ method: "tasks/result", params }, resultSchema, options);
  }
  /**
   * Lists tasks, optionally starting from a pagination cursor.
   *
   * @experimental Use `client.experimental.tasks.listTasks()` to access this method.
   */
  async listTasks(params, options) {
    return this.request({ method: "tasks/list", params }, ListTasksResultSchema, options);
  }
  /**
   * Cancels a specific task.
   *
   * @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
   */
  async cancelTask(params, options) {
    return this.request({ method: "tasks/cancel", params }, CancelTaskResultSchema, options);
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(notification, options) {
    if (!this._transport) {
      throw new Error("Not connected");
    }
    this.assertNotificationCapability(notification.method);
    const relatedTaskId = options?.relatedTask?.taskId;
    if (relatedTaskId) {
      const jsonrpcNotification2 = {
        ...notification,
        jsonrpc: "2.0",
        params: {
          ...notification.params,
          _meta: {
            ...notification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(relatedTaskId, {
        type: "notification",
        message: jsonrpcNotification2,
        timestamp: Date.now()
      });
      return;
    }
    const debouncedMethods = this._options?.debouncedNotificationMethods ?? [];
    const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !options?.relatedRequestId && !options?.relatedTask;
    if (canDebounce) {
      if (this._pendingDebouncedNotifications.has(notification.method)) {
        return;
      }
      this._pendingDebouncedNotifications.add(notification.method);
      Promise.resolve().then(() => {
        this._pendingDebouncedNotifications.delete(notification.method);
        if (!this._transport) {
          return;
        }
        let jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        if (options?.relatedTask) {
          jsonrpcNotification2 = {
            ...jsonrpcNotification2,
            params: {
              ...jsonrpcNotification2.params,
              _meta: {
                ...jsonrpcNotification2.params?._meta || {},
                [RELATED_TASK_META_KEY]: options.relatedTask
              }
            }
          };
        }
        this._transport?.send(jsonrpcNotification2, options).catch((error2) => this._onerror(error2));
      });
      return;
    }
    let jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    if (options?.relatedTask) {
      jsonrpcNotification = {
        ...jsonrpcNotification,
        params: {
          ...jsonrpcNotification.params,
          _meta: {
            ...jsonrpcNotification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
    }
    await this._transport.send(jsonrpcNotification, options);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(requestSchema, handler) {
    const method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method);
    this._requestHandlers.set(method, (request3, extra) => {
      const parsed = parseWithCompat(requestSchema, request3);
      return Promise.resolve(handler(parsed, extra));
    });
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method)) {
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(notificationSchema, handler) {
    const method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      const parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler(parsed));
    });
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
  /**
   * Cleans up the progress handler associated with a task.
   * This should be called when a task reaches a terminal status.
   */
  _cleanupTaskProgressHandler(taskId) {
    const progressToken = this._taskProgressTokens.get(taskId);
    if (progressToken !== void 0) {
      this._progressHandlers.delete(progressToken);
      this._taskProgressTokens.delete(taskId);
    }
  }
  /**
   * Enqueues a task-related message for side-channel delivery via tasks/result.
   * @param taskId The task ID to associate the message with
   * @param message The message to enqueue
   * @param sessionId Optional session ID for binding the operation to a specific session
   * @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
   *
   * Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
   * the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
   * simply propagates the error.
   */
  async _enqueueTaskMessage(taskId, message, sessionId) {
    if (!this._taskStore || !this._taskMessageQueue) {
      throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    }
    const maxQueueSize = this._options?.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
  }
  /**
   * Clears the message queue for a task and rejects any pending request resolvers.
   * @param taskId The task ID whose queue should be cleared
   * @param sessionId Optional session ID for binding the operation to a specific session
   */
  async _clearTaskQueue(taskId, sessionId) {
    if (this._taskMessageQueue) {
      const messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
      for (const message of messages) {
        if (message.type === "request" && isJSONRPCRequest(message.message)) {
          const requestId = message.message.id;
          const resolver = this._requestResolvers.get(requestId);
          if (resolver) {
            resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed"));
            this._requestResolvers.delete(requestId);
          } else {
            this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
          }
        }
      }
    }
  }
  /**
   * Waits for a task update (new messages or status change) with abort signal support.
   * Uses polling to check for updates at the task's configured poll interval.
   * @param taskId The task ID to wait for
   * @param signal Abort signal to cancel the wait
   * @returns Promise that resolves when an update occurs or rejects if aborted
   */
  async _waitForTaskUpdate(taskId, signal) {
    let interval = this._options?.defaultTaskPollInterval ?? 1e3;
    try {
      const task = await this._taskStore?.getTask(taskId);
      if (task?.pollInterval) {
        interval = task.pollInterval;
      }
    } catch {
    }
    return new Promise((resolve, reject) => {
      if (signal.aborted) {
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
        return;
      }
      const timeoutId = setTimeout(resolve, interval);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId);
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
      }, { once: true });
    });
  }
  requestTaskStore(request3, sessionId) {
    const taskStore = this._taskStore;
    if (!taskStore) {
      throw new Error("No task store configured");
    }
    return {
      createTask: async (taskParams) => {
        if (!request3) {
          throw new Error("No request provided");
        }
        return await taskStore.createTask(taskParams, request3.id, {
          method: request3.method,
          params: request3.params
        }, sessionId);
      },
      getTask: async (taskId) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return task;
      },
      storeTaskResult: async (taskId, status, result) => {
        await taskStore.storeTaskResult(taskId, status, result, sessionId);
        const task = await taskStore.getTask(taskId, sessionId);
        if (task) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: task
          });
          await this.notification(notification);
          if (isTerminal(task.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      getTaskResult: (taskId) => {
        return taskStore.getTaskResult(taskId, sessionId);
      },
      updateTaskStatus: async (taskId, status, statusMessage) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
        }
        if (isTerminal(task.status)) {
          throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        }
        await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);
        const updatedTask = await taskStore.getTask(taskId, sessionId);
        if (updatedTask) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: updatedTask
          });
          await this.notification(notification);
          if (isTerminal(updatedTask.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      listTasks: (cursor) => {
        return taskStore.listTasks(cursor, sessionId);
      }
    };
  }
};
function isPlainObject2(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
  const result = { ...base };
  for (const key in additional) {
    const k = key;
    const addValue = additional[k];
    if (addValue === void 0)
      continue;
    const baseValue = result[k];
    if (isPlainObject2(baseValue) && isPlainObject2(addValue)) {
      result[k] = { ...baseValue, ...addValue };
    } else {
      result[k] = addValue;
    }
  }
  return result;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
var import_ajv = __toESM(require_ajv(), 1);
var import_ajv_formats = __toESM(require_dist2(), 1);
function createDefaultAjvInstance() {
  const ajv = new import_ajv.default({
    strict: false,
    validateFormats: true,
    validateSchema: false,
    allErrors: true
  });
  const addFormats = import_ajv_formats.default;
  addFormats(ajv);
  return ajv;
}
var AjvJsonSchemaValidator = class {
  /**
   * Create an AJV validator
   *
   * @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
   *
   * @example
   * ```typescript
   * // Use default configuration (recommended for most cases)
   * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
   * const validator = new AjvJsonSchemaValidator();
   *
   * // Or provide custom AJV instance for advanced configuration
   * import { Ajv } from 'ajv';
   * import addFormats from 'ajv-formats';
   *
   * const ajv = new Ajv({ validateFormats: true });
   * addFormats(ajv);
   * const validator = new AjvJsonSchemaValidator(ajv);
   * ```
   */
  constructor(ajv) {
    this._ajv = ajv ?? createDefaultAjvInstance();
  }
  /**
   * Create a validator for the given JSON Schema
   *
   * The validator is compiled once and can be reused multiple times.
   * If the schema has an $id, it will be cached by AJV automatically.
   *
   * @param schema - Standard JSON Schema object
   * @returns A validator function that validates input data
   */
  getValidator(schema) {
    const ajvValidator = "$id" in schema && typeof schema.$id === "string" ? this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => {
      const valid = ajvValidator(input);
      if (valid) {
        return {
          valid: true,
          data: input,
          errorMessage: void 0
        };
      } else {
        return {
          valid: false,
          data: void 0,
          errorMessage: this._ajv.errorsText(ajvValidator.errors)
        };
      }
    };
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/client.js
var ExperimentalClientTasks = class {
  constructor(_client) {
    this._client = _client;
  }
  /**
   * Calls a tool and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to tool execution, allowing you to
   * observe intermediate task status updates for long-running tool calls.
   * Automatically validates structured output if the tool has an outputSchema.
   *
   * @example
   * ```typescript
   * const stream = client.experimental.tasks.callToolStream({ name: 'myTool', arguments: {} });
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Tool execution started:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Tool status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Tool result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Tool error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @param params - Tool call parameters (name and arguments)
   * @param resultSchema - Zod schema for validating the result (defaults to CallToolResultSchema)
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  async *callToolStream(params, resultSchema = CallToolResultSchema, options) {
    const clientInternal = this._client;
    const optionsWithTask = {
      ...options,
      // We check if the tool is known to be a task during auto-configuration, but assume
      // the caller knows what they're doing if they pass this explicitly
      task: options?.task ?? (clientInternal.isToolTask(params.name) ? {} : void 0)
    };
    const stream = clientInternal.requestStream({ method: "tools/call", params }, resultSchema, optionsWithTask);
    const validator = clientInternal.getToolOutputValidator(params.name);
    for await (const message of stream) {
      if (message.type === "result" && validator) {
        const result = message.result;
        if (!result.structuredContent && !result.isError) {
          yield {
            type: "error",
            error: new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`)
          };
          return;
        }
        if (result.structuredContent) {
          try {
            const validationResult = validator(result.structuredContent);
            if (!validationResult.valid) {
              yield {
                type: "error",
                error: new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`)
              };
              return;
            }
          } catch (error2) {
            if (error2 instanceof McpError) {
              yield { type: "error", error: error2 };
              return;
            }
            yield {
              type: "error",
              error: new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error2 instanceof Error ? error2.message : String(error2)}`)
            };
            return;
          }
        }
      }
      yield message;
    }
  }
  /**
   * Gets the current status of a task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   * @returns The task status
   *
   * @experimental
   */
  async getTask(taskId, options) {
    return this._client.getTask({ taskId }, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @param taskId - The task identifier
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options
   * @returns The task result
   *
   * @experimental
   */
  async getTaskResult(taskId, resultSchema, options) {
    return this._client.getTaskResult({ taskId }, resultSchema, options);
  }
  /**
   * Lists tasks with optional pagination.
   *
   * @param cursor - Optional pagination cursor
   * @param options - Optional request options
   * @returns List of tasks with optional next cursor
   *
   * @experimental
   */
  async listTasks(cursor, options) {
    return this._client.listTasks(cursor ? { cursor } : void 0, options);
  }
  /**
   * Cancels a running task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   *
   * @experimental
   */
  async cancelTask(taskId, options) {
    return this._client.cancelTask({ taskId }, options);
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to request processing, allowing you to
   * observe intermediate task status updates for task-augmented requests.
   *
   * @param request - The request to send
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  requestStream(request3, resultSchema, options) {
    return this._client.requestStream(request3, resultSchema, options);
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
function assertToolsCallTaskCapability(requests, method, entityName) {
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "tools/call":
      if (!requests.tools?.call) {
        throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
      }
      break;
    default:
      break;
  }
}
function assertClientRequestTaskCapability(requests, method, entityName) {
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "sampling/createMessage":
      if (!requests.sampling?.createMessage) {
        throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
      }
      break;
    case "elicitation/create":
      if (!requests.elicitation?.create) {
        throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
      }
      break;
    default:
      break;
  }
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
function applyElicitationDefaults(schema, data) {
  if (!schema || data === null || typeof data !== "object")
    return;
  if (schema.type === "object" && schema.properties && typeof schema.properties === "object") {
    const obj = data;
    const props = schema.properties;
    for (const key of Object.keys(props)) {
      const propSchema = props[key];
      if (obj[key] === void 0 && Object.prototype.hasOwnProperty.call(propSchema, "default")) {
        obj[key] = propSchema.default;
      }
      if (obj[key] !== void 0) {
        applyElicitationDefaults(propSchema, obj[key]);
      }
    }
  }
  if (Array.isArray(schema.anyOf)) {
    for (const sub of schema.anyOf) {
      if (typeof sub !== "boolean") {
        applyElicitationDefaults(sub, data);
      }
    }
  }
  if (Array.isArray(schema.oneOf)) {
    for (const sub of schema.oneOf) {
      if (typeof sub !== "boolean") {
        applyElicitationDefaults(sub, data);
      }
    }
  }
}
function getSupportedElicitationModes(capabilities) {
  if (!capabilities) {
    return { supportsFormMode: false, supportsUrlMode: false };
  }
  const hasFormCapability = capabilities.form !== void 0;
  const hasUrlCapability = capabilities.url !== void 0;
  const supportsFormMode = hasFormCapability || !hasFormCapability && !hasUrlCapability;
  const supportsUrlMode = hasUrlCapability;
  return { supportsFormMode, supportsUrlMode };
}
var Client = class extends Protocol {
  /**
   * Initializes this client with the given name and version information.
   */
  constructor(_clientInfo, options) {
    super(options);
    this._clientInfo = _clientInfo;
    this._cachedToolOutputValidators = /* @__PURE__ */ new Map();
    this._cachedKnownTaskTools = /* @__PURE__ */ new Set();
    this._cachedRequiredTaskTools = /* @__PURE__ */ new Set();
    this._listChangedDebounceTimers = /* @__PURE__ */ new Map();
    this._capabilities = options?.capabilities ?? {};
    this._jsonSchemaValidator = options?.jsonSchemaValidator ?? new AjvJsonSchemaValidator();
    if (options?.listChanged) {
      this._pendingListChangedConfig = options.listChanged;
    }
  }
  /**
   * Set up handlers for list changed notifications based on config and server capabilities.
   * This should only be called after initialization when server capabilities are known.
   * Handlers are silently skipped if the server doesn't advertise the corresponding listChanged capability.
   * @internal
   */
  _setupListChangedHandlers(config2) {
    if (config2.tools && this._serverCapabilities?.tools?.listChanged) {
      this._setupListChangedHandler("tools", ToolListChangedNotificationSchema, config2.tools, async () => {
        const result = await this.listTools();
        return result.tools;
      });
    }
    if (config2.prompts && this._serverCapabilities?.prompts?.listChanged) {
      this._setupListChangedHandler("prompts", PromptListChangedNotificationSchema, config2.prompts, async () => {
        const result = await this.listPrompts();
        return result.prompts;
      });
    }
    if (config2.resources && this._serverCapabilities?.resources?.listChanged) {
      this._setupListChangedHandler("resources", ResourceListChangedNotificationSchema, config2.resources, async () => {
        const result = await this.listResources();
        return result.resources;
      });
    }
  }
  /**
   * Access experimental features.
   *
   * WARNING: These APIs are experimental and may change without notice.
   *
   * @experimental
   */
  get experimental() {
    if (!this._experimental) {
      this._experimental = {
        tasks: new ExperimentalClientTasks(this)
      };
    }
    return this._experimental;
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport) {
      throw new Error("Cannot register capabilities after connecting to transport");
    }
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  /**
   * Override request handler registration to enforce client-side validation for elicitation.
   */
  setRequestHandler(requestSchema, handler) {
    const shape = getObjectShape(requestSchema);
    const methodSchema = shape?.method;
    if (!methodSchema) {
      throw new Error("Schema is missing a method literal");
    }
    let methodValue;
    if (isZ4Schema(methodSchema)) {
      const v4Schema = methodSchema;
      const v4Def = v4Schema._zod?.def;
      methodValue = v4Def?.value ?? v4Schema.value;
    } else {
      const v3Schema = methodSchema;
      const legacyDef = v3Schema._def;
      methodValue = legacyDef?.value ?? v3Schema.value;
    }
    if (typeof methodValue !== "string") {
      throw new Error("Schema method literal must be a string");
    }
    const method = methodValue;
    if (method === "elicitation/create") {
      const wrappedHandler = async (request3, extra) => {
        const validatedRequest = safeParse2(ElicitRequestSchema, request3);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        params.mode = params.mode ?? "form";
        const { supportsFormMode, supportsUrlMode } = getSupportedElicitationModes(this._capabilities.elicitation);
        if (params.mode === "form" && !supportsFormMode) {
          throw new McpError(ErrorCode.InvalidParams, "Client does not support form-mode elicitation requests");
        }
        if (params.mode === "url" && !supportsUrlMode) {
          throw new McpError(ErrorCode.InvalidParams, "Client does not support URL-mode elicitation requests");
        }
        const result = await Promise.resolve(handler(request3, extra));
        if (params.task) {
          const taskValidationResult = safeParse2(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const validationResult = safeParse2(ElicitResultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation result: ${errorMessage}`);
        }
        const validatedResult = validationResult.data;
        const requestedSchema = params.mode === "form" ? params.requestedSchema : void 0;
        if (params.mode === "form" && validatedResult.action === "accept" && validatedResult.content && requestedSchema) {
          if (this._capabilities.elicitation?.form?.applyDefaults) {
            try {
              applyElicitationDefaults(requestedSchema, validatedResult.content);
            } catch {
            }
          }
        }
        return validatedResult;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    if (method === "sampling/createMessage") {
      const wrappedHandler = async (request3, extra) => {
        const validatedRequest = safeParse2(CreateMessageRequestSchema, request3);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid sampling request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        const result = await Promise.resolve(handler(request3, extra));
        if (params.task) {
          const taskValidationResult = safeParse2(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const validationResult = safeParse2(CreateMessageResultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid sampling result: ${errorMessage}`);
        }
        return validationResult.data;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    return super.setRequestHandler(requestSchema, handler);
  }
  assertCapability(capability, method) {
    if (!this._serverCapabilities?.[capability]) {
      throw new Error(`Server does not support ${capability} (required for ${method})`);
    }
  }
  async connect(transport, options) {
    await super.connect(transport);
    if (transport.sessionId !== void 0) {
      return;
    }
    try {
      const result = await this.request({
        method: "initialize",
        params: {
          protocolVersion: LATEST_PROTOCOL_VERSION,
          capabilities: this._capabilities,
          clientInfo: this._clientInfo
        }
      }, InitializeResultSchema, options);
      if (result === void 0) {
        throw new Error(`Server sent invalid initialize result: ${result}`);
      }
      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
        throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
      }
      this._serverCapabilities = result.capabilities;
      this._serverVersion = result.serverInfo;
      if (transport.setProtocolVersion) {
        transport.setProtocolVersion(result.protocolVersion);
      }
      this._instructions = result.instructions;
      await this.notification({
        method: "notifications/initialized"
      });
      if (this._pendingListChangedConfig) {
        this._setupListChangedHandlers(this._pendingListChangedConfig);
        this._pendingListChangedConfig = void 0;
      }
    } catch (error2) {
      void this.close();
      throw error2;
    }
  }
  /**
   * After initialization has completed, this will be populated with the server's reported capabilities.
   */
  getServerCapabilities() {
    return this._serverCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the server's name and version.
   */
  getServerVersion() {
    return this._serverVersion;
  }
  /**
   * After initialization has completed, this may be populated with information about the server's instructions.
   */
  getInstructions() {
    return this._instructions;
  }
  assertCapabilityForMethod(method) {
    switch (method) {
      case "logging/setLevel":
        if (!this._serverCapabilities?.logging) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "prompts/get":
      case "prompts/list":
        if (!this._serverCapabilities?.prompts) {
          throw new Error(`Server does not support prompts (required for ${method})`);
        }
        break;
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
      case "resources/subscribe":
      case "resources/unsubscribe":
        if (!this._serverCapabilities?.resources) {
          throw new Error(`Server does not support resources (required for ${method})`);
        }
        if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) {
          throw new Error(`Server does not support resource subscriptions (required for ${method})`);
        }
        break;
      case "tools/call":
      case "tools/list":
        if (!this._serverCapabilities?.tools) {
          throw new Error(`Server does not support tools (required for ${method})`);
        }
        break;
      case "completion/complete":
        if (!this._serverCapabilities?.completions) {
          throw new Error(`Server does not support completions (required for ${method})`);
        }
        break;
      case "initialize":
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    switch (method) {
      case "notifications/roots/list_changed":
        if (!this._capabilities.roots?.listChanged) {
          throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
        }
        break;
      case "notifications/initialized":
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    switch (method) {
      case "sampling/createMessage":
        if (!this._capabilities.sampling) {
          throw new Error(`Client does not support sampling capability (required for ${method})`);
        }
        break;
      case "elicitation/create":
        if (!this._capabilities.elicitation) {
          throw new Error(`Client does not support elicitation capability (required for ${method})`);
        }
        break;
      case "roots/list":
        if (!this._capabilities.roots) {
          throw new Error(`Client does not support roots capability (required for ${method})`);
        }
        break;
      case "tasks/get":
      case "tasks/list":
      case "tasks/result":
      case "tasks/cancel":
        if (!this._capabilities.tasks) {
          throw new Error(`Client does not support tasks capability (required for ${method})`);
        }
        break;
      case "ping":
        break;
    }
  }
  assertTaskCapability(method) {
    assertToolsCallTaskCapability(this._serverCapabilities?.tasks?.requests, method, "Server");
  }
  assertTaskHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    assertClientRequestTaskCapability(this._capabilities.tasks?.requests, method, "Client");
  }
  async ping(options) {
    return this.request({ method: "ping" }, EmptyResultSchema, options);
  }
  async complete(params, options) {
    return this.request({ method: "completion/complete", params }, CompleteResultSchema, options);
  }
  async setLoggingLevel(level, options) {
    return this.request({ method: "logging/setLevel", params: { level } }, EmptyResultSchema, options);
  }
  async getPrompt(params, options) {
    return this.request({ method: "prompts/get", params }, GetPromptResultSchema, options);
  }
  async listPrompts(params, options) {
    return this.request({ method: "prompts/list", params }, ListPromptsResultSchema, options);
  }
  async listResources(params, options) {
    return this.request({ method: "resources/list", params }, ListResourcesResultSchema, options);
  }
  async listResourceTemplates(params, options) {
    return this.request({ method: "resources/templates/list", params }, ListResourceTemplatesResultSchema, options);
  }
  async readResource(params, options) {
    return this.request({ method: "resources/read", params }, ReadResourceResultSchema, options);
  }
  async subscribeResource(params, options) {
    return this.request({ method: "resources/subscribe", params }, EmptyResultSchema, options);
  }
  async unsubscribeResource(params, options) {
    return this.request({ method: "resources/unsubscribe", params }, EmptyResultSchema, options);
  }
  /**
   * Calls a tool and waits for the result. Automatically validates structured output if the tool has an outputSchema.
   *
   * For task-based execution with streaming behavior, use client.experimental.tasks.callToolStream() instead.
   */
  async callTool(params, resultSchema = CallToolResultSchema, options) {
    if (this.isToolTaskRequired(params.name)) {
      throw new McpError(ErrorCode.InvalidRequest, `Tool "${params.name}" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);
    }
    const result = await this.request({ method: "tools/call", params }, resultSchema, options);
    const validator = this.getToolOutputValidator(params.name);
    if (validator) {
      if (!result.structuredContent && !result.isError) {
        throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
      }
      if (result.structuredContent) {
        try {
          const validationResult = validator(result.structuredContent);
          if (!validationResult.valid) {
            throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`);
          }
        } catch (error2) {
          if (error2 instanceof McpError) {
            throw error2;
          }
          throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error2 instanceof Error ? error2.message : String(error2)}`);
        }
      }
    }
    return result;
  }
  isToolTask(toolName) {
    if (!this._serverCapabilities?.tasks?.requests?.tools?.call) {
      return false;
    }
    return this._cachedKnownTaskTools.has(toolName);
  }
  /**
   * Check if a tool requires task-based execution.
   * Unlike isToolTask which includes 'optional' tools, this only checks for 'required'.
   */
  isToolTaskRequired(toolName) {
    return this._cachedRequiredTaskTools.has(toolName);
  }
  /**
   * Cache validators for tool output schemas.
   * Called after listTools() to pre-compile validators for better performance.
   */
  cacheToolMetadata(tools) {
    this._cachedToolOutputValidators.clear();
    this._cachedKnownTaskTools.clear();
    this._cachedRequiredTaskTools.clear();
    for (const tool of tools) {
      if (tool.outputSchema) {
        const toolValidator = this._jsonSchemaValidator.getValidator(tool.outputSchema);
        this._cachedToolOutputValidators.set(tool.name, toolValidator);
      }
      const taskSupport = tool.execution?.taskSupport;
      if (taskSupport === "required" || taskSupport === "optional") {
        this._cachedKnownTaskTools.add(tool.name);
      }
      if (taskSupport === "required") {
        this._cachedRequiredTaskTools.add(tool.name);
      }
    }
  }
  /**
   * Get cached validator for a tool
   */
  getToolOutputValidator(toolName) {
    return this._cachedToolOutputValidators.get(toolName);
  }
  async listTools(params, options) {
    const result = await this.request({ method: "tools/list", params }, ListToolsResultSchema, options);
    this.cacheToolMetadata(result.tools);
    return result;
  }
  /**
   * Set up a single list changed handler.
   * @internal
   */
  _setupListChangedHandler(listType, notificationSchema, options, fetcher) {
    const parseResult = ListChangedOptionsBaseSchema.safeParse(options);
    if (!parseResult.success) {
      throw new Error(`Invalid ${listType} listChanged options: ${parseResult.error.message}`);
    }
    if (typeof options.onChanged !== "function") {
      throw new Error(`Invalid ${listType} listChanged options: onChanged must be a function`);
    }
    const { autoRefresh, debounceMs } = parseResult.data;
    const { onChanged } = options;
    const refresh = async () => {
      if (!autoRefresh) {
        onChanged(null, null);
        return;
      }
      try {
        const items = await fetcher();
        onChanged(null, items);
      } catch (e) {
        const error2 = e instanceof Error ? e : new Error(String(e));
        onChanged(error2, null);
      }
    };
    const handler = () => {
      if (debounceMs) {
        const existingTimer = this._listChangedDebounceTimers.get(listType);
        if (existingTimer) {
          clearTimeout(existingTimer);
        }
        const timer = setTimeout(refresh, debounceMs);
        this._listChangedDebounceTimers.set(listType, timer);
      } else {
        refresh();
      }
    };
    this.setNotificationHandler(notificationSchema, handler);
  }
  async sendRootsListChanged() {
    return this.notification({ method: "notifications/roots/list_changed" });
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/transport.js
function normalizeHeaders(headers) {
  if (!headers)
    return {};
  if (headers instanceof Headers) {
    return Object.fromEntries(headers.entries());
  }
  if (Array.isArray(headers)) {
    return Object.fromEntries(headers);
  }
  return { ...headers };
}
function createFetchWithInit(baseFetch = fetch, baseInit) {
  if (!baseInit) {
    return baseFetch;
  }
  return async (url2, init) => {
    const mergedInit = {
      ...baseInit,
      ...init,
      // Headers need special handling - merge instead of replace
      headers: init?.headers ? { ...normalizeHeaders(baseInit.headers), ...normalizeHeaders(init.headers) } : baseInit.headers
    };
    return baseFetch(url2, mergedInit);
  };
}

// node_modules/pkce-challenge/dist/index.node.js
var crypto3;
crypto3 = globalThis.crypto?.webcrypto ?? // Node.js [18-16] REPL
globalThis.crypto ?? // Node.js >18
import("node:crypto").then((m) => m.webcrypto);
async function getRandomValues(size) {
  return (await crypto3).getRandomValues(new Uint8Array(size));
}
async function random(size) {
  const mask = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
  let result = "";
  const randomUints = await getRandomValues(size);
  for (let i = 0; i < size; i++) {
    const randomIndex = randomUints[i] % mask.length;
    result += mask[randomIndex];
  }
  return result;
}
async function generateVerifier(length) {
  return await random(length);
}
async function generateChallenge(code_verifier) {
  const buffer = await (await crypto3).subtle.digest("SHA-256", new TextEncoder().encode(code_verifier));
  return btoa(String.fromCharCode(...new Uint8Array(buffer))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
}
async function pkceChallenge(length) {
  if (!length)
    length = 43;
  if (length < 43 || length > 128) {
    throw `Expected a length between 43 and 128. Received ${length}.`;
  }
  const verifier = await generateVerifier(length);
  const challenge = await generateChallenge(verifier);
  return {
    code_verifier: verifier,
    code_challenge: challenge
  };
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth.js
var SafeUrlSchema = url().superRefine((val, ctx) => {
  if (!URL.canParse(val)) {
    ctx.addIssue({
      code: ZodIssueCode.custom,
      message: "URL must be parseable",
      fatal: true
    });
    return NEVER;
  }
}).refine((url2) => {
  const u = new URL(url2);
  return u.protocol !== "javascript:" && u.protocol !== "data:" && u.protocol !== "vbscript:";
}, { message: "URL cannot use javascript:, data:, or vbscript: scheme" });
var OAuthProtectedResourceMetadataSchema = looseObject({
  resource: string2().url(),
  authorization_servers: array(SafeUrlSchema).optional(),
  jwks_uri: string2().url().optional(),
  scopes_supported: array(string2()).optional(),
  bearer_methods_supported: array(string2()).optional(),
  resource_signing_alg_values_supported: array(string2()).optional(),
  resource_name: string2().optional(),
  resource_documentation: string2().optional(),
  resource_policy_uri: string2().url().optional(),
  resource_tos_uri: string2().url().optional(),
  tls_client_certificate_bound_access_tokens: boolean2().optional(),
  authorization_details_types_supported: array(string2()).optional(),
  dpop_signing_alg_values_supported: array(string2()).optional(),
  dpop_bound_access_tokens_required: boolean2().optional()
});
var OAuthMetadataSchema = looseObject({
  issuer: string2(),
  authorization_endpoint: SafeUrlSchema,
  token_endpoint: SafeUrlSchema,
  registration_endpoint: SafeUrlSchema.optional(),
  scopes_supported: array(string2()).optional(),
  response_types_supported: array(string2()),
  response_modes_supported: array(string2()).optional(),
  grant_types_supported: array(string2()).optional(),
  token_endpoint_auth_methods_supported: array(string2()).optional(),
  token_endpoint_auth_signing_alg_values_supported: array(string2()).optional(),
  service_documentation: SafeUrlSchema.optional(),
  revocation_endpoint: SafeUrlSchema.optional(),
  revocation_endpoint_auth_methods_supported: array(string2()).optional(),
  revocation_endpoint_auth_signing_alg_values_supported: array(string2()).optional(),
  introspection_endpoint: string2().optional(),
  introspection_endpoint_auth_methods_supported: array(string2()).optional(),
  introspection_endpoint_auth_signing_alg_values_supported: array(string2()).optional(),
  code_challenge_methods_supported: array(string2()).optional(),
  client_id_metadata_document_supported: boolean2().optional()
});
var OpenIdProviderMetadataSchema = looseObject({
  issuer: string2(),
  authorization_endpoint: SafeUrlSchema,
  token_endpoint: SafeUrlSchema,
  userinfo_endpoint: SafeUrlSchema.optional(),
  jwks_uri: SafeUrlSchema,
  registration_endpoint: SafeUrlSchema.optional(),
  scopes_supported: array(string2()).optional(),
  response_types_supported: array(string2()),
  response_modes_supported: array(string2()).optional(),
  grant_types_supported: array(string2()).optional(),
  acr_values_supported: array(string2()).optional(),
  subject_types_supported: array(string2()),
  id_token_signing_alg_values_supported: array(string2()),
  id_token_encryption_alg_values_supported: array(string2()).optional(),
  id_token_encryption_enc_values_supported: array(string2()).optional(),
  userinfo_signing_alg_values_supported: array(string2()).optional(),
  userinfo_encryption_alg_values_supported: array(string2()).optional(),
  userinfo_encryption_enc_values_supported: array(string2()).optional(),
  request_object_signing_alg_values_supported: array(string2()).optional(),
  request_object_encryption_alg_values_supported: array(string2()).optional(),
  request_object_encryption_enc_values_supported: array(string2()).optional(),
  token_endpoint_auth_methods_supported: array(string2()).optional(),
  token_endpoint_auth_signing_alg_values_supported: array(string2()).optional(),
  display_values_supported: array(string2()).optional(),
  claim_types_supported: array(string2()).optional(),
  claims_supported: array(string2()).optional(),
  service_documentation: string2().optional(),
  claims_locales_supported: array(string2()).optional(),
  ui_locales_supported: array(string2()).optional(),
  claims_parameter_supported: boolean2().optional(),
  request_parameter_supported: boolean2().optional(),
  request_uri_parameter_supported: boolean2().optional(),
  require_request_uri_registration: boolean2().optional(),
  op_policy_uri: SafeUrlSchema.optional(),
  op_tos_uri: SafeUrlSchema.optional(),
  client_id_metadata_document_supported: boolean2().optional()
});
var OpenIdProviderDiscoveryMetadataSchema = object2({
  ...OpenIdProviderMetadataSchema.shape,
  ...OAuthMetadataSchema.pick({
    code_challenge_methods_supported: true
  }).shape
});
var OAuthTokensSchema = object2({
  access_token: string2(),
  id_token: string2().optional(),
  // Optional for OAuth 2.1, but necessary in OpenID Connect
  token_type: string2(),
  expires_in: coerce_exports.number().optional(),
  scope: string2().optional(),
  refresh_token: string2().optional()
}).strip();
var OAuthErrorResponseSchema = object2({
  error: string2(),
  error_description: string2().optional(),
  error_uri: string2().optional()
});
var OptionalSafeUrlSchema = SafeUrlSchema.optional().or(literal("").transform(() => void 0));
var OAuthClientMetadataSchema = object2({
  redirect_uris: array(SafeUrlSchema),
  token_endpoint_auth_method: string2().optional(),
  grant_types: array(string2()).optional(),
  response_types: array(string2()).optional(),
  client_name: string2().optional(),
  client_uri: SafeUrlSchema.optional(),
  logo_uri: OptionalSafeUrlSchema,
  scope: string2().optional(),
  contacts: array(string2()).optional(),
  tos_uri: OptionalSafeUrlSchema,
  policy_uri: string2().optional(),
  jwks_uri: SafeUrlSchema.optional(),
  jwks: any().optional(),
  software_id: string2().optional(),
  software_version: string2().optional(),
  software_statement: string2().optional()
}).strip();
var OAuthClientInformationSchema = object2({
  client_id: string2(),
  client_secret: string2().optional(),
  client_id_issued_at: number2().optional(),
  client_secret_expires_at: number2().optional()
}).strip();
var OAuthClientInformationFullSchema = OAuthClientMetadataSchema.merge(OAuthClientInformationSchema);
var OAuthClientRegistrationErrorSchema = object2({
  error: string2(),
  error_description: string2().optional()
}).strip();
var OAuthTokenRevocationRequestSchema = object2({
  token: string2(),
  token_type_hint: string2().optional()
}).strip();

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth-utils.js
function resourceUrlFromServerUrl(url2) {
  const resourceURL = typeof url2 === "string" ? new URL(url2) : new URL(url2.href);
  resourceURL.hash = "";
  return resourceURL;
}
function checkResourceAllowed({ requestedResource, configuredResource }) {
  const requested = typeof requestedResource === "string" ? new URL(requestedResource) : new URL(requestedResource.href);
  const configured = typeof configuredResource === "string" ? new URL(configuredResource) : new URL(configuredResource.href);
  if (requested.origin !== configured.origin) {
    return false;
  }
  if (requested.pathname.length < configured.pathname.length) {
    return false;
  }
  const requestedPath = requested.pathname.endsWith("/") ? requested.pathname : requested.pathname + "/";
  const configuredPath = configured.pathname.endsWith("/") ? configured.pathname : configured.pathname + "/";
  return requestedPath.startsWith(configuredPath);
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/auth/errors.js
var OAuthError = class extends Error {
  constructor(message, errorUri) {
    super(message);
    this.errorUri = errorUri;
    this.name = this.constructor.name;
  }
  /**
   * Converts the error to a standard OAuth error response object
   */
  toResponseObject() {
    const response = {
      error: this.errorCode,
      error_description: this.message
    };
    if (this.errorUri) {
      response.error_uri = this.errorUri;
    }
    return response;
  }
  get errorCode() {
    return this.constructor.errorCode;
  }
};
var InvalidRequestError = class extends OAuthError {
};
InvalidRequestError.errorCode = "invalid_request";
var InvalidClientError = class extends OAuthError {
};
InvalidClientError.errorCode = "invalid_client";
var InvalidGrantError = class extends OAuthError {
};
InvalidGrantError.errorCode = "invalid_grant";
var UnauthorizedClientError = class extends OAuthError {
};
UnauthorizedClientError.errorCode = "unauthorized_client";
var UnsupportedGrantTypeError = class extends OAuthError {
};
UnsupportedGrantTypeError.errorCode = "unsupported_grant_type";
var InvalidScopeError = class extends OAuthError {
};
InvalidScopeError.errorCode = "invalid_scope";
var AccessDeniedError = class extends OAuthError {
};
AccessDeniedError.errorCode = "access_denied";
var ServerError = class extends OAuthError {
};
ServerError.errorCode = "server_error";
var TemporarilyUnavailableError = class extends OAuthError {
};
TemporarilyUnavailableError.errorCode = "temporarily_unavailable";
var UnsupportedResponseTypeError = class extends OAuthError {
};
UnsupportedResponseTypeError.errorCode = "unsupported_response_type";
var UnsupportedTokenTypeError = class extends OAuthError {
};
UnsupportedTokenTypeError.errorCode = "unsupported_token_type";
var InvalidTokenError = class extends OAuthError {
};
InvalidTokenError.errorCode = "invalid_token";
var MethodNotAllowedError = class extends OAuthError {
};
MethodNotAllowedError.errorCode = "method_not_allowed";
var TooManyRequestsError = class extends OAuthError {
};
TooManyRequestsError.errorCode = "too_many_requests";
var InvalidClientMetadataError = class extends OAuthError {
};
InvalidClientMetadataError.errorCode = "invalid_client_metadata";
var InsufficientScopeError = class extends OAuthError {
};
InsufficientScopeError.errorCode = "insufficient_scope";
var InvalidTargetError = class extends OAuthError {
};
InvalidTargetError.errorCode = "invalid_target";
var OAUTH_ERRORS = {
  [InvalidRequestError.errorCode]: InvalidRequestError,
  [InvalidClientError.errorCode]: InvalidClientError,
  [InvalidGrantError.errorCode]: InvalidGrantError,
  [UnauthorizedClientError.errorCode]: UnauthorizedClientError,
  [UnsupportedGrantTypeError.errorCode]: UnsupportedGrantTypeError,
  [InvalidScopeError.errorCode]: InvalidScopeError,
  [AccessDeniedError.errorCode]: AccessDeniedError,
  [ServerError.errorCode]: ServerError,
  [TemporarilyUnavailableError.errorCode]: TemporarilyUnavailableError,
  [UnsupportedResponseTypeError.errorCode]: UnsupportedResponseTypeError,
  [UnsupportedTokenTypeError.errorCode]: UnsupportedTokenTypeError,
  [InvalidTokenError.errorCode]: InvalidTokenError,
  [MethodNotAllowedError.errorCode]: MethodNotAllowedError,
  [TooManyRequestsError.errorCode]: TooManyRequestsError,
  [InvalidClientMetadataError.errorCode]: InvalidClientMetadataError,
  [InsufficientScopeError.errorCode]: InsufficientScopeError,
  [InvalidTargetError.errorCode]: InvalidTargetError
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/auth.js
var UnauthorizedError = class extends Error {
  constructor(message) {
    super(message ?? "Unauthorized");
  }
};
function isClientAuthMethod(method) {
  return ["client_secret_basic", "client_secret_post", "none"].includes(method);
}
var AUTHORIZATION_CODE_RESPONSE_TYPE = "code";
var AUTHORIZATION_CODE_CHALLENGE_METHOD = "S256";
function selectClientAuthMethod(clientInformation, supportedMethods) {
  const hasClientSecret = clientInformation.client_secret !== void 0;
  if (supportedMethods.length === 0) {
    return hasClientSecret ? "client_secret_post" : "none";
  }
  if ("token_endpoint_auth_method" in clientInformation && clientInformation.token_endpoint_auth_method && isClientAuthMethod(clientInformation.token_endpoint_auth_method) && supportedMethods.includes(clientInformation.token_endpoint_auth_method)) {
    return clientInformation.token_endpoint_auth_method;
  }
  if (hasClientSecret && supportedMethods.includes("client_secret_basic")) {
    return "client_secret_basic";
  }
  if (hasClientSecret && supportedMethods.includes("client_secret_post")) {
    return "client_secret_post";
  }
  if (supportedMethods.includes("none")) {
    return "none";
  }
  return hasClientSecret ? "client_secret_post" : "none";
}
function applyClientAuthentication(method, clientInformation, headers, params) {
  const { client_id, client_secret } = clientInformation;
  switch (method) {
    case "client_secret_basic":
      applyBasicAuth(client_id, client_secret, headers);
      return;
    case "client_secret_post":
      applyPostAuth(client_id, client_secret, params);
      return;
    case "none":
      applyPublicAuth(client_id, params);
      return;
    default:
      throw new Error(`Unsupported client authentication method: ${method}`);
  }
}
function applyBasicAuth(clientId, clientSecret, headers) {
  if (!clientSecret) {
    throw new Error("client_secret_basic authentication requires a client_secret");
  }
  const credentials = btoa(`${clientId}:${clientSecret}`);
  headers.set("Authorization", `Basic ${credentials}`);
}
function applyPostAuth(clientId, clientSecret, params) {
  params.set("client_id", clientId);
  if (clientSecret) {
    params.set("client_secret", clientSecret);
  }
}
function applyPublicAuth(clientId, params) {
  params.set("client_id", clientId);
}
async function parseErrorResponse(input) {
  const statusCode = input instanceof Response ? input.status : void 0;
  const body = input instanceof Response ? await input.text() : input;
  try {
    const result = OAuthErrorResponseSchema.parse(JSON.parse(body));
    const { error: error2, error_description, error_uri } = result;
    const errorClass = OAUTH_ERRORS[error2] || ServerError;
    return new errorClass(error_description || "", error_uri);
  } catch (error2) {
    const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ""}Invalid OAuth error response: ${error2}. Raw body: ${body}`;
    return new ServerError(errorMessage);
  }
}
async function auth(provider, options) {
  try {
    return await authInternal(provider, options);
  } catch (error2) {
    if (error2 instanceof InvalidClientError || error2 instanceof UnauthorizedClientError) {
      await provider.invalidateCredentials?.("all");
      return await authInternal(provider, options);
    } else if (error2 instanceof InvalidGrantError) {
      await provider.invalidateCredentials?.("tokens");
      return await authInternal(provider, options);
    }
    throw error2;
  }
}
async function authInternal(provider, { serverUrl, authorizationCode, scope, resourceMetadataUrl, fetchFn }) {
  let resourceMetadata;
  let authorizationServerUrl;
  try {
    resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, { resourceMetadataUrl }, fetchFn);
    if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) {
      authorizationServerUrl = resourceMetadata.authorization_servers[0];
    }
  } catch {
  }
  if (!authorizationServerUrl) {
    authorizationServerUrl = new URL("/", serverUrl);
  }
  const resource = await selectResourceURL(serverUrl, provider, resourceMetadata);
  const metadata = await discoverAuthorizationServerMetadata(authorizationServerUrl, {
    fetchFn
  });
  let clientInformation = await Promise.resolve(provider.clientInformation());
  if (!clientInformation) {
    if (authorizationCode !== void 0) {
      throw new Error("Existing OAuth client information is required when exchanging an authorization code");
    }
    const supportsUrlBasedClientId = metadata?.client_id_metadata_document_supported === true;
    const clientMetadataUrl = provider.clientMetadataUrl;
    if (clientMetadataUrl && !isHttpsUrl(clientMetadataUrl)) {
      throw new InvalidClientMetadataError(`clientMetadataUrl must be a valid HTTPS URL with a non-root pathname, got: ${clientMetadataUrl}`);
    }
    const shouldUseUrlBasedClientId = supportsUrlBasedClientId && clientMetadataUrl;
    if (shouldUseUrlBasedClientId) {
      clientInformation = {
        client_id: clientMetadataUrl
      };
      await provider.saveClientInformation?.(clientInformation);
    } else {
      if (!provider.saveClientInformation) {
        throw new Error("OAuth client information must be saveable for dynamic registration");
      }
      const fullInformation = await registerClient(authorizationServerUrl, {
        metadata,
        clientMetadata: provider.clientMetadata,
        fetchFn
      });
      await provider.saveClientInformation(fullInformation);
      clientInformation = fullInformation;
    }
  }
  const nonInteractiveFlow = !provider.redirectUrl;
  if (authorizationCode !== void 0 || nonInteractiveFlow) {
    const tokens2 = await fetchToken(provider, authorizationServerUrl, {
      metadata,
      resource,
      authorizationCode,
      fetchFn
    });
    await provider.saveTokens(tokens2);
    return "AUTHORIZED";
  }
  const tokens = await provider.tokens();
  if (tokens?.refresh_token) {
    try {
      const newTokens = await refreshAuthorization(authorizationServerUrl, {
        metadata,
        clientInformation,
        refreshToken: tokens.refresh_token,
        resource,
        addClientAuthentication: provider.addClientAuthentication,
        fetchFn
      });
      await provider.saveTokens(newTokens);
      return "AUTHORIZED";
    } catch (error2) {
      if (!(error2 instanceof OAuthError) || error2 instanceof ServerError) {
      } else {
        throw error2;
      }
    }
  }
  const state = provider.state ? await provider.state() : void 0;
  const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {
    metadata,
    clientInformation,
    state,
    redirectUrl: provider.redirectUrl,
    scope: scope || resourceMetadata?.scopes_supported?.join(" ") || provider.clientMetadata.scope,
    resource
  });
  await provider.saveCodeVerifier(codeVerifier);
  await provider.redirectToAuthorization(authorizationUrl);
  return "REDIRECT";
}
function isHttpsUrl(value) {
  if (!value)
    return false;
  try {
    const url2 = new URL(value);
    return url2.protocol === "https:" && url2.pathname !== "/";
  } catch {
    return false;
  }
}
async function selectResourceURL(serverUrl, provider, resourceMetadata) {
  const defaultResource = resourceUrlFromServerUrl(serverUrl);
  if (provider.validateResourceURL) {
    return await provider.validateResourceURL(defaultResource, resourceMetadata?.resource);
  }
  if (!resourceMetadata) {
    return void 0;
  }
  if (!checkResourceAllowed({ requestedResource: defaultResource, configuredResource: resourceMetadata.resource })) {
    throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);
  }
  return new URL(resourceMetadata.resource);
}
function extractWWWAuthenticateParams(res) {
  const authenticateHeader = res.headers.get("WWW-Authenticate");
  if (!authenticateHeader) {
    return {};
  }
  const [type, scheme] = authenticateHeader.split(" ");
  if (type.toLowerCase() !== "bearer" || !scheme) {
    return {};
  }
  const resourceMetadataMatch = extractFieldFromWwwAuth(res, "resource_metadata") || void 0;
  let resourceMetadataUrl;
  if (resourceMetadataMatch) {
    try {
      resourceMetadataUrl = new URL(resourceMetadataMatch);
    } catch {
    }
  }
  const scope = extractFieldFromWwwAuth(res, "scope") || void 0;
  const error2 = extractFieldFromWwwAuth(res, "error") || void 0;
  return {
    resourceMetadataUrl,
    scope,
    error: error2
  };
}
function extractFieldFromWwwAuth(response, fieldName) {
  const wwwAuthHeader = response.headers.get("WWW-Authenticate");
  if (!wwwAuthHeader) {
    return null;
  }
  const pattern = new RegExp(`${fieldName}=(?:"([^"]+)"|([^\\s,]+))`);
  const match = wwwAuthHeader.match(pattern);
  if (match) {
    return match[1] || match[2];
  }
  return null;
}
async function discoverOAuthProtectedResourceMetadata(serverUrl, opts, fetchFn = fetch) {
  const response = await discoverMetadataWithFallback(serverUrl, "oauth-protected-resource", fetchFn, {
    protocolVersion: opts?.protocolVersion,
    metadataUrl: opts?.resourceMetadataUrl
  });
  if (!response || response.status === 404) {
    await response?.body?.cancel();
    throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);
  }
  if (!response.ok) {
    await response.body?.cancel();
    throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);
  }
  return OAuthProtectedResourceMetadataSchema.parse(await response.json());
}
async function fetchWithCorsRetry(url2, headers, fetchFn = fetch) {
  try {
    return await fetchFn(url2, { headers });
  } catch (error2) {
    if (error2 instanceof TypeError) {
      if (headers) {
        return fetchWithCorsRetry(url2, void 0, fetchFn);
      } else {
        return void 0;
      }
    }
    throw error2;
  }
}
function buildWellKnownPath(wellKnownPrefix, pathname = "", options = {}) {
  if (pathname.endsWith("/")) {
    pathname = pathname.slice(0, -1);
  }
  return options.prependPathname ? `${pathname}/.well-known/${wellKnownPrefix}` : `/.well-known/${wellKnownPrefix}${pathname}`;
}
async function tryMetadataDiscovery(url2, protocolVersion, fetchFn = fetch) {
  const headers = {
    "MCP-Protocol-Version": protocolVersion
  };
  return await fetchWithCorsRetry(url2, headers, fetchFn);
}
function shouldAttemptFallback(response, pathname) {
  return !response || response.status >= 400 && response.status < 500 && pathname !== "/";
}
async function discoverMetadataWithFallback(serverUrl, wellKnownType, fetchFn, opts) {
  const issuer = new URL(serverUrl);
  const protocolVersion = opts?.protocolVersion ?? LATEST_PROTOCOL_VERSION;
  let url2;
  if (opts?.metadataUrl) {
    url2 = new URL(opts.metadataUrl);
  } else {
    const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);
    url2 = new URL(wellKnownPath, opts?.metadataServerUrl ?? issuer);
    url2.search = issuer.search;
  }
  let response = await tryMetadataDiscovery(url2, protocolVersion, fetchFn);
  if (!opts?.metadataUrl && shouldAttemptFallback(response, issuer.pathname)) {
    const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);
    response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);
  }
  return response;
}
function buildDiscoveryUrls(authorizationServerUrl) {
  const url2 = typeof authorizationServerUrl === "string" ? new URL(authorizationServerUrl) : authorizationServerUrl;
  const hasPath = url2.pathname !== "/";
  const urlsToTry = [];
  if (!hasPath) {
    urlsToTry.push({
      url: new URL("/.well-known/oauth-authorization-server", url2.origin),
      type: "oauth"
    });
    urlsToTry.push({
      url: new URL(`/.well-known/openid-configuration`, url2.origin),
      type: "oidc"
    });
    return urlsToTry;
  }
  let pathname = url2.pathname;
  if (pathname.endsWith("/")) {
    pathname = pathname.slice(0, -1);
  }
  urlsToTry.push({
    url: new URL(`/.well-known/oauth-authorization-server${pathname}`, url2.origin),
    type: "oauth"
  });
  urlsToTry.push({
    url: new URL(`/.well-known/openid-configuration${pathname}`, url2.origin),
    type: "oidc"
  });
  urlsToTry.push({
    url: new URL(`${pathname}/.well-known/openid-configuration`, url2.origin),
    type: "oidc"
  });
  return urlsToTry;
}
async function discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn = fetch, protocolVersion = LATEST_PROTOCOL_VERSION } = {}) {
  const headers = {
    "MCP-Protocol-Version": protocolVersion,
    Accept: "application/json"
  };
  const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);
  for (const { url: endpointUrl, type } of urlsToTry) {
    const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);
    if (!response) {
      continue;
    }
    if (!response.ok) {
      await response.body?.cancel();
      if (response.status >= 400 && response.status < 500) {
        continue;
      }
      throw new Error(`HTTP ${response.status} trying to load ${type === "oauth" ? "OAuth" : "OpenID provider"} metadata from ${endpointUrl}`);
    }
    if (type === "oauth") {
      return OAuthMetadataSchema.parse(await response.json());
    } else {
      return OpenIdProviderDiscoveryMetadataSchema.parse(await response.json());
    }
  }
  return void 0;
}
async function startAuthorization(authorizationServerUrl, { metadata, clientInformation, redirectUrl, scope, state, resource }) {
  let authorizationUrl;
  if (metadata) {
    authorizationUrl = new URL(metadata.authorization_endpoint);
    if (!metadata.response_types_supported.includes(AUTHORIZATION_CODE_RESPONSE_TYPE)) {
      throw new Error(`Incompatible auth server: does not support response type ${AUTHORIZATION_CODE_RESPONSE_TYPE}`);
    }
    if (metadata.code_challenge_methods_supported && !metadata.code_challenge_methods_supported.includes(AUTHORIZATION_CODE_CHALLENGE_METHOD)) {
      throw new Error(`Incompatible auth server: does not support code challenge method ${AUTHORIZATION_CODE_CHALLENGE_METHOD}`);
    }
  } else {
    authorizationUrl = new URL("/authorize", authorizationServerUrl);
  }
  const challenge = await pkceChallenge();
  const codeVerifier = challenge.code_verifier;
  const codeChallenge = challenge.code_challenge;
  authorizationUrl.searchParams.set("response_type", AUTHORIZATION_CODE_RESPONSE_TYPE);
  authorizationUrl.searchParams.set("client_id", clientInformation.client_id);
  authorizationUrl.searchParams.set("code_challenge", codeChallenge);
  authorizationUrl.searchParams.set("code_challenge_method", AUTHORIZATION_CODE_CHALLENGE_METHOD);
  authorizationUrl.searchParams.set("redirect_uri", String(redirectUrl));
  if (state) {
    authorizationUrl.searchParams.set("state", state);
  }
  if (scope) {
    authorizationUrl.searchParams.set("scope", scope);
  }
  if (scope?.includes("offline_access")) {
    authorizationUrl.searchParams.append("prompt", "consent");
  }
  if (resource) {
    authorizationUrl.searchParams.set("resource", resource.href);
  }
  return { authorizationUrl, codeVerifier };
}
function prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, redirectUri) {
  return new URLSearchParams({
    grant_type: "authorization_code",
    code: authorizationCode,
    code_verifier: codeVerifier,
    redirect_uri: String(redirectUri)
  });
}
async function executeTokenRequest(authorizationServerUrl, { metadata, tokenRequestParams, clientInformation, addClientAuthentication, resource, fetchFn }) {
  const tokenUrl = metadata?.token_endpoint ? new URL(metadata.token_endpoint) : new URL("/token", authorizationServerUrl);
  const headers = new Headers({
    "Content-Type": "application/x-www-form-urlencoded",
    Accept: "application/json"
  });
  if (resource) {
    tokenRequestParams.set("resource", resource.href);
  }
  if (addClientAuthentication) {
    await addClientAuthentication(headers, tokenRequestParams, tokenUrl, metadata);
  } else if (clientInformation) {
    const supportedMethods = metadata?.token_endpoint_auth_methods_supported ?? [];
    const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
    applyClientAuthentication(authMethod, clientInformation, headers, tokenRequestParams);
  }
  const response = await (fetchFn ?? fetch)(tokenUrl, {
    method: "POST",
    headers,
    body: tokenRequestParams
  });
  if (!response.ok) {
    throw await parseErrorResponse(response);
  }
  return OAuthTokensSchema.parse(await response.json());
}
async function refreshAuthorization(authorizationServerUrl, { metadata, clientInformation, refreshToken, resource, addClientAuthentication, fetchFn }) {
  const tokenRequestParams = new URLSearchParams({
    grant_type: "refresh_token",
    refresh_token: refreshToken
  });
  const tokens = await executeTokenRequest(authorizationServerUrl, {
    metadata,
    tokenRequestParams,
    clientInformation,
    addClientAuthentication,
    resource,
    fetchFn
  });
  return { refresh_token: refreshToken, ...tokens };
}
async function fetchToken(provider, authorizationServerUrl, { metadata, resource, authorizationCode, fetchFn } = {}) {
  const scope = provider.clientMetadata.scope;
  let tokenRequestParams;
  if (provider.prepareTokenRequest) {
    tokenRequestParams = await provider.prepareTokenRequest(scope);
  }
  if (!tokenRequestParams) {
    if (!authorizationCode) {
      throw new Error("Either provider.prepareTokenRequest() or authorizationCode is required");
    }
    if (!provider.redirectUrl) {
      throw new Error("redirectUrl is required for authorization_code flow");
    }
    const codeVerifier = await provider.codeVerifier();
    tokenRequestParams = prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, provider.redirectUrl);
  }
  const clientInformation = await provider.clientInformation();
  return executeTokenRequest(authorizationServerUrl, {
    metadata,
    tokenRequestParams,
    clientInformation: clientInformation ?? void 0,
    addClientAuthentication: provider.addClientAuthentication,
    resource,
    fetchFn
  });
}
async function registerClient(authorizationServerUrl, { metadata, clientMetadata, fetchFn }) {
  let registrationUrl;
  if (metadata) {
    if (!metadata.registration_endpoint) {
      throw new Error("Incompatible auth server: does not support dynamic client registration");
    }
    registrationUrl = new URL(metadata.registration_endpoint);
  } else {
    registrationUrl = new URL("/register", authorizationServerUrl);
  }
  const response = await (fetchFn ?? fetch)(registrationUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(clientMetadata)
  });
  if (!response.ok) {
    throw await parseErrorResponse(response);
  }
  return OAuthClientInformationFullSchema.parse(await response.json());
}

// node_modules/eventsource-parser/dist/index.js
var ParseError = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop3(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop3, onError = noop3, onRetry = noop3, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}

// node_modules/eventsource-parser/dist/stream.js
var EventSourceParserStream = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error2) {
            onError === "terminate" ? controller.error(error2) : typeof onError == "function" && onError(error2);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/streamableHttp.js
var DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS = {
  initialReconnectionDelay: 1e3,
  maxReconnectionDelay: 3e4,
  reconnectionDelayGrowFactor: 1.5,
  maxRetries: 2
};
var StreamableHTTPError = class extends Error {
  constructor(code, message) {
    super(`Streamable HTTP error: ${message}`);
    this.code = code;
  }
};
var StreamableHTTPClientTransport = class {
  constructor(url2, opts) {
    this._hasCompletedAuthFlow = false;
    this._url = url2;
    this._resourceMetadataUrl = void 0;
    this._scope = void 0;
    this._requestInit = opts?.requestInit;
    this._authProvider = opts?.authProvider;
    this._fetch = opts?.fetch;
    this._fetchWithInit = createFetchWithInit(opts?.fetch, opts?.requestInit);
    this._sessionId = opts?.sessionId;
    this._reconnectionOptions = opts?.reconnectionOptions ?? DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS;
  }
  async _authThenStart() {
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    let result;
    try {
      result = await auth(this._authProvider, {
        serverUrl: this._url,
        resourceMetadataUrl: this._resourceMetadataUrl,
        scope: this._scope,
        fetchFn: this._fetchWithInit
      });
    } catch (error2) {
      this.onerror?.(error2);
      throw error2;
    }
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError();
    }
    return await this._startOrAuthSse({ resumptionToken: void 0 });
  }
  async _commonHeaders() {
    const headers = {};
    if (this._authProvider) {
      const tokens = await this._authProvider.tokens();
      if (tokens) {
        headers["Authorization"] = `Bearer ${tokens.access_token}`;
      }
    }
    if (this._sessionId) {
      headers["mcp-session-id"] = this._sessionId;
    }
    if (this._protocolVersion) {
      headers["mcp-protocol-version"] = this._protocolVersion;
    }
    const extraHeaders = normalizeHeaders(this._requestInit?.headers);
    return new Headers({
      ...headers,
      ...extraHeaders
    });
  }
  async _startOrAuthSse(options) {
    const { resumptionToken } = options;
    try {
      const headers = await this._commonHeaders();
      headers.set("Accept", "text/event-stream");
      if (resumptionToken) {
        headers.set("last-event-id", resumptionToken);
      }
      const response = await (this._fetch ?? fetch)(this._url, {
        method: "GET",
        headers,
        signal: this._abortController?.signal
      });
      if (!response.ok) {
        await response.body?.cancel();
        if (response.status === 401 && this._authProvider) {
          return await this._authThenStart();
        }
        if (response.status === 405) {
          return;
        }
        throw new StreamableHTTPError(response.status, `Failed to open SSE stream: ${response.statusText}`);
      }
      this._handleSseStream(response.body, options, true);
    } catch (error2) {
      this.onerror?.(error2);
      throw error2;
    }
  }
  /**
   * Calculates the next reconnection delay using  backoff algorithm
   *
   * @param attempt Current reconnection attempt count for the specific stream
   * @returns Time to wait in milliseconds before next reconnection attempt
   */
  _getNextReconnectionDelay(attempt) {
    if (this._serverRetryMs !== void 0) {
      return this._serverRetryMs;
    }
    const initialDelay = this._reconnectionOptions.initialReconnectionDelay;
    const growFactor = this._reconnectionOptions.reconnectionDelayGrowFactor;
    const maxDelay = this._reconnectionOptions.maxReconnectionDelay;
    return Math.min(initialDelay * Math.pow(growFactor, attempt), maxDelay);
  }
  /**
   * Schedule a reconnection attempt using server-provided retry interval or backoff
   *
   * @param lastEventId The ID of the last received event for resumability
   * @param attemptCount Current reconnection attempt count for this specific stream
   */
  _scheduleReconnection(options, attemptCount = 0) {
    const maxRetries = this._reconnectionOptions.maxRetries;
    if (attemptCount >= maxRetries) {
      this.onerror?.(new Error(`Maximum reconnection attempts (${maxRetries}) exceeded.`));
      return;
    }
    const delay = this._getNextReconnectionDelay(attemptCount);
    this._reconnectionTimeout = setTimeout(() => {
      this._startOrAuthSse(options).catch((error2) => {
        this.onerror?.(new Error(`Failed to reconnect SSE stream: ${error2 instanceof Error ? error2.message : String(error2)}`));
        this._scheduleReconnection(options, attemptCount + 1);
      });
    }, delay);
  }
  _handleSseStream(stream, options, isReconnectable) {
    if (!stream) {
      return;
    }
    const { onresumptiontoken, replayMessageId } = options;
    let lastEventId;
    let hasPrimingEvent = false;
    let receivedResponse = false;
    const processStream = async () => {
      try {
        const reader = stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream({
          onRetry: (retryMs) => {
            this._serverRetryMs = retryMs;
          }
        })).getReader();
        while (true) {
          const { value: event, done } = await reader.read();
          if (done) {
            break;
          }
          if (event.id) {
            lastEventId = event.id;
            hasPrimingEvent = true;
            onresumptiontoken?.(event.id);
          }
          if (!event.data) {
            continue;
          }
          if (!event.event || event.event === "message") {
            try {
              const message = JSONRPCMessageSchema.parse(JSON.parse(event.data));
              if (isJSONRPCResultResponse(message)) {
                receivedResponse = true;
                if (replayMessageId !== void 0) {
                  message.id = replayMessageId;
                }
              }
              this.onmessage?.(message);
            } catch (error2) {
              this.onerror?.(error2);
            }
          }
        }
        const canResume = isReconnectable || hasPrimingEvent;
        const needsReconnect = canResume && !receivedResponse;
        if (needsReconnect && this._abortController && !this._abortController.signal.aborted) {
          this._scheduleReconnection({
            resumptionToken: lastEventId,
            onresumptiontoken,
            replayMessageId
          }, 0);
        }
      } catch (error2) {
        this.onerror?.(new Error(`SSE stream disconnected: ${error2}`));
        const canResume = isReconnectable || hasPrimingEvent;
        const needsReconnect = canResume && !receivedResponse;
        if (needsReconnect && this._abortController && !this._abortController.signal.aborted) {
          try {
            this._scheduleReconnection({
              resumptionToken: lastEventId,
              onresumptiontoken,
              replayMessageId
            }, 0);
          } catch (error3) {
            this.onerror?.(new Error(`Failed to reconnect: ${error3 instanceof Error ? error3.message : String(error3)}`));
          }
        }
      }
    };
    processStream();
  }
  async start() {
    if (this._abortController) {
      throw new Error("StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    }
    this._abortController = new AbortController();
  }
  /**
   * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
   */
  async finishAuth(authorizationCode) {
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    const result = await auth(this._authProvider, {
      serverUrl: this._url,
      authorizationCode,
      resourceMetadataUrl: this._resourceMetadataUrl,
      scope: this._scope,
      fetchFn: this._fetchWithInit
    });
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError("Failed to authorize");
    }
  }
  async close() {
    if (this._reconnectionTimeout) {
      clearTimeout(this._reconnectionTimeout);
      this._reconnectionTimeout = void 0;
    }
    this._abortController?.abort();
    this.onclose?.();
  }
  async send(message, options) {
    try {
      const { resumptionToken, onresumptiontoken } = options || {};
      if (resumptionToken) {
        this._startOrAuthSse({ resumptionToken, replayMessageId: isJSONRPCRequest(message) ? message.id : void 0 }).catch((err) => this.onerror?.(err));
        return;
      }
      const headers = await this._commonHeaders();
      headers.set("content-type", "application/json");
      headers.set("accept", "application/json, text/event-stream");
      const init = {
        ...this._requestInit,
        method: "POST",
        headers,
        body: JSON.stringify(message),
        signal: this._abortController?.signal
      };
      const response = await (this._fetch ?? fetch)(this._url, init);
      const sessionId = response.headers.get("mcp-session-id");
      if (sessionId) {
        this._sessionId = sessionId;
      }
      if (!response.ok) {
        const text = await response.text().catch(() => null);
        if (response.status === 401 && this._authProvider) {
          if (this._hasCompletedAuthFlow) {
            throw new StreamableHTTPError(401, "Server returned 401 after successful authentication");
          }
          const { resourceMetadataUrl, scope } = extractWWWAuthenticateParams(response);
          this._resourceMetadataUrl = resourceMetadataUrl;
          this._scope = scope;
          const result = await auth(this._authProvider, {
            serverUrl: this._url,
            resourceMetadataUrl: this._resourceMetadataUrl,
            scope: this._scope,
            fetchFn: this._fetchWithInit
          });
          if (result !== "AUTHORIZED") {
            throw new UnauthorizedError();
          }
          this._hasCompletedAuthFlow = true;
          return this.send(message);
        }
        if (response.status === 403 && this._authProvider) {
          const { resourceMetadataUrl, scope, error: error2 } = extractWWWAuthenticateParams(response);
          if (error2 === "insufficient_scope") {
            const wwwAuthHeader = response.headers.get("WWW-Authenticate");
            if (this._lastUpscopingHeader === wwwAuthHeader) {
              throw new StreamableHTTPError(403, "Server returned 403 after trying upscoping");
            }
            if (scope) {
              this._scope = scope;
            }
            if (resourceMetadataUrl) {
              this._resourceMetadataUrl = resourceMetadataUrl;
            }
            this._lastUpscopingHeader = wwwAuthHeader ?? void 0;
            const result = await auth(this._authProvider, {
              serverUrl: this._url,
              resourceMetadataUrl: this._resourceMetadataUrl,
              scope: this._scope,
              fetchFn: this._fetch
            });
            if (result !== "AUTHORIZED") {
              throw new UnauthorizedError();
            }
            return this.send(message);
          }
        }
        throw new StreamableHTTPError(response.status, `Error POSTing to endpoint: ${text}`);
      }
      this._hasCompletedAuthFlow = false;
      this._lastUpscopingHeader = void 0;
      if (response.status === 202) {
        await response.body?.cancel();
        if (isInitializedNotification(message)) {
          this._startOrAuthSse({ resumptionToken: void 0 }).catch((err) => this.onerror?.(err));
        }
        return;
      }
      const messages = Array.isArray(message) ? message : [message];
      const hasRequests = messages.filter((msg) => "method" in msg && "id" in msg && msg.id !== void 0).length > 0;
      const contentType = response.headers.get("content-type");
      if (hasRequests) {
        if (contentType?.includes("text/event-stream")) {
          this._handleSseStream(response.body, { onresumptiontoken }, false);
        } else if (contentType?.includes("application/json")) {
          const data = await response.json();
          const responseMessages = Array.isArray(data) ? data.map((msg) => JSONRPCMessageSchema.parse(msg)) : [JSONRPCMessageSchema.parse(data)];
          for (const msg of responseMessages) {
            this.onmessage?.(msg);
          }
        } else {
          await response.body?.cancel();
          throw new StreamableHTTPError(-1, `Unexpected content type: ${contentType}`);
        }
      } else {
        await response.body?.cancel();
      }
    } catch (error2) {
      this.onerror?.(error2);
      throw error2;
    }
  }
  get sessionId() {
    return this._sessionId;
  }
  /**
   * Terminates the current session by sending a DELETE request to the server.
   *
   * Clients that no longer need a particular session
   * (e.g., because the user is leaving the client application) SHOULD send an
   * HTTP DELETE to the MCP endpoint with the Mcp-Session-Id header to explicitly
   * terminate the session.
   *
   * The server MAY respond with HTTP 405 Method Not Allowed, indicating that
   * the server does not allow clients to terminate sessions.
   */
  async terminateSession() {
    if (!this._sessionId) {
      return;
    }
    try {
      const headers = await this._commonHeaders();
      const init = {
        ...this._requestInit,
        method: "DELETE",
        headers,
        signal: this._abortController?.signal
      };
      const response = await (this._fetch ?? fetch)(this._url, init);
      await response.body?.cancel();
      if (!response.ok && response.status !== 405) {
        throw new StreamableHTTPError(response.status, `Failed to terminate session: ${response.statusText}`);
      }
      this._sessionId = void 0;
    } catch (error2) {
      this.onerror?.(error2);
      throw error2;
    }
  }
  setProtocolVersion(version9) {
    this._protocolVersion = version9;
  }
  get protocolVersion() {
    return this._protocolVersion;
  }
  /**
   * Resume an SSE stream from a previous event ID.
   * Opens a GET SSE connection with Last-Event-ID header to replay missed events.
   *
   * @param lastEventId The event ID to resume from
   * @param options Optional callback to receive new resumption tokens
   */
  async resumeStream(lastEventId, options) {
    await this._startOrAuthSse({
      resumptionToken: lastEventId,
      onresumptiontoken: options?.onresumptiontoken
    });
  }
};

// src/utils/mcpWebSearchClient.ts
var vscode29 = __toESM(require("vscode"));
init_apiKeyManager();
init_configManager();
init_logger();
var MCPWebSearchClient = class _MCPWebSearchClient {
  // Static cache: cache client instances based on API key
  static clientCache = /* @__PURE__ */ new Map();
  client = null;
  transport = null;
  userAgent;
  currentApiKey = null;
  isConnecting = false;
  connectionPromise = null;
  constructor() {
    this.userAgent = VersionManager.getUserAgent("MCPWebSearch");
  }
  /**
   * Get or create client instance (singleton mode, based on API key)
   */
  static async getInstance(apiKey) {
    const key = apiKey || await ApiKeyManager.getApiKey("zhipu");
    if (!key) {
      throw new Error("ZhipuAI API key not set");
    }
    let instance = _MCPWebSearchClient.clientCache.get(key);
    if (!instance) {
      Logger.debug(
        `[MCP WebSearch] Creating new client instance (API key: ${key.substring(0, 8)}...)`
      );
      instance = new _MCPWebSearchClient();
      instance.currentApiKey = key;
      _MCPWebSearchClient.clientCache.set(key, instance);
    } else {
      Logger.debug(
        `[MCP WebSearch] Reusing cached client instance (API key: ${key.substring(0, 8)}...)`
      );
    }
    await instance.ensureConnected();
    return instance;
  }
  /**
   * Clear cache for specified API key
   */
  static async clearCache(apiKey) {
    if (apiKey) {
      const instance = _MCPWebSearchClient.clientCache.get(apiKey);
      if (instance) {
        await instance.cleanup();
        _MCPWebSearchClient.clientCache.delete(apiKey);
        Logger.info(
          `[MCP WebSearch] Cleared cache for API key ${apiKey.substring(0, 8)}...`
        );
      }
    } else {
      for (const [key, instance] of _MCPWebSearchClient.clientCache.entries()) {
        await instance.cleanup();
        Logger.info(
          `[MCP WebSearch] Cleared cache for API key ${key.substring(0, 8)}...`
        );
      }
      _MCPWebSearchClient.clientCache.clear();
      Logger.info("[MCP WebSearch] Cleared all client caches");
    }
  }
  /**
   * Get cache statistics
   */
  static getCacheStats() {
    const stats = {
      totalClients: _MCPWebSearchClient.clientCache.size,
      connectedClients: 0,
      apiKeys: []
    };
    for (const [key, instance] of _MCPWebSearchClient.clientCache.entries()) {
      if (instance.isConnected()) {
        stats.connectedClients++;
      }
      stats.apiKeys.push(`${key.substring(0, 8)}...`);
    }
    return stats;
  }
  /**
   * Process error response
   */
  async handleErrorResponse(error2) {
    const errorMessage = error2.message;
    if (errorMessage.includes("403") || errorMessage.includes("You do not have access")) {
      if (errorMessage.includes("search-prime") || errorMessage.includes("web_search_prime")) {
        Logger.warn(
          `[MCP WebSearch] Detected insufficient MCP permissions for web search: ${errorMessage}`
        );
        const shouldDisableMCP = await this.showMCPDisableDialog();
        if (shouldDisableMCP) {
          await this.disableMCPMode();
          throw new Error(
            "Insufficient ZhipuAI search permissions: MCP mode disabled, please try searching again."
          );
        } else {
          throw new Error(
            "Insufficient ZhipuAI search permissions: Your account does not have access to web search MCP features. Please check your ZhipuAI subscription status."
          );
        }
      } else {
        throw new Error(
          "Insufficient ZhipuAI search permissions: 403 error. Please check your API key permissions or subscription status."
        );
      }
    } else if (errorMessage.includes("MCP error")) {
      const mcpErrorMatch = errorMessage.match(/MCP error (\d+): (.+)/);
      if (mcpErrorMatch) {
        const [, errorCode, errorDesc] = mcpErrorMatch;
        throw new Error(
          `ZhipuAI MCP protocol error ${errorCode}: ${errorDesc}`
        );
      }
    }
    throw error2;
  }
  /**
   * Show MCP disable dialog
   */
  async showMCPDisableDialog() {
    const message = "Detected that your ZhipuAI account does not have access to web search MCP features. This could be because:\n\n1. Your account does not support MCP features (requires Coding Plan subscription)\n2. Insufficient API key permissions\n\nSwitch to standard billing mode (pay-per-use)?";
    const result = await vscode29.window.showWarningMessage(
      message,
      { modal: true },
      "Switch to Standard Mode",
      "Keep MCP Mode"
    );
    return result === "Switch to Standard Mode";
  }
  /**
   * Disable MCP mode
   */
  async disableMCPMode() {
    try {
      const config2 = vscode29.workspace.getConfiguration("chp.zhipu.search");
      await config2.update(
        "enableMCP",
        false,
        vscode29.ConfigurationTarget.Global
      );
      Logger.info(
        "[MCP WebSearch] MCP mode disabled, switched to standard billing mode"
      );
      vscode29.window.showInformationMessage(
        "ZhipuAI search has switched to standard billing mode (pay-per-use). You can re-enable MCP mode in settings."
      );
      await this.internalCleanup();
    } catch (error2) {
      Logger.error(
        "[MCP WebSearch] Failed to disable MCP mode",
        error2 instanceof Error ? error2 : void 0
      );
      throw new Error(
        `Failed to disable MCP mode: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
  /**
   * Check if available
   */
  async isEnabled() {
    const apiKey = await ApiKeyManager.getApiKey("zhipu");
    return !!apiKey;
  }
  /**
   * Check if connected
   */
  isConnected() {
    return this.client !== null && this.transport !== null;
  }
  /**
   * Ensure client is connected (with auto-reconnect)
   */
  async ensureConnected() {
    if (this.isConnected()) {
      Logger.debug("[MCP WebSearch] Client connected");
      return;
    }
    if (this.isConnecting && this.connectionPromise) {
      Logger.debug("[MCP WebSearch] Waiting for connection to complete...");
      return this.connectionPromise;
    }
    this.isConnecting = true;
    this.connectionPromise = this.initializeClient().finally(() => {
      this.isConnecting = false;
      this.connectionPromise = null;
    });
    return this.connectionPromise;
  }
  /**
   * Initialize MCP client connection
   */
  async initializeClient() {
    if (this.client && this.transport) {
      Logger.debug("[MCP WebSearch] Client initialized");
      return;
    }
    const apiKey = this.currentApiKey || await ApiKeyManager.getApiKey("zhipu");
    if (!apiKey) {
      throw new Error("ZhipuAI API key not set");
    }
    this.currentApiKey = apiKey;
    Logger.info("[MCP WebSearch] Initializing MCP client...");
    try {
      let httpUrl = "https://open.bigmodel.cn/api/mcp/web_search_prime/mcp";
      const endpoint = ConfigManager.getZhipuEndpoint();
      if (endpoint === "api.z.ai") {
        httpUrl = httpUrl.replace("open.bigmodel.cn", "api.z.ai");
      }
      this.client = new Client(
        {
          name: "CHP-WebSearch-Client",
          version: VersionManager.getVersion()
        },
        {
          capabilities: {}
        }
      );
      this.transport = new StreamableHTTPClientTransport(new URL(httpUrl), {
        requestInit: {
          headers: {
            Authorization: `Bearer ${apiKey}`,
            "User-Agent": this.userAgent
          }
        }
      });
      await this.client.connect(this.transport);
      Logger.info(
        "[MCP WebSearch] Connected successfully using StreamableHTTP transport (authenticated via Authorization header)"
      );
    } catch (error2) {
      Logger.error(
        "[MCP WebSearch] Client initialization failed",
        error2 instanceof Error ? error2 : void 0
      );
      await this.internalCleanup();
      throw new Error(
        `MCP client connection failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
  /**
   * Execute search
   */
  async search(params) {
    Logger.info(`[MCP WebSearch] Starting search: "${params.search_query}"`);
    await this.ensureConnected();
    if (!this.client) {
      throw new Error("MCP client not initialized");
    }
    try {
      const tools = await this.client.listTools();
      Logger.debug(
        `[MCP WebSearch] Available tools: ${tools.tools.map((t) => t.name).join(", ")}`
      );
      const webSearchTool = tools.tools.find(
        (t) => t.name === "webSearchPrime"
      );
      if (!webSearchTool) {
        throw new Error("webSearchPrime tool not found");
      }
      const result = await this.client.callTool({
        name: "webSearchPrime",
        arguments: {
          search_query: params.search_query,
          search_engine: params.search_engine || "search_std",
          search_intent: params.search_intent || false,
          count: params.count || 10,
          search_domain_filter: params.search_domain_filter,
          search_recency_filter: params.search_recency_filter || "noLimit",
          content_size: params.content_size || "medium"
        }
      });
      if (Array.isArray(result.content)) {
        const [{ text }] = result.content;
        if (text.startsWith("MCP error")) {
          throw new Error(text);
        }
        const searchResults = JSON.parse(
          JSON.parse(text)
        );
        Logger.debug(
          `[MCP WebSearch] Tool invocation successful: ${searchResults?.length || 0} results`
        );
        return searchResults;
      }
      Logger.debug("[MCP WebSearch] Tool invocation finished: no results");
      return [];
    } catch (error2) {
      Logger.error(
        "[MCP WebSearch] Search failed",
        error2 instanceof Error ? error2 : void 0
      );
      if (error2 instanceof Error) {
        await this.handleErrorResponse(error2);
      }
      if (error2 instanceof Error && (error2.message.includes("connection") || error2.message.includes("connect"))) {
        Logger.warn(
          "[MCP WebSearch] Connection error detected, will auto-reconnect on next search"
        );
        await this.internalCleanup();
      }
      throw new Error(
        `Search failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
  /**
   * Get client status
   */
  getStatus() {
    return {
      name: "CHP-MCP-WebSearch-Client",
      version: VersionManager.getVersion(),
      enabled: true,
      connected: this.isConnected()
    };
  }
  /**
   * Internal cleanup method (does not remove from cache)
   */
  async internalCleanup() {
    Logger.debug("[MCP WebSearch] Cleaning up client connection...");
    try {
      if (this.transport) {
        await this.transport.close();
        this.transport = null;
      }
      this.client = null;
      Logger.debug("[MCP WebSearch] Client connection cleaned up");
    } catch (error2) {
      Logger.error(
        "[MCP WebSearch] Connection cleanup failed",
        error2 instanceof Error ? error2 : void 0
      );
    }
  }
  /**
   * Cleanup resources (public method, removes from cache)
   */
  async cleanup() {
    Logger.info("[MCP WebSearch] Cleaning up client resources...");
    try {
      await this.internalCleanup();
      if (this.currentApiKey) {
        _MCPWebSearchClient.clientCache.delete(this.currentApiKey);
        Logger.info(
          `[MCP WebSearch] Removed client from cache (API key: ${this.currentApiKey.substring(0, 8)}...)`
        );
      }
      Logger.info("[MCP WebSearch] Client resources cleaned up");
    } catch (error2) {
      Logger.error(
        "[MCP WebSearch] Resource cleanup failed",
        error2 instanceof Error ? error2 : void 0
      );
    }
  }
  /**
   * Reconnect
   */
  async reconnect() {
    Logger.info("[MCP WebSearch] Reconnecting client...");
    await this.internalCleanup();
    await this.ensureConnected();
  }
};

// src/utils/modelInfoCache.ts
var import_node_crypto2 = __toESM(require("node:crypto"));
var vscode30 = __toESM(require("vscode"));
init_config();
init_logger();
var ModelInfoCache = class _ModelInfoCache {
  context;
  cacheVersion = "1";
  cacheExpiryMs = 24 * 60 * 60 * 1e3;
  // 24 hours
  static SELECTED_MODEL_KEY = "chp_selected_model";
  // Global model selection storage key
  constructor(context) {
    this.context = context;
  }
  /**
   * Get cached model information
   *
   * Quickly checks if cache is valid. Checks:
   * - Cache existence
   * - Extension version match
   * - API key hash match
   * - Cache not expired
   *
   * @param providerKey Provider identifier (e.g., 'zhipu', 'kimi')
   * @param apiKeyHash API key hash
   * @returns Valid model information list, or null (if cache is invalid or non-existent)
   */
  async getCachedModels(providerKey, apiKeyHash) {
    try {
      const isDevelopment = this.context.extensionMode === vscode30.ExtensionMode.Development;
      if (isDevelopment) {
        Logger.trace(
          `[ModelInfoCache] ${providerKey}: Skipping cache in development mode`
        );
        return null;
      }
      const cacheKey = this.getCacheKey(providerKey);
      const cached2 = this.context.globalState.get(cacheKey);
      if (!cached2) {
        Logger.trace(`[ModelInfoCache] ${providerKey}: No cache`);
        return null;
      }
      const currentVersion = vscode30.extensions.getExtension("vicanent.copilot-helper-pro")?.packageJSON.version || "";
      if (cached2.extensionVersion !== currentVersion) {
        Logger.trace(
          `[ModelInfoCache] ${providerKey}: Version mismatch (cached: ${cached2.extensionVersion}, current: ${currentVersion})`
        );
        return null;
      }
      if (cached2.apiKeyHash !== apiKeyHash) {
        Logger.trace(`[ModelInfoCache] ${providerKey}: API key changed`);
        return null;
      }
      const now = Date.now();
      const ageMs = now - cached2.timestamp;
      if (ageMs > this.cacheExpiryMs) {
        const ageHours = (ageMs / (60 * 60 * 1e3)).toFixed(1);
        Logger.trace(
          `[ModelInfoCache] ${providerKey}: Cache expired (${ageHours} hours ago)`
        );
        return null;
      }
      Logger.trace(
        `[ModelInfoCache] ${providerKey}: Cache hit (${cached2.models.length} models, age ${(ageMs / 1e3).toFixed(1)}s)`
      );
      return cached2.models;
    } catch (err) {
      Logger.warn(
        `[ModelInfoCache] Failed to read ${providerKey} cache:`,
        err instanceof Error ? err.message : String(err)
      );
      return null;
    }
  }
  /**
   * Cache model information
   *
   * Asynchronously stores model information in globalState. This operation should not block.
   *
   * @param providerKey Provider identifier
   * @param models Model information list to cache
   * @param apiKeyHash API key hash
   */
  async cacheModels(providerKey, models, apiKeyHash) {
    try {
      const currentVersion = vscode30.extensions.getExtension("vicanent.copilot-helper-pro")?.packageJSON.version || "";
      const cacheData = {
        models,
        extensionVersion: currentVersion,
        timestamp: Date.now(),
        apiKeyHash
      };
      const cacheKey = this.getCacheKey(providerKey);
      await this.context.globalState.update(cacheKey, cacheData);
    } catch (err) {
      Logger.warn(
        `[ModelInfoCache] Failed to cache ${providerKey}:`,
        err instanceof Error ? err.message : String(err)
      );
    }
  }
  /**
   * Invalidate cache for a specific provider
   *
   * Called when:
   * - API key changes (ApiKeyManager.setApiKey)
   * - Provider configuration changes (onDidChangeConfiguration)
   * - User manually clears cache
   *
   * @param providerKey Provider identifier
   */
  async invalidateCache(providerKey) {
    try {
      const cacheKey = this.getCacheKey(providerKey);
      await this.context.globalState.update(cacheKey, void 0);
      Logger.trace(`[ModelInfoCache] ${providerKey}: Cache cleared`);
    } catch (err) {
      Logger.warn(
        `[ModelInfoCache] Failed to clear ${providerKey} cache:`,
        err instanceof Error ? err.message : String(err)
      );
    }
  }
  /**
   * Clear all caches
   *
   * Called during extension uninstall or user request
   */
  async clearAll() {
    const allProviderKeys = [...Object.keys(configProviders), "compatible"];
    let clearedCount = 0;
    for (const key of allProviderKeys) {
      try {
        await this.invalidateCache(key);
        clearedCount++;
      } catch (err) {
        Logger.warn(
          `[ModelInfoCache] Error clearing ${key} cache:`,
          err instanceof Error ? err.message : String(err)
        );
      }
    }
    Logger.info(
      `[ModelInfoCache] All caches cleared (${clearedCount}/${allProviderKeys.length})`
    );
  }
  /**
   * Compute API key hash
   *
   * Uses SHA-256 hash and takes first 16 characters to avoid storing full key in cache
   *
   * @param apiKey API key
   * @returns First 16 characters of key hash
   */
  static async computeApiKeyHash(apiKey) {
    try {
      const hash = import_node_crypto2.default.createHash("sha256").update(apiKey).digest("hex");
      return hash.substring(0, 16);
    } catch (err) {
      Logger.warn(
        "Failed to compute API key hash:",
        err instanceof Error ? err.message : String(err)
      );
      return "hash-error";
    }
  }
  /**
   * Get cache storage key
   *
   * Format: chp_modelinfo_cache_<version>_<providerKey>
   * Ensures caches for different versions do not conflict
   */
  getCacheKey(providerKey) {
    return `chp_modelinfo_cache_${this.cacheVersion}_${providerKey}`;
  }
  /**
   * Save user's model selection (globally save provider+model pair)
   *
   * Reference: Microsoft vscode-copilot-chat COPILOT_CLI_MODEL_MEMENTO_KEY
   * Saves user's last selected model and its provider to distinguish models with same name from different providers
   *
   * @param providerKey Provider identifier
   * @param modelId Model ID
   */
  async saveLastSelectedModel(providerKey, modelId) {
    try {
      const selection = {
        providerKey,
        modelId,
        timestamp: Date.now()
      };
      await this.context.globalState.update(
        _ModelInfoCache.SELECTED_MODEL_KEY,
        selection
      );
    } catch (err) {
      Logger.warn(
        "[ModelInfoCache] Failed to save model selection:",
        err instanceof Error ? err.message : String(err)
      );
    }
  }
  /**
   * Get user's last selected model (global query)
   * Only returns saved model matching current provider
   *
   * @param providerKey Current provider identifier
   * @returns Model ID if last selected provider matches current; otherwise null
   */
  getLastSelectedModel(providerKey) {
    try {
      const saved = this.context.globalState.get(
        _ModelInfoCache.SELECTED_MODEL_KEY
      );
      if (saved && saved.providerKey === providerKey) {
        Logger.trace(
          `[ModelInfoCache] ${providerKey}: Read default model (${saved.modelId})`
        );
        return saved.modelId;
      }
      if (saved) {
        Logger.trace(
          `[ModelInfoCache] ${providerKey}: Skipping default selection for other provider (saved: ${saved.providerKey}/${saved.modelId})`
        );
      }
      return null;
    } catch (err) {
      Logger.warn(
        "[ModelInfoCache] Failed to read model selection:",
        err instanceof Error ? err.message : String(err)
      );
      return null;
    }
  }
};

// src/utils/rateLimitParser.ts
init_logger();

// src/utils/retryManager.ts
init_logger();
var DEFAULT_RETRY_CONFIG = {
  maxAttempts: 3,
  initialDelayMs: 1e3,
  maxDelayMs: 3e4,
  backoffMultiplier: 2,
  jitterEnabled: true
};
var RetryManager = class {
  config;
  constructor(config2) {
    this.config = { ...DEFAULT_RETRY_CONFIG, ...config2 };
  }
  /**
   * Execute an operation with automatic retry logic
   * @param operation The async operation to execute
   * @param isRetryable Function to determine if an error is retryable
   * @param providerName Provider name for logging purposes
   * @returns The result of the successful operation
   * @throws The last error if all retry attempts fail
   */
  async executeWithRetry(operation, isRetryable, providerName) {
    let lastError;
    let attempt = 0;
    let delayMs = this.config.initialDelayMs;
    Logger.trace(`[${providerName}] Starting initial request`);
    try {
      const result = await operation();
      return result;
    } catch (error2) {
      lastError = error2;
      if (!isRetryable(lastError)) {
        Logger.warn(
          `[${providerName}] Initial request failed (non-retryable): ${lastError.message}`
        );
        throw lastError;
      }
      Logger.warn(
        `[${providerName}] Initial request failed, initiating retry mechanism: ${lastError.message}`
      );
    }
    while (attempt < this.config.maxAttempts) {
      attempt++;
      const jitter = this.config.jitterEnabled ? Math.random() * 0.1 : 0;
      const actualDelayMs = Math.min(
        delayMs * (1 + jitter),
        this.config.maxDelayMs
      );
      Logger.info(
        `[${providerName}] Retrying in ${actualDelayMs / 1e3} seconds...`
      );
      await this.delay(actualDelayMs);
      Logger.info(
        `[${providerName}] Retry attempt #${attempt}/${this.config.maxAttempts}`
      );
      try {
        const result = await operation();
        Logger.info(
          `[${providerName}] Retry successful after ${attempt} attempt(s)`
        );
        return result;
      } catch (error2) {
        lastError = error2;
        if (!isRetryable(lastError)) {
          Logger.warn(
            `[${providerName}] Retry attempt #${attempt} failed (non-retryable): ${lastError.message}`
          );
          break;
        }
        Logger.warn(
          `[${providerName}] Retry attempt #${attempt} failed, preparing next retry: ${lastError.message}`
        );
        delayMs *= this.config.backoffMultiplier;
      }
    }
    if (lastError) {
      Logger.error(
        `[${providerName}] All retry attempts exhausted: ${lastError.message}`
      );
      throw lastError;
    } else {
      throw new Error(`[${providerName}] Unknown error occurred`);
    }
  }
  /**
   * Check if an error is a rate limit (429) error
   * @param error The error object to check
   * @returns True if the error is a 429 rate limit error
   */
  static isRateLimitError(error2) {
    if (error2 instanceof Error) {
      if (error2.message.includes("429")) {
        return true;
      }
      if ("status" in error2 && error2.status === 429) {
        return true;
      }
      if ("statusCode" in error2 && error2.statusCode === 429) {
        return true;
      }
    }
    return false;
  }
  /**
   * Delay execution for a specified number of milliseconds
   * @param ms Milliseconds to delay
   * @returns Promise that resolves after the delay
   */
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
};

// src/utils/statusLogger.ts
var vscode31 = __toESM(require("vscode"));
var StatusLogger = class _StatusLogger {
  static outputChannel;
  /**
   * Initialize high-frequency status logger manager
   */
  static initialize(channelName = "CHP-Status") {
    _StatusLogger.outputChannel = vscode31.window.createOutputChannel(
      channelName,
      { log: true }
    );
  }
  /**
   * Trace level log (VS Code LogLevel.Trace = 1)
   */
  static trace(message, ...args) {
    if (_StatusLogger.outputChannel) {
      _StatusLogger.outputChannel.trace(message, ...args);
    }
  }
  /**
   * Debug level log (VS Code LogLevel.Debug = 2)
   */
  static debug(message, ...args) {
    if (_StatusLogger.outputChannel) {
      _StatusLogger.outputChannel.debug(message, ...args);
    }
  }
  /**
   * Info level log (VS Code LogLevel.Info = 3)
   */
  static info(message, ...args) {
    if (_StatusLogger.outputChannel) {
      _StatusLogger.outputChannel.info(message, ...args);
    }
  }
  /**
   * Warning level log (VS Code LogLevel.Warning = 4)
   */
  static warn(message, ...args) {
    if (_StatusLogger.outputChannel) {
      _StatusLogger.outputChannel.warn(message, ...args);
    }
  }
  /**
   * Error level log (VS Code LogLevel.Error = 5)
   */
  static error(message, ...args) {
    if (_StatusLogger.outputChannel) {
      _StatusLogger.outputChannel.error(message, ...args);
    }
  }
  /**
   * Dispose logger manager
   */
  static dispose() {
    if (_StatusLogger.outputChannel) {
      _StatusLogger.outputChannel.dispose();
    }
  }
};

// src/providers/common/genericModelProvider.ts
var vscode32 = __toESM(require("vscode"));
var GenericModelProvider = class _GenericModelProvider {
  openaiHandler;
  anthropicHandler;
  providerKey;
  context;
  baseProviderConfig;
  // protected to support subclass access
  cachedProviderConfig;
  // Cached configuration
  configListener;
  // Configuration listener
  modelInfoCache;
  // Model information cache
  accountManager;
  lastUsedAccountByModel = /* @__PURE__ */ new Map();
  // Cached chat endpoints for chat endpoint-aware providers (model id and max prompt tokens)
  _chatEndpoints;
  // Model information change event
  _onDidChangeLanguageModelChatInformation = new vscode32.EventEmitter();
  onDidChangeLanguageModelChatInformation = this._onDidChangeLanguageModelChatInformation.event;
  constructor(context, providerKey, providerConfig) {
    this.context = context;
    this.providerKey = providerKey;
    this.accountManager = AccountManager.getInstance();
    this.baseProviderConfig = providerConfig;
    this.cachedProviderConfig = ConfigManager.applyProviderOverrides(
      this.providerKey,
      this.baseProviderConfig
    );
    this.modelInfoCache = new ModelInfoCache(context);
    this.configListener = vscode32.workspace.onDidChangeConfiguration((e) => {
      if (providerKey !== "compatible" && (e.affectsConfiguration("chp.providerOverrides") || e.affectsConfiguration(`chp.${providerKey}.baseUrl`))) {
        this.cachedProviderConfig = ConfigManager.applyProviderOverrides(
          this.providerKey,
          this.baseProviderConfig
        );
        this.refreshHandlers();
        this.modelInfoCache?.invalidateCache(this.providerKey).catch(
          (err) => Logger.warn(`[${this.providerKey}] Failed to clear cache:`, err)
        );
        Logger.trace(`${this.providerKey} configuration updated`);
        this._onDidChangeLanguageModelChatInformation.fire();
      }
      if (e.affectsConfiguration("chp.editToolMode")) {
        Logger.trace(`${this.providerKey} detected editToolMode change`);
        this.modelInfoCache?.invalidateCache(this.providerKey).catch(
          (err) => Logger.warn(`[${this.providerKey}] Failed to clear cache:`, err)
        );
        this._onDidChangeLanguageModelChatInformation.fire();
      }
    });
    this.accountManager.onAccountChange((e) => {
      if (e.provider === this.providerKey || e.provider === "all") {
        Logger.trace(
          `[${this.providerKey}] Account change detected: ${e.type}`
        );
        this.modelInfoCache?.invalidateCache(this.providerKey).catch(
          (err) => Logger.warn(`[${this.providerKey}] Failed to clear cache:`, err)
        );
        this._onDidChangeLanguageModelChatInformation.fire();
      }
    });
    this.refreshHandlers();
  }
  /**
   * Refresh SDK handlers to apply baseUrl overrides
   */
  refreshHandlers() {
    this.openaiHandler?.dispose();
    this.openaiHandler = new OpenAIHandler(
      this.providerKey,
      this.baseProviderConfig.displayName,
      this.cachedProviderConfig.baseUrl
    );
    this.anthropicHandler = new AnthropicHandler(
      this.providerKey,
      this.baseProviderConfig.displayName,
      this.cachedProviderConfig.baseUrl
    );
  }
  /**
   * Deduplicate model info by id
   */
  dedupeModelInfos(models) {
    const seen = /* @__PURE__ */ new Set();
    const deduped = [];
    for (const model of models) {
      if (seen.has(model.id)) {
        Logger.warn(
          `[${this.providerKey}] Duplicate model id detected, skipping: ${model.id}`
        );
        continue;
      }
      seen.add(model.id);
      deduped.push(model);
    }
    return deduped;
  }
  /**
   * Release resources
   */
  dispose() {
    this.configListener?.dispose();
    this._onDidChangeLanguageModelChatInformation.dispose();
    this.openaiHandler?.dispose();
    Logger.info(`${this.providerConfig.displayName}: Extension destroyed`);
  }
  /**
   * Get current effective provider configuration
   */
  get providerConfig() {
    return this.cachedProviderConfig;
  }
  /**
   * Static factory method - Create and activate provider based on configuration
   */
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(`${providerConfig.displayName} model extension activated!`);
    const provider = new _GenericModelProvider(
      context,
      providerKey,
      providerConfig
    );
    const providerDisposable = vscode32.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const setApiKeyCommand = vscode32.commands.registerCommand(
      `chp.${providerKey}.setApiKey`,
      async () => {
        if (providerKey === "moonshot") {
          await MoonshotWizard.startWizard(
            providerConfig.displayName,
            providerConfig.apiKeyTemplate
          );
        } else {
          await ProviderWizard.startWizard({
            providerKey,
            displayName: providerConfig.displayName,
            apiKeyTemplate: providerConfig.apiKeyTemplate,
            supportsApiKey: true,
            supportsBaseUrl: true
          });
        }
        await provider.modelInfoCache?.invalidateCache(providerKey);
        provider._onDidChangeLanguageModelChatInformation.fire();
      }
    );
    const disposables = [providerDisposable, setApiKeyCommand];
    for (const disposable of disposables) {
      context.subscriptions.push(disposable);
    }
    return { provider, disposables };
  }
  /**
   * Convert ModelConfig to LanguageModelChatInformation
   */
  modelConfigToInfo(model) {
    const editToolMode = vscode32.workspace.getConfiguration("chp").get("editToolMode", "claude");
    let family;
    if (editToolMode && editToolMode !== "none") {
      family = editToolMode.startsWith("claude") ? "claude-sonnet-4.5" : editToolMode;
    } else if (editToolMode === "none") {
      family = model.id;
    } else {
      family = model.id;
    }
    const info = {
      id: model.id,
      name: model.name,
      detail: this.providerConfig.displayName,
      tooltip: model.tooltip || `${model.name} via ${this.providerConfig.displayName}`,
      family,
      maxInputTokens: model.maxInputTokens,
      maxOutputTokens: model.maxOutputTokens,
      version: model.id,
      capabilities: model.capabilities
    };
    return info;
  }
  async provideLanguageModelChatInformation(options, _token) {
    try {
      const apiKeyHash = await this.getApiKeyHash();
      let cachedModels = await this.modelInfoCache?.getCachedModels(
        this.providerKey,
        apiKeyHash
      );
      if (cachedModels) {
        Logger.trace(
          `[${this.providerKey}] Return model list from cache (${cachedModels.length} models)`
        );
        const rememberLastModel2 = ConfigManager.getRememberLastModel();
        if (rememberLastModel2) {
          const lastSelectedId = this.modelInfoCache?.getLastSelectedModel(
            this.providerKey
          );
          if (lastSelectedId) {
            cachedModels = cachedModels.map((model) => ({
              ...model,
              isDefault: model.id === lastSelectedId
            }));
          }
        }
        this.updateModelCacheAsync(apiKeyHash);
        return this.dedupeModelInfos(cachedModels);
      }
    } catch (err) {
      Logger.warn(
        `[${this.providerKey}] Cache query failed, falling back to original logic:`,
        err instanceof Error ? err.message : String(err)
      );
    }
    const hasApiKey = await ApiKeyManager.hasValidApiKey(this.providerKey);
    if (!hasApiKey) {
      if (options.silent) {
        return [];
      }
      await vscode32.commands.executeCommand(`chp.${this.providerKey}.setApiKey`);
      const hasApiKeyAfterSet = await ApiKeyManager.hasValidApiKey(
        this.providerKey
      );
      if (!hasApiKeyAfterSet) {
        return [];
      }
    }
    let models = this.providerConfig.models.map(
      (model) => this.modelConfigToInfo(model)
    );
    const rememberLastModel = ConfigManager.getRememberLastModel();
    if (rememberLastModel) {
      const lastSelectedId = this.modelInfoCache?.getLastSelectedModel(
        this.providerKey
      );
      if (lastSelectedId) {
        models = models.map((model) => ({
          ...model,
          isDefault: model.id === lastSelectedId
        }));
      }
    }
    try {
      const apiKeyHash = await this.getApiKeyHash();
      this.updateModelCacheAsync(apiKeyHash);
    } catch (err) {
      Logger.warn(`[${this.providerKey}] Cache saving failed:`, err);
    }
    return this.dedupeModelInfos(models);
  }
  /**
   * Update model cache asynchronously (non-blocking)
   */
  updateModelCacheAsync(apiKeyHash) {
    (async () => {
      try {
        let models = this.providerConfig.models.map(
          (model) => this.modelConfigToInfo(model)
        );
        models = this.dedupeModelInfos(models);
        await this.modelInfoCache?.cacheModels(
          this.providerKey,
          models,
          apiKeyHash
        );
      } catch (err) {
        Logger.trace(
          `[${this.providerKey}] Background cache update failed:`,
          err instanceof Error ? err.message : String(err)
        );
      }
    })();
  }
  /**
   * Compute API key hash (used for cache check)
   */
  async getApiKeyHash() {
    try {
      const apiKey = await ApiKeyManager.getApiKey(this.providerKey);
      if (!apiKey) {
        return "no-key";
      }
      return await ModelInfoCache.computeApiKeyHash(apiKey);
    } catch (err) {
      Logger.warn(
        `[${this.providerKey}] Failed to compute API key hash:`,
        err instanceof Error ? err.message : String(err)
      );
      return "hash-error";
    }
  }
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    const rememberLastModel = ConfigManager.getRememberLastModel();
    if (rememberLastModel) {
      this.modelInfoCache?.saveLastSelectedModel(this.providerKey, model.id).catch(
        (err) => Logger.warn(
          `[${this.providerKey}] Failed to save model selection:`,
          err
        )
      );
    }
    const modelConfig = this.providerConfig.models.find(
      (m) => m.id === model.id
    );
    if (!modelConfig) {
      const errorMessage = `Model not found: ${model.id}`;
      Logger.error(errorMessage);
      throw new Error(errorMessage);
    }
    const effectiveProviderKey = modelConfig.provider || this.providerKey;
    try {
      const accounts = this.accountManager.getAccountsByProvider(effectiveProviderKey);
      const loadBalanceEnabled = this.accountManager.getLoadBalanceEnabled(effectiveProviderKey);
      const assignedAccountId = this.accountManager.getAccountIdForModel(
        effectiveProviderKey,
        model.id
      );
      if (accounts.length === 0) {
        await ApiKeyManager.ensureApiKey(
          effectiveProviderKey,
          this.providerConfig.displayName
        );
        const sdkMode = modelConfig.sdkMode || "openai";
        Logger.info(
          `${this.providerConfig.displayName} Provider starts processing request (fallback mode): ${modelConfig.name}`
        );
        if (sdkMode === "anthropic") {
          await this.anthropicHandler.handleRequest(
            model,
            modelConfig,
            messages,
            options,
            progress,
            token
          );
        } else {
          await this.openaiHandler.handleRequest(
            model,
            modelConfig,
            messages,
            options,
            progress,
            token
          );
        }
        return;
      }
      const usableAccounts = accounts.filter((a) => a.status === "active").length > 0 ? accounts.filter((a) => a.status === "active") : accounts;
      const candidates = this.buildAccountCandidates(
        model.id,
        usableAccounts,
        assignedAccountId,
        loadBalanceEnabled,
        effectiveProviderKey
      );
      const activeAccount = this.accountManager.getActiveAccount(effectiveProviderKey);
      const available = loadBalanceEnabled ? candidates.filter(
        (a) => !this.accountManager.isAccountQuotaLimited(a.id)
      ) : candidates;
      let accountsToTry;
      if (available.length > 0) {
        if (activeAccount && available.some((a) => a.id === activeAccount.id)) {
          accountsToTry = [
            activeAccount,
            ...available.filter((a) => a.id !== activeAccount.id)
          ];
        } else {
          accountsToTry = available;
        }
      } else {
        if (activeAccount && candidates.some((a) => a.id === activeAccount.id)) {
          accountsToTry = [
            activeAccount,
            ...candidates.filter((a) => a.id !== activeAccount.id)
          ];
        } else {
          accountsToTry = candidates;
        }
      }
      Logger.debug(
        `[${effectiveProviderKey}] Active account: ${activeAccount?.displayName || "none"}, accountsToTry: ${accountsToTry.map((a) => a.displayName).join(", ")}`
      );
      let lastError;
      let switchedAccount = false;
      for (const account of accountsToTry) {
        const credentials = await this.accountManager.getCredentials(
          account.id
        );
        if (!credentials) {
          lastError = new Error(
            `Missing credentials for ${account.displayName}`
          );
          continue;
        }
        const configWithAuth = {
          ...modelConfig,
          apiKey: "apiKey" in credentials ? credentials.apiKey : void 0,
          baseUrl: "endpoint" in credentials ? credentials.endpoint : void 0,
          customHeader: "customHeaders" in credentials ? credentials.customHeaders : void 0
        };
        const selectionsMetadata = options?.selectionsMetadata;
        if (!configWithAuth.baseUrl && selectionsMetadata?.baseUrl) {
          configWithAuth.baseUrl = selectionsMetadata.baseUrl;
        }
        if ("accessToken" in credentials) {
          configWithAuth.accessToken = credentials.accessToken;
          configWithAuth.apiKey = credentials.accessToken;
        }
        try {
          const sdkMode = modelConfig.sdkMode || "openai";
          Logger.info(
            `${this.providerConfig.displayName}: ${model.name} using account "${account.displayName}" (ID: ${account.id})`
          );
          if (sdkMode === "anthropic") {
            await this.anthropicHandler.handleRequest(
              model,
              configWithAuth,
              messages,
              options,
              progress,
              token
            );
          } else {
            await this.openaiHandler.handleRequest(
              model,
              configWithAuth,
              messages,
              options,
              progress,
              token,
              account.id
            );
          }
          this.lastUsedAccountByModel.set(model.id, account.id);
          if (switchedAccount) {
            Logger.info(
              `[${effectiveProviderKey}] Saving account "${account.displayName}" as preferred for model ${model.id}`
            );
            await this.accountManager.setAccountForModel(
              effectiveProviderKey,
              model.id,
              account.id
            );
          }
          return;
        } catch (error2) {
          switchedAccount = true;
          if (this.isLongTermQuotaExhausted(error2)) {
            if (loadBalanceEnabled) {
              Logger.warn(
                `[${effectiveProviderKey}] Account ${account.displayName} quota exhausted, switching...`
              );
              lastError = error2;
              continue;
            }
            throw error2;
          }
          if (loadBalanceEnabled && this.isQuotaError(error2)) {
            Logger.warn(
              `[${effectiveProviderKey}] Account ${account.displayName} rate limited, switching...`
            );
            lastError = error2;
            continue;
          }
          throw error2;
        }
      }
      if (lastError) {
        throw lastError;
      }
      throw new Error(`No available accounts for ${effectiveProviderKey}`);
    } catch (error2) {
      const errorMessage = `Error: ${error2 instanceof Error ? error2.message : "Unknown error"}`;
      Logger.error(errorMessage);
      throw error2;
    } finally {
      Logger.info(
        `${this.providerConfig.displayName}: ${model.name} Request completed`
      );
    }
  }
  buildAccountCandidates(modelId, accounts, assignedAccountId, loadBalanceEnabled, providerKey) {
    if (accounts.length === 0) {
      return [];
    }
    const assignedAccount = assignedAccountId ? accounts.find((a) => a.id === assignedAccountId) : void 0;
    const activeAccount = this.accountManager.getActiveAccount(providerKey);
    const defaultAccount = activeAccount || accounts.find((a) => a.isDefault) || accounts[0];
    if (!loadBalanceEnabled) {
      return assignedAccount ? [assignedAccount] : defaultAccount ? [defaultAccount] : [];
    }
    const ordered = [...accounts].sort(
      (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
    );
    const lastUsed = this.lastUsedAccountByModel.get(modelId);
    let rotatedOrder = ordered;
    if (lastUsed) {
      const index = ordered.findIndex((a) => a.id === lastUsed);
      if (index >= 0) {
        rotatedOrder = [
          ...ordered.slice(index + 1),
          ...ordered.slice(0, index + 1)
        ];
      }
    }
    if (assignedAccount) {
      return [
        assignedAccount,
        ...rotatedOrder.filter((a) => a.id !== assignedAccount.id)
      ];
    }
    if (defaultAccount) {
      return [
        defaultAccount,
        ...rotatedOrder.filter((a) => a.id !== defaultAccount.id)
      ];
    }
    return rotatedOrder;
  }
  isQuotaError(error2) {
    if (!(error2 instanceof Error)) {
      return false;
    }
    const msg = error2.message;
    return msg.startsWith("Quota exceeded") || msg.startsWith("Rate limited") || msg.includes("HTTP 429") || msg.includes('"code": 429') || msg.includes('"code":429') || msg.includes("RESOURCE_EXHAUSTED") || msg.includes("429") && msg.includes("Resource has been exhausted");
  }
  isLongTermQuotaExhausted(error2) {
    return error2 instanceof Error && error2.message.startsWith("Account quota exhausted");
  }
  async provideTokenCount(model, text, _token) {
    return TokenCounter.getInstance().countTokens(model, text);
  }
  /**
   * Calculate total tokens for multiple messages
   */
  async countMessagesTokens(model, messages, modelConfig, options) {
    return TokenCounter.getInstance().countMessagesTokens(
      model,
      messages,
      modelConfig,
      options
    );
  }
};

// src/providers/antigravity/provider.ts
init_auth();
var AntigravityProvider = class _AntigravityProvider extends GenericModelProvider {
  static PROVIDER_KEY = "antigravity" /* Antigravity */;
  cachedModels = [];
  antigravityHandler;
  accountManager;
  lastUsedAccountByModel = /* @__PURE__ */ new Map();
  constructor(context) {
    const virtualConfig = {
      displayName: "Antigravity",
      baseUrl: "https://cloudcode-pa.googleapis.com/v1internal",
      apiKeyTemplate: "",
      models: []
    };
    super(context, _AntigravityProvider.PROVIDER_KEY, virtualConfig);
    this.antigravityHandler = new AntigravityHandler(virtualConfig.displayName);
    this.accountManager = AccountManager.getInstance();
  }
  static createAndActivate(context) {
    Logger.trace("Antigravity Provider activated!");
    const provider = new _AntigravityProvider(context);
    const providerDisposable = vscode33.lm.registerLanguageModelChatProvider(
      "chp.antigravity",
      provider
    );
    const loginCommand = vscode33.commands.registerCommand(
      "chp.antigravity.login",
      async () => {
        await antigravityLoginCommand();
        await provider.modelInfoCache?.invalidateCache(
          _AntigravityProvider.PROVIDER_KEY
        );
        provider._onDidChangeLanguageModelChatInformation.fire();
      }
    );
    const logoutCommand = vscode33.commands.registerCommand(
      "chp.antigravity.logout",
      async () => {
        await AntigravityAuth.logout();
        await provider.modelInfoCache?.invalidateCache(
          _AntigravityProvider.PROVIDER_KEY
        );
        provider._onDidChangeLanguageModelChatInformation.fire();
      }
    );
    const disposables = [providerDisposable, loginCommand, logoutCommand];
    for (const disposable of disposables) {
      context.subscriptions.push(disposable);
    }
    return { provider, disposables };
  }
  getProviderConfig() {
    return {
      displayName: "Antigravity",
      baseUrl: "https://cloudcode-pa.googleapis.com/v1internal",
      apiKeyTemplate: "",
      models: this.cachedModels
    };
  }
  async provideLanguageModelChatInformation(options, _token) {
    try {
      const isLoggedIn = await AntigravityAuth.isLoggedIn();
      if (!isLoggedIn) {
        if (!options.silent) {
          const action = await vscode33.window.showInformationMessage(
            "Antigravity requires login. Would you like to login now?",
            "Login",
            "Cancel"
          );
          if (action === "Login") {
            await antigravityLoginCommand();
          }
        }
        return [];
      }
      let models = await AntigravityAuth.getCachedModels();
      if (models.length === 0) {
        models = await AntigravityAuth.getModels();
      }
      if (models.length === 0) {
        Logger.warn("No Antigravity models available");
        return [];
      }
      const overrides = ConfigManager.getProviderOverrides();
      const antigravityOverride = overrides[_AntigravityProvider.PROVIDER_KEY];
      const modelOverrides = antigravityOverride?.models || [];
      const baseUrlOverride = antigravityOverride?.baseUrl;
      this.cachedModels = models.map((m) => {
        const override = modelOverrides.find((o) => o.id === m.id);
        const baseConfig = {
          id: m.id,
          name: m.displayName || m.name,
          tooltip: `${m.displayName} - Antigravity`,
          maxInputTokens: m.maxTokens || 2e5,
          maxOutputTokens: override?.maxOutputTokens || m.maxOutputTokens || 8192,
          sdkMode: "openai",
          capabilities: { toolCalling: true, imageInput: true }
        };
        if (baseUrlOverride) {
          baseConfig.baseUrl = baseUrlOverride;
        }
        if (override?.extraBody) {
          baseConfig.extraBody = override.extraBody;
          Logger.debug(
            `[Antigravity] Applied extraBody override to model ${m.id}`
          );
        }
        if (override?.outputThinking !== void 0) {
          baseConfig.outputThinking = override.outputThinking;
        }
        return baseConfig;
      });
      const rememberLastModel = ConfigManager.getRememberLastModel();
      let lastSelectedId;
      if (rememberLastModel) {
        lastSelectedId = this.modelInfoCache?.getLastSelectedModel(
          _AntigravityProvider.PROVIDER_KEY
        ) ?? void 0;
      }
      const modelInfos = this.cachedModels.map(
        (model) => ({
          id: model.id,
          name: model.name,
          vendor: "chp.antigravity",
          family: "antigravity",
          version: "1.0",
          maxInputTokens: model.maxInputTokens,
          maxOutputTokens: model.maxOutputTokens,
          isDefault: rememberLastModel && model.id === lastSelectedId,
          capabilities: {
            toolCalling: model.capabilities?.toolCalling ?? true,
            imageInput: model.capabilities?.imageInput ?? true
          },
          tooltip: model.tooltip || model.name,
          detail: "Antigravity"
        })
      );
      Logger.debug(`Antigravity Provider provides ${modelInfos.length} models`);
      return modelInfos;
    } catch (error2) {
      Logger.error("Failed to get Antigravity models:", error2);
      return [];
    }
  }
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    const rememberLastModel = ConfigManager.getRememberLastModel();
    if (rememberLastModel) {
      this.modelInfoCache?.saveLastSelectedModel(_AntigravityProvider.PROVIDER_KEY, model.id).catch(
        (err) => Logger.warn("[antigravity] Failed to save model selection:", err)
      );
    }
    const modelConfig = this.cachedModels.find((m) => m.id === model.id);
    if (!modelConfig) {
      throw new Error(`Model not found: ${model.id}`);
    }
    try {
      const configWithAuth = { ...modelConfig, model: model.id };
      const accounts = this.accountManager.getAccountsByProvider(
        _AntigravityProvider.PROVIDER_KEY
      );
      const loadBalanceEnabled = this.accountManager.getLoadBalanceEnabled(
        _AntigravityProvider.PROVIDER_KEY
      );
      const assignedAccountId = this.accountManager.getAccountIdForModel(
        _AntigravityProvider.PROVIDER_KEY,
        model.id
      );
      if (accounts.length === 0) {
        const accessToken = await AntigravityAuth.getAccessToken();
        if (!accessToken) {
          throw new Error("Not logged in to Antigravity. Please login first.");
        }
        Logger.info(
          `Antigravity Provider processing request: ${model.name} (default account)`
        );
        await this.antigravityHandler.handleRequest(
          model,
          configWithAuth,
          messages,
          options,
          progress,
          token,
          accessToken,
          void 0,
          loadBalanceEnabled
        );
        return;
      }
      const usableAccounts = accounts.filter((a) => a.status === "active").length > 0 ? accounts.filter((a) => a.status === "active") : accounts;
      const candidates = this.buildAccountCandidates(
        model.id,
        usableAccounts,
        assignedAccountId,
        loadBalanceEnabled
      );
      const activeAccount = this.accountManager.getActiveAccount(
        _AntigravityProvider.PROVIDER_KEY
      );
      const available = loadBalanceEnabled ? candidates.filter(
        (a) => !this.accountManager.isAccountQuotaLimited(a.id) && !this.antigravityHandler.isInCooldown(model.id, a.id)
      ) : candidates;
      let accountsToTry;
      if (available.length > 0) {
        if (activeAccount && available.some((a) => a.id === activeAccount.id)) {
          accountsToTry = [
            activeAccount,
            ...available.filter((a) => a.id !== activeAccount.id)
          ];
        } else {
          accountsToTry = available;
        }
      } else {
        if (activeAccount && candidates.some((a) => a.id === activeAccount.id)) {
          accountsToTry = [
            activeAccount,
            ...candidates.filter((a) => a.id !== activeAccount.id)
          ];
        } else {
          accountsToTry = candidates;
        }
      }
      Logger.debug(
        `[antigravity] Active account: ${activeAccount?.displayName || "none"}, accountsToTry: ${accountsToTry.map((a) => a.displayName).join(", ")}`
      );
      let lastError;
      let switchedAccount = false;
      for (const account of accountsToTry) {
        const accessToken = await this.getAccessTokenForAccount(account);
        if (!accessToken) {
          lastError = new Error(
            `Missing Antigravity credentials for ${account.displayName}`
          );
          continue;
        }
        try {
          Logger.info(
            `Antigravity Provider: ${model.name} using account "${account.displayName}" (ID: ${account.id})`
          );
          await this.antigravityHandler.handleRequest(
            model,
            configWithAuth,
            messages,
            options,
            progress,
            token,
            accessToken,
            account.id,
            loadBalanceEnabled
          );
          this.lastUsedAccountByModel.set(model.id, account.id);
          if (switchedAccount) {
            Logger.info(
              `[antigravity] Saving account "${account.displayName}" as preferred for model ${model.id}`
            );
            await this.accountManager.setAccountForModel(
              _AntigravityProvider.PROVIDER_KEY,
              model.id,
              account.id
            );
          }
          return;
        } catch (error2) {
          switchedAccount = true;
          if (this.isLongTermQuotaExhausted(error2)) {
            if (loadBalanceEnabled) {
              Logger.warn(
                `[antigravity] Account ${account.displayName} quota exhausted, switching...`
              );
              lastError = error2;
              continue;
            }
            throw error2;
          }
          if (loadBalanceEnabled && this.isQuotaError(error2)) {
            Logger.warn(
              `[antigravity] Account ${account.displayName} rate limited, switching...`
            );
            lastError = error2;
            continue;
          }
          throw error2;
        }
      }
      if (lastError) {
        throw lastError;
      }
      throw new Error("No available Antigravity accounts for this request.");
    } catch (error2) {
      Logger.error("Antigravity request failed:", error2);
      throw error2;
    } finally {
      Logger.info(`Antigravity Provider: ${model.name} request completed`);
    }
  }
  buildAccountCandidates(modelId, accounts, assignedAccountId, loadBalanceEnabled) {
    if (accounts.length === 0) {
      return [];
    }
    const assignedAccount = assignedAccountId ? accounts.find((a) => a.id === assignedAccountId) : void 0;
    const activeAccount = this.accountManager.getActiveAccount(
      _AntigravityProvider.PROVIDER_KEY
    );
    const defaultAccount = activeAccount || accounts.find((a) => a.isDefault) || accounts[0];
    if (!loadBalanceEnabled) {
      return assignedAccount ? [assignedAccount] : defaultAccount ? [defaultAccount] : [];
    }
    const ordered = [...accounts].sort(
      (a, b) => new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
    );
    const lastUsed = this.lastUsedAccountByModel.get(modelId);
    let rotatedOrder = ordered;
    if (lastUsed) {
      const index = ordered.findIndex((a) => a.id === lastUsed);
      if (index >= 0) {
        rotatedOrder = [
          ...ordered.slice(index + 1),
          ...ordered.slice(0, index + 1)
        ];
      }
    }
    if (assignedAccount) {
      return [
        assignedAccount,
        ...rotatedOrder.filter((a) => a.id !== assignedAccount.id)
      ];
    }
    if (defaultAccount) {
      return [
        defaultAccount,
        ...rotatedOrder.filter((a) => a.id !== defaultAccount.id)
      ];
    }
    return rotatedOrder;
  }
  async getAccessTokenForAccount(account) {
    const credentials = await this.accountManager.getCredentials(account.id);
    if (!credentials || !("accessToken" in credentials)) {
      return null;
    }
    const expiresAt = credentials.expiresAt ? new Date(credentials.expiresAt).getTime() : 0;
    if (expiresAt && expiresAt - Date.now() > 5 * 60 * 1e3) {
      return credentials.accessToken;
    }
    if (!("refreshToken" in credentials) || !credentials.refreshToken) {
      return credentials.accessToken;
    }
    const refreshed = await AntigravityAuth.refreshToken(
      credentials.refreshToken,
      {
        persist: account.isDefault === true
      }
    );
    if (!refreshed) {
      return null;
    }
    await this.accountManager.updateCredentials(account.id, {
      ...credentials,
      accessToken: refreshed.accessToken,
      expiresAt: refreshed.expiresAt
    });
    return refreshed.accessToken;
  }
  isQuotaError(error2) {
    if (!(error2 instanceof Error)) {
      return false;
    }
    const msg = error2.message;
    return msg.startsWith("Quota exceeded") || msg.startsWith("Rate limited") || msg.includes("HTTP 429") || msg.includes('"code": 429') || msg.includes('"code":429') || msg.includes("RESOURCE_EXHAUSTED") || msg.includes("429") && msg.includes("Resource has been exhausted");
  }
  isLongTermQuotaExhausted(error2) {
    return error2 instanceof Error && error2.message.startsWith("Account quota exhausted");
  }
};

// src/providers/chutes/chutesProvider.ts
var fs = __toESM(require("node:fs"));
var path3 = __toESM(require("node:path"));
var vscode35 = __toESM(require("vscode"));
init_apiKeyManager();
init_configManager();
init_logger();

// src/providers/huggingface/utils.ts
var vscode34 = __toESM(require("vscode"));
init_logger();
function isIntegerLikePropertyName(propertyName) {
  if (!propertyName) {
    return false;
  }
  const lowered = propertyName.toLowerCase();
  const integerMarkers = [
    "id",
    "limit",
    "count",
    "index",
    "size",
    "offset",
    "length",
    "results_limit",
    "maxresults",
    "debugsessionid",
    "cellid"
  ];
  return integerMarkers.some((m) => lowered.includes(m)) || lowered.endsWith("_id");
}
function sanitizeFunctionName(name) {
  if (typeof name !== "string" || !name) {
    return "tool";
  }
  let sanitized = name.replace(/[^a-zA-Z0-9_-]/g, "_");
  if (!/^[a-zA-Z]/.test(sanitized)) {
    sanitized = `tool_${sanitized}`;
  }
  sanitized = sanitized.replace(/_+/g, "_");
  return sanitized.slice(0, 64);
}
function pruneUnknownSchemaKeywords(schema) {
  if (!schema || typeof schema !== "object" || Array.isArray(schema)) {
    return {};
  }
  const allow = /* @__PURE__ */ new Set([
    "type",
    "properties",
    "required",
    "additionalProperties",
    "description",
    "enum",
    "default",
    "items",
    "minLength",
    "maxLength",
    "minimum",
    "maximum",
    "pattern",
    "format"
  ]);
  const out = {};
  for (const [k, v] of Object.entries(schema)) {
    if (allow.has(k)) {
      out[k] = v;
    }
  }
  return out;
}
function sanitizeSchema(input, propName) {
  if (!input || typeof input !== "object" || Array.isArray(input)) {
    return { type: "object", properties: {} };
  }
  let schema = input;
  for (const composite of ["anyOf", "oneOf", "allOf"]) {
    const branch = schema[composite];
    if (Array.isArray(branch) && branch.length > 0) {
      let preferred;
      for (const b of branch) {
        if (b && typeof b === "object" && b.type === "string") {
          preferred = b;
          break;
        }
      }
      schema = { ...preferred ?? branch[0] };
      break;
    }
  }
  schema = pruneUnknownSchemaKeywords(schema);
  let t = schema.type;
  if (t == null) {
    t = "object";
    schema.type = t;
  }
  if (t === "number" && propName && isIntegerLikePropertyName(propName)) {
    schema.type = "integer";
    t = "integer";
  }
  if (t === "object") {
    const props = schema.properties ?? {};
    const newProps = {};
    if (props && typeof props === "object") {
      for (const [k, v] of Object.entries(props)) {
        newProps[k] = sanitizeSchema(v, k);
      }
    }
    schema.properties = newProps;
    const req = schema.required;
    if (Array.isArray(req)) {
      schema.required = req.filter((r) => typeof r === "string");
    } else if (req !== void 0) {
      schema.required = [];
    }
    const ap = schema.additionalProperties;
    if (ap !== void 0 && typeof ap !== "boolean") {
      delete schema.additionalProperties;
    }
  } else if (t === "array") {
    const items = schema.items;
    if (Array.isArray(items) && items.length > 0) {
      schema.items = sanitizeSchema(items[0]);
    } else if (items && typeof items === "object") {
      schema.items = sanitizeSchema(items);
    } else {
      schema.items = { type: "string" };
    }
  }
  return schema;
}
function convertTools(options) {
  const tools = options.tools ?? [];
  if (!tools || tools.length === 0) {
    return {};
  }
  const toolDefs = tools.filter(
    (t) => !!t && typeof t === "object"
  ).map((t) => {
    const name = sanitizeFunctionName(
      typeof t.name === "string" ? t.name : String(t.name ?? "tool")
    );
    const description = typeof t.description === "string" ? t.description : "";
    const params = sanitizeSchema(
      t.inputSchema ?? {
        type: "object",
        properties: {}
      }
    );
    return {
      type: "function",
      function: {
        name,
        description,
        parameters: params
      }
    };
  });
  let tool_choice = "auto";
  if (options.toolMode === vscode34.LanguageModelChatToolMode.Required) {
    if (tools.length !== 1) {
      Logger.error(
        "[Hugging Face Model Provider] ToolMode.Required but multiple tools:",
        tools.length
      );
      throw new Error(
        "LanguageModelChatToolMode.Required is not supported with more than one tool"
      );
    }
    tool_choice = {
      type: "function",
      function: { name: sanitizeFunctionName(tools[0].name) }
    };
  }
  return { tools: toolDefs, tool_choice };
}
function validateRequest(messages) {
  const lastMessage = messages[messages.length - 1];
  if (!lastMessage) {
    Logger.error("[Hugging Face Model Provider] No messages in request");
    throw new Error("Invalid request: no messages.");
  }
  messages.forEach((message, i) => {
    if (message.role === vscode34.LanguageModelChatMessageRole.Assistant) {
      const toolCallIds = new Set(
        message.content.filter((part) => part instanceof vscode34.LanguageModelToolCallPart).map(
          (part) => part.callId
        )
      );
      if (toolCallIds.size === 0) {
        return;
      }
      let nextMessageIdx = i + 1;
      const errMsg = "Invalid request: Tool call part must be followed by a User message with a LanguageModelToolResultPart with a matching callId.";
      while (toolCallIds.size > 0) {
        const nextMessage = messages[nextMessageIdx++];
        if (!nextMessage || nextMessage.role !== vscode34.LanguageModelChatMessageRole.User) {
          Logger.error(
            "[Hugging Face Model Provider] Validation failed: missing tool result for call IDs:",
            Array.from(toolCallIds)
          );
          throw new Error(errMsg);
        }
        nextMessage.content.forEach((part) => {
          if (!isToolResultPart(part)) {
            const ctorName = Object.getPrototypeOf(part)?.constructor?.name ?? typeof part;
            Logger.error(
              "[Hugging Face Model Provider] Validation failed: expected tool result part, got:",
              ctorName
            );
            throw new Error(errMsg);
          }
          const callId = part.callId;
          toolCallIds.delete(callId);
        });
      }
    }
  });
}
function isToolResultPart(value) {
  if (!value || typeof value !== "object") {
    return false;
  }
  const obj = value;
  const hasCallId = typeof obj.callId === "string";
  const hasContent = "content" in obj;
  return hasCallId && hasContent;
}

// src/providers/chutes/chutesProvider.ts
var BASE_URL = "https://llm.chutes.ai/v1";
var DEFAULT_MAX_OUTPUT_TOKENS = 16e3;
var DEFAULT_CONTEXT_LENGTH = 131072;
var ChutesProvider = class _ChutesProvider extends GenericModelProvider {
  userAgent;
  extensionPath;
  configFilePath;
  clientCache = /* @__PURE__ */ new Map();
  constructor(context, providerKey, providerConfig, userAgent, extensionPath2) {
    super(context, providerKey, providerConfig);
    this.userAgent = userAgent;
    this.extensionPath = extensionPath2;
    this.configFilePath = path3.join(
      this.extensionPath,
      "src",
      "providers",
      "config",
      "chutes.json"
    );
  }
  /**
   * Override refreshHandlers to also clear the OpenAI client cache
   * This ensures that when baseUrl changes, new clients are created with the correct URL
   */
  refreshHandlers() {
    if (this.clientCache && this.clientCache.size > 0) {
      Logger.debug(`[Chutes] Clearing ${this.clientCache.size} cached OpenAI clients due to config change`);
      this.clientCache.clear();
    }
    super.refreshHandlers();
  }
  estimateMessagesTokens(msgs) {
    let total = 0;
    for (const m of msgs) {
      for (const part of m.content) {
        if (part instanceof vscode35.LanguageModelTextPart) {
          total += Math.ceil(part.value.length / 4);
        }
      }
    }
    return total;
  }
  estimateToolTokens(tools) {
    if (!tools || tools.length === 0) {
      return 0;
    }
    try {
      const json = JSON.stringify(tools);
      return Math.ceil(json.length / 4);
    } catch {
      return 0;
    }
  }
  async prepareLanguageModelChatInformation(options, _token) {
    const apiKey = await this.ensureApiKey(options.silent ?? true);
    if (!apiKey) {
      return [];
    }
    const { models } = await this.fetchModels(apiKey);
    this.updateConfigFileAsync(models);
    const infos = models.map((m) => {
      const modalities = m.input_modalities ?? [];
      const vision = Array.isArray(modalities) && modalities.includes("image");
      const supportsTools = m.supported_features?.includes("tools") ?? false;
      const contextLen = m.context_length ?? m.max_model_len ?? DEFAULT_CONTEXT_LENGTH;
      let maxOutput = m.max_output_length ?? DEFAULT_MAX_OUTPUT_TOKENS;
      if (maxOutput >= contextLen) {
        maxOutput = Math.min(contextLen / 2, DEFAULT_MAX_OUTPUT_TOKENS);
      }
      maxOutput = Math.floor(
        Math.max(1, Math.min(maxOutput, contextLen - 1024))
      );
      const maxInput = Math.max(1, contextLen - maxOutput);
      return {
        id: m.id,
        name: m.id,
        tooltip: `${m.id} by Chutes`,
        family: "chutes",
        version: "1.0.0",
        maxInputTokens: maxInput,
        maxOutputTokens: maxOutput,
        capabilities: {
          toolCalling: supportsTools,
          imageInput: vision
        }
      };
    });
    this._chatEndpoints = infos.map((info) => ({
      model: info.id,
      modelMaxPromptTokens: info.maxInputTokens + info.maxOutputTokens
    }));
    const dedupedInfos = this.dedupeModelInfos(infos);
    return dedupedInfos;
  }
  async provideLanguageModelChatInformation(options, _token) {
    return this.prepareLanguageModelChatInformation(
      { silent: options.silent ?? false },
      _token
    );
  }
  async fetchModels(apiKey) {
    const modelsList = (async () => {
      const baseUrl = this.providerConfig.baseUrl || BASE_URL;
      const resp = await fetch(`${baseUrl}/models`, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${apiKey}`,
          "User-Agent": this.userAgent
        }
      });
      if (!resp.ok) {
        let text = "";
        try {
          text = await resp.text();
        } catch (error2) {
          Logger.error(
            "[Chutes Model Provider] Failed to read response text",
            error2
          );
        }
        const err = new Error(
          `Failed to fetch Chutes models: ${resp.status} ${resp.statusText}${text ? `
${text}` : ""}`
        );
        Logger.error(
          "[Chutes Model Provider] Failed to fetch Chutes models",
          err
        );
        throw err;
      }
      const parsed = await resp.json();
      return parsed.data ?? [];
    })();
    try {
      const models = await modelsList;
      return { models };
    } catch (err) {
      Logger.error(
        "[Chutes Model Provider] Failed to fetch Chutes models",
        err
      );
      throw err;
    }
  }
  /**
   * Update config file asynchronously in background
   */
  updateConfigFileAsync(models) {
    (async () => {
      try {
        if (!fs.existsSync(this.configFilePath)) {
          Logger.debug(
            `[Chutes] Config file not found at ${this.configFilePath}, skipping auto-update`
          );
          return;
        }
        const modelConfigs = models.map((m) => {
          const modalities = m.input_modalities ?? [];
          const vision = Array.isArray(modalities) && modalities.includes("image");
          const supportsTools = m.supported_features?.includes("tools") ?? false;
          const contextLen = m.context_length ?? m.max_model_len ?? DEFAULT_CONTEXT_LENGTH;
          const maxOutput = m.max_output_length ?? DEFAULT_MAX_OUTPUT_TOKENS;
          const maxInput = Math.max(1, contextLen - maxOutput);
          const cleanId = m.id.replace(/[/]/g, "-").replace(/[^a-zA-Z0-9-]/g, "-").toLowerCase();
          return {
            id: cleanId,
            name: m.id,
            tooltip: `${m.id} by Chutes`,
            maxInputTokens: maxInput,
            maxOutputTokens: maxOutput,
            model: m.id,
            capabilities: {
              toolCalling: supportsTools,
              imageInput: vision
            }
          };
        });
        let existingConfig;
        try {
          const configContent = fs.readFileSync(this.configFilePath, "utf8");
          existingConfig = JSON.parse(configContent);
        } catch (err) {
          Logger.warn(
            `[Chutes] Failed to read existing config, using defaults:`,
            err instanceof Error ? err.message : String(err)
          );
          existingConfig = {
            displayName: "Chutes",
            baseUrl: BASE_URL,
            apiKeyTemplate: "cpk_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            models: []
          };
        }
        const updatedConfig = {
          displayName: existingConfig.displayName || "Chutes",
          baseUrl: existingConfig.baseUrl || BASE_URL,
          apiKeyTemplate: existingConfig.apiKeyTemplate || "cpk_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
          models: modelConfigs
        };
        fs.writeFileSync(
          this.configFilePath,
          JSON.stringify(updatedConfig, null, 4),
          "utf8"
        );
        Logger.info(
          `[Chutes] Auto-updated config file with ${modelConfigs.length} models`
        );
      } catch (err) {
        Logger.warn(
          `[Chutes] Background config update failed:`,
          err instanceof Error ? err.message : String(err)
        );
      }
    })();
  }
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    await RateLimiter.getInstance(this.providerKey, 2, 1e3).throttle(
      this.providerConfig.displayName
    );
    try {
      const apiKey = await this.ensureApiKey(true);
      if (!apiKey) {
        throw new Error("Chutes API key not found");
      }
      validateRequest(
        messages
      );
      if (options.tools && options.tools.length > 128) {
        throw new Error("Cannot have more than 128 tools per request.");
      }
      const inputTokenCount = this.estimateMessagesTokens(
        messages
      );
      const toolTokenCount = options.tools ? this.estimateToolTokens(
        this.openaiHandler.convertToolsToOpenAI([...options.tools])
      ) : 0;
      const tokenLimit = Math.max(1, model.maxInputTokens);
      if (inputTokenCount + toolTokenCount > tokenLimit) {
        Logger.error("[Chutes Model Provider] Message exceeds token limit", {
          total: inputTokenCount + toolTokenCount,
          tokenLimit
        });
        throw new Error("Message exceeds token limit.");
      }
      const client = await this.createOpenAIClient(apiKey);
      const modelConfig = this.providerConfig.models.find(
        (m) => m.id === model.id
      );
      const openaiMessages = this.openaiHandler.convertMessagesToOpenAI(
        messages,
        model.capabilities || void 0,
        modelConfig
      );
      const createParams = {
        model: model.id,
        messages: openaiMessages,
        stream: true,
        stream_options: { include_usage: true },
        max_tokens: Math.min(
          options.modelOptions?.max_tokens || 4096,
          model.maxOutputTokens
        ),
        temperature: options.modelOptions?.temperature ?? ConfigManager.getTemperature(),
        top_p: ConfigManager.getTopP()
      };
      if (options.modelOptions) {
        const mo = options.modelOptions;
        if (typeof mo.stop === "string" || Array.isArray(mo.stop)) {
          createParams.stop = mo.stop;
        }
        if (typeof mo.frequency_penalty === "number") {
          createParams.frequency_penalty = mo.frequency_penalty;
        }
        if (typeof mo.presence_penalty === "number") {
          createParams.presence_penalty = mo.presence_penalty;
        }
      }
      if (options.tools && options.tools.length > 0 && model.capabilities?.toolCalling) {
        createParams.tools = this.openaiHandler.convertToolsToOpenAI([
          ...options.tools
        ]);
        createParams.tool_choice = "auto";
      }
      const abortController = new AbortController();
      token.onCancellationRequested(() => abortController.abort());
      const stream = client.chat.completions.stream(createParams, {
        signal: abortController.signal
      });
      let currentThinkingId = null;
      let thinkingContentBuffer = "";
      let _hasReceivedContent = false;
      let hasThinkingContent = false;
      const toolCallIds = /* @__PURE__ */ new Map();
      stream.on("chunk", (chunk) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (chunk.choices && chunk.choices.length > 0) {
          for (const choice of chunk.choices) {
            if (choice.delta?.tool_calls) {
              for (const toolCall of choice.delta.tool_calls) {
                if (toolCall.id && toolCall.index !== void 0) {
                  toolCallIds.set(toolCall.index, toolCall.id);
                }
              }
            }
            const delta = choice.delta;
            const reasoningContent = delta?.reasoning ?? delta?.reasoning_content;
            if (reasoningContent && typeof reasoningContent === "string") {
              if (!currentThinkingId) {
                currentThinkingId = `chutes_thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
              }
              thinkingContentBuffer += reasoningContent;
              try {
                progress.report(
                  new vscode35.LanguageModelThinkingPart(
                    thinkingContentBuffer,
                    currentThinkingId
                  )
                );
                thinkingContentBuffer = "";
                hasThinkingContent = true;
              } catch (e) {
                Logger.warn(
                  "[Chutes] Failed to report thinking",
                  e instanceof Error ? e.message : String(e)
                );
              }
            }
          }
        }
      });
      stream.on("content", (delta) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (delta && typeof delta === "string" && delta.trim().length > 0) {
          if (currentThinkingId) {
            try {
              progress.report(
                new vscode35.LanguageModelThinkingPart(
                  "",
                  currentThinkingId
                )
              );
            } catch {
            }
            currentThinkingId = null;
          }
          try {
            progress.report(new vscode35.LanguageModelTextPart(delta));
            _hasReceivedContent = true;
          } catch (e) {
            Logger.warn(
              "[Chutes] Failed to report content",
              e instanceof Error ? e.message : String(e)
            );
          }
        }
      });
      stream.on("tool_calls.function.arguments.done", (event) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (currentThinkingId) {
          try {
            progress.report(
              new vscode35.LanguageModelThinkingPart(
                "",
                currentThinkingId
              )
            );
          } catch {
          }
          currentThinkingId = null;
        }
        const toolCallId = toolCallIds.get(event.index) || `tool_call_${event.index}_${Date.now()}`;
        let parsedArgs = {};
        if (event.parsed_arguments) {
          const result = event.parsed_arguments;
          parsedArgs = typeof result === "object" && result !== null ? result : {};
        } else {
          try {
            parsedArgs = JSON.parse(event.arguments || "{}");
          } catch {
            parsedArgs = { value: event.arguments };
          }
        }
        try {
          progress.report(
            new vscode35.LanguageModelToolCallPart(
              toolCallId,
              event.name,
              parsedArgs
            )
          );
          _hasReceivedContent = true;
        } catch (e) {
          Logger.warn(
            "[Chutes] Failed to report tool call",
            e instanceof Error ? e.message : String(e)
          );
        }
      });
      await stream.finalChatCompletion();
      if (currentThinkingId) {
        try {
          progress.report(
            new vscode35.LanguageModelThinkingPart(
              "",
              currentThinkingId
            )
          );
        } catch {
        }
      }
    } catch (err) {
      Logger.error("[Chutes Model Provider] Chat request failed", {
        modelId: model.id,
        messageCount: messages.length,
        error: err instanceof Error ? { name: err.name, message: err.message } : String(err)
      });
      throw err;
    } finally {
      this.incrementRequestCount();
    }
  }
  /**
   * Create OpenAI client for Chutes API
   */
  async createOpenAIClient(apiKey) {
    const baseUrl = this.providerConfig.baseUrl || BASE_URL;
    const cacheKey = `chutes:${baseUrl}`;
    const cached2 = this.clientCache.get(cacheKey);
    if (cached2) {
      cached2.lastUsed = Date.now();
      return cached2.client;
    }
    const client = new OpenAI({
      apiKey,
      baseURL: baseUrl,
      defaultHeaders: {
        "User-Agent": this.userAgent
      },
      maxRetries: 2,
      timeout: 6e4
    });
    this.clientCache.set(cacheKey, { client, lastUsed: Date.now() });
    return client;
  }
  async provideTokenCount(model, text, _token) {
    return TokenCounter.getInstance().countTokens(model, text);
  }
  async ensureApiKey(silent) {
    let apiKey = await ApiKeyManager.getApiKey("chutes");
    if (!apiKey && !silent) {
      await ApiKeyManager.promptAndSetApiKey(
        "chutes",
        "Chutes",
        "cpk_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      );
      apiKey = await ApiKeyManager.getApiKey("chutes");
    }
    return apiKey;
  }
  /**
   * Increment global request count and update status bar
   */
  incrementRequestCount() {
    const today = (/* @__PURE__ */ new Date()).toDateString();
    let count = this.context?.globalState.get("chutes.requestCount") || 0;
    const lastReset = this.context?.globalState.get(
      "chutes.lastResetDate"
    );
    if (lastReset !== today) {
      count = 1;
      this.context?.globalState.update("chutes.lastResetDate", today);
    } else {
      count++;
    }
    this.context?.globalState.update("chutes.requestCount", count);
    Logger.debug(`[Chutes] Global request count: ${count}/5000`);
  }
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(`${providerConfig.displayName} provider activated!`);
    const ext = vscode35.extensions.getExtension("OEvortex.better-copilot-chat");
    const extVersion = ext?.packageJSON?.version ?? "unknown";
    const vscodeVersion = vscode35.version;
    const ua = `better-copilot-chat/${extVersion} VSCode/${vscodeVersion}`;
    const extensionPath2 = context.extensionPath;
    const provider = new _ChutesProvider(
      context,
      providerKey,
      providerConfig,
      ua,
      extensionPath2
    );
    const providerDisposable = vscode35.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const setApiKeyCommand = vscode35.commands.registerCommand(
      `chp.${providerKey}.setApiKey`,
      async () => {
        await ProviderWizard.startWizard({
          providerKey,
          displayName: providerConfig.displayName,
          apiKeyTemplate: providerConfig.apiKeyTemplate,
          supportsApiKey: true,
          supportsBaseUrl: true
        });
        await provider.modelInfoCache?.invalidateCache(providerKey);
        provider._onDidChangeLanguageModelChatInformation.fire(void 0);
      }
    );
    const disposables = [providerDisposable, setApiKeyCommand];
    for (const d of disposables) {
      context.subscriptions.push(d);
    }
    return { provider, disposables };
  }
};

// src/providers/compatible/compatibleProvider.ts
var vscode36 = __toESM(require("vscode"));
init_config();
var CompatibleProvider = class _CompatibleProvider extends GenericModelProvider {
  static PROVIDER_KEY = "compatible";
  modelsChangeListener;
  retryManager;
  constructor(context) {
    const virtualConfig = {
      displayName: "Compatible",
      baseUrl: "https://api.openai.com/v1",
      // Default value, will be overridden during actual use
      apiKeyTemplate: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
      models: []
      // Empty model list, actual retrieved from CompatibleModelManager
    };
    super(context, _CompatibleProvider.PROVIDER_KEY, virtualConfig);
    this.retryManager = new RetryManager({
      maxAttempts: 3,
      initialDelayMs: 1e3,
      maxDelayMs: 3e4,
      backoffMultiplier: 2,
      jitterEnabled: true
    });
    this.getProviderConfig();
    this.modelsChangeListener = CompatibleModelManager.onDidChangeModels(() => {
      Logger.debug(
        "[compatible] Received model change event, refreshing configuration and cache"
      );
      this.getProviderConfig();
      this.modelInfoCache?.invalidateCache(_CompatibleProvider.PROVIDER_KEY).catch(
        (err) => Logger.warn("[compatible] Failed to clear cache:", err)
      );
      this._onDidChangeLanguageModelChatInformation.fire();
      Logger.debug(
        "[compatible] Triggered language model information change event"
      );
    });
  }
  dispose() {
    this.modelsChangeListener?.dispose();
    super.dispose();
  }
  /**
   * Override: Get dynamic provider configuration
   * Retrieve user-configured models from CompatibleModelManager
   */
  getProviderConfig() {
    try {
      const models = CompatibleModelManager.getModels();
      const modelConfigs = models.map((model) => {
        let customHeader = model.customHeader;
        if (model.provider) {
          const provider = KnownProviders[model.provider];
          if (provider?.customHeader) {
            const existingHeaders = model.customHeader || {};
            customHeader = { ...existingHeaders, ...provider.customHeader };
          }
          let knownOverride;
          if (model.sdkMode === "anthropic" && provider?.anthropic) {
            knownOverride = provider.anthropic;
          } else if (model.sdkMode !== "anthropic" && provider?.openai) {
            knownOverride = provider.openai.extraBody;
          }
          if (knownOverride) {
            const extraBody = knownOverride.extraBody || {};
            const modelBody = model.extraBody || {};
            model.extraBody = { ...extraBody, ...modelBody };
          }
        }
        return {
          id: model.id,
          name: model.name,
          provider: model.provider,
          tooltip: model.tooltip || `${model.name} (${model.sdkMode})`,
          maxInputTokens: model.maxInputTokens,
          maxOutputTokens: model.maxOutputTokens,
          sdkMode: model.sdkMode,
          capabilities: model.capabilities,
          ...model.baseUrl && { baseUrl: model.baseUrl },
          ...model.model && { model: model.model },
          ...customHeader && { customHeader },
          ...model.extraBody && { extraBody: model.extraBody },
          ...model.outputThinking !== void 0 && {
            outputThinking: model.outputThinking
          },
          ...model.includeThinking !== void 0 && {
            includeThinking: model.includeThinking
          }
        };
      });
      Logger.debug(
        `Compatible Provider loaded ${modelConfigs.length} user-configured models`
      );
      this.cachedProviderConfig = {
        displayName: "Compatible",
        baseUrl: "https://api.openai.com/v1",
        // Default value, model-level configuration will override
        apiKeyTemplate: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
        models: modelConfigs
      };
    } catch (error2) {
      Logger.error("Failed to get Compatible Provider configuration:", error2);
      this.cachedProviderConfig = {
        displayName: "Compatible",
        baseUrl: "https://api.openai.com/v1",
        apiKeyTemplate: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
        models: []
      };
    }
    return this.cachedProviderConfig;
  }
  /**
   * Override: Provide language model chat information
   * Get the latest dynamic configuration directly, not relying on configuration at construction time
   * Check API Keys for providers involved in all models
   * Integrate model caching mechanism to improve performance
   */
  async provideLanguageModelChatInformation(options, _token) {
    try {
      const apiKeyHash = await this.getApiKeyHash();
      let cachedModels = await this.modelInfoCache?.getCachedModels(
        _CompatibleProvider.PROVIDER_KEY,
        apiKeyHash
      );
      if (cachedModels) {
        Logger.trace(
          `Compatible Provider cache hit: ${cachedModels.length} models`
        );
        const rememberLastModel2 = ConfigManager.getRememberLastModel();
        if (rememberLastModel2) {
          const lastSelectedId = this.modelInfoCache?.getLastSelectedModel(
            _CompatibleProvider.PROVIDER_KEY
          );
          if (lastSelectedId) {
            cachedModels = cachedModels.map((model) => ({
              ...model,
              isDefault: model.id === lastSelectedId
            }));
          }
        }
        this.updateModelCacheAsync(apiKeyHash);
        return cachedModels;
      }
      const currentConfig = this.providerConfig;
      if (currentConfig.models.length === 0) {
        if (!options.silent) {
          setImmediate(async () => {
            try {
              await CompatibleModelManager.configureModelOrUpdateAPIKey();
            } catch {
              Logger.debug(
                "Automatically triggering new model addition failed or was cancelled by user"
              );
            }
          });
        }
        return [];
      }
      const providers2 = /* @__PURE__ */ new Set();
      for (const model of currentConfig.models) {
        if (model.provider) {
          providers2.add(model.provider);
        }
      }
      for (const provider of providers2) {
        if (!options.silent) {
          const hasValidKey = await ApiKeyManager.ensureApiKey(
            provider,
            provider,
            false
          );
          if (!hasValidKey) {
            Logger.warn(
              `Compatible Provider: user has not set API key for provider "${provider}"`
            );
            return [];
          }
        }
      }
      let modelInfos = currentConfig.models.map((model) => {
        const info = this.modelConfigToInfo(model);
        const sdkModeDisplay = model.sdkMode === "anthropic" ? "Anthropic" : "OpenAI";
        if (model.provider) {
          const knownProvider = KnownProviders[model.provider];
          if (knownProvider?.displayName) {
            return { ...info, detail: knownProvider.displayName };
          }
          const provider = configProviders[model.provider];
          if (provider?.displayName) {
            return { ...info, detail: provider.displayName };
          }
        }
        return { ...info, detail: `${sdkModeDisplay} Compatible` };
      });
      const rememberLastModel = ConfigManager.getRememberLastModel();
      if (rememberLastModel) {
        const lastSelectedId = this.modelInfoCache?.getLastSelectedModel(
          _CompatibleProvider.PROVIDER_KEY
        );
        if (lastSelectedId) {
          modelInfos = modelInfos.map((model) => ({
            ...model,
            isDefault: model.id === lastSelectedId
          }));
        }
      }
      Logger.debug(
        `Compatible Provider provided ${modelInfos.length} model information`
      );
      this.updateModelCacheAsync(apiKeyHash);
      return modelInfos;
    } catch (error2) {
      Logger.error(
        "Failed to get Compatible Provider model information:",
        error2
      );
      return [];
    }
  }
  /**
   * Override: Update model cache asynchronously
   * Need to correctly set detail field to display SDK mode
   */
  updateModelCacheAsync(apiKeyHash) {
    (async () => {
      try {
        const currentConfig = this.providerConfig;
        const models = currentConfig.models.map((model) => {
          const info = this.modelConfigToInfo(model);
          const sdkModeDisplay = model.sdkMode === "anthropic" ? "Anthropic" : "OpenAI";
          if (model.provider) {
            const knownProvider = KnownProviders[model.provider];
            if (knownProvider?.displayName) {
              return { ...info, detail: knownProvider.displayName };
            }
            const provider = configProviders[model.provider];
            if (provider?.displayName) {
              return { ...info, detail: provider.displayName };
            }
          }
          return { ...info, detail: `${sdkModeDisplay} Compatible` };
        });
        await this.modelInfoCache?.cacheModels(
          _CompatibleProvider.PROVIDER_KEY,
          models,
          apiKeyHash
        );
      } catch (err) {
        Logger.trace(
          "[compatible] Background cache update failed:",
          err instanceof Error ? err.message : String(err)
        );
      }
    })();
  }
  /**
   * Override: Provide language model chat response
   * Process request using latest dynamic configuration and add failure retry mechanism
   */
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    const rememberLastModel = ConfigManager.getRememberLastModel();
    if (rememberLastModel) {
      this.modelInfoCache?.saveLastSelectedModel(_CompatibleProvider.PROVIDER_KEY, model.id).catch(
        (err) => Logger.warn("[compatible] Failed to save model selection:", err)
      );
    }
    try {
      const currentConfig = this.providerConfig;
      const modelConfig = currentConfig.models.find((m) => m.id === model.id);
      if (!modelConfig) {
        const errorMessage = `Compatible Provider could not find model: ${model.id}`;
        Logger.error(errorMessage);
        throw new Error(errorMessage);
      }
      const hasValidKey = await ApiKeyManager.ensureApiKey(
        modelConfig.provider,
        currentConfig.displayName,
        false
      );
      if (!hasValidKey) {
        throw new Error(
          `API key for model ${modelConfig.name} has not been set yet`
        );
      }
      const sdkMode = modelConfig.sdkMode || "openai";
      let sdkName = "OpenAI SDK";
      if (sdkMode === "anthropic") {
        sdkName = "Anthropic SDK";
      } else if (sdkMode === "openai-sse") {
        sdkName = "OpenAI SSE";
      }
      Logger.info(
        `Compatible Provider starts processing request (${sdkName}): ${modelConfig.name}`
      );
      try {
        await this.retryManager.executeWithRetry(
          async () => {
            if (sdkMode === "anthropic") {
              await this.anthropicHandler.handleRequest(
                model,
                modelConfig,
                messages,
                options,
                progress,
                token
              );
            } else if (sdkMode === "openai-sse") {
              await this.handleRequestWithCustomSSE(
                model,
                modelConfig,
                messages,
                options,
                progress,
                token
              );
            } else {
              await this.openaiHandler.handleRequest(
                model,
                modelConfig,
                messages,
                options,
                progress,
                token
              );
            }
          },
          (error2) => RetryManager.isRateLimitError(error2),
          this.providerConfig.displayName
        );
      } catch (error2) {
        const errorMessage = `Error: ${error2 instanceof Error ? error2.message : "Unknown error"}`;
        Logger.error(errorMessage);
        throw error2;
      } finally {
        Logger.info(`Compatible Provider: ${model.name} Request completed`);
      }
    } catch (error2) {
      Logger.error("Compatible Provider failed to process request:", error2);
      throw error2;
    }
  }
  /**
   * Parse <thinking>...</thinking> tags in content
   * Return parsing result, including separation of thinking content and normal content
   */
  parseThinkingTags(content, isInsideThinkingTag, tagBuffer) {
    const thinkingParts = [];
    const contentParts = [];
    let currentBuffer = tagBuffer + content;
    let insideTag = isInsideThinkingTag;
    let remainingBuffer = "";
    while (currentBuffer.length > 0) {
      if (insideTag) {
        const endIndex = currentBuffer.indexOf("</thinking>");
        if (endIndex !== -1) {
          const thinkingContent = currentBuffer.substring(0, endIndex);
          if (thinkingContent.length > 0) {
            thinkingParts.push(thinkingContent);
          }
          currentBuffer = currentBuffer.substring(
            endIndex + "</thinking>".length
          );
          insideTag = false;
        } else {
          const partialEndMatch = this.findPartialTag(
            currentBuffer,
            "</thinking>"
          );
          if (partialEndMatch.found) {
            const thinkingContent = currentBuffer.substring(
              0,
              partialEndMatch.index
            );
            if (thinkingContent.length > 0) {
              thinkingParts.push(thinkingContent);
            }
            remainingBuffer = currentBuffer.substring(partialEndMatch.index);
            currentBuffer = "";
          } else {
            thinkingParts.push(currentBuffer);
            currentBuffer = "";
          }
        }
      } else {
        const startIndex = currentBuffer.indexOf("<thinking>");
        if (startIndex !== -1) {
          const beforeThinking = currentBuffer.substring(0, startIndex);
          if (beforeThinking.length > 0) {
            contentParts.push(beforeThinking);
          }
          currentBuffer = currentBuffer.substring(
            startIndex + "<thinking>".length
          );
          insideTag = true;
        } else {
          const partialStartMatch = this.findPartialTag(
            currentBuffer,
            "<thinking>"
          );
          if (partialStartMatch.found) {
            const normalContent = currentBuffer.substring(
              0,
              partialStartMatch.index
            );
            if (normalContent.length > 0) {
              contentParts.push(normalContent);
            }
            remainingBuffer = currentBuffer.substring(partialStartMatch.index);
            currentBuffer = "";
          } else {
            contentParts.push(currentBuffer);
            currentBuffer = "";
          }
        }
      }
    }
    return {
      thinkingParts,
      contentParts,
      isInsideThinkingTag: insideTag,
      remainingTagBuffer: remainingBuffer
    };
  }
  /**
   * Find partial tags (used for tags across chunks)
   */
  findPartialTag(content, tag) {
    for (let i = 1; i < tag.length; i++) {
      const suffix = content.substring(content.length - i);
      const prefix = tag.substring(0, i);
      if (suffix === prefix) {
        return { found: true, index: content.length - i };
      }
    }
    return { found: false, index: -1 };
  }
  /**
   * Request method using custom SSE stream processing
   */
  async handleRequestWithCustomSSE(model, modelConfig, messages, options, progress, token) {
    const provider = modelConfig.provider || this.providerKey;
    const apiKey = await ApiKeyManager.getApiKey(provider);
    if (!apiKey) {
      throw new Error(`Missing ${provider} API key`);
    }
    const baseURL = modelConfig.baseUrl || "https://api.openai.com/v1";
    const url2 = `${baseURL}/chat/completions`;
    Logger.info(
      `[${model.name}] Process ${messages.length} messages using custom SSE processing`
    );
    const requestBody = {
      model: modelConfig.model || model.id,
      messages: this.openaiHandler.convertMessagesToOpenAI(
        messages,
        model.capabilities || void 0,
        modelConfig
      ),
      max_tokens: ConfigManager.getMaxTokensForModel(model.maxOutputTokens),
      stream: true,
      temperature: ConfigManager.getTemperature(),
      top_p: ConfigManager.getTopP()
    };
    if (options.tools && options.tools.length > 0 && model.capabilities?.toolCalling) {
      requestBody.tools = this.openaiHandler.convertToolsToOpenAI([
        ...options.tools
      ]);
      requestBody.tool_choice = "auto";
    }
    if (modelConfig.extraBody) {
      const filteredExtraBody = modelConfig.extraBody;
      Object.assign(requestBody, filteredExtraBody);
      Logger.trace(
        `${model.name} merged extraBody parameters: ${JSON.stringify(filteredExtraBody)}`
      );
    }
    Logger.debug(`[${model.name}] Send API request`);
    const abortController = new AbortController();
    const cancellationListener = token.onCancellationRequested(
      () => abortController.abort()
    );
    try {
      const processedCustomHeader = ApiKeyManager.processCustomHeader(
        modelConfig?.customHeader,
        apiKey
      );
      const response = await fetch(url2, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`,
          ...processedCustomHeader
        },
        body: JSON.stringify(requestBody),
        signal: abortController.signal
      });
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(
          `API request failed: ${response.status} ${response.statusText} - ${errorText}`
        );
      }
      if (!response.body) {
        throw new Error("Response body is empty");
      }
      const reader = response.body.getReader();
      const decoder = new TextDecoder();
      let buffer = "";
      let finalUsage;
      let hasReceivedContent = false;
      let hasThinkingContent = false;
      let chunkCount = 0;
      const toolCallsBuffer = /* @__PURE__ */ new Map();
      let currentThinkingId = null;
      let thinkingContentBuffer = "";
      const MAX_THINKING_BUFFER_LENGTH = 10;
      let isInsideThinkingTag = false;
      let thinkingTagBuffer = "";
      const _pendingContentBuffer = "";
      try {
        while (true) {
          if (token.isCancellationRequested) {
            Logger.warn(`[${model.name}] User cancelled request`);
            break;
          }
          const { done, value } = await reader.read();
          if (done) {
            break;
          }
          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop() || "";
          for (const line of lines) {
            if (!line.trim() || line.trim() === "") {
              continue;
            }
            if (line.startsWith("data:")) {
              const data = line.substring(5).trim();
              if (data === "[DONE]") {
                Logger.debug(`[${model.name}] Received end of stream marker`);
                continue;
              }
              try {
                const chunk = JSON.parse(data);
                chunkCount++;
                let hasContent = false;
                if (chunk.usage && (!chunk.choices || chunk.choices.length === 0)) {
                  finalUsage = chunk.usage;
                  Logger.debug(
                    `[${model.name}] Received usage statistics: ${JSON.stringify(chunk.usage)}`
                  );
                } else {
                  for (const choice of chunk.choices || []) {
                    const delta = choice.delta;
                    if (delta?.reasoning_content && typeof delta.reasoning_content === "string") {
                      Logger.trace(
                        `[${model.name}] Received thinking content: ${delta.reasoning_content.length} characters, content="${delta.reasoning_content}"`
                      );
                      if (!currentThinkingId) {
                        currentThinkingId = `thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
                        Logger.trace(
                          `[${model.name}] Create new chain of thought ID: ${currentThinkingId}`
                        );
                      }
                      thinkingContentBuffer += delta.reasoning_content;
                      if (thinkingContentBuffer.length >= MAX_THINKING_BUFFER_LENGTH) {
                        try {
                          progress.report(
                            new vscode36.LanguageModelThinkingPart(
                              thinkingContentBuffer,
                              currentThinkingId
                            )
                          );
                          thinkingContentBuffer = "";
                          hasThinkingContent = true;
                        } catch (e) {
                          Logger.trace(
                            `[${model.name}] Failed to report thinking content: ${String(e)}`
                          );
                        }
                      } else {
                        hasThinkingContent = true;
                      }
                    }
                    if (delta?.content && typeof delta.content === "string") {
                      Logger.trace(
                        `[${model.name}] Output text content: ${delta.content.length} characters, preview=${delta.content}`
                      );
                      const parseResult = this.parseThinkingTags(
                        delta.content,
                        isInsideThinkingTag,
                        thinkingTagBuffer
                      );
                      isInsideThinkingTag = parseResult.isInsideThinkingTag;
                      thinkingTagBuffer = parseResult.remainingTagBuffer;
                      for (const thinkingPart of parseResult.thinkingParts) {
                        if (thinkingPart.length > 0) {
                          if (!currentThinkingId) {
                            currentThinkingId = `thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
                            Logger.trace(
                              `[${model.name}] Create new chain of thought ID (from tag): ${currentThinkingId}`
                            );
                          }
                          thinkingContentBuffer += thinkingPart;
                          if (thinkingContentBuffer.length >= MAX_THINKING_BUFFER_LENGTH) {
                            try {
                              progress.report(
                                new vscode36.LanguageModelThinkingPart(
                                  thinkingContentBuffer,
                                  currentThinkingId
                                )
                              );
                              thinkingContentBuffer = "";
                              hasThinkingContent = true;
                            } catch (e) {
                              Logger.trace(
                                `[${model.name}] Failed to report thinking content (from tag): ${String(e)}`
                              );
                            }
                          } else {
                            hasThinkingContent = true;
                          }
                        }
                      }
                      for (const contentPart of parseResult.contentParts) {
                        if (contentPart.length > 0) {
                          if (thinkingContentBuffer.length > 0 && currentThinkingId) {
                            try {
                              progress.report(
                                new vscode36.LanguageModelThinkingPart(
                                  thinkingContentBuffer,
                                  currentThinkingId
                                )
                              );
                              thinkingContentBuffer = "";
                              hasThinkingContent = true;
                            } catch (e) {
                              Logger.trace(
                                `[${model.name}] Failed to report remaining thinking content: ${String(e)}`
                              );
                            }
                          }
                          if (currentThinkingId && !isInsideThinkingTag) {
                            try {
                              Logger.trace(
                                `[${model.name}] End chain of thought before outputting content ID: ${currentThinkingId}`
                              );
                              progress.report(
                                new vscode36.LanguageModelThinkingPart(
                                  "",
                                  currentThinkingId
                                )
                              );
                            } catch (e) {
                              Logger.trace(
                                `[${model.name}] Failed to send thinking done(id=${currentThinkingId}) failure: ${String(e)}`
                              );
                            }
                            currentThinkingId = null;
                          }
                          progress.report(
                            new vscode36.LanguageModelTextPart(contentPart)
                          );
                          hasContent = true;
                        }
                      }
                    }
                    if (delta?.tool_calls && Array.isArray(delta.tool_calls)) {
                      for (const toolCall of delta.tool_calls) {
                        const toolIndex = toolCall.index ?? 0;
                        if (toolIndex !== void 0 && !toolCall.function?.arguments) {
                          if (thinkingContentBuffer.length > 0 && currentThinkingId) {
                            try {
                              progress.report(
                                new vscode36.LanguageModelThinkingPart(
                                  thinkingContentBuffer,
                                  currentThinkingId
                                )
                              );
                              progress.report(
                                new vscode36.LanguageModelThinkingPart(
                                  "",
                                  currentThinkingId
                                )
                              );
                              thinkingContentBuffer = "";
                              hasThinkingContent = true;
                            } catch (e) {
                              Logger.trace(
                                `[${model.name}] Failed to report remaining thinking content: ${String(e)}`
                              );
                            }
                          }
                          Logger.trace(
                            `[${model.name}] Tool call start: ${toolCall.function?.name || "unknown"} (index: ${toolIndex})`
                          );
                        }
                        let bufferedTool = toolCallsBuffer.get(toolIndex);
                        if (!bufferedTool) {
                          bufferedTool = { arguments: "" };
                          toolCallsBuffer.set(toolIndex, bufferedTool);
                        }
                        if (toolCall.id) {
                          bufferedTool.id = toolCall.id;
                        }
                        if (toolCall.function?.name) {
                          bufferedTool.name = toolCall.function.name;
                        }
                        if (toolCall.function?.arguments) {
                          const newArgs = toolCall.function.arguments;
                          if (bufferedTool.arguments.endsWith(newArgs)) {
                            Logger.trace(
                              `[${model.name}] Skip duplicate tool call parameters [${toolIndex}]: "${newArgs}"`
                            );
                          } else if (bufferedTool.arguments.length > 0 && newArgs.startsWith(bufferedTool.arguments)) {
                            const incrementalArgs = newArgs.substring(
                              bufferedTool.arguments.length
                            );
                            bufferedTool.arguments += incrementalArgs;
                            Logger.trace(
                              `[${model.name}] Partial duplication detected, extract incremental part [${toolIndex}]: "${incrementalArgs}"`
                            );
                          } else {
                            bufferedTool.arguments += newArgs;
                          }
                        }
                        Logger.trace(
                          `[${model.name}] Accumulate tool call data [${toolIndex}]: name=${bufferedTool.name}, args_length=${bufferedTool.arguments.length}`
                        );
                      }
                    }
                    if (choice.finish_reason) {
                      Logger.debug(
                        `[${model.name}] Stream ended, reason: ${choice.finish_reason}`
                      );
                      if (thinkingContentBuffer.length > 0 && currentThinkingId) {
                        try {
                          progress.report(
                            new vscode36.LanguageModelThinkingPart(
                              thinkingContentBuffer,
                              currentThinkingId
                            )
                          );
                          thinkingContentBuffer = "";
                          hasThinkingContent = true;
                        } catch (e) {
                          Logger.trace(
                            `[${model.name}] Failed to report remaining thinking content: ${String(e)}`
                          );
                        }
                      }
                      if (currentThinkingId && choice.finish_reason !== "length") {
                        try {
                          Logger.trace(
                            `[${model.name}] End chain of thought before stream ends ID: ${currentThinkingId}`
                          );
                          progress.report(
                            new vscode36.LanguageModelThinkingPart(
                              "",
                              currentThinkingId
                            )
                          );
                        } catch (e) {
                          Logger.warn(
                            `[${model.name}] Failed to end chain of thought: ${String(e)}`
                          );
                        }
                        currentThinkingId = null;
                      }
                      if (choice.finish_reason === "tool_calls") {
                        let toolProcessed = false;
                        for (const [
                          toolIndex,
                          bufferedTool
                        ] of toolCallsBuffer.entries()) {
                          if (bufferedTool.name && bufferedTool.arguments) {
                            try {
                              const args = JSON.parse(bufferedTool.arguments);
                              const toolCallId = bufferedTool.id || `tool_${Date.now()}_${toolIndex}`;
                              progress.report(
                                new vscode36.LanguageModelToolCallPart(
                                  toolCallId,
                                  bufferedTool.name,
                                  args
                                )
                              );
                              Logger.info(
                                `[${model.name}] Successfully processed tool call: ${bufferedTool.name}, args: ${bufferedTool.arguments}`
                              );
                              toolProcessed = true;
                            } catch (error2) {
                              Logger.error(
                                `[${model.name}] Unable to parse tool call parameters: ${bufferedTool.name}, args: ${bufferedTool.arguments}, error: ${error2}`
                              );
                            }
                          } else {
                            Logger.warn(
                              `[${model.name}] Incomplete tool call [${toolIndex}]: name=${bufferedTool.name}, args_length=${bufferedTool.arguments.length}`
                            );
                          }
                        }
                        if (toolProcessed) {
                          hasContent = true;
                          Logger.trace(
                            `[${model.name}] Tool call processed, marked as content received`
                          );
                        }
                      } else if (choice.finish_reason === "stop") {
                        if (!hasContent) {
                          Logger.trace(
                            `[${model.name}] finish_reason=stop, no text content received`
                          );
                        }
                      }
                    }
                  }
                }
                if (hasContent) {
                  hasReceivedContent = true;
                }
              } catch (error2) {
                Logger.error(
                  `[${model.name}] Failed to parse JSON: ${data}`,
                  error2
                );
              }
            }
          }
        }
      } finally {
        reader.releaseLock();
      }
      Logger.trace(
        `[${model.name}] SSE stream processing statistics: ${chunkCount} chunks, hasReceivedContent=${hasReceivedContent}`
      );
      Logger.debug(`[${model.name}] Stream processing complete`);
      let promptTokens = finalUsage?.prompt_tokens;
      let completionTokens = finalUsage?.completion_tokens;
      let totalTokens = finalUsage?.total_tokens;
      let estimatedPromptTokens = false;
      if (promptTokens === void 0) {
        try {
          promptTokens = await TokenCounter.getInstance().countMessagesTokens(
            model,
            [...messages],
            { sdkMode: modelConfig.sdkMode || "openai" },
            options
          );
          completionTokens = 0;
          totalTokens = promptTokens;
          estimatedPromptTokens = true;
        } catch (e) {
          Logger.trace(
            `[${model.name}] Failed to estimate prompt tokens in custom SSE mode: ${String(e)}`
          );
        }
      }
      if (promptTokens !== void 0 && completionTokens !== void 0) {
        TokenTelemetryTracker.getInstance().recordSuccess({
          modelId: model.id,
          modelName: model.name,
          providerId: this.providerKey,
          promptTokens,
          completionTokens,
          totalTokens,
          maxInputTokens: model.maxInputTokens,
          maxOutputTokens: model.maxOutputTokens,
          estimatedPromptTokens
        });
      }
      if (hasThinkingContent && !hasReceivedContent) {
        progress.report(new vscode36.LanguageModelTextPart("<think/>"));
        Logger.warn(
          `[${model.name}] End of message stream has only thinking content and no text content, added <think/> placeholder as output`
        );
      }
      Logger.debug(`[${model.name}] API request complete`);
    } catch (error2) {
      if (error2 instanceof Error && error2.name === "AbortError") {
        Logger.warn(`[${model.name}] User cancelled request`);
        throw new vscode36.CancellationError();
      }
      throw error2;
    } finally {
      cancellationListener.dispose();
    }
  }
  /**
   * Register commands
   */
  static registerCommands(context) {
    const disposables = [];
    disposables.push(
      vscode36.commands.registerCommand(
        "chp.compatible.manageModels",
        async () => {
          try {
            await CompatibleModelManager.configureModelOrUpdateAPIKey();
          } catch (error2) {
            Logger.error("Failed to manage Compatible models:", error2);
            vscode36.window.showErrorMessage(
              `Failed to manage models: ${error2 instanceof Error ? error2.message : "Unknown error"}`
            );
          }
        }
      )
    );
    for (const disposable of disposables) {
      context.subscriptions.push(disposable);
    }
    Logger.debug("Compatible Provider commands registered");
    return disposables;
  }
  /**
   * Static factory method - Create and activate provider
   */
  static createAndActivate(context) {
    Logger.trace("Compatible Provider activated!");
    const provider = new _CompatibleProvider(context);
    const providerDisposable = vscode36.lm.registerLanguageModelChatProvider(
      "chp.compatible",
      provider
    );
    const commandDisposables = _CompatibleProvider.registerCommands(context);
    const disposables = [providerDisposable, ...commandDisposables];
    for (const disposable of disposables) {
      context.subscriptions.push(disposable);
    }
    return { provider, disposables };
  }
};

// src/providers/deepinfra/deepinfraProvider.ts
var vscode37 = __toESM(require("vscode"));
var DeepInfraProvider = class _DeepInfraProvider extends GenericModelProvider {
  userAgent;
  clientCache = /* @__PURE__ */ new Map();
  constructor(context, providerKey, providerConfig, userAgent) {
    super(context, providerKey, providerConfig);
    this.userAgent = userAgent;
  }
  /**
   * Override refreshHandlers to also clear the OpenAI client cache
   * This ensures that when baseUrl changes, new clients are created with the correct URL
   */
  refreshHandlers() {
    if (this.clientCache && this.clientCache.size > 0) {
      Logger.debug(`[DeepInfra] Clearing ${this.clientCache.size} cached OpenAI clients due to config change`);
      this.clientCache.clear();
    }
    super.refreshHandlers();
  }
  async ensureApiKey(silent) {
    let apiKey = await ApiKeyManager.getApiKey(this.providerKey);
    if (!apiKey && !silent) {
      await ApiKeyManager.promptAndSetApiKey(
        this.providerKey,
        this.providerConfig.displayName,
        this.providerConfig.apiKeyTemplate
      );
      apiKey = await ApiKeyManager.getApiKey(this.providerKey);
    }
    return apiKey;
  }
  async fetchModels(apiKey) {
    try {
      const baseUrl = this.providerConfig.baseUrl || "https://api.deepinfra.com/v1/openai";
      const modelsUrl = `${baseUrl}/models`;
      Logger.debug(`[DeepInfra] Fetching models from: ${modelsUrl}`);
      const abortController = new AbortController();
      const timeoutId = setTimeout(() => abortController.abort(), 1e4);
      try {
        const resp = await fetch(modelsUrl, {
          method: "GET",
          headers: {
            Authorization: `Bearer ${apiKey}`,
            "User-Agent": this.userAgent
          },
          signal: abortController.signal
        });
        clearTimeout(timeoutId);
        if (!resp.ok) {
          const text = await resp.text();
          Logger.warn(
            `[DeepInfra] Failed to fetch models: ${resp.status} ${resp.statusText}`
          );
          if (resp.status === 429) {
            Logger.warn(
              "[DeepInfra] Rate limited (429). Will retry with pre-configured models."
            );
          }
          return [];
        }
        const parsed = await resp.json();
        const models = parsed.data || [];
        Logger.info(`[DeepInfra] Successfully fetched ${models.length} models`);
        return models;
      } catch (fetchError) {
        clearTimeout(timeoutId);
        if (fetchError instanceof Error && fetchError.name === "AbortError") {
          Logger.warn(
            "[DeepInfra] Model fetch timeout (10s). Using pre-configured models."
          );
        } else {
          Logger.warn(
            `[DeepInfra] Model fetch failed: ${fetchError instanceof Error ? fetchError.message : String(fetchError)}. Using pre-configured models.`
          );
        }
        return [];
      }
    } catch (err) {
      Logger.warn(
        "[DeepInfra] Error in fetchModels:",
        err instanceof Error ? err.message : String(err)
      );
      return [];
    }
  }
  async prepareLanguageModelChatInformation(options, _token) {
    const apiKey = await this.ensureApiKey(options.silent ?? true);
    if (!apiKey) {
      return [];
    }
    let models = await this.fetchModels(apiKey);
    if (!models || models.length === 0) {
      Logger.info(
        "[DeepInfra] No models from API, using pre-configured models from config"
      );
      const preConfiguredModels = this.providerConfig.models.map(
        (m) => ({
          id: m.id,
          object: "model",
          created: 0,
          owned_by: "deepinfra",
          metadata: {
            description: m.tooltip || "",
            context_length: m.maxInputTokens || 128e3,
            max_tokens: m.maxOutputTokens || 16e3
          }
        })
      );
      models = preConfiguredModels;
    }
    const filteredModels = models.filter(
      (m) => m.metadata && typeof m.metadata.max_tokens === "number" && typeof m.metadata.context_length === "number"
    );
    const infos = filteredModels.map((m) => {
      const metadata = m.metadata;
      const vision = metadata.tags?.includes("vision") ?? false;
      const capabilities = {
        toolCalling: true,
        imageInput: vision
      };
      const maxOutput = 16e3;
      const maxInput = metadata.max_tokens || 128e3;
      return {
        id: m.id,
        name: m.id,
        tooltip: metadata.description || `DeepInfra model: ${m.id}`,
        family: "deepinfra",
        version: "1.0.0",
        maxInputTokens: maxInput,
        maxOutputTokens: maxOutput,
        capabilities
      };
    });
    const dedupedInfos = this.dedupeModelInfos(infos);
    this._chatEndpoints = dedupedInfos.map((info) => ({
      model: info.id,
      modelMaxPromptTokens: info.maxInputTokens + info.maxOutputTokens
    }));
    return dedupedInfos;
  }
  async provideLanguageModelChatInformation(options, _token) {
    try {
      const apiKeyHash = await this.getApiKeyHash();
      const cachedModels = await this.modelInfoCache?.getCachedModels(
        this.providerKey,
        apiKeyHash
      );
      if (cachedModels) {
        this.prepareLanguageModelChatInformation(options, _token).then((models2) => {
          this.modelInfoCache?.cacheModels(
            this.providerKey,
            models2,
            apiKeyHash
          );
        }).catch(() => {
        });
        return cachedModels;
      }
      const models = await this.prepareLanguageModelChatInformation(
        options,
        _token
      );
      if (models.length > 0) {
        await this.modelInfoCache?.cacheModels(
          this.providerKey,
          models,
          apiKeyHash
        );
      }
      return models;
    } catch (error2) {
      Logger.error("[DeepInfra] Failed to provide model info", error2);
      return [];
    }
  }
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(`${providerConfig.displayName} provider activated!`);
    const ext = vscode37.extensions.getExtension("OEvortex.better-copilot-chat");
    const extVersion = ext?.packageJSON?.version ?? "unknown";
    const vscodeVersion = vscode37.version;
    const ua = `better-copilot-chat/${extVersion} VSCode/${vscodeVersion}`;
    const provider = new _DeepInfraProvider(
      context,
      providerKey,
      providerConfig,
      ua
    );
    const providerDisposable = vscode37.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const setApiKeyCommand = vscode37.commands.registerCommand(
      `chp.${providerKey}.setApiKey`,
      async () => {
        await ProviderWizard.startWizard({
          providerKey,
          displayName: providerConfig.displayName,
          apiKeyTemplate: providerConfig.apiKeyTemplate,
          supportsApiKey: true,
          supportsBaseUrl: true
        });
        await provider.modelInfoCache?.invalidateCache(providerKey);
        provider._onDidChangeLanguageModelChatInformation.fire();
      }
    );
    const disposables = [
      providerDisposable,
      setApiKeyCommand
    ];
    for (const d of disposables) {
      context.subscriptions.push(d);
    }
    return { provider, disposables };
  }
  async createOpenAIClient(apiKey) {
    const baseURL = this.providerConfig.baseUrl || "https://api.deepinfra.com/v1/openai";
    Logger.info(`[DeepInfra] Creating OpenAI client with baseURL: ${baseURL}`);
    const cacheKey = `deepinfra:${apiKey}:${baseURL}`;
    const cached2 = this.clientCache.get(cacheKey);
    if (cached2) {
      cached2.lastUsed = Date.now();
      Logger.debug(`[DeepInfra] Using cached client for baseURL: ${baseURL}`);
      return cached2.client;
    }
    const client = new OpenAI({
      apiKey,
      baseURL,
      defaultHeaders: {
        "User-Agent": this.userAgent
      },
      maxRetries: 2,
      timeout: 6e4
    });
    this.clientCache.set(cacheKey, { client, lastUsed: Date.now() });
    Logger.info(`[DeepInfra] Created new OpenAI client for baseURL: ${baseURL}`);
    return client;
  }
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    await RateLimiter.getInstance(this.providerKey, 2, 1e3).throttle(
      this.providerConfig.displayName
    );
    try {
      Logger.info(`[DeepInfra] Starting request for model: ${model.name}`);
      const apiKey = await this.ensureApiKey(true);
      if (!apiKey) {
        throw new Error("DeepInfra API key not found");
      }
      const client = await this.createOpenAIClient(apiKey);
      const modelConfig = this.providerConfig.models.find(
        (m) => m.id === model.id
      );
      const openaiMessages = this.openaiHandler.convertMessagesToOpenAI(
        messages,
        model.capabilities || void 0,
        modelConfig
      );
      const createParams = {
        model: model.id,
        messages: openaiMessages,
        stream: true,
        stream_options: { include_usage: true },
        max_tokens: Math.min(
          options.modelOptions?.max_tokens || 4096,
          model.maxOutputTokens
        ),
        temperature: options.modelOptions?.temperature ?? ConfigManager.getTemperature(),
        top_p: ConfigManager.getTopP()
      };
      if (options.tools && options.tools.length > 0 && model.capabilities?.toolCalling) {
        createParams.tools = this.openaiHandler.convertToolsToOpenAI([
          ...options.tools
        ]);
        createParams.tool_choice = "auto";
      }
      const abortController = new AbortController();
      token.onCancellationRequested(() => abortController.abort());
      const stream = client.chat.completions.stream(createParams, {
        signal: abortController.signal
      });
      let currentThinkingId = null;
      let thinkingContentBuffer = "";
      let hasReceivedContent = false;
      let hasThinkingContent = false;
      const toolCallIds = /* @__PURE__ */ new Map();
      stream.on("chunk", (chunk) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (chunk.choices && chunk.choices.length > 0) {
          for (const choice of chunk.choices) {
            if (choice.delta?.tool_calls) {
              for (const toolCall of choice.delta.tool_calls) {
                if (toolCall.id && toolCall.index !== void 0) {
                  toolCallIds.set(toolCall.index, toolCall.id);
                }
              }
            }
            const delta = choice.delta;
            if (delta?.reasoning_content) {
              if (!currentThinkingId) {
                currentThinkingId = `di_thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
              }
              thinkingContentBuffer += delta.reasoning_content;
              progress.report(
                new vscode37.LanguageModelThinkingPart(
                  thinkingContentBuffer,
                  currentThinkingId
                )
              );
              thinkingContentBuffer = "";
              hasThinkingContent = true;
            }
          }
        }
      });
      stream.on("content", (delta) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (delta) {
          if (currentThinkingId) {
            progress.report(
              new vscode37.LanguageModelThinkingPart(
                "",
                currentThinkingId
              )
            );
            currentThinkingId = null;
          }
          progress.report(new vscode37.LanguageModelTextPart(delta));
          if (delta.trim().length > 0) {
            hasReceivedContent = true;
          }
        }
      });
      stream.on("tool_calls.function.arguments.done", (event) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (currentThinkingId) {
          try {
            progress.report(
              new vscode37.LanguageModelThinkingPart(
                "",
                currentThinkingId
              )
            );
          } catch {
          }
          currentThinkingId = null;
        }
        const toolCallId = toolCallIds.get(event.index) || `tool_call_${event.index}_${Date.now()}`;
        let parsedArgs = {};
        if (event.parsed_arguments) {
          const result = event.parsed_arguments;
          parsedArgs = typeof result === "object" && result !== null ? result : {};
        } else {
          try {
            parsedArgs = JSON.parse(event.arguments || "{}");
          } catch {
            parsedArgs = { value: event.arguments };
          }
        }
        try {
          progress.report(
            new vscode37.LanguageModelToolCallPart(
              toolCallId,
              event.name,
              parsedArgs
            )
          );
          hasReceivedContent = true;
        } catch (e) {
          Logger.warn(
            "[DeepInfra] Failed to report tool call",
            e instanceof Error ? e.message : String(e)
          );
        }
      });
      await stream.finalChatCompletion();
      if (currentThinkingId) {
        progress.report(
          new vscode37.LanguageModelThinkingPart(
            "",
            currentThinkingId
          )
        );
      }
      if (hasThinkingContent && !hasReceivedContent) {
        progress.report(new vscode37.LanguageModelTextPart("<think/>"));
        Logger.warn(
          "[DeepInfra] End of message stream has only thinking content and no text content, added <think/> placeholder as output"
        );
      }
    } catch (error2) {
      Logger.error(
        `[DeepInfra] Request failed: ${error2 instanceof Error ? error2.message : String(error2)}`
      );
      throw error2;
    }
  }
  async provideTokenCount(model, text, _token) {
    return TokenCounter.getInstance().countTokens(model, text);
  }
};

// src/providers/geminicli/provider.ts
var vscode40 = __toESM(require("vscode"));
init_logger();

// src/providers/geminicli/auth.ts
var fs2 = __toESM(require("node:fs"));
var os = __toESM(require("node:os"));
var path4 = __toESM(require("node:path"));
init_logger();

// src/providers/geminicli/types.ts
var GEMINI_OAUTH_CLIENT_ID = "681255809395-oo8ft2oprdrnp9e3aqf6av3hmdib135j.apps.googleusercontent.com";
var GEMINI_OAUTH_CLIENT_SECRET = "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";
var GEMINI_OAUTH_TOKEN_ENDPOINT = "https://accounts.google.com/o/oauth2/token";
var GEMINI_DEFAULT_BASE_URL = "https://cloudcode-pa.googleapis.com/v1internal";
var TOKEN_REFRESH_BUFFER_MS = 5 * 60 * 1e3;
var GEMINI_OAUTH_SCOPES = [
  "https://www.googleapis.com/auth/cloud-platform",
  "https://www.googleapis.com/auth/userinfo.email",
  "https://www.googleapis.com/auth/userinfo.profile"
];

// src/providers/geminicli/auth.ts
var GeminiOAuthManager = class _GeminiOAuthManager {
  static instance;
  credentials = null;
  refreshTimer = null;
  refreshLock = false;
  constructor() {
    this.startProactiveRefresh();
  }
  static getInstance() {
    if (!_GeminiOAuthManager.instance) {
      _GeminiOAuthManager.instance = new _GeminiOAuthManager();
    }
    return _GeminiOAuthManager.instance;
  }
  startProactiveRefresh() {
    if (this.refreshTimer) {
      clearInterval(this.refreshTimer);
    }
    this.refreshTimer = setInterval(async () => {
      try {
        if (this.credentials && !this.isTokenValid(this.credentials)) {
          Logger.debug("Gemini CLI: Proactive token refresh triggered");
          await this.refreshAccessToken(this.credentials);
        }
      } catch (error2) {
        Logger.trace(`Gemini CLI: Proactive refresh failed: ${error2}`);
      }
    }, 3e4);
  }
  getCredentialPath() {
    const credentialPath = path4.join(
      os.homedir(),
      ".gemini",
      "oauth_creds.json"
    );
    return path4.normalize(credentialPath);
  }
  loadCachedCredentials() {
    const keyFile = this.getCredentialPath();
    Logger.debug(`Gemini CLI: Checking credentials at: ${keyFile}`);
    Logger.debug(`Gemini CLI: File exists: ${fs2.existsSync(keyFile)}`);
    try {
      if (!fs2.existsSync(keyFile)) {
        throw new Error(
          `Gemini OAuth credentials not found at ${keyFile}. Please login using the Gemini CLI first: gemini auth login`
        );
      }
      const data = JSON.parse(fs2.readFileSync(keyFile, "utf-8"));
      return {
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        token_type: data.token_type || "Bearer",
        expiry_date: data.expiry_date
      };
    } catch (error2) {
      if (error2 instanceof Error) {
        throw error2;
      }
      throw new Error("Invalid Gemini OAuth credentials file");
    }
  }
  async refreshAccessToken(credentials) {
    if (this.refreshLock) {
      while (this.refreshLock) {
        await new Promise((resolve) => setTimeout(resolve, 100));
      }
      return this.credentials || credentials;
    }
    this.refreshLock = true;
    try {
      if (!credentials.refresh_token) {
        throw new Error("No refresh token available in credentials.");
      }
      const bodyData = new URLSearchParams();
      bodyData.set("grant_type", "refresh_token");
      bodyData.set("refresh_token", credentials.refresh_token);
      bodyData.set("client_id", GEMINI_OAUTH_CLIENT_ID);
      bodyData.set("client_secret", GEMINI_OAUTH_CLIENT_SECRET);
      bodyData.set("scope", GEMINI_OAUTH_SCOPES.join(" "));
      const response = await fetch(GEMINI_OAUTH_TOKEN_ENDPOINT, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded",
          Accept: "application/json",
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
        },
        body: bodyData.toString()
      });
      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(
          `Token refresh failed: ${response.status} ${response.statusText}. Response: ${errorText}`
        );
      }
      const tokenData = await response.json();
      if (tokenData.error) {
        throw new Error(
          `Token refresh failed: ${tokenData.error} - ${tokenData.error_description || "Unknown error"}`
        );
      }
      const newCredentials = {
        access_token: tokenData.access_token,
        token_type: tokenData.token_type || "Bearer",
        refresh_token: tokenData.refresh_token || credentials.refresh_token,
        expiry_date: Date.now() + tokenData.expires_in * 1e3
      };
      this.saveCredentials(newCredentials);
      this.credentials = newCredentials;
      return newCredentials;
    } finally {
      this.refreshLock = false;
    }
  }
  saveCredentials(credentials) {
    const filePath = this.getCredentialPath();
    try {
      const dir = path4.dirname(filePath);
      if (!fs2.existsSync(dir)) {
        fs2.mkdirSync(dir, { recursive: true });
      }
      fs2.writeFileSync(filePath, JSON.stringify(credentials, null, 2), "utf-8");
    } catch (error2) {
      Logger.warn(`Failed to save refreshed credentials: ${error2}`);
    }
  }
  isTokenValid(credentials) {
    if (!credentials.expiry_date) {
      return false;
    }
    return Date.now() < credentials.expiry_date - TOKEN_REFRESH_BUFFER_MS;
  }
  async ensureAuthenticated(forceRefresh = false) {
    this.credentials = this.loadCachedCredentials();
    if (forceRefresh || !this.isTokenValid(this.credentials)) {
      this.credentials = await this.refreshAccessToken(this.credentials);
    }
    return {
      accessToken: this.credentials.access_token,
      baseURL: this.getBaseURL()
    };
  }
  invalidateCredentials() {
    this.credentials = null;
  }
  getBaseURL() {
    return GEMINI_DEFAULT_BASE_URL;
  }
  async getAccessToken() {
    const { accessToken } = await this.ensureAuthenticated();
    return accessToken;
  }
  async getBaseURLAsync() {
    const { baseURL } = await this.ensureAuthenticated();
    return baseURL;
  }
  async forceRefresh() {
    return await this.ensureAuthenticated(true);
  }
};

// src/providers/geminicli/handler.ts
var import_node_crypto3 = __toESM(require("node:crypto"));
var vscode39 = __toESM(require("vscode"));
init_accountQuotaCache();
init_configManager();
init_logger();

// src/providers/geminicli/streamProcessor.ts
var vscode38 = __toESM(require("vscode"));
var GeminiStreamProcessor = class _GeminiStreamProcessor {
  textBuffer = "";
  textBufferLastFlush = 0;
  thinkingBuffer = "";
  currentThinkingId = null;
  seenToolCalls = /* @__PURE__ */ new Set();
  toolCallCounter = 0;
  isInsideThinkingTag = false;
  thinkingTagBuffer = "";
  sseDataParts = [];
  CLOSING_TAG = "</thinking>";
  thinkingQueue = "";
  thinkingFlushInterval = null;
  thinkingProgress = null;
  chunkCounter = 0;
  lastChunkTime = 0;
  streamVelocity = 0;
  // Function calls buffer to support XML-style <function_calls> blocks split across parts/chunks
  functionCallsBuffer = "";
  // Activity tracking to keep UI "alive" when processing tool calls
  lastActivityReportTime = 0;
  activityReportInterval = null;
  pendingToolCalls = [];
  toolCallFlushInterval = null;
  static THINKING_FLUSH_INTERVAL_MS = 80;
  static THINKING_CHARS_PER_FLUSH = 150;
  static ACTIVITY_REPORT_INTERVAL_MS = 400;
  // Decreased for more frequent reporting
  static TEXT_BUFFER_MIN_SIZE = 40;
  static TEXT_BUFFER_MAX_DELAY_MS = 25;
  static YIELD_EVERY_N_CHUNKS = 5;
  static HIGH_VELOCITY_THRESHOLD = 10;
  static ADAPTIVE_BUFFER_MULTIPLIER = 0.5;
  static TOOL_CALL_FLUSH_DELAY_MS = 50;
  // Small delay before flushing tool calls
  async processStream(options) {
    const { response, modelConfig, progress, token } = options;
    if (!response.body) {
      throw new Error("Gemini response body is empty.");
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    this.startActivityReporting(progress);
    try {
      while (true) {
        if (token.isCancellationRequested) {
          throw new vscode38.CancellationError();
        }
        const { done, value } = await reader.read();
        if (done) {
          break;
        }
        const now = performance.now();
        if (this.lastChunkTime > 0) {
          const delta = now - this.lastChunkTime;
          this.streamVelocity = delta > 0 ? value.length / delta : this.streamVelocity;
        }
        this.lastChunkTime = now;
        buffer += decoder.decode(value, { stream: true });
        buffer = buffer.replace(/\r\n/g, "\n");
        buffer = this.processSSELines(buffer, modelConfig, progress);
        this.flushTextBufferAdaptive(progress);
        this.flushThinkingBufferIfNeeded(progress);
        this.schedulePendingToolCallsFlush(progress);
        this.chunkCounter++;
        if (this.chunkCounter % _GeminiStreamProcessor.YIELD_EVERY_N_CHUNKS === 0) {
          await new Promise((resolve) => setTimeout(resolve, 1));
        }
      }
    } finally {
      console.log(
        `GeminiCLI: Stream processing complete, pending tool calls: ${this.pendingToolCalls.length}`
      );
      this.stopActivityReporting();
      this.processRemainingBuffer(buffer, modelConfig, progress);
      this.flushTextBuffer(progress, true);
      this.flushPendingToolCallsImmediate(progress);
      this.finalizeThinkingPart(progress);
      console.log(
        `GeminiCLI: Final pending tool calls after cleanup: ${this.pendingToolCalls.length}`
      );
    }
  }
  /**
   * Start periodic activity reporting to keep UI displaying "Working..."
   */
  startActivityReporting(progress) {
    if (this.activityReportInterval) {
      return;
    }
    this.lastActivityReportTime = Date.now();
    this.activityReportInterval = setInterval(() => {
      const now = Date.now();
      const timeSinceLastActivity = now - this.lastActivityReportTime;
      if (timeSinceLastActivity >= _GeminiStreamProcessor.ACTIVITY_REPORT_INTERVAL_MS) {
        if (this.thinkingBuffer.length > 0) {
          this.flushThinkingBuffer(progress);
        } else if (this.textBuffer.length > 0) {
          this.flushTextBuffer(progress, true);
        }
        this.lastActivityReportTime = now;
      }
    }, _GeminiStreamProcessor.ACTIVITY_REPORT_INTERVAL_MS / 2);
  }
  /**
   * Stop activity reporting
   */
  stopActivityReporting() {
    if (this.activityReportInterval) {
      clearInterval(this.activityReportInterval);
      this.activityReportInterval = null;
    }
    if (this.toolCallFlushInterval) {
      clearInterval(this.toolCallFlushInterval);
      this.toolCallFlushInterval = null;
    }
  }
  /**
   * Mark activity to reset timer
   */
  markActivity() {
    this.lastActivityReportTime = Date.now();
  }
  /**
   * Schedule flush pending tool calls with small delay
   */
  schedulePendingToolCallsFlush(progress) {
    if (this.pendingToolCalls.length === 0 || this.toolCallFlushInterval) {
      return;
    }
    this.toolCallFlushInterval = setTimeout(() => {
      this.flushPendingToolCallsImmediate(progress);
      this.toolCallFlushInterval = null;
    }, _GeminiStreamProcessor.TOOL_CALL_FLUSH_DELAY_MS);
  }
  /**
   * Flush all pending tool calls immediately
   */
  flushPendingToolCallsImmediate(progress) {
    console.log(
      `GeminiCLI: flushPendingToolCallsImmediate called, pending count: ${this.pendingToolCalls.length}`
    );
    while (this.pendingToolCalls.length > 0) {
      const toolCall = this.pendingToolCalls.shift();
      if (toolCall) {
        console.log(
          `GeminiCLI: Reporting tool call: ${toolCall.callId}, name: ${toolCall.name}`
        );
        progress.report(
          new vscode38.LanguageModelToolCallPart(
            toolCall.callId,
            toolCall.name,
            toolCall.args
          )
        );
        this.markActivity();
      }
    }
    console.log("GeminiCLI: All pending tool calls flushed");
  }
  processSSELines(buffer, modelConfig, progress) {
    let lineEndIndex = buffer.indexOf("\n");
    let linesProcessed = 0;
    while (lineEndIndex !== -1) {
      const line = buffer.slice(0, lineEndIndex).trimEnd();
      buffer = buffer.slice(lineEndIndex + 1);
      linesProcessed++;
      if (line.length === 0) {
        console.log(
          `GeminiCLI: Empty line, processing SSE event, sseDataParts count: ${this.sseDataParts.length}`
        );
        this.processSSEEvent(modelConfig, progress);
        lineEndIndex = buffer.indexOf("\n");
        continue;
      }
      if (line.startsWith("data:")) {
        const dataLine = line.slice(5);
        if (dataLine.trim() === "[DONE]") {
          console.log("GeminiCLI: Received [DONE] signal");
          this.sseDataParts = [];
          lineEndIndex = buffer.indexOf("\n");
          continue;
        }
        if (dataLine.length > 0) {
          this.sseDataParts.push(dataLine.trimStart());
          console.log(
            `GeminiCLI: Added data line, sseDataParts count: ${this.sseDataParts.length}`
          );
        }
      }
      lineEndIndex = buffer.indexOf("\n");
    }
    if (linesProcessed > 0) {
      console.log(
        `GeminiCLI: Processed ${linesProcessed} SSE lines, buffer remaining: "${buffer.substring(0, 50)}..."`
      );
    }
    return buffer;
  }
  processSSEEvent(modelConfig, progress) {
    if (this.sseDataParts.length === 0) {
      return;
    }
    const eventData = this.sseDataParts.join("\n").trim();
    this.sseDataParts = [];
    if (!eventData || eventData === "[DONE]") {
      console.log("GeminiCLI: SSE event is empty or [DONE]");
      return;
    }
    console.log(
      `GeminiCLI: Processing SSE event, data length: ${eventData.length}`
    );
    const createCallId = () => `tool_call_${this.toolCallCounter++}_${Date.now()}`;
    try {
      this.handleStreamPayload(eventData, createCallId, modelConfig, progress);
      this.flushTextBufferIfNeeded(progress);
      this.flushThinkingBufferIfNeeded(progress);
    } catch (error2) {
      console.error("GeminiCLI: Error in handleStreamPayload:", error2);
      if (error2 instanceof SyntaxError && String(error2.message).includes("after JSON")) {
        console.log("GeminiCLI: Attempting to split concatenated JSON");
        const jsonObjects = this.splitConcatenatedJSON(eventData);
        console.log(`GeminiCLI: Found ${jsonObjects.length} JSON objects`);
        for (const jsonStr of jsonObjects) {
          try {
            this.handleStreamPayload(
              jsonStr,
              createCallId,
              modelConfig,
              progress
            );
          } catch (innerError) {
            console.error(
              "GeminiCLI: Error processing JSON object:",
              innerError
            );
          }
        }
      }
    }
  }
  processRemainingBuffer(buffer, modelConfig, progress) {
    const trailing = buffer.trim();
    console.log(
      `GeminiCLI: processRemainingBuffer, trailing: "${trailing.substring(0, 100)}..."`
    );
    if (trailing.length > 0 && trailing.startsWith("data:")) {
      this.sseDataParts.push(trailing.slice(5).trimStart());
      console.log(
        `GeminiCLI: Added trailing data to sseDataParts, count: ${this.sseDataParts.length}`
      );
    }
    if (this.sseDataParts.length > 0) {
      const eventData = this.sseDataParts.join("\n").trim();
      console.log(
        `GeminiCLI: Processing remaining SSE data, length: ${eventData.length}`
      );
      if (eventData && eventData !== "[DONE]") {
        const createCallId = () => `tool_call_${this.toolCallCounter++}_${Date.now()}`;
        try {
          this.handleStreamPayload(
            eventData,
            createCallId,
            modelConfig,
            progress
          );
        } catch (error2) {
          console.error("GeminiCLI: Error processing remaining buffer:", error2);
        }
      }
    }
  }
  handleStreamPayload(data, createCallId, modelConfig, progress) {
    console.log(`GeminiCLI: Parsing JSON payload, length: ${data.length}`);
    let parsed;
    try {
      parsed = JSON.parse(data);
      console.log("GeminiCLI: JSON parsed successfully");
    } catch (error2) {
      console.error("GeminiCLI: Failed to parse JSON:", error2);
      throw error2;
    }
    const payload = parsed.response || parsed;
    const candidates = payload.candidates || [];
    console.log(`GeminiCLI: Found ${candidates.length} candidates`);
    for (const candidate of candidates) {
      const content = candidate.content;
      if (!content?.parts) {
        console.log("GeminiCLI: No content or parts in candidate");
        continue;
      }
      console.log(`GeminiCLI: Processing ${content.parts.length} parts`);
      for (const part of content.parts) {
        this.handlePart(part, createCallId, modelConfig, progress);
      }
    }
  }
  handlePart(part, createCallId, modelConfig, progress) {
    console.log("GeminiCLI: Received part:", JSON.stringify(part, null, 2));
    const hasFunctionCall = !!part.functionCall;
    const hasText = typeof part.text === "string";
    const hasThought = part.thought === true;
    console.log(
      `GeminiCLI: Part has functionCall=${hasFunctionCall}, text=${hasText}, thought=${hasThought}`
    );
    if (part.thought === true) {
      if (modelConfig.outputThinking !== false && typeof part.text === "string") {
        if (!this.currentThinkingId) {
          this.currentThinkingId = createCallId();
        }
        console.log("GeminiCLI: Received thought part:", part.text);
        this.thinkingBuffer += part.text;
        this.flushThinkingBufferIfNeeded(progress);
      }
      return;
    }
    if (typeof part.text === "string") {
      const textToProcess = this.functionCallsBuffer + part.text;
      const funcCallsRegex = /<function_calls>[\s\S]*?<\/function_calls>/g;
      let lastIndex = 0;
      let match = funcCallsRegex.exec(textToProcess);
      while (match !== null) {
        const before = textToProcess.slice(lastIndex, match.index);
        if (before.length > 0) {
          const processedText = this.processTextWithThinkingTags(
            before,
            modelConfig
          );
          if (this.isInsideThinkingTag) {
            this.flushThinkingBufferIfNeeded(progress);
          } else {
            this.finalizeThinkingPart(progress);
            if (processedText.length > 0) {
              this.textBuffer += processedText;
              this.flushTextBufferIfNeeded(progress);
            }
          }
        }
        const block = match[0];
        const toolCallRegex = /<tool_call\s+name="([^"]+)"\s+arguments='([^']*)'\s*\/>/g;
        let toolMatch = toolCallRegex.exec(block);
        this.flushTextBuffer(progress, true);
        this.flushThinkingBuffer(progress);
        while (toolMatch !== null) {
          const name = toolMatch[1];
          const argsString = toolMatch[2] || "";
          let argsObj = {};
          try {
            argsObj = JSON.parse(argsString);
          } catch {
            argsObj = { value: argsString };
          }
          const callId = createCallId();
          const dedupeKey = `${callId}:${name}`;
          if (!this.seenToolCalls.has(dedupeKey)) {
            this.seenToolCalls.add(dedupeKey);
            this.pendingToolCalls.push({ callId, name, args: argsObj });
            this.markActivity();
          }
          toolMatch = toolCallRegex.exec(block);
        }
        lastIndex = funcCallsRegex.lastIndex;
        match = funcCallsRegex.exec(textToProcess);
      }
      const remaining = textToProcess.slice(lastIndex);
      const openStart = remaining.indexOf("<function_calls>");
      const closeEnd = remaining.indexOf("</function_calls>");
      if (openStart !== -1 && closeEnd === -1) {
        this.functionCallsBuffer = remaining.slice(openStart);
        const beforeOpen = remaining.slice(0, openStart);
        if (beforeOpen.length > 0) {
          const processedText = this.processTextWithThinkingTags(
            beforeOpen,
            modelConfig
          );
          if (this.isInsideThinkingTag) {
            this.flushThinkingBufferIfNeeded(progress);
          } else {
            this.finalizeThinkingPart(progress);
            if (processedText.length > 0) {
              this.textBuffer += processedText;
              this.flushTextBufferIfNeeded(progress);
            }
          }
        }
      } else {
        this.functionCallsBuffer = "";
        if (remaining.length > 0) {
          const processedText = this.processTextWithThinkingTags(
            remaining,
            modelConfig
          );
          if (this.isInsideThinkingTag) {
            this.flushThinkingBufferIfNeeded(progress);
          } else {
            this.finalizeThinkingPart(progress);
            if (processedText.length > 0) {
              this.textBuffer += processedText;
              this.flushTextBufferIfNeeded(progress);
            }
          }
        }
      }
    }
    const functionCall = part.functionCall;
    if (functionCall?.name) {
      console.log(
        `GeminiCLI: Processing functionCall: name=${functionCall.name}, id=${functionCall.id || "generated"}`
      );
      this.flushTextBuffer(progress, true);
      this.flushThinkingBuffer(progress);
      const toolCallInfo = extractToolCallFromGeminiResponse2(part);
      console.log(
        `GeminiCLI: Extracted tool call info: callId=${toolCallInfo?.callId}, name=${toolCallInfo?.name}`
      );
      if (toolCallInfo?.callId && toolCallInfo.name) {
        const dedupeKey = `${toolCallInfo.callId}:${toolCallInfo.name}`;
        console.log(
          `GeminiCLI: Dedupe key: ${dedupeKey}, alreadySeen=${this.seenToolCalls.has(dedupeKey)}`
        );
        if (this.seenToolCalls.has(dedupeKey)) {
          console.log(`GeminiCLI: Skipping duplicate tool call: ${dedupeKey}`);
          return;
        }
        this.seenToolCalls.add(dedupeKey);
        console.log(`GeminiCLI: Added to seenToolCalls: ${dedupeKey}`);
        if (toolCallInfo.thoughtSignature) {
          storeThoughtSignature2(
            toolCallInfo.callId,
            toolCallInfo.thoughtSignature
          );
        }
        let normalizedArgs = {};
        if (toolCallInfo.args && typeof toolCallInfo.args === "object") {
          normalizedArgs = toolCallInfo.args;
        } else if (typeof toolCallInfo.args === "string") {
          try {
            const parsed = JSON.parse(toolCallInfo.args);
            if (parsed && typeof parsed === "object") {
              normalizedArgs = parsed;
            }
          } catch {
            normalizedArgs = { value: toolCallInfo.args };
          }
        }
        this.pendingToolCalls.push({
          callId: toolCallInfo.callId,
          name: toolCallInfo.name,
          args: normalizedArgs
        });
        this.markActivity();
        console.log(
          `GeminiCLI: Queued tool call: ${toolCallInfo.callId}, pending count: ${this.pendingToolCalls.length}`
        );
      }
    }
  }
  processTextWithThinkingTags(text, modelConfig) {
    if (modelConfig.outputThinking === false) {
      return text.replace(/<thinking>[\s\S]*?<\/thinking>/g, "");
    }
    let result = "";
    let remaining = this.thinkingTagBuffer + text;
    this.thinkingTagBuffer = "";
    while (remaining.length > 0) {
      if (this.isInsideThinkingTag) {
        const closeIdx = remaining.indexOf(this.CLOSING_TAG);
        if (closeIdx !== -1) {
          const thinkingContent = remaining.slice(0, closeIdx);
          if (thinkingContent.length > 0) {
            if (!this.currentThinkingId) {
              this.currentThinkingId = this.generateThinkingId();
            }
            this.thinkingBuffer += thinkingContent;
          }
          this.isInsideThinkingTag = false;
          remaining = remaining.slice(closeIdx + this.CLOSING_TAG.length);
        } else {
          const safeLen = Math.max(0, remaining.length - 12);
          if (safeLen > 0) {
            if (!this.currentThinkingId) {
              this.currentThinkingId = this.generateThinkingId();
            }
            this.thinkingBuffer += remaining.slice(0, safeLen);
          }
          this.thinkingTagBuffer = remaining.slice(safeLen);
          remaining = "";
        }
      } else {
        const openIdx = remaining.indexOf("<thinking>");
        if (openIdx !== -1) {
          result += remaining.slice(0, openIdx);
          this.isInsideThinkingTag = true;
          if (!this.currentThinkingId) {
            this.currentThinkingId = this.generateThinkingId();
          }
          remaining = remaining.slice(openIdx + 10);
        } else {
          const safeLen = Math.max(0, remaining.length - 10);
          result += remaining.slice(0, safeLen);
          this.thinkingTagBuffer = remaining.slice(safeLen);
          remaining = "";
        }
      }
    }
    return result;
  }
  flushTextBuffer(progress, force = false) {
    if (this.textBuffer.length > 0 && (force || this.textBuffer.length >= _GeminiStreamProcessor.TEXT_BUFFER_MIN_SIZE)) {
      progress.report(new vscode38.LanguageModelTextPart(this.textBuffer));
      this.textBuffer = "";
      this.textBufferLastFlush = Date.now();
      this.markActivity();
    }
  }
  flushTextBufferIfNeeded(progress) {
    if (this.textBuffer.length === 0) {
      return;
    }
    const timeSinceLastFlush = Date.now() - this.textBufferLastFlush;
    const shouldFlush = this.textBuffer.length >= _GeminiStreamProcessor.TEXT_BUFFER_MIN_SIZE || timeSinceLastFlush >= _GeminiStreamProcessor.TEXT_BUFFER_MAX_DELAY_MS;
    if (shouldFlush) {
      this.flushTextBuffer(progress, true);
    }
  }
  flushTextBufferAdaptive(progress) {
    if (this.textBuffer.length === 0) {
      return;
    }
    const isHighVelocity = this.streamVelocity > _GeminiStreamProcessor.HIGH_VELOCITY_THRESHOLD;
    const baseSize = _GeminiStreamProcessor.TEXT_BUFFER_MIN_SIZE;
    const baseDelay = _GeminiStreamProcessor.TEXT_BUFFER_MAX_DELAY_MS;
    const multiplier = _GeminiStreamProcessor.ADAPTIVE_BUFFER_MULTIPLIER;
    const adaptiveMinSize = isHighVelocity ? Math.floor(baseSize * multiplier) : baseSize;
    const adaptiveMaxDelay = isHighVelocity ? Math.floor(baseDelay * multiplier) : baseDelay;
    const timeSinceLastFlush = Date.now() - this.textBufferLastFlush;
    const shouldFlush = this.textBuffer.length >= adaptiveMinSize || timeSinceLastFlush >= adaptiveMaxDelay;
    if (shouldFlush) {
      this.flushTextBuffer(progress, true);
    }
  }
  flushThinkingBuffer(progress) {
    if (this.thinkingBuffer.length > 0 && this.currentThinkingId) {
      this.enqueueThinking(this.thinkingBuffer, progress);
      this.thinkingBuffer = "";
    }
  }
  flushThinkingBufferIfNeeded(progress) {
    this.flushThinkingBuffer(progress);
  }
  enqueueThinking(text, progress) {
    this.thinkingQueue += text;
    this.thinkingProgress = progress;
    this.markActivity();
    if (!this.thinkingFlushInterval) {
      this.thinkingFlushInterval = setInterval(
        () => this.flushThinkingChunk(),
        _GeminiStreamProcessor.THINKING_FLUSH_INTERVAL_MS
      );
    }
  }
  flushThinkingChunk() {
    if (this.thinkingQueue.length === 0 || !this.thinkingProgress || !this.currentThinkingId) {
      return;
    }
    const chunkSize = Math.min(
      _GeminiStreamProcessor.THINKING_CHARS_PER_FLUSH,
      this.thinkingQueue.length
    );
    const chunk = this.thinkingQueue.slice(0, chunkSize);
    this.thinkingQueue = this.thinkingQueue.slice(chunkSize);
    this.thinkingProgress.report(
      new vscode38.LanguageModelThinkingPart(chunk, this.currentThinkingId)
    );
    this.markActivity();
  }
  finalizeThinkingPart(progress) {
    if (this.thinkingFlushInterval) {
      clearInterval(this.thinkingFlushInterval);
      this.thinkingFlushInterval = null;
    }
    if (this.thinkingBuffer.length > 0) {
      this.thinkingQueue += this.thinkingBuffer;
      this.thinkingBuffer = "";
    }
    this.thinkingProgress = progress;
    while (this.thinkingQueue.length > 0) {
      const chunkSize = Math.min(
        _GeminiStreamProcessor.THINKING_CHARS_PER_FLUSH * 2,
        this.thinkingQueue.length
      );
      const chunk = this.thinkingQueue.slice(0, chunkSize);
      this.thinkingQueue = this.thinkingQueue.slice(chunkSize);
      if (this.currentThinkingId) {
        progress.report(
          new vscode38.LanguageModelThinkingPart(chunk, this.currentThinkingId)
        );
      }
    }
    if (this.currentThinkingId) {
      progress.report(
        new vscode38.LanguageModelThinkingPart("", this.currentThinkingId)
      );
      this.currentThinkingId = null;
    }
  }
  splitConcatenatedJSON(data) {
    const results = [];
    let depth = 0;
    let start = -1;
    for (let i = 0; i < data.length; i++) {
      if (data[i] === "{") {
        if (depth === 0) {
          start = i;
        }
        depth++;
      } else if (data[i] === "}") {
        depth--;
        if (depth === 0 && start !== -1) {
          results.push(data.slice(start, i + 1));
          start = -1;
        }
      }
    }
    return results;
  }
  generateThinkingId() {
    return `thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
  }
};

// src/providers/geminicli/handler.ts
var DEFAULT_BASE_URLS2 = ["https://cloudcode-pa.googleapis.com"];
var DEFAULT_USER_AGENT2 = "gemini-cli/1.0.0";
var RATE_LIMIT_MAX_RETRIES2 = 5;
var RATE_LIMIT_BASE_DELAY_MS2 = 1e3;
var RATE_LIMIT_MAX_DELAY_MS2 = 3e4;
var QUOTA_BACKOFF_BASE_MS2 = 1e3;
var QUOTA_BACKOFF_MAX_MS2 = 30 * 60 * 1e3;
var QUOTA_EXHAUSTED_THRESHOLD_MS2 = 10 * 60 * 1e3;
var QUOTA_COOLDOWN_WAIT_MAX_MS2 = 2 * 60 * 1e3;
var GEMINI_UNSUPPORTED_FIELDS2 = /* @__PURE__ */ new Set([
  "$ref",
  "$defs",
  "definitions",
  "$id",
  "$anchor",
  "$dynamicRef",
  "$dynamicAnchor",
  "$schema",
  "$vocabulary",
  "$comment",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "minimum",
  "maximum",
  "multipleOf",
  "additionalProperties",
  "minLength",
  "maxLength",
  "pattern",
  "minItems",
  "maxItems",
  "uniqueItems",
  "minContains",
  "maxContains",
  "minProperties",
  "maxProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  "unevaluatedItems",
  "unevaluatedProperties",
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  "dependencies",
  "allOf",
  "anyOf",
  "oneOf",
  "not",
  "strict",
  "input_examples",
  "examples"
]);
var thoughtSignatureStore2 = /* @__PURE__ */ new Map();
var FALLBACK_THOUGHT_SIGNATURE2 = "skip_thought_signature_validator";
function storeThoughtSignature2(callId, signature) {
  if (callId && signature) {
    thoughtSignatureStore2.set(callId, signature);
  }
}
function categorizeHttpStatus2(statusCode) {
  switch (statusCode) {
    case 400:
      return "user_error" /* UserError */;
    case 401:
      return "auth_error" /* AuthError */;
    case 402:
    case 403:
    case 429:
      return "quota_error" /* QuotaError */;
    case 404:
      return "not_found" /* NotFound */;
    case 500:
    case 502:
    case 503:
    case 504:
      return "transient" /* Transient */;
    default:
      return "unknown" /* Unknown */;
  }
}
function shouldFallback2(category) {
  return category === "quota_error" /* QuotaError */ || category === "transient" /* Transient */ || category === "auth_error" /* AuthError */;
}
function isPermissionDeniedError2(statusCode, bodyText) {
  if (statusCode !== 403 || !bodyText) {
    return false;
  }
  if (bodyText.toLowerCase().includes("permission denied")) {
    return true;
  }
  try {
    const parsed = JSON.parse(bodyText);
    if (parsed?.error?.status === "PERMISSION_DENIED") {
      return true;
    }
    const details = parsed?.error?.details;
    if (Array.isArray(details)) {
      for (const detail of details) {
        if (detail["@type"] === "type.googleapis.com/google.rpc.ErrorInfo" && detail.reason === "CONSUMER_INVALID") {
          return true;
        }
      }
    }
  } catch {
  }
  return false;
}
function parseSecondsDuration2(duration3) {
  const match = duration3.match(/^(\d+(?:\.\d+)?)s$/);
  return match ? Math.round(parseFloat(match[1]) * 1e3) : null;
}
function parseDurationFormat2(duration3) {
  const simpleSeconds = parseSecondsDuration2(duration3);
  if (simpleSeconds !== null) {
    return simpleSeconds;
  }
  let totalMs = 0;
  const hourMatch = duration3.match(/(\d+)h/);
  const minMatch = duration3.match(/(\d+)m/);
  const secMatch = duration3.match(/(\d+(?:\.\d+)?)s/);
  if (hourMatch) {
    totalMs += parseInt(hourMatch[1], 10) * 60 * 60 * 1e3;
  }
  if (minMatch) {
    totalMs += parseInt(minMatch[1], 10) * 60 * 1e3;
  }
  if (secMatch) {
    totalMs += Math.round(parseFloat(secMatch[1]) * 1e3);
  }
  return totalMs > 0 ? totalMs : null;
}
function parseQuotaRetryDelay2(errorBody) {
  try {
    const parsed = JSON.parse(errorBody);
    const details = parsed?.error?.details || (Array.isArray(parsed) ? parsed[0]?.error?.details : null);
    if (!details) {
      return null;
    }
    for (const detail of details) {
      if (detail["@type"] === "type.googleapis.com/google.rpc.RetryInfo" && detail.retryDelay) {
        const d = parseSecondsDuration2(detail.retryDelay);
        if (d !== null && d > 0) {
          return d;
        }
      }
      if (detail["@type"] === "type.googleapis.com/google.rpc.ErrorInfo" && detail.metadata?.quotaResetDelay) {
        const d = parseDurationFormat2(detail.metadata.quotaResetDelay);
        if (d !== null && d > 0) {
          return d;
        }
      }
    }
  } catch {
  }
  return null;
}
function sleepWithCancellation2(ms, token) {
  return new Promise((resolve) => {
    if (ms <= 0) {
      resolve();
      return;
    }
    const timeout = setTimeout(resolve, ms);
    const disposable = token.onCancellationRequested(() => {
      clearTimeout(timeout);
      resolve();
    });
    setTimeout(() => disposable.dispose(), ms + 100);
  });
}
var QuotaStateManager2 = class _QuotaStateManager {
  static instance;
  modelStates = /* @__PURE__ */ new Map();
  static getInstance() {
    if (!_QuotaStateManager.instance) {
      _QuotaStateManager.instance = new _QuotaStateManager();
    }
    return _QuotaStateManager.instance;
  }
  markQuotaExceeded(modelId, retryAfterMs) {
    const existing = this.modelStates.get(modelId) || {
      isExhausted: false,
      resetsAt: 0,
      lastUpdated: 0,
      exceeded: false,
      nextRecoverAt: 0,
      backoffLevel: 0
    };
    let cooldown = QUOTA_BACKOFF_BASE_MS2 * 2 ** (existing.backoffLevel || 0);
    if (cooldown > QUOTA_BACKOFF_MAX_MS2) {
      cooldown = QUOTA_BACKOFF_MAX_MS2;
    }
    const actualCooldown = retryAfterMs && retryAfterMs > cooldown ? retryAfterMs : cooldown;
    this.modelStates.set(modelId, {
      isExhausted: true,
      resetsAt: Date.now() + actualCooldown,
      lastUpdated: Date.now(),
      exceeded: true,
      nextRecoverAt: Date.now() + actualCooldown,
      backoffLevel: (existing.backoffLevel || 0) + 1,
      lastError: `Quota exceeded, retry after ${Math.round(actualCooldown / 1e3)}s`
    });
  }
  clearQuotaExceeded(modelId) {
    const existing = this.modelStates.get(modelId);
    if (existing) {
      existing.exceeded = false;
      existing.backoffLevel = 0;
      existing.lastError = void 0;
    }
  }
  isInCooldown(modelId) {
    const state = this.modelStates.get(modelId);
    if (!state || !state.exceeded) {
      return false;
    }
    if (Date.now() >= (state.nextRecoverAt || 0)) {
      this.clearQuotaExceeded(modelId);
      return false;
    }
    return true;
  }
  getRemainingCooldown(modelId) {
    const state = this.modelStates.get(modelId);
    if (!state || !state.exceeded) {
      return 0;
    }
    const remaining = (state.nextRecoverAt || 0) - Date.now();
    return remaining > 0 ? remaining : 0;
  }
};
var RateLimitRetrier2 = class {
  retryCount = 0;
  async handleRateLimit(hasNextUrl, errorBody, token) {
    if (hasNextUrl) {
      return "continue" /* Continue */;
    }
    if (this.retryCount >= RATE_LIMIT_MAX_RETRIES2) {
      return "max_exceeded" /* MaxExceeded */;
    }
    let delay = RATE_LIMIT_BASE_DELAY_MS2 * 2 ** this.retryCount;
    const serverDelay = parseQuotaRetryDelay2(errorBody);
    if (serverDelay !== null) {
      delay = Math.min(serverDelay + 500, RATE_LIMIT_MAX_DELAY_MS2);
    } else if (delay > RATE_LIMIT_MAX_DELAY_MS2) {
      delay = RATE_LIMIT_MAX_DELAY_MS2;
    }
    this.retryCount++;
    await sleepWithCancellation2(delay, token);
    return token.isCancellationRequested ? "max_exceeded" /* MaxExceeded */ : "retry" /* Retry */;
  }
};
function sanitizeToolSchema2(schema) {
  if (!schema || typeof schema !== "object" || Array.isArray(schema)) {
    return { type: "object", properties: {} };
  }
  let sanitized;
  try {
    sanitized = JSON.parse(JSON.stringify(schema));
  } catch {
    return { type: "object", properties: {} };
  }
  const cleanRecursive = (s) => {
    if (!s) {
      return;
    }
    for (const composite of ["anyOf", "oneOf", "allOf"]) {
      const branch = s[composite];
      if (Array.isArray(branch) && branch.length > 0) {
        let preferred;
        for (const option of branch) {
          if (option && typeof option === "object") {
            preferred = option;
            if (preferred.type === "string") {
              break;
            }
          }
        }
        const selected = preferred ?? branch[0];
        for (const key of Object.keys(s)) {
          delete s[key];
        }
        Object.assign(s, selected);
        break;
      }
    }
    if (Array.isArray(s.type)) {
      const typeCandidates = s.type.filter((t) => t !== "null");
      const preferredType = typeCandidates.find(
        (t) => typeof t === "string" && t.trim() !== ""
      );
      s.type = preferredType ?? "object";
    }
    if (s.nullable === true) {
      delete s.nullable;
    }
    if (Array.isArray(s.properties)) {
      const mapped = {};
      for (const item of s.properties) {
        if (!item || typeof item !== "object") {
          continue;
        }
        const entry = item;
        const name = entry.name ?? entry.key;
        const value = entry.value ?? entry.schema ?? entry.property;
        if (typeof name === "string" && value && typeof value === "object") {
          mapped[name] = value;
        }
      }
      s.properties = mapped;
    }
    if (Array.isArray(s.items)) {
      const firstItem = s.items[0];
      s.items = firstItem && typeof firstItem === "object" ? firstItem : void 0;
    }
    if (typeof s.type === "string") {
      s.type = s.type.toLowerCase();
    }
    for (const key of Object.keys(s)) {
      if (GEMINI_UNSUPPORTED_FIELDS2.has(key)) {
        delete s[key];
      }
    }
    for (const nested of [
      s.properties,
      s.items,
      s.additionalProperties,
      s.patternProperties,
      s.propertyNames,
      s.contains
    ]) {
      if (nested && typeof nested === "object" && !Array.isArray(nested)) {
        cleanRecursive(nested);
      }
      if (Array.isArray(nested)) {
        for (const item of nested) {
          if (item && typeof item === "object") {
            cleanRecursive(item);
          }
        }
      }
    }
    if (s.properties && typeof s.properties === "object") {
      for (const v of Object.values(s.properties)) {
        if (v && typeof v === "object") {
          cleanRecursive(v);
        }
      }
    }
  };
  cleanRecursive(sanitized);
  if (typeof sanitized.type !== "string" || !sanitized.type.trim() || sanitized.type === "None") {
    sanitized.type = "object";
  }
  if (!sanitized.properties || typeof sanitized.properties !== "object") {
    sanitized.properties = {};
  }
  return sanitized;
}
function convertToolCallsToGeminiParts2(toolCalls) {
  return toolCalls.map((toolCall) => {
    const storedSignature = thoughtSignatureStore2.get(toolCall.callId);
    const signature = storedSignature || FALLBACK_THOUGHT_SIGNATURE2;
    if (!storedSignature) {
      thoughtSignatureStore2.set(toolCall.callId, signature);
    }
    let args = toolCall.input;
    if (typeof args === "string") {
      try {
        args = JSON.parse(args);
      } catch {
        args = { value: args };
      }
    }
    if (!args || typeof args !== "object" || Array.isArray(args)) {
      args = { value: args };
    }
    return {
      functionCall: {
        name: toolCall.name,
        id: toolCall.callId,
        args
      },
      thoughtSignature: signature
    };
  });
}
function extractToolCallFromGeminiResponse2(part) {
  const functionCall = part.functionCall;
  if (!functionCall?.name) {
    return null;
  }
  return {
    callId: functionCall.id || `call_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`,
    name: functionCall.name,
    args: functionCall.args,
    thoughtSignature: part.thoughtSignature
  };
}
var MessageConverter2 = class {
  convertMessagesToGemini(messages, modelConfig, resolvedModelName) {
    const contents = [];
    let systemText = "";
    const toolIdToName = /* @__PURE__ */ new Map();
    for (const m of messages) {
      if (m.role === vscode39.LanguageModelChatMessageRole.Assistant) {
        for (const p of m.content) {
          if (p instanceof vscode39.LanguageModelToolCallPart) {
            toolIdToName.set(p.callId, p.name);
          }
        }
      }
    }
    const _isThinkingEnabled = modelConfig.outputThinking !== false || modelConfig.includeThinking === true;
    const modelName = (resolvedModelName || modelConfig.model || "").toLowerCase();
    const isClaudeModel = modelName.includes("claude");
    const nonSystemMessages = messages.filter(
      (m) => m.role !== vscode39.LanguageModelChatMessageRole.System
    );
    const msgCount = nonSystemMessages.length;
    let currentMsgIndex = 0;
    for (const message of messages) {
      if (message.role === vscode39.LanguageModelChatMessageRole.System) {
        systemText = message.content.filter((p) => p instanceof vscode39.LanguageModelTextPart).map((p) => p.value).join("\n");
        continue;
      }
      currentMsgIndex++;
      if (message.role === vscode39.LanguageModelChatMessageRole.User) {
        const parts = [];
        const text = message.content.filter((p) => p instanceof vscode39.LanguageModelTextPart).map((p) => p.value).join("\n");
        if (text) {
          parts.push({ text });
        }
        for (const part of message.content) {
          if (part instanceof vscode39.LanguageModelDataPart && part.mimeType.toLowerCase().startsWith("image/")) {
            parts.push({
              inlineData: {
                mimeType: part.mimeType,
                data: Buffer.from(part.data).toString("base64")
              }
            });
          }
          if (part instanceof vscode39.LanguageModelToolResultPart) {
            const name = toolIdToName.get(part.callId) || "unknown";
            let content = "";
            if (typeof part.content === "string") {
              content = part.content;
            } else if (Array.isArray(part.content)) {
              content = part.content.map(
                (r) => r instanceof vscode39.LanguageModelTextPart ? r.value : JSON.stringify(r)
              ).join("\n");
            } else {
              content = JSON.stringify(part.content);
            }
            let response = { content };
            try {
              const parsed = JSON.parse(content.trim());
              if (parsed && typeof parsed === "object") {
                response = Array.isArray(parsed) ? { result: parsed } : parsed;
              }
            } catch {
            }
            parts.push({
              functionResponse: { name, id: part.callId, response }
            });
          }
        }
        if (parts.length > 0) {
          contents.push({
            role: "user",
            parts
          });
        }
        continue;
      }
      if (message.role === vscode39.LanguageModelChatMessageRole.Assistant) {
        let parts = [];
        const includeThinking = !isClaudeModel && (modelConfig.includeThinking === true || modelConfig.outputThinking !== false);
        const toolCalls = message.content.filter(
          (p) => p instanceof vscode39.LanguageModelToolCallPart
        );
        if (includeThinking && toolCalls.length === 0) {
          for (const part of message.content) {
            if (part instanceof vscode39.LanguageModelThinkingPart) {
              const value = Array.isArray(part.value) ? part.value.join("") : part.value;
              if (value) {
                parts.push({ text: value, thought: true });
              }
              break;
            }
          }
        }
        const text = message.content.filter((p) => p instanceof vscode39.LanguageModelTextPart).map((p) => p.value).join("\n");
        if (text) {
          parts.push({ text });
        }
        if (toolCalls.length > 0) {
          parts.push(...convertToolCallsToGeminiParts2(toolCalls));
        }
        if (isClaudeModel) {
          parts = parts.filter((p) => p.thought !== true);
        }
        if (!isClaudeModel && toolCalls.length === 0 && includeThinking && currentMsgIndex === msgCount && !parts.some((p) => p.thought === true)) {
          parts.unshift({ text: "Thinking...", thought: true });
        }
        if (parts.length > 0) {
          contents.push({
            role: "model",
            parts
          });
        }
      }
    }
    return {
      contents,
      systemInstruction: systemText ? { role: "user", parts: [{ text: systemText }] } : void 0
    };
  }
};
var FromIRTranslator2 = class {
  messageConverter = new MessageConverter2();
  buildGeminiPayload(model, modelConfig, messages, options, modelName, projectId) {
    const maxOutputTokens = ConfigManager.getMaxTokensForModel(
      model.maxOutputTokens
    );
    const resolvedModel = modelName.toLowerCase();
    const { contents, systemInstruction } = this.messageConverter.convertMessagesToGemini(
      messages,
      modelConfig,
      resolvedModel
    );
    const isClaudeThinkingModel = resolvedModel.includes("claude") && resolvedModel.includes("thinking");
    const isThinkingEnabled = modelConfig.outputThinking !== false || modelConfig.includeThinking === true;
    const generationConfig = {
      maxOutputTokens,
      temperature: ConfigManager.getTemperature(),
      topP: ConfigManager.getTopP()
    };
    const hasTools = options.tools && options.tools.length > 0 && model.capabilities?.toolCalling;
    if (isThinkingEnabled) {
      console.log("GeminiCLI: Thinking enabled for model:", resolvedModel);
      if (isClaudeThinkingModel) {
        const thinkingBudget = modelConfig.thinkingBudget || 1e4;
        if (maxOutputTokens < thinkingBudget + 1e3) {
          generationConfig.maxOutputTokens = thinkingBudget + 1e3;
        }
        generationConfig.thinkingConfig = {
          includeThoughts: true,
          thinkingBudget
        };
        console.log(
          "GeminiCLI: Claude thinking config:",
          generationConfig.thinkingConfig
        );
      } else if (resolvedModel.includes("gemini-3")) {
        generationConfig.thinkingConfig = {
          includeThoughts: true,
          thinkingLevel: "HIGH"
        };
        console.log(
          "GeminiCLI: Gemini-3 thinking config:",
          generationConfig.thinkingConfig
        );
      } else if (resolvedModel.includes("gemini-2.5")) {
        generationConfig.thinkingConfig = {
          includeThoughts: true,
          thinkingBudget: 8192
        };
        console.log(
          "GeminiCLI: Gemini-2.5 thinking config:",
          generationConfig.thinkingConfig
        );
      } else {
        console.log(
          "GeminiCLI: Model does not support thinking:",
          resolvedModel
        );
      }
    } else {
      console.log("GeminiCLI: Thinking disabled for model:", resolvedModel);
    }
    const request3 = {
      contents,
      generationConfig
    };
    if (systemInstruction) {
      request3.systemInstruction = systemInstruction;
    }
    if (hasTools) {
      request3.tools = [
        {
          functionDeclarations: options.tools?.map((tool) => ({
            name: tool.name,
            description: tool.description || "",
            parameters: tool.inputSchema && typeof tool.inputSchema === "object" ? sanitizeToolSchema2(tool.inputSchema) : { type: "object", properties: {} }
          }))
        }
      ];
      request3.toolConfig = { functionCallingConfig: { mode: "AUTO" } };
    }
    if (modelConfig.extraBody && typeof modelConfig.extraBody === "object") {
      Object.assign(request3, modelConfig.extraBody);
    }
    const uuid2 = import_node_crypto3.default.randomUUID ? import_node_crypto3.default.randomUUID() : import_node_crypto3.default.randomBytes(16).toString("hex");
    const userPromptId = `agent-${uuid2}`;
    const payload = {
      model: modelName,
      user_prompt_id: userPromptId,
      request: request3
    };
    if (projectId) {
      payload.project = projectId;
    }
    this.validatePartsBalance(request3.contents, resolvedModel);
    this.balanceFunctionCallResponses(request3.contents, resolvedModel);
    return payload;
  }
  /**
   * Validate that functionCall and functionResponse parts are balanced
   * This prevents the "Please ensure that the number of function response parts is equal to
   * the number of function call parts of the function call turn" error
   */
  validatePartsBalance(contents, _modelName) {
    let totalFunctionCalls = 0;
    let totalFunctionResponses = 0;
    let totalThoughtSignatureParts = 0;
    for (const content of contents) {
      for (const part of content.parts) {
        if (part.functionCall) {
          totalFunctionCalls++;
        }
        if (part.functionResponse) {
          totalFunctionResponses++;
        }
        if (part.thoughtSignature && !part.functionCall) {
          totalThoughtSignatureParts++;
        }
      }
    }
    console.log(
      `GeminiCLI: Parts validation - functionCalls=${totalFunctionCalls}, functionResponses=${totalFunctionResponses}, orphanThoughtSignatures=${totalThoughtSignatureParts}`
    );
    if (totalFunctionCalls !== totalFunctionResponses) {
      console.warn(
        `GeminiCLI: WARNING - Function call/response mismatch! calls=${totalFunctionCalls}, responses=${totalFunctionResponses}. Attempting to automatically balance parts before sending.`
      );
    }
    if (totalThoughtSignatureParts > 0) {
      console.warn(
        `GeminiCLI: WARNING - Found ${totalThoughtSignatureParts} thoughtSignature parts without functionCall. Attempting to reattach them to the nearest functionCall part.`
      );
    }
  }
  /**
   * Attempt to automatically balance functionCall/functionResponse parts and reattach orphan thoughtSignatures.
   * This mutates the contents array in-place to fix common causes of the "function response parts" 400 error.
   */
  balanceFunctionCallResponses(contents, _modelName) {
    const callsById = /* @__PURE__ */ new Map();
    const responsesById = /* @__PURE__ */ new Map();
    const orphanThoughts = [];
    for (let ci = 0; ci < contents.length; ci++) {
      const content = contents[ci];
      for (let pi = 0; pi < content.parts.length; pi++) {
        const part = content.parts[pi];
        if (part.functionCall) {
          const id = part.functionCall.id || part.functionCall.callId || `call_${ci}_${pi}`;
          callsById.set(String(id), {
            name: part.functionCall.name,
            contentIndex: ci,
            partIndex: pi
          });
          if (part.thoughtSignature) {
            part.thoughtSignature = String(part.thoughtSignature);
          }
        } else if (part.functionResponse) {
          const id = part.functionResponse.id;
          const key = id || `__name_${part.functionResponse.name}`;
          const arr = responsesById.get(key) || [];
          arr.push({ contentIndex: ci, partIndex: pi });
          responsesById.set(key, arr);
        }
        if (part.thoughtSignature && !part.functionCall) {
          orphanThoughts.push({
            signature: String(part.thoughtSignature),
            contentIndex: ci,
            partIndex: pi
          });
        }
      }
    }
    for (const [id, info] of callsById.entries()) {
      const responseKey = id;
      if (!responsesById.has(responseKey)) {
        contents.push({
          role: "user",
          parts: [
            { functionResponse: { name: info.name || "", id, response: {} } }
          ]
        });
        console.log(
          `GeminiCLI: Added placeholder functionResponse for id=${id} name=${info.name || ""}`
        );
      }
    }
    for (const [key, arr] of responsesById.entries()) {
      if (!callsById.has(key)) {
        for (let i = arr.length - 1; i >= 0; i--) {
          const loc = arr[i];
          const c = contents[loc.contentIndex];
          const p = c.parts[loc.partIndex];
          const resp = p.functionResponse?.response;
          if (resp && Object.keys(resp).length > 0) {
            c.parts[loc.partIndex] = { text: JSON.stringify(resp) };
          } else {
            c.parts.splice(loc.partIndex, 1);
          }
        }
        console.warn(
          `GeminiCLI: Converted/removed ${arr.length} orphan functionResponse(s) for key=${key}`
        );
      }
    }
    for (const orphan of orphanThoughts) {
      const { signature, contentIndex, partIndex } = orphan;
      let attached = false;
      const content = contents[contentIndex];
      if (content) {
        const idx = content.parts.findIndex((p) => p.functionCall);
        if (idx !== -1) {
          content.parts[idx].thoughtSignature = signature;
          delete content.parts[partIndex].thoughtSignature;
          attached = true;
        }
      }
      if (!attached) {
        for (let ci = contentIndex - 1; ci >= 0 && !attached; ci--) {
          const idx = contents[ci].parts.findIndex(
            (p) => p.functionCall
          );
          if (idx !== -1) {
            contents[ci].parts[idx].thoughtSignature = signature;
            delete contents[contentIndex].parts[partIndex].thoughtSignature;
            attached = true;
          }
        }
      }
      if (!attached) {
        for (let ci = contentIndex + 1; ci < contents.length && !attached; ci++) {
          const idx = contents[ci].parts.findIndex(
            (p) => p.functionCall
          );
          if (idx !== -1) {
            contents[ci].parts[idx].thoughtSignature = signature;
            delete contents[contentIndex].parts[partIndex].thoughtSignature;
            attached = true;
          }
        }
      }
      if (!attached) {
        delete contents[contentIndex].parts[partIndex].thoughtSignature;
        console.warn(
          `GeminiCLI: Removed orphan thoughtSignature at content=${contentIndex} part=${partIndex} - no functionCall found to attach to.`
        );
      }
    }
    for (let i = contents.length - 1; i >= 0; i--) {
      if (!contents[i].parts || contents[i].parts.length === 0) {
        contents.splice(i, 1);
      }
    }
  }
};
var GeminiHandler = class {
  constructor(displayName) {
    this.displayName = displayName;
  }
  quotaManager = QuotaStateManager2.getInstance();
  accountQuotaCache = AccountQuotaCache.getInstance();
  quotaNotificationManager = new QuotaNotificationManager();
  fromIRTranslator = new FromIRTranslator2();
  cacheUpdateTimers = /* @__PURE__ */ new Map();
  pendingCacheUpdates = /* @__PURE__ */ new Map();
  projectIdCache = null;
  projectIdPromise = null;
  async handleRequest(model, modelConfig, messages, options, progress, token, accessToken, accountId, loadBalanceEnabled) {
    await RateLimiter.getInstance("geminicli", 2, 1e3).throttle(
      this.displayName
    );
    const authToken = accessToken || await GeminiOAuthManager.getInstance().getAccessToken();
    if (!authToken) {
      throw new Error("Not logged in to Gemini CLI. Please login first.");
    }
    const resolvedModel = modelConfig.model || model.id;
    const effectiveAccountId = accountId || "default-gemini";
    const quotaKey = `${effectiveAccountId}:${resolvedModel}`;
    if (this.quotaManager.isInCooldown(quotaKey)) {
      const remaining = this.quotaManager.getRemainingCooldown(quotaKey);
      if (remaining > 5e3) {
        this.quotaNotificationManager.notifyQuotaExceeded(
          remaining,
          resolvedModel,
          accountId,
          this.displayName
        );
      }
      if (remaining > QUOTA_COOLDOWN_WAIT_MAX_MS2) {
        this.debouncedCacheUpdate(
          `quota-${effectiveAccountId}`,
          () => this.accountQuotaCache.markQuotaExceeded(
            effectiveAccountId,
            "gemini",
            {
              accountName: this.displayName,
              resetDelayMs: remaining,
              affectedModel: resolvedModel,
              error: "Quota cooldown exceeds max wait threshold"
            }
          ),
          50
        );
        await this.quotaNotificationManager.notifyQuotaTooLong(
          remaining,
          resolvedModel,
          accountId,
          this.displayName
        );
        throw new Error(
          `Quota wait too long (${this.quotaNotificationManager.formatDuration(remaining)}). Please add another account or try again later.`
        );
      }
      await sleepWithCancellation2(remaining, token);
      if (token.isCancellationRequested) {
        throw new vscode39.CancellationError();
      }
    }
    const projectId = await this.getProjectId(authToken, modelConfig.baseUrl);
    const payload = this.fromIRTranslator.buildGeminiPayload(
      model,
      modelConfig,
      messages,
      options,
      resolvedModel,
      projectId
    );
    const baseUrls = modelConfig.baseUrl ? [modelConfig.baseUrl.replace(/\/v1internal\/?$/, "")] : [...DEFAULT_BASE_URLS2];
    const abortController = new AbortController();
    const cancelListener = token.onCancellationRequested(
      () => abortController.abort()
    );
    const retrier = new RateLimitRetrier2();
    progress.report(new vscode39.LanguageModelTextPart(""));
    let lastStatus = 0, lastBody = "", lastError = null;
    try {
      for (let idx = 0; idx < baseUrls.length; idx++) {
        const url2 = `${baseUrls[idx].replace(/\/$/, "")}/v1internal:streamGenerateContent?alt=sse`;
        if (token.isCancellationRequested) {
          throw new vscode39.CancellationError();
        }
        try {
          const result = await this.streamRequest(
            url2,
            authToken,
            payload,
            modelConfig,
            progress,
            token,
            abortController
          );
          if (result.success) {
            this.quotaManager.clearQuotaExceeded(quotaKey);
            this.quotaNotificationManager.clearQuotaCountdown();
            this.debouncedCacheUpdate(
              `success-${effectiveAccountId}`,
              () => this.accountQuotaCache.recordSuccess(
                effectiveAccountId,
                "gemini",
                this.displayName
              ),
              50
            );
            try {
              const promptTokens = await TokenCounter.getInstance().countMessagesTokens(
                model,
                [...messages],
                { sdkMode: modelConfig.sdkMode || "openai" },
                options
              );
              TokenTelemetryTracker.getInstance().recordSuccess({
                modelId: model.id,
                modelName: model.name,
                providerId: "gemini",
                promptTokens,
                completionTokens: 0,
                totalTokens: promptTokens,
                maxInputTokens: model.maxInputTokens,
                maxOutputTokens: model.maxOutputTokens,
                estimatedPromptTokens: true
              });
            } catch (e) {
              Logger.trace(
                `[GeminiCLI] Failed to estimate prompt tokens: ${String(e)}`
              );
            }
            return;
          }
          if (isPermissionDeniedError2(result.status, result.body)) {
            this.debouncedCacheUpdate(
              `failure-${effectiveAccountId}`,
              () => this.accountQuotaCache.recordFailure(
                effectiveAccountId,
                "gemini",
                `HTTP ${result.status || 403}: ${result.body || "Permission denied"}`,
                this.displayName
              ),
              50
            );
            throw new Error(
              result.body || "Permission denied on Gemini project."
            );
          }
          const category = categorizeHttpStatus2(result.status || 0);
          if (category === "quota_error" /* QuotaError */) {
            lastStatus = result.status || 0;
            lastBody = result.body || "";
            const quotaDelay = parseQuotaRetryDelay2(lastBody);
            this.quotaManager.markQuotaExceeded(
              quotaKey,
              quotaDelay || void 0
            );
            const cooldownRemaining = this.quotaManager.getRemainingCooldown(quotaKey);
            if (cooldownRemaining > 5e3) {
              this.quotaNotificationManager.notifyQuotaExceeded(
                cooldownRemaining,
                resolvedModel,
                effectiveAccountId,
                this.displayName
              );
            }
            this.debouncedCacheUpdate(
              `quota-${effectiveAccountId}`,
              () => this.accountQuotaCache.markQuotaExceeded(
                effectiveAccountId,
                "gemini",
                {
                  accountName: this.displayName,
                  resetDelayMs: quotaDelay || cooldownRemaining,
                  affectedModel: resolvedModel,
                  error: `HTTP ${lastStatus}: Quota exceeded`
                }
              ),
              50
            );
            if (cooldownRemaining > QUOTA_COOLDOWN_WAIT_MAX_MS2) {
              await this.quotaNotificationManager.notifyQuotaTooLong(
                cooldownRemaining,
                resolvedModel,
                effectiveAccountId,
                this.displayName
              );
              throw new Error(
                `Quota wait too long (${this.quotaNotificationManager.formatDuration(cooldownRemaining)}). Please add another account or try again later.`
              );
            }
            if (quotaDelay && quotaDelay > QUOTA_EXHAUSTED_THRESHOLD_MS2) {
              throw new Error(
                `Account quota exhausted (quota resets in ${this.quotaNotificationManager.formatDuration(quotaDelay)}). Please wait or use a different account.`
              );
            }
            if (idx + 1 < baseUrls.length) {
              continue;
            }
            if (loadBalanceEnabled !== false) {
              const action = await retrier.handleRateLimit(
                false,
                lastBody,
                token
              );
              if (action === "retry" /* Retry */) {
                idx--;
                continue;
              }
            }
            throw new Error(
              `Quota exceeded${quotaDelay ? ` (quota resets in ${this.quotaNotificationManager.formatDuration(quotaDelay)})` : ""}: ${lastBody || `HTTP ${result.status}`}`
            );
          }
          if (category === "transient" /* Transient */ && shouldFallback2(category) && idx + 1 < baseUrls.length) {
            lastStatus = result.status || 0;
            lastBody = result.body || "";
            continue;
          }
          if (category === "auth_error" /* AuthError */) {
            throw new Error(
              "Authentication failed. Please re-login to Gemini CLI."
            );
          }
          if (result.status === 404 && idx + 1 < baseUrls.length) {
            lastStatus = result.status;
            lastBody = result.body || "";
            continue;
          }
          throw new Error(
            result.body || `HTTP ${result.status} ${result.statusText}`
          );
        } catch (error2) {
          if (error2 instanceof vscode39.CancellationError) {
            throw error2;
          }
          if (error2 instanceof Error && (error2.message.startsWith("Quota exceeded") || error2.message.startsWith("Rate limited") || error2.message.startsWith("HTTP") || error2.message.startsWith("Authentication failed"))) {
            throw error2;
          }
          lastStatus = 0;
          lastBody = "";
          lastError = error2 instanceof Error ? error2 : new Error(String(error2));
          if (idx + 1 < baseUrls.length) {
            continue;
          }
          throw error2;
        }
      }
      if (lastStatus !== 0) {
        const delay = parseQuotaRetryDelay2(lastBody);
        throw new Error(
          `HTTP ${lastStatus}${delay ? ` (quota resets in ${this.quotaNotificationManager.formatDuration(delay)})` : ""}: ${lastBody}`
        );
      }
      if (lastError) {
        throw lastError;
      }
      throw new Error("All Gemini endpoints unavailable");
    } finally {
      cancelListener.dispose();
    }
  }
  async getProjectId(accessToken, baseUrl) {
    if (this.projectIdCache) {
      return this.projectIdCache;
    }
    if (this.projectIdPromise) {
      return this.projectIdPromise;
    }
    this.projectIdPromise = (async () => {
      try {
        const urlBase = (baseUrl || "https://cloudcode-pa.googleapis.com/v1internal").replace(/\/$/, "");
        const loadUrl = urlBase.includes("/v1internal") ? `${urlBase}:loadCodeAssist` : `${urlBase.replace(/\/$/, "")}/v1internal:loadCodeAssist`;
        const envProject = process.env.GOOGLE_CLOUD_PROJECT || process.env.GOOGLE_CLOUD_PROJECT_ID || "";
        const metadata = {
          ideType: "IDE_UNSPECIFIED",
          platform: "PLATFORM_UNSPECIFIED",
          pluginType: "GEMINI"
        };
        if (envProject) {
          metadata.duetProject = envProject;
        }
        const res = await fetch(loadUrl, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${accessToken}`,
            "Content-Type": "application/json",
            "User-Agent": DEFAULT_USER_AGENT2,
            "Client-Metadata": JSON.stringify(metadata)
          },
          body: JSON.stringify({
            cloudaicompanionProject: envProject || void 0,
            metadata
          })
        });
        if (!res.ok) {
          this.projectIdCache = "";
          return "";
        }
        const text = await res.text();
        let data;
        try {
          data = JSON.parse(text);
        } catch {
          this.projectIdCache = "";
          return "";
        }
        const rawProject = data?.cloudaicompanionProject;
        let projectId = "";
        if (typeof rawProject === "string") {
          projectId = rawProject.trim();
        } else if (rawProject && typeof rawProject === "object" && typeof rawProject.id === "string") {
          projectId = rawProject.id.trim();
        }
        this.projectIdCache = projectId;
        return projectId;
      } catch {
        this.projectIdCache = "";
        return "";
      } finally {
        this.projectIdPromise = null;
      }
    })();
    return this.projectIdPromise;
  }
  async streamRequest(url2, accessToken, payload, modelConfig, progress, token, abortController) {
    let response;
    try {
      response = await fetch(url2, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${accessToken}`,
          "Content-Type": "application/json",
          Accept: "text/event-stream",
          "User-Agent": DEFAULT_USER_AGENT2
        },
        body: JSON.stringify(payload),
        signal: abortController.signal
      });
    } catch (error2) {
      if (token.isCancellationRequested || abortController.signal.aborted) {
        throw new vscode39.CancellationError();
      }
      throw error2;
    }
    if (!response.ok) {
      return {
        success: false,
        status: response.status,
        statusText: response.statusText,
        body: await response.text()
      };
    }
    if (modelConfig.sdkMode === "openai" || modelConfig.sdkMode === "openai-sse") {
      await new OpenAIStreamProcessor().processStream({
        response,
        modelConfig,
        progress,
        token
      });
    } else {
      await new GeminiStreamProcessor().processStream({
        response,
        modelConfig,
        progress,
        token
      });
    }
    return { success: true };
  }
  isInCooldown(modelId, accountId) {
    return this.quotaManager.isInCooldown(
      `${accountId || "default-gemini"}:${modelId}`
    );
  }
  getRemainingCooldown(modelId, accountId) {
    return this.quotaManager.getRemainingCooldown(
      `${accountId || "default-gemini"}:${modelId}`
    );
  }
  debouncedCacheUpdate(key, updateFn, delayMs) {
    const existingTimer = this.cacheUpdateTimers.get(key);
    if (existingTimer) {
      clearTimeout(existingTimer);
    }
    this.pendingCacheUpdates.set(key, updateFn);
    const timer = setTimeout(() => {
      const fn = this.pendingCacheUpdates.get(key);
      if (fn) {
        void fn().catch(() => {
        });
        this.pendingCacheUpdates.delete(key);
      }
      this.cacheUpdateTimers.delete(key);
    }, delayMs);
    this.cacheUpdateTimers.set(key, timer);
  }
};

// src/providers/geminicli/provider.ts
var GeminiCliProvider = class _GeminiCliProvider extends GenericModelProvider {
  geminiHandler;
  cooldowns = /* @__PURE__ */ new Map();
  constructor(context, providerKey, providerConfig) {
    super(context, providerKey, providerConfig);
    this.geminiHandler = new GeminiHandler(providerConfig.displayName);
  }
  isInCooldown(modelId) {
    const until = this.cooldowns.get(modelId);
    return typeof until === "number" && Date.now() < until;
  }
  setCooldown(modelId, ms = 1e4) {
    this.cooldowns.set(modelId, Date.now() + ms);
  }
  isRateLimitError(error2) {
    if (!(error2 instanceof Error)) {
      return false;
    }
    const msg = error2.message;
    return msg.includes("HTTP 429") || msg.includes("Rate limited") || msg.includes("Quota exceeded") || msg.includes("429");
  }
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(`${providerConfig.displayName} provider activated!`);
    const provider = new _GeminiCliProvider(
      context,
      providerKey,
      providerConfig
    );
    const providerDisposable = vscode40.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const loginCommand = vscode40.commands.registerCommand(
      `chp.${providerKey}.login`,
      async () => {
        try {
          const { accessToken, baseURL } = await GeminiOAuthManager.getInstance().ensureAuthenticated(true);
          vscode40.window.showInformationMessage(
            `${providerConfig.displayName} login successful!`
          );
          try {
            const accountManager = AccountManager.getInstance();
            const existing = accountManager.getAccountsByProvider("geminicli").find((a) => a.metadata?.source === "cli");
            if (!existing) {
              await accountManager.addOAuthAccount(
                "geminicli",
                "Gemini CLI (Local)",
                "",
                {
                  accessToken: accessToken ?? "",
                  refreshToken: "",
                  expiresAt: "",
                  tokenType: ""
                },
                { source: "cli", baseURL }
              );
            }
          } catch (e) {
            Logger.warn(
              "[geminicli] Failed to register CLI account with AccountManager",
              e
            );
          }
          await provider.modelInfoCache?.invalidateCache(providerKey);
          provider._onDidChangeLanguageModelChatInformation.fire();
        } catch (error2) {
          vscode40.window.showErrorMessage(
            `${providerConfig.displayName} login failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
          );
        }
      }
    );
    const disposables = [providerDisposable, loginCommand];
    for (const disposable of disposables) {
      context.subscriptions.push(disposable);
    }
    return { provider, disposables };
  }
  async provideLanguageModelChatInformation(_options, _token) {
    return this.providerConfig.models.map(
      (model) => this.modelConfigToInfo(model)
    );
  }
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    const modelConfig = this.providerConfig.models.find(
      (m) => m.id === model.id
    );
    if (!modelConfig) {
      throw new Error(`Model not found: ${model.id}`);
    }
    try {
      if (this.isInCooldown(model.id)) {
        throw new Error("Rate limited: please try again later");
      }
      const accountManager = AccountManager.getInstance();
      const accounts = accountManager.getAccountsByProvider("geminicli");
      const loadBalanceEnabled = accountManager.getLoadBalanceEnabled("geminicli");
      const assignedAccountId = accountManager.getAccountIdForModel(
        "geminicli",
        model.id
      );
      const tryAccountRequest = async (account) => {
        const creds = await accountManager.getCredentials(account.id);
        if (!creds) return { success: false, reason: "no-creds" };
        let acctToken;
        if ("accessToken" in creds) {
          acctToken = creds.accessToken;
        } else if ("apiKey" in creds) {
          acctToken = creds.apiKey;
        }
        if (!acctToken) return { success: false, reason: "no-token" };
        const configWithAuth2 = {
          ...modelConfig,
          baseUrl: modelConfig.baseUrl || void 0,
          customHeader: {
            ...modelConfig.customHeader || {},
            Authorization: `Bearer ${acctToken}`
          }
        };
        try {
          await this.geminiHandler.handleRequest(
            model,
            configWithAuth2,
            messages,
            options,
            progress,
            token,
            acctToken
          );
          return { success: true };
        } catch (err) {
          return { success: false, error: err };
        }
      };
      if (accounts && accounts.length > 0) {
        const usableAccounts = accounts.filter(
          (a) => a.status === "active"
        );
        const candidates = usableAccounts.length > 0 ? usableAccounts : accounts;
        const activeAccount = accountManager.getActiveAccount("geminicli");
        let accountsToTry;
        if (loadBalanceEnabled) {
          if (activeAccount && candidates.some((a) => a.id === activeAccount.id)) {
            accountsToTry = [
              activeAccount,
              ...candidates.filter((a) => a.id !== activeAccount.id)
            ];
          } else {
            accountsToTry = candidates;
          }
        } else {
          const assigned = assignedAccountId ? accounts.find((a) => a.id === assignedAccountId) : activeAccount;
          accountsToTry = assigned ? [assigned] : candidates.length > 0 ? [candidates[0]] : [];
        }
        let lastError;
        let switchedAccount = false;
        for (const account of accountsToTry) {
          const result = await tryAccountRequest(account);
          if (result.success) {
            if (switchedAccount && loadBalanceEnabled) {
              accountManager.setAccountForModel("geminicli", model.id, account.id).catch(() => {
              });
            }
            return;
          }
          lastError = result.error ?? result.reason;
          if (result.error instanceof Error && result.error.message.includes("401")) {
            await accountManager.markAccountExpired(account.id);
            continue;
          }
          if (this.isRateLimitError(result.error) && loadBalanceEnabled) {
            switchedAccount = true;
            continue;
          }
          if (result.error) {
            throw result.error;
          }
        }
        if (lastError) {
          Logger.warn(
            "[geminicli] Managed accounts failed, falling back to CLI credentials",
            lastError
          );
        }
      }
      const { accessToken, baseURL } = await GeminiOAuthManager.getInstance().ensureAuthenticated();
      const configWithAuth = {
        ...modelConfig,
        baseUrl: baseURL,
        apiKey: accessToken,
        customHeader: modelConfig.customHeader
      };
      await this.geminiHandler.handleRequest(
        model,
        configWithAuth,
        messages,
        options,
        progress,
        token,
        accessToken
      );
    } catch (error2) {
      if (error2 instanceof Error && error2.message.includes("401")) {
        GeminiOAuthManager.getInstance().invalidateCredentials?.();
        const { accessToken, baseURL } = await GeminiOAuthManager.getInstance().ensureAuthenticated(true);
        const configWithAuth = {
          ...modelConfig,
          baseUrl: baseURL,
          customHeader: {
            ...modelConfig.customHeader,
            Authorization: `Bearer ${accessToken}`
          }
        };
        await this.geminiHandler.handleRequest(
          model,
          configWithAuth,
          messages,
          options,
          progress,
          token,
          accessToken
        );
        return;
      }
      if (this.isRateLimitError(error2)) {
        this.setCooldown(model.id, 1e4);
        throw new Error("Rate limited: please try again in a few seconds");
      }
      throw error2;
    }
  }
};

// src/providers/huggingface/provider.ts
var vscode41 = __toESM(require("vscode"));
init_apiKeyManager();
init_configManager();
init_logger();
var BASE_URL2 = "https://router.huggingface.co/v1";
var DEFAULT_MAX_OUTPUT_TOKENS2 = 16e3;
var DEFAULT_CONTEXT_LENGTH2 = 128e3;
var HuggingfaceProvider = class _HuggingfaceProvider extends GenericModelProvider {
  userAgent;
  clientCache = /* @__PURE__ */ new Map();
  constructor(context, providerKey, providerConfig, userAgent) {
    super(context, providerKey, providerConfig);
    this.userAgent = userAgent;
  }
  /**
   * Override refreshHandlers to also clear the OpenAI client cache
   * This ensures that when baseUrl changes, new clients are created with the correct URL
   */
  refreshHandlers() {
    if (this.clientCache && this.clientCache.size > 0) {
      Logger.debug(`[HuggingFace] Clearing ${this.clientCache.size} cached OpenAI clients due to config change`);
      this.clientCache.clear();
    }
    super.refreshHandlers();
  }
  estimateMessagesTokens(msgs) {
    let total = 0;
    for (const m of msgs) {
      for (const part of m.content) {
        if (part instanceof vscode41.LanguageModelTextPart) {
          total += Math.ceil(part.value.length / 4);
        }
      }
    }
    return total;
  }
  estimateToolTokens(tools) {
    if (!tools || tools.length === 0) {
      return 0;
    }
    try {
      const json = JSON.stringify(tools);
      return Math.ceil(json.length / 4);
    } catch {
      return 0;
    }
  }
  async prepareLanguageModelChatInformation(options, _token) {
    const apiKey = await this.ensureApiKey(options.silent ?? true);
    if (!apiKey) {
      return [];
    }
    const { models } = await this.fetchModels(apiKey);
    const infos = models.flatMap((m) => {
      const providers2 = m?.providers ?? [];
      const modalities = m.architecture?.input_modalities ?? [];
      const vision = Array.isArray(modalities) && modalities.includes("image");
      const toolProviders = providers2.filter((p) => p.supports_tools === true);
      const entries = [];
      if (toolProviders.length > 0) {
        const contextLengths = toolProviders.map(
          (p) => typeof p?.context_length === "number" && p.context_length > 0 ? p.context_length : void 0
        ).filter((len) => typeof len === "number");
        const aggregateContextLen = contextLengths.length > 0 ? Math.min(...contextLengths) : DEFAULT_CONTEXT_LENGTH2;
        let maxOutput = DEFAULT_MAX_OUTPUT_TOKENS2;
        if (maxOutput >= aggregateContextLen) {
          maxOutput = Math.min(
            aggregateContextLen / 2,
            DEFAULT_MAX_OUTPUT_TOKENS2
          );
        }
        maxOutput = Math.floor(
          Math.max(1, Math.min(maxOutput, aggregateContextLen - 1024))
        );
        const maxInput = Math.max(1, aggregateContextLen - maxOutput);
        const aggregateCapabilities = {
          toolCalling: true,
          imageInput: vision
        };
        entries.push({
          id: `${m.id}:cheapest`,
          name: `${m.id} (cheapest)`,
          tooltip: "Hugging Face via the cheapest provider",
          family: "huggingface",
          version: "1.0.0",
          maxInputTokens: maxInput,
          maxOutputTokens: maxOutput,
          capabilities: aggregateCapabilities
        });
        entries.push({
          id: `${m.id}:fastest`,
          name: `${m.id} (fastest)`,
          tooltip: "Hugging Face via the fastest provider",
          family: "huggingface",
          version: "1.0.0",
          maxInputTokens: maxInput,
          maxOutputTokens: maxOutput,
          capabilities: aggregateCapabilities
        });
      }
      for (const p of toolProviders) {
        const contextLen = p?.context_length ?? DEFAULT_CONTEXT_LENGTH2;
        let maxOutput = DEFAULT_MAX_OUTPUT_TOKENS2;
        if (maxOutput >= contextLen) {
          maxOutput = Math.min(contextLen / 2, DEFAULT_MAX_OUTPUT_TOKENS2);
        }
        maxOutput = Math.floor(
          Math.max(1, Math.min(maxOutput, contextLen - 1024))
        );
        const maxInput = Math.max(1, contextLen - maxOutput);
        entries.push({
          id: `${m.id}:${p.provider}`,
          name: `${m.id} via ${p.provider}`,
          tooltip: `Hugging Face via ${p.provider}`,
          family: "huggingface",
          version: "1.0.0",
          maxInputTokens: maxInput,
          maxOutputTokens: maxOutput,
          capabilities: {
            toolCalling: true,
            imageInput: vision
          }
        });
      }
      if (toolProviders.length === 0 && providers2.length > 0) {
        const base = providers2[0];
        const contextLen = base?.context_length ?? DEFAULT_CONTEXT_LENGTH2;
        let maxOutput = DEFAULT_MAX_OUTPUT_TOKENS2;
        if (maxOutput >= contextLen) {
          maxOutput = Math.min(contextLen / 2, DEFAULT_MAX_OUTPUT_TOKENS2);
        }
        maxOutput = Math.floor(
          Math.max(1, Math.min(maxOutput, contextLen - 1024))
        );
        const maxInput = Math.max(1, contextLen - maxOutput);
        entries.push({
          id: m.id,
          name: m.id,
          tooltip: "Hugging Face",
          family: "huggingface",
          version: "1.0.0",
          maxInputTokens: maxInput,
          maxOutputTokens: maxOutput,
          capabilities: {
            toolCalling: false,
            imageInput: vision
          }
        });
      }
      return entries;
    });
    const dedupedInfos = this.dedupeModelInfos(infos);
    this._chatEndpoints = dedupedInfos.map((info) => ({
      model: info.id,
      modelMaxPromptTokens: info.maxInputTokens + info.maxOutputTokens
    }));
    return dedupedInfos;
  }
  async provideLanguageModelChatInformation(options, _token) {
    return this.prepareLanguageModelChatInformation(
      { silent: options.silent ?? false },
      _token
    );
  }
  async fetchModels(apiKey) {
    const modelsList = (async () => {
      const baseUrl = this.providerConfig.baseUrl || BASE_URL2;
      const resp = await fetch(`${baseUrl}/models`, {
        method: "GET",
        headers: {
          Authorization: `Bearer ${apiKey}`,
          "User-Agent": this.userAgent
        }
      });
      if (!resp.ok) {
        let text = "";
        try {
          text = await resp.text();
        } catch (error2) {
          Logger.error(
            "[Hugging Face Model Provider] Failed to read response text",
            error2
          );
        }
        const err = new Error(
          `Failed to fetch Hugging Face models: ${resp.status} ${resp.statusText}${text ? `
${text}` : ""}`
        );
        Logger.error(
          "[Hugging Face Model Provider] Failed to fetch Hugging Face models",
          err
        );
        throw err;
      }
      const parsed = await resp.json();
      return parsed.data ?? [];
    })();
    try {
      const models = await modelsList;
      return { models };
    } catch (err) {
      Logger.error(
        "[Hugging Face Model Provider] Failed to fetch Hugging Face models",
        err
      );
      throw err;
    }
  }
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    await RateLimiter.getInstance(this.providerKey, 2, 1e3).throttle(
      this.providerConfig.displayName
    );
    try {
      const apiKey = await this.ensureApiKey(true);
      if (!apiKey) {
        throw new Error("Hugging Face API key not found");
      }
      validateRequest(
        messages
      );
      if (options.tools && options.tools.length > 128) {
        throw new Error("Cannot have more than 128 tools per request.");
      }
      const inputTokenCount = this.estimateMessagesTokens(
        messages
      );
      const toolTokenCount = options.tools ? this.estimateToolTokens(
        this.openaiHandler.convertToolsToOpenAI([...options.tools])
      ) : 0;
      const tokenLimit = Math.max(1, model.maxInputTokens);
      if (inputTokenCount + toolTokenCount > tokenLimit) {
        Logger.error(
          "[Hugging Face Model Provider] Message exceeds token limit",
          {
            total: inputTokenCount + toolTokenCount,
            tokenLimit
          }
        );
        throw new Error("Message exceeds token limit.");
      }
      const client = await this.createOpenAIClient(apiKey);
      const modelConfig = this.providerConfig.models.find(
        (m) => m.id === model.id
      );
      const openaiMessages = this.openaiHandler.convertMessagesToOpenAI(
        messages,
        model.capabilities || void 0,
        modelConfig
      );
      const createParams = {
        model: model.id,
        messages: openaiMessages,
        stream: true,
        stream_options: { include_usage: true },
        max_tokens: Math.min(
          options.modelOptions?.max_tokens || 4096,
          model.maxOutputTokens
        ),
        temperature: options.modelOptions?.temperature ?? ConfigManager.getTemperature(),
        top_p: ConfigManager.getTopP()
      };
      if (options.modelOptions) {
        const mo = options.modelOptions;
        if (typeof mo.stop === "string" || Array.isArray(mo.stop)) {
          createParams.stop = mo.stop;
        }
        if (typeof mo.frequency_penalty === "number") {
          createParams.frequency_penalty = mo.frequency_penalty;
        }
        if (typeof mo.presence_penalty === "number") {
          createParams.presence_penalty = mo.presence_penalty;
        }
      }
      if (options.tools && options.tools.length > 0 && model.capabilities?.toolCalling) {
        createParams.tools = this.openaiHandler.convertToolsToOpenAI([
          ...options.tools
        ]);
        createParams.tool_choice = "auto";
      }
      const abortController = new AbortController();
      token.onCancellationRequested(() => abortController.abort());
      const stream = client.chat.completions.stream(createParams, {
        signal: abortController.signal
      });
      let currentThinkingId = null;
      let thinkingContentBuffer = "";
      let _hasReceivedContent = false;
      let hasThinkingContent = false;
      const toolCallIds = /* @__PURE__ */ new Map();
      stream.on("chunk", (chunk) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (chunk.choices && chunk.choices.length > 0) {
          for (const choice of chunk.choices) {
            if (choice.delta?.tool_calls) {
              for (const toolCall of choice.delta.tool_calls) {
                if (toolCall.id && toolCall.index !== void 0) {
                  toolCallIds.set(toolCall.index, toolCall.id);
                }
              }
            }
            const delta = choice.delta;
            const reasoningContent = delta?.reasoning ?? delta?.reasoning_content;
            if (reasoningContent && typeof reasoningContent === "string") {
              if (!currentThinkingId) {
                currentThinkingId = `hf_thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
              }
              thinkingContentBuffer += reasoningContent;
              try {
                progress.report(
                  new vscode41.LanguageModelThinkingPart(
                    thinkingContentBuffer,
                    currentThinkingId
                  )
                );
                thinkingContentBuffer = "";
                hasThinkingContent = true;
              } catch (e) {
                Logger.warn(
                  "[Hugging Face] Failed to report thinking",
                  e instanceof Error ? e.message : String(e)
                );
              }
            }
          }
        }
      });
      stream.on("content", (delta) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (delta && typeof delta === "string" && delta.trim().length > 0) {
          if (currentThinkingId) {
            try {
              progress.report(
                new vscode41.LanguageModelThinkingPart(
                  "",
                  currentThinkingId
                )
              );
            } catch {
            }
            currentThinkingId = null;
          }
          try {
            progress.report(new vscode41.LanguageModelTextPart(delta));
            _hasReceivedContent = true;
          } catch (e) {
            Logger.warn(
              "[Hugging Face] Failed to report content",
              e instanceof Error ? e.message : String(e)
            );
          }
        }
      });
      stream.on("tool_calls.function.arguments.done", (event) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (currentThinkingId) {
          try {
            progress.report(
              new vscode41.LanguageModelThinkingPart(
                "",
                currentThinkingId
              )
            );
          } catch {
          }
          currentThinkingId = null;
        }
        const toolCallId = toolCallIds.get(event.index) || `tool_call_${event.index}_${Date.now()}`;
        let parsedArgs = {};
        if (event.parsed_arguments) {
          const result = event.parsed_arguments;
          parsedArgs = typeof result === "object" && result !== null ? result : {};
        } else {
          try {
            parsedArgs = JSON.parse(event.arguments || "{}");
          } catch {
            parsedArgs = { value: event.arguments };
          }
        }
        try {
          progress.report(
            new vscode41.LanguageModelToolCallPart(
              toolCallId,
              event.name,
              parsedArgs
            )
          );
          _hasReceivedContent = true;
        } catch (e) {
          Logger.warn(
            "[Hugging Face] Failed to report tool call",
            e instanceof Error ? e.message : String(e)
          );
        }
      });
      await stream.finalChatCompletion();
      if (currentThinkingId) {
        try {
          progress.report(
            new vscode41.LanguageModelThinkingPart(
              "",
              currentThinkingId
            )
          );
        } catch {
        }
      }
      if (hasThinkingContent && !_hasReceivedContent) {
        progress.report(new vscode41.LanguageModelTextPart("<think/>"));
        Logger.warn(
          "[Hugging Face] End of message stream has only thinking content and no text content, added <think/> placeholder as output"
        );
      }
    } catch (err) {
      Logger.error("[Hugging Face Model Provider] Chat request failed", {
        modelId: model.id,
        messageCount: messages.length,
        error: err instanceof Error ? { name: err.name, message: err.message } : String(err)
      });
      throw err;
    }
  }
  /**
   * Create OpenAI client for HuggingFace API
   */
  async createOpenAIClient(apiKey) {
    const baseUrl = this.providerConfig.baseUrl || BASE_URL2;
    const cacheKey = `huggingface:${baseUrl}`;
    const cached2 = this.clientCache.get(cacheKey);
    if (cached2) {
      cached2.lastUsed = Date.now();
      return cached2.client;
    }
    const client = new OpenAI({
      apiKey,
      baseURL: baseUrl,
      defaultHeaders: {
        "User-Agent": this.userAgent
      },
      maxRetries: 2,
      timeout: 6e4
    });
    this.clientCache.set(cacheKey, { client, lastUsed: Date.now() });
    return client;
  }
  async provideTokenCount(model, text, _token) {
    return TokenCounter.getInstance().countTokens(model, text);
  }
  async ensureApiKey(silent) {
    let apiKey = await ApiKeyManager.getApiKey("huggingface");
    if (!apiKey && !silent) {
      await ApiKeyManager.promptAndSetApiKey(
        "huggingface",
        "Hugging Face",
        "hf_xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      );
      apiKey = await ApiKeyManager.getApiKey("huggingface");
    }
    return apiKey;
  }
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(`${providerConfig.displayName} provider activated!`);
    const ext = vscode41.extensions.getExtension("OEvortex.better-copilot-chat");
    const extVersion = ext?.packageJSON?.version ?? "unknown";
    const vscodeVersion = vscode41.version;
    const ua = `better-copilot-chat/${extVersion} VSCode/${vscodeVersion}`;
    const provider = new _HuggingfaceProvider(
      context,
      providerKey,
      providerConfig,
      ua
    );
    const providerDisposable = vscode41.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const setApiKeyCommand = vscode41.commands.registerCommand(
      `chp.${providerKey}.setApiKey`,
      async () => {
        await ProviderWizard.startWizard({
          providerKey,
          displayName: providerConfig.displayName,
          apiKeyTemplate: providerConfig.apiKeyTemplate,
          supportsApiKey: true,
          supportsBaseUrl: true
        });
        await provider.modelInfoCache?.invalidateCache(providerKey);
        provider._onDidChangeLanguageModelChatInformation.fire(void 0);
      }
    );
    const disposables = [providerDisposable, setApiKeyCommand];
    for (const d of disposables) {
      context.subscriptions.push(d);
    }
    return { provider, disposables };
  }
};

// src/providers/lightningai/provider.ts
var fs3 = __toESM(require("node:fs"));
var path5 = __toESM(require("node:path"));
var vscode43 = __toESM(require("vscode"));
init_apiKeyManager();
init_configManager();
init_logger();

// src/providers/lightningai/lightningaiWizard.ts
var vscode42 = __toESM(require("vscode"));
init_apiKeyManager();
init_logger();
var LightningAIWizard = class _LightningAIWizard {
  static PROVIDER_KEY = "lightningai";
  /**
   * Start configuration wizard
   */
  static async startWizard(displayName, apiKeyTemplate) {
    try {
      const choice = await vscode42.window.showQuickPick(
        [
          {
            label: `$(key) Configure ${displayName} API Key`,
            detail: `Format: APIKey/Username/StudioName (e.g., 26e4d40e.../abhay/vision-model)`,
            action: "updateApiKey"
          },
          {
            label: "$(globe) Configure Base URL (Proxy)",
            detail: `Override ${displayName} endpoint (optional)`,
            action: "baseUrl"
          }
        ],
        {
          title: `${displayName} Configuration Menu`,
          placeHolder: "Select action to perform"
        }
      );
      if (!choice) {
        Logger.debug("User cancelled Lightning AI configuration wizard");
        return;
      }
      if (choice.action === "updateApiKey") {
        await _LightningAIWizard.showSetApiKeyStep(displayName, apiKeyTemplate);
      }
      if (choice.action === "baseUrl") {
        await ProviderWizard.configureBaseUrl("lightningai", displayName);
      }
    } catch (error2) {
      Logger.error(
        `Lightning AI configuration wizard error: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
    }
  }
  /**
   * Show API key setup step
   */
  static async showSetApiKeyStep(displayName, apiKeyTemplate) {
    const result = await vscode42.window.showInputBox({
      prompt: `Enter ${displayName} API Key in format: APIKey/Username/StudioName`,
      title: `Set ${displayName} API Key`,
      placeHolder: "************************/abhay/vision-model",
      password: true,
      validateInput: (value) => {
        if (!value || value.trim() === "") {
          return null;
        }
        const parts = value.split("/");
        if (parts.length !== 3) {
          return "Invalid format. Expected: APIKey/Username/StudioName";
        }
        return null;
      }
    });
    if (result === void 0) {
      return false;
    }
    try {
      if (result.trim() === "") {
        Logger.info(`${displayName} API Key cleared`);
        await ApiKeyManager.deleteApiKey(_LightningAIWizard.PROVIDER_KEY);
      } else {
        await ApiKeyManager.setApiKey(_LightningAIWizard.PROVIDER_KEY, result.trim());
        Logger.info(`${displayName} API Key set`);
        vscode42.window.showInformationMessage(`${displayName} API Key set successfully.`);
      }
      return true;
    } catch (error2) {
      Logger.error(
        `API Key operation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
      );
      return false;
    }
  }
};

// src/providers/lightningai/provider.ts
var BASE_URL3 = "https://lightning.ai/api/v1";
var DEFAULT_MAX_OUTPUT_TOKENS3 = 16e3;
var DEFAULT_CONTEXT_LENGTH3 = 128e3;
var LightningAIProvider = class _LightningAIProvider extends GenericModelProvider {
  userAgent;
  extensionPath;
  configFilePath;
  clientCache = /* @__PURE__ */ new Map();
  constructor(context, providerKey, providerConfig, userAgent, extensionPath2) {
    super(context, providerKey, providerConfig);
    this.userAgent = userAgent;
    this.extensionPath = extensionPath2;
    this.configFilePath = path5.join(
      this.extensionPath,
      "src",
      "providers",
      "config",
      "lightningai.json"
    );
  }
  /**
   * Override refreshHandlers to also clear the OpenAI client cache
   * This ensures that when baseUrl changes, new clients are created with the correct URL
   */
  refreshHandlers() {
    if (this.clientCache && this.clientCache.size > 0) {
      Logger.debug(`[LightningAI] Clearing ${this.clientCache.size} cached OpenAI clients due to config change`);
      this.clientCache.clear();
    }
    super.refreshHandlers();
  }
  estimateMessagesTokens(msgs) {
    let total = 0;
    for (const m of msgs) {
      for (const part of m.content) {
        if (part instanceof vscode43.LanguageModelTextPart) {
          total += Math.ceil(part.value.length / 4);
        }
      }
    }
    return total;
  }
  estimateToolTokens(tools) {
    if (!tools || tools.length === 0) {
      return 0;
    }
    try {
      const json = JSON.stringify(tools);
      return Math.ceil(json.length / 4);
    } catch {
      return 0;
    }
  }
  async prepareLanguageModelChatInformation(options, _token) {
    const apiKey = await this.ensureApiKey(options.silent ?? true);
    if (!apiKey) {
      if (this.providerConfig.models && this.providerConfig.models.length > 0) {
        return this.providerConfig.models.map((m) => this.modelConfigToInfo(m));
      }
      return [];
    }
    let models = [];
    try {
      models = await this.fetchModels(apiKey);
      this.updateConfigFileAsync(models);
    } catch (err) {
      Logger.warn("[LightningAI] Failed to fetch models, using cached config");
      return this.providerConfig.models.map((m) => this.modelConfigToInfo(m));
    }
    const infos = models.map((m) => {
      const modalities = m.architecture?.input_modalities ?? [];
      const vision = Array.isArray(modalities) && modalities.includes("image");
      const supportsTools = true;
      const contextLen = m.context_length ?? DEFAULT_CONTEXT_LENGTH3;
      let maxOutput = m.max_tokens && m.max_tokens > 0 ? m.max_tokens : DEFAULT_MAX_OUTPUT_TOKENS3;
      if (maxOutput >= contextLen) {
        maxOutput = Math.min(contextLen / 2, DEFAULT_MAX_OUTPUT_TOKENS3);
      }
      maxOutput = Math.floor(
        Math.max(1, Math.min(maxOutput, contextLen - 1024))
      );
      const maxInput = Math.max(1, contextLen - maxOutput);
      return {
        id: m.id,
        name: m.name || m.id,
        tooltip: m.description || `${m.id} by Lightning AI`,
        family: m.id,
        version: "1.0.0",
        maxInputTokens: maxInput,
        maxOutputTokens: maxOutput,
        capabilities: {
          toolCalling: supportsTools,
          imageInput: vision
        }
      };
    });
    const dedupedInfos = this.dedupeModelInfos(infos);
    this._chatEndpoints = dedupedInfos.map((info) => ({
      model: info.id,
      modelMaxPromptTokens: info.maxInputTokens + info.maxOutputTokens
    }));
    return dedupedInfos;
  }
  async provideLanguageModelChatInformation(options, _token) {
    return this.prepareLanguageModelChatInformation(
      { silent: options.silent ?? false },
      _token
    );
  }
  async fetchModels(apiKey) {
    const baseUrl = this.providerConfig.baseUrl || BASE_URL3;
    const resp = await fetch(`${baseUrl}/models`, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "User-Agent": this.userAgent
      }
    });
    if (!resp.ok) {
      let text = "";
      try {
        text = await resp.text();
      } catch {
      }
      throw new Error(`Failed to fetch Lightning AI models: ${resp.status} ${text}`);
    }
    const parsed = await resp.json();
    return parsed.data ?? [];
  }
  /**
   * Update config file asynchronously in background
   */
  updateConfigFileAsync(models) {
    (async () => {
      try {
        if (!fs3.existsSync(this.configFilePath)) {
          return;
        }
        const modelConfigs = models.map((m) => {
          const modalities = m.architecture?.input_modalities ?? [];
          const vision = Array.isArray(modalities) && modalities.includes("image");
          const contextLen = m.context_length ?? DEFAULT_CONTEXT_LENGTH3;
          const maxOutput = m.max_tokens && m.max_tokens > 0 ? m.max_tokens : DEFAULT_MAX_OUTPUT_TOKENS3;
          const maxInput = Math.max(1, contextLen - maxOutput);
          return {
            id: m.id,
            name: m.name || m.id,
            tooltip: m.description || `${m.id} by Lightning AI`,
            maxInputTokens: maxInput,
            maxOutputTokens: maxOutput,
            model: m.id,
            capabilities: {
              toolCalling: true,
              imageInput: vision
            }
          };
        });
        let existingConfig;
        try {
          const configContent = fs3.readFileSync(this.configFilePath, "utf8");
          existingConfig = JSON.parse(configContent);
        } catch {
          existingConfig = {
            displayName: "Lightning AI",
            baseUrl: BASE_URL3,
            apiKeyTemplate: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            models: []
          };
        }
        const updatedConfig = {
          ...existingConfig,
          models: modelConfigs
        };
        fs3.writeFileSync(
          this.configFilePath,
          JSON.stringify(updatedConfig, null, 4),
          "utf8"
        );
        Logger.info(`[LightningAI] Auto-updated config with ${modelConfigs.length} models`);
      } catch (err) {
        Logger.warn(`[LightningAI] Background config update failed:`, err);
      }
    })();
  }
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    await RateLimiter.getInstance(this.providerKey, 2, 1e3).throttle(
      this.providerConfig.displayName
    );
    try {
      const apiKey = await this.ensureApiKey(true);
      if (!apiKey) {
        throw new Error("Lightning AI API key not found");
      }
      validateRequest(
        messages
      );
      if (options.tools && options.tools.length > 128) {
        throw new Error("Cannot have more than 128 tools per request.");
      }
      const inputTokenCount = this.estimateMessagesTokens(messages);
      const convertedTools = options.tools ? convertTools({
        ...options,
        tools: options.tools
      }) : {};
      const toolTokenCount = convertedTools.tools ? this.estimateToolTokens(
        convertedTools.tools
      ) : 0;
      const tokenLimit = Math.max(1, model.maxInputTokens);
      if (inputTokenCount + toolTokenCount > tokenLimit) {
        throw new Error("Message exceeds token limit.");
      }
      const client = await this.createOpenAIClient(apiKey);
      const modelConfig = this.providerConfig.models.find(
        (m) => m.model === model.id || m.id === model.id
      );
      const openaiMessages = this.openaiHandler.convertMessagesToOpenAI(
        messages,
        model.capabilities || void 0,
        modelConfig
      );
      const createParams = {
        model: model.id,
        messages: openaiMessages,
        stream: true,
        stream_options: { include_usage: true },
        max_tokens: Math.min(
          options.modelOptions?.max_tokens || 4096,
          model.maxOutputTokens
        )
      };
      const userTemperature = options.modelOptions?.temperature ?? ConfigManager.getTemperature();
      const userTopP = ConfigManager.getTopP();
      if (userTemperature !== void 0 && userTemperature !== 1) {
        createParams.temperature = userTemperature;
      } else if (userTopP !== void 0 && userTopP !== 1) {
        createParams.top_p = userTopP;
      } else {
        createParams.temperature = userTemperature;
      }
      if (options.modelOptions) {
        const mo = options.modelOptions;
        if (typeof mo.stop === "string" || Array.isArray(mo.stop)) {
          createParams.stop = mo.stop;
        }
        if (typeof mo.frequency_penalty === "number") {
          createParams.frequency_penalty = mo.frequency_penalty;
        }
        if (typeof mo.presence_penalty === "number") {
          createParams.presence_penalty = mo.presence_penalty;
        }
      }
      if (convertedTools.tools && model.capabilities?.toolCalling) {
        createParams.tools = convertedTools.tools;
        createParams.tool_choice = convertedTools.tool_choice;
      }
      const abortController = new AbortController();
      token.onCancellationRequested(() => abortController.abort());
      const stream = client.chat.completions.stream(createParams, {
        signal: abortController.signal
      });
      let currentThinkingId = null;
      let thinkingContentBuffer = "";
      let _hasReceivedContent = false;
      let hasThinkingContent = false;
      const toolCallIds = /* @__PURE__ */ new Map();
      const seenToolCalls = /* @__PURE__ */ new Set();
      const toolCallBuffers = /* @__PURE__ */ new Map();
      let legacyFunctionCallBuffer;
      const reportToolCall = (callId, name, args) => {
        const isSyntheticId = callId.startsWith("tool_call_") || callId.startsWith("tool_call_legacy_");
        let argsKey = "";
        if (isSyntheticId) {
          try {
            argsKey = JSON.stringify(args);
          } catch {
            argsKey = "";
          }
        }
        const dedupeKey = isSyntheticId ? `${name}:${argsKey}` : `${callId}:${name}`;
        if (seenToolCalls.has(dedupeKey)) {
          return;
        }
        seenToolCalls.add(dedupeKey);
        if (currentThinkingId) {
          try {
            progress.report(new vscode43.LanguageModelThinkingPart("", currentThinkingId));
          } catch {
          }
          currentThinkingId = null;
        }
        try {
          progress.report(new vscode43.LanguageModelToolCallPart(callId, name, args));
          _hasReceivedContent = true;
        } catch (e) {
          Logger.warn(
            "[LightningAI] Failed to report tool call",
            e instanceof Error ? e.message : String(e)
          );
        }
      };
      const flushBufferedToolCalls = () => {
        for (const [idx, buf] of toolCallBuffers.entries()) {
          if (!buf.name) {
            continue;
          }
          const callId = buf.id || toolCallIds.get(idx) || `tool_call_${idx}_${Date.now()}`;
          let parsedArgs = {};
          try {
            parsedArgs = JSON.parse(buf.arguments || "{}");
          } catch {
            parsedArgs = { value: buf.arguments };
          }
          reportToolCall(callId, buf.name, parsedArgs);
        }
      };
      stream.on("chunk", (chunk) => {
        if (token.isCancellationRequested) return;
        if (chunk.choices && chunk.choices.length > 0) {
          for (const choice of chunk.choices) {
            if (choice.delta?.tool_calls) {
              for (const toolCall of choice.delta.tool_calls) {
                if (toolCall.id && toolCall.index !== void 0) {
                  toolCallIds.set(toolCall.index, toolCall.id);
                }
                const idx = toolCall.index ?? 0;
                const existing = toolCallBuffers.get(idx) ?? { arguments: "" };
                if (toolCall.id) {
                  existing.id = toolCall.id;
                }
                const fn = toolCall.function;
                if (fn?.name) {
                  existing.name = fn.name;
                }
                if (typeof fn?.arguments === "string" && fn.arguments.length > 0) {
                  existing.arguments += fn.arguments;
                }
                toolCallBuffers.set(idx, existing);
              }
            }
            const legacy = choice.delta?.function_call;
            if (legacy) {
              legacyFunctionCallBuffer = legacyFunctionCallBuffer ?? { arguments: "" };
              if (legacy.name) {
                legacyFunctionCallBuffer.name = legacy.name;
              }
              if (typeof legacy.arguments === "string" && legacy.arguments.length > 0) {
                legacyFunctionCallBuffer.arguments += legacy.arguments;
              }
            }
            const delta = choice.delta;
            const reasoningContent = delta?.reasoning ?? delta?.reasoning_content;
            if (reasoningContent && typeof reasoningContent === "string") {
              if (!currentThinkingId) {
                currentThinkingId = `lightningai_thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
              }
              thinkingContentBuffer += reasoningContent;
              try {
                progress.report(
                  new vscode43.LanguageModelThinkingPart(
                    thinkingContentBuffer,
                    currentThinkingId
                  )
                );
                thinkingContentBuffer = "";
                hasThinkingContent = true;
              } catch {
              }
            }
            const finishReason = choice?.finish_reason;
            if (finishReason === "tool_calls") {
              flushBufferedToolCalls();
            }
            if (finishReason === "function_call" && legacyFunctionCallBuffer?.name) {
              let parsedArgs = {};
              try {
                parsedArgs = JSON.parse(legacyFunctionCallBuffer.arguments || "{}");
              } catch {
                parsedArgs = { value: legacyFunctionCallBuffer.arguments };
              }
              const callId = `tool_call_legacy_${Date.now()}`;
              reportToolCall(callId, legacyFunctionCallBuffer.name, parsedArgs);
            }
          }
        }
      });
      stream.on("content", (delta) => {
        if (token.isCancellationRequested) return;
        if (delta && typeof delta === "string" && delta.trim().length > 0) {
          if (currentThinkingId) {
            try {
              progress.report(new vscode43.LanguageModelThinkingPart("", currentThinkingId));
            } catch {
            }
            currentThinkingId = null;
          }
          try {
            progress.report(new vscode43.LanguageModelTextPart(delta));
            _hasReceivedContent = true;
          } catch {
          }
        }
      });
      stream.on("tool_calls.function.arguments.done", (event) => {
        if (token.isCancellationRequested) return;
        const toolCallId = toolCallIds.get(event.index) || `tool_call_${event.index}_${Date.now()}`;
        let parsedArgs = {};
        if (event.parsed_arguments) {
          const result = event.parsed_arguments;
          parsedArgs = typeof result === "object" && result !== null ? result : {};
        } else {
          try {
            parsedArgs = JSON.parse(event.arguments || "{}");
          } catch {
            parsedArgs = { value: event.arguments };
          }
        }
        reportToolCall(toolCallId, event.name, parsedArgs);
      });
      await stream.finalChatCompletion();
      flushBufferedToolCalls();
      if (currentThinkingId) {
        try {
          progress.report(new vscode43.LanguageModelThinkingPart("", currentThinkingId));
        } catch {
        }
      }
      if (hasThinkingContent && !_hasReceivedContent) {
        progress.report(new vscode43.LanguageModelTextPart("<think/>"));
      }
    } catch (err) {
      const isAbort = token.isCancellationRequested || err instanceof Error && err.name === "AbortError";
      if (!isAbort) {
        const isQuotaError = err instanceof Error && err.status === 402;
        if (isQuotaError) {
          Logger.warn(`[LightningAI] Quota exceeded (402) for model ${model.id}`);
          throw new Error(`Lightning AI quota exceeded for model ${model.id}. Please check your account balance or try again later.`);
        }
        const isAuthError = err instanceof Error && err.status === 401;
        if (isAuthError) {
          Logger.warn(`[LightningAI] Authentication failed (401) for model ${model.id}`);
          throw new Error(`Lightning AI authentication failed. Please check your API key format (APIKey/Username/StudioName) and try again.`);
        }
        Logger.error(
          "[LightningAI] Chat request failed",
          err instanceof Error ? err.message : String(err)
        );
      }
      throw err;
    } finally {
      this.incrementRequestCount();
    }
  }
  /**
   * Increment global request count and update status bar
   */
  incrementRequestCount() {
    const today = (/* @__PURE__ */ new Date()).toDateString();
    const prefix = this.providerKey;
    let count = this.context?.globalState.get(`${prefix}.requestCount`) || 0;
    const lastReset = this.context?.globalState.get(`${prefix}.lastResetDate`);
    if (lastReset !== today) {
      count = 1;
      this.context?.globalState.update(`${prefix}.lastResetDate`, today);
    } else {
      count++;
    }
    this.context?.globalState.update(`${prefix}.requestCount`, count);
    Logger.debug(`[LightningAI] Global request count: ${count}`);
  }
  async createOpenAIClient(apiKey) {
    const baseUrl = this.providerConfig.baseUrl || BASE_URL3;
    const cacheKey = `lightningai:${baseUrl}`;
    const cached2 = this.clientCache.get(cacheKey);
    if (cached2) {
      cached2.lastUsed = Date.now();
      return cached2.client;
    }
    const client = new OpenAI({
      apiKey,
      baseURL: baseUrl,
      defaultHeaders: { "User-Agent": this.userAgent },
      maxRetries: 2,
      timeout: 6e4
    });
    this.clientCache.set(cacheKey, { client, lastUsed: Date.now() });
    return client;
  }
  async provideTokenCount(model, text, _token) {
    return TokenCounter.getInstance().countTokens(model, text);
  }
  async ensureApiKey(silent) {
    let apiKey = await ApiKeyManager.getApiKey(this.providerKey);
    if (!apiKey && !silent) {
      await ApiKeyManager.promptAndSetApiKey(
        this.providerKey,
        this.providerConfig.displayName,
        this.providerConfig.apiKeyTemplate
      );
      apiKey = await ApiKeyManager.getApiKey(this.providerKey);
    }
    return apiKey;
  }
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(`${providerConfig.displayName} provider activated!`);
    const ext = vscode43.extensions.getExtension("OEvortex.better-copilot-chat");
    const extVersion = ext?.packageJSON?.version ?? "unknown";
    const vscodeVersion = vscode43.version;
    const ua = `better-copilot-chat/${extVersion} VSCode/${vscodeVersion}`;
    const provider = new _LightningAIProvider(
      context,
      providerKey,
      providerConfig,
      ua,
      context.extensionPath
    );
    const providerDisposable = vscode43.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const setApiKeyCommand = vscode43.commands.registerCommand(
      `chp.${providerKey}.setApiKey`,
      async () => {
        await LightningAIWizard.startWizard(
          providerConfig.displayName,
          providerConfig.apiKeyTemplate
        );
        await provider.modelInfoCache?.invalidateCache(providerKey);
        provider._onDidChangeLanguageModelChatInformation.fire(void 0);
      }
    );
    const configWizardCommand = vscode43.commands.registerCommand(
      `chp.${providerKey}.configWizard`,
      async () => {
        await LightningAIWizard.startWizard(
          providerConfig.displayName,
          providerConfig.apiKeyTemplate
        );
      }
    );
    const disposables = [providerDisposable, setApiKeyCommand, configWizardCommand];
    for (const d of disposables) {
      context.subscriptions.push(d);
    }
    return { provider, disposables };
  }
};

// src/providers/minimax/minimaxProvider.ts
var vscode44 = __toESM(require("vscode"));
var MiniMaxProvider = class _MiniMaxProvider extends GenericModelProvider {
  /**
   * Static factory method - Create and activate MiniMax provider
   */
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(
      `${providerConfig.displayName} dedicated model extension activated!`
    );
    const provider = new _MiniMaxProvider(context, providerKey, providerConfig);
    const providerDisposable = vscode44.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const setApiKeyCommand = vscode44.commands.registerCommand(
      `chp.${providerKey}.setApiKey`,
      async () => {
        await MiniMaxWizard.startWizard(
          providerConfig.displayName,
          providerConfig.apiKeyTemplate
        );
        await provider.modelInfoCache?.invalidateCache(providerKey);
        provider._onDidChangeLanguageModelChatInformation.fire();
      }
    );
    const setCodingKeyCommand = vscode44.commands.registerCommand(
      `chp.${providerKey}.setCodingPlanApiKey`,
      async () => {
        await MiniMaxWizard.setCodingPlanApiKey(
          providerConfig.displayName,
          providerConfig.apiKeyTemplate
        );
        await provider.modelInfoCache?.invalidateCache("minimax-coding");
        provider._onDidChangeLanguageModelChatInformation.fire();
      }
    );
    const setCodingPlanEndpointCommand = vscode44.commands.registerCommand(
      `chp.${providerKey}.setCodingPlanEndpoint`,
      async () => {
        Logger.info(
          `User manually opens ${providerConfig.displayName} Coding Plan endpoint selection`
        );
        await MiniMaxWizard.setCodingPlanEndpoint(providerConfig.displayName);
      }
    );
    const configWizardCommand = vscode44.commands.registerCommand(
      `chp.${providerKey}.configWizard`,
      async () => {
        Logger.info(`Start ${providerConfig.displayName} configuration wizard`);
        await MiniMaxWizard.startWizard(
          providerConfig.displayName,
          providerConfig.apiKeyTemplate
        );
      }
    );
    const disposables = [
      providerDisposable,
      setApiKeyCommand,
      setCodingKeyCommand,
      setCodingPlanEndpointCommand,
      configWizardCommand
    ];
    for (const disposable of disposables) {
      context.subscriptions.push(disposable);
    }
    return { provider, disposables };
  }
  /**
   * Get provider key for model (considering provider field and default values)
   */
  getProviderKeyForModel(modelConfig) {
    if (modelConfig.provider) {
      return modelConfig.provider;
    }
    return this.providerKey;
  }
  /**
   * Get key for model, ensuring a valid key exists
   * @param modelConfig Model configuration
   * @returns Return available API key
   */
  async ensureApiKeyForModel(modelConfig) {
    const providerKey = this.getProviderKeyForModel(modelConfig);
    const isCodingPlan = providerKey === "minimax-coding";
    const keyType = isCodingPlan ? "Coding Plan Dedicated" : "Normal";
    const hasApiKey = await ApiKeyManager.hasValidApiKey(providerKey);
    if (hasApiKey) {
      const apiKey2 = await ApiKeyManager.getApiKey(providerKey);
      if (apiKey2) {
        return apiKey2;
      }
    }
    Logger.warn(
      `Model ${modelConfig.name} lacks ${keyType} API key, entering setup process`
    );
    if (isCodingPlan) {
      await MiniMaxWizard.setCodingPlanApiKey(
        this.providerConfig.displayName,
        this.providerConfig.apiKeyTemplate
      );
    } else {
      await MiniMaxWizard.setNormalApiKey(
        this.providerConfig.displayName,
        this.providerConfig.apiKeyTemplate
      );
    }
    const apiKey = await ApiKeyManager.getApiKey(providerKey);
    if (apiKey) {
      Logger.info(`${keyType} key setup successful`);
      return apiKey;
    }
    throw new Error(
      `${this.providerConfig.displayName}: User has not set ${keyType} API key`
    );
  }
  /**
   * Override: Get model information - add key check
   * Return all models if any key exists, no filtering
   * Specific key verification is performed during actual use (provideLanguageModelChatResponse)
   */
  async provideLanguageModelChatInformation(options, _token) {
    const hasNormalKey = await ApiKeyManager.hasValidApiKey(this.providerKey);
    const hasCodingKey = await ApiKeyManager.hasValidApiKey("minimax-coding");
    const hasAnyKey = hasNormalKey || hasCodingKey;
    if (options.silent && !hasAnyKey) {
      Logger.debug(
        `${this.providerConfig.displayName}: In silent mode, no keys detected, returning empty model list`
      );
      return [];
    }
    if (!options.silent && !hasAnyKey) {
      Logger.info(
        `${this.providerConfig.displayName}: Detected no keys configured, starting configuration wizard`
      );
      await MiniMaxWizard.startWizard(
        this.providerConfig.displayName,
        this.providerConfig.apiKeyTemplate
      );
      const normalKeyValid = await ApiKeyManager.hasValidApiKey(
        this.providerKey
      );
      const codingKeyValid = await ApiKeyManager.hasValidApiKey("minimax-coding");
      if (!normalKeyValid && !codingKeyValid) {
        Logger.warn(
          `${this.providerConfig.displayName}: User has not set any keys, returning empty model list`
        );
        return [];
      }
    }
    Logger.debug(
      `${this.providerConfig.displayName}: Return all ${this.providerConfig.models.length} models`
    );
    let models = this.providerConfig.models.map(
      (model) => this.modelConfigToInfo(model)
    );
    const rememberLastModel = ConfigManager.getRememberLastModel();
    if (rememberLastModel) {
      const lastSelectedId = this.modelInfoCache?.getLastSelectedModel(
        this.providerKey
      );
      if (lastSelectedId) {
        models = models.map((model) => ({
          ...model,
          isDefault: model.id === lastSelectedId
        }));
      }
    }
    return models;
  }
  /**
   * Override: Provide language model chat response - add pre-request key assurance mechanism
   * Ensure corresponding key exists before processing request
   */
  async provideLanguageModelChatResponse(model, messages, options, progress, _token) {
    await RateLimiter.getInstance(this.providerKey, 2, 1e3).throttle(
      this.providerConfig.displayName
    );
    const rememberLastModel = ConfigManager.getRememberLastModel();
    if (rememberLastModel) {
      this.modelInfoCache?.saveLastSelectedModel(this.providerKey, model.id).catch(
        (err) => Logger.warn(
          `[${this.providerKey}] Failed to save model selection:`,
          err
        )
      );
    }
    const modelConfig = this.providerConfig.models.find(
      (m) => m.id === model.id
    );
    if (!modelConfig) {
      const errorMessage = `Model not found: ${model.id}`;
      Logger.error(errorMessage);
      throw new Error(errorMessage);
    }
    const providerKey = this.getProviderKeyForModel(modelConfig);
    const apiKey = await this.ensureApiKeyForModel(modelConfig);
    if (!apiKey) {
      const keyType = providerKey === "minimax-coding" ? "Coding Plan Dedicated" : "Normal";
      throw new Error(
        `${this.providerConfig.displayName}: Invalid ${keyType} API key`
      );
    }
    Logger.info(
      `${this.providerConfig.displayName}: About to process request, using ${providerKey === "minimax-coding" ? "Coding Plan" : "Normal"} key - model: ${modelConfig.name}`
    );
    const sdkMode = modelConfig.sdkMode || "openai";
    const sdkName = sdkMode === "anthropic" ? "Anthropic SDK" : "OpenAI SDK";
    Logger.info(
      `${this.providerConfig.displayName} Provider starts processing request (${sdkName}): ${modelConfig.name}`
    );
    try {
      if (sdkMode === "anthropic") {
        await this.anthropicHandler.handleRequest(
          model,
          modelConfig,
          messages,
          options,
          progress,
          _token
        );
      } else {
        await this.openaiHandler.handleRequest(
          model,
          modelConfig,
          messages,
          options,
          progress,
          _token
        );
      }
    } catch (error2) {
      const errorMessage = `Error: ${error2 instanceof Error ? error2.message : "Unknown error"}`;
      Logger.error(errorMessage);
      throw error2;
    } finally {
      Logger.info(
        `${this.providerConfig.displayName}: ${model.name} Request completed`
      );
    }
  }
  async provideTokenCount(model, text, _token) {
    return TokenCounter.getInstance().countTokens(model, text);
  }
};

// src/providers/mistral/mistralProvider.ts
var vscode45 = __toESM(require("vscode"));
var MistralProvider = class _MistralProvider extends GenericModelProvider {
  mistralHandler;
  constructor(context, providerKey, providerConfig) {
    super(context, providerKey, providerConfig);
    this.mistralHandler = new MistralHandler(
      providerKey,
      providerConfig.displayName,
      providerConfig.baseUrl
    );
  }
  /**
   * Static factory method - Create and activate Mistral provider
   */
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(
      `${providerConfig.displayName} dedicated model extension activated!`
    );
    const provider = new _MistralProvider(context, providerKey, providerConfig);
    const providerDisposable = vscode45.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const setApiKeyCommand = vscode45.commands.registerCommand(
      `chp.${providerKey}.setApiKey`,
      async () => {
        await ProviderWizard.startWizard({
          providerKey,
          displayName: providerConfig.displayName,
          apiKeyTemplate: providerConfig.apiKeyTemplate,
          supportsApiKey: true,
          supportsBaseUrl: true
        });
        await provider.modelInfoCache?.invalidateCache(providerKey);
        provider._onDidChangeLanguageModelChatInformation.fire();
      }
    );
    const disposables = [providerDisposable, setApiKeyCommand];
    for (const disposable of disposables) {
      context.subscriptions.push(disposable);
    }
    return { provider, disposables };
  }
  /**
   * Override: Provide language model chat response
   */
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    Logger.info(`[Mistral] Starting request for model: ${model.name}`);
    if (ConfigManager.getRememberLastModel()) {
      this.modelInfoCache?.saveLastSelectedModel(this.providerKey, model.id).catch(
        (err) => Logger.warn(
          `[${this.providerKey}] Failed to save model selection:`,
          err
        )
      );
    }
    const modelConfig = this.providerConfig.models.find((m) => m.id === model.id);
    if (!modelConfig) {
      const errorMessage = `Model not found: ${model.id}`;
      Logger.error(errorMessage);
      throw new Error(errorMessage);
    }
    const effectiveProviderKey = modelConfig.provider || this.providerKey;
    try {
      const accounts = this.accountManager.getAccountsByProvider(
        effectiveProviderKey
      );
      const loadBalanceEnabled = this.accountManager.getLoadBalanceEnabled(
        effectiveProviderKey
      );
      const assignedAccountId = this.accountManager.getAccountIdForModel(
        effectiveProviderKey,
        model.id
      );
      if (accounts.length === 0) {
        await ApiKeyManager.ensureApiKey(
          effectiveProviderKey,
          this.providerConfig.displayName
        );
        Logger.info(
          `${this.providerConfig.displayName} Provider starts processing request (fallback mode): ${modelConfig.name}`
        );
        await this.mistralHandler.handleRequest(
          model,
          modelConfig,
          messages,
          options,
          progress,
          token
        );
        return;
      }
      const usableAccounts = accounts.filter((a) => a.status === "active").length > 0 ? accounts.filter((a) => a.status === "active") : accounts;
      const candidates = this.buildAccountCandidates(
        model.id,
        usableAccounts,
        assignedAccountId,
        loadBalanceEnabled,
        effectiveProviderKey
      );
      const activeAccount = this.accountManager.getActiveAccount(
        effectiveProviderKey
      );
      const available = loadBalanceEnabled ? candidates.filter(
        (a) => !this.accountManager.isAccountQuotaLimited(a.id)
      ) : candidates;
      let accountsToTry;
      if (available.length > 0) {
        if (activeAccount && available.some((a) => a.id === activeAccount.id)) {
          accountsToTry = [
            activeAccount,
            ...available.filter((a) => a.id !== activeAccount.id)
          ];
        } else {
          accountsToTry = available;
        }
      } else {
        if (activeAccount && candidates.some((a) => a.id === activeAccount.id)) {
          accountsToTry = [
            activeAccount,
            ...candidates.filter((a) => a.id !== activeAccount.id)
          ];
        } else {
          accountsToTry = candidates;
        }
      }
      Logger.debug(
        `[${effectiveProviderKey}] Active account: ${activeAccount?.displayName || "none"}, accountsToTry: ${accountsToTry.map((a) => a.displayName).join(", ")}`
      );
      let lastError;
      let switchedAccount = false;
      for (const account of accountsToTry) {
        const credentials = await this.accountManager.getCredentials(account.id);
        if (!credentials) {
          lastError = new Error(
            `Missing credentials for ${account.displayName}`
          );
          continue;
        }
        const configWithAuth = {
          ...modelConfig,
          apiKey: "apiKey" in credentials ? credentials.apiKey : void 0,
          baseUrl: "endpoint" in credentials ? credentials.endpoint : void 0,
          customHeader: "customHeaders" in credentials ? credentials.customHeaders : void 0
        };
        if ("accessToken" in credentials) {
          configWithAuth.accessToken = credentials.accessToken;
          configWithAuth.apiKey = credentials.accessToken;
        }
        try {
          Logger.info(
            `${this.providerConfig.displayName}: ${model.name} using account "${account.displayName}" (ID: ${account.id})`
          );
          await this.mistralHandler.handleRequest(
            model,
            configWithAuth,
            messages,
            options,
            progress,
            token,
            account.id
          );
          this.lastUsedAccountByModel.set(model.id, account.id);
          if (switchedAccount) {
            Logger.info(
              `[${effectiveProviderKey}] Saving account "${account.displayName}" as preferred for model ${model.id}`
            );
            await this.accountManager.setAccountForModel(
              effectiveProviderKey,
              model.id,
              account.id
            );
          }
          return;
        } catch (error2) {
          switchedAccount = true;
          if (this.isLongTermQuotaExhausted(error2)) {
            if (loadBalanceEnabled) {
              Logger.warn(
                `[${effectiveProviderKey}] Account ${account.displayName} quota exhausted, switching...`
              );
              lastError = error2;
              continue;
            }
            throw error2;
          }
          if (loadBalanceEnabled && this.isQuotaError(error2)) {
            Logger.warn(
              `[${effectiveProviderKey}] Account ${account.displayName} rate limited, switching...`
            );
            lastError = error2;
            continue;
          }
          throw error2;
        }
      }
      if (lastError) {
        throw lastError;
      }
      throw new Error(`No available accounts for ${effectiveProviderKey}`);
    } catch (error2) {
      Logger.error(
        `[Mistral] Request failed: ${error2 instanceof Error ? error2.message : String(error2)}`
      );
      throw error2;
    } finally {
      Logger.info(
        `${this.providerConfig.displayName}: ${model.name} Request completed`
      );
    }
  }
  async provideTokenCount(model, text, _token) {
    return TokenCounter.getInstance().countTokens(model, text);
  }
};

// src/providers/ollama/ollamaProvider.ts
var vscode46 = __toESM(require("vscode"));
init_apiKeyManager();
init_configManager();
init_logger();
var DEFAULT_MAX_OUTPUT_TOKENS4 = 16e3;
var DEFAULT_CONTEXT_LENGTH4 = 262e3;
var OllamaProvider = class _OllamaProvider extends GenericModelProvider {
  userAgent;
  clientCache = /* @__PURE__ */ new Map();
  constructor(context, providerKey, providerConfig, userAgent) {
    super(context, providerKey, providerConfig);
    this.userAgent = userAgent;
  }
  /**
   * Override refreshHandlers to also clear the OpenAI client cache
   * This ensures that when baseUrl changes, new clients are created with the correct URL
   */
  refreshHandlers() {
    if (this.clientCache && this.clientCache.size > 0) {
      Logger.debug(`[Ollama] Clearing ${this.clientCache.size} cached OpenAI clients due to config change`);
      this.clientCache.clear();
    }
    super.refreshHandlers();
  }
  async prepareLanguageModelChatInformation(options, _token) {
    const apiKey = await this.ensureApiKey(options.silent ?? true);
    if (!apiKey) {
      return [];
    }
    const infos = this.providerConfig.models.map((model) => {
      const capabilities = {
        toolCalling: model.capabilities?.toolCalling ?? false,
        imageInput: model.capabilities?.imageInput ?? false
      };
      return {
        id: model.id,
        name: model.name,
        tooltip: `${model.name} by Ollama`,
        family: "ollama",
        version: "1.0.0",
        maxInputTokens: model.maxInputTokens || DEFAULT_CONTEXT_LENGTH4,
        maxOutputTokens: model.maxOutputTokens || DEFAULT_MAX_OUTPUT_TOKENS4,
        capabilities
      };
    });
    this._chatEndpoints = infos.map((info) => ({
      model: info.id,
      modelMaxPromptTokens: info.maxInputTokens + info.maxOutputTokens
    }));
    return infos;
  }
  async provideLanguageModelChatInformation(options, _token) {
    return this.prepareLanguageModelChatInformation(
      { silent: options.silent ?? false },
      _token
    );
  }
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    await RateLimiter.getInstance(this.providerKey, 2, 1e3).throttle(
      this.providerConfig.displayName
    );
    try {
      const rememberLastModel = ConfigManager.getRememberLastModel();
      if (rememberLastModel) {
        this.modelInfoCache?.saveLastSelectedModel(this.providerKey, model.id).catch(
          (err) => Logger.warn(
            "[Ollama] Failed to save model selection",
            err instanceof Error ? err.message : String(err)
          )
        );
      }
      const apiKey = await this.ensureApiKey(false);
      if (!apiKey) {
        throw new Error("Ollama API key not found");
      }
      if (options.tools && options.tools.length > 128) {
        throw new Error("Cannot have more than 128 tools per request.");
      }
      const modelConfig = this.providerConfig.models.find(
        (m) => m.id === model.id
      );
      const client = await this.createOpenAIClient(apiKey, modelConfig);
      const openaiMessages = this.openaiHandler.convertMessagesToOpenAI(
        messages,
        model.capabilities || void 0,
        modelConfig
      );
      const createParams = {
        model: model.id,
        messages: openaiMessages,
        stream: true,
        stream_options: { include_usage: true },
        max_tokens: Math.min(
          options.modelOptions?.max_tokens || 4096,
          model.maxOutputTokens
        ),
        temperature: options.modelOptions?.temperature ?? ConfigManager.getTemperature(),
        top_p: ConfigManager.getTopP()
      };
      if (options.modelOptions) {
        const mo = options.modelOptions;
        if (typeof mo.stop === "string" || Array.isArray(mo.stop)) {
          createParams.stop = mo.stop;
        }
        if (typeof mo.frequency_penalty === "number") {
          createParams.frequency_penalty = mo.frequency_penalty;
        }
        if (typeof mo.presence_penalty === "number") {
          createParams.presence_penalty = mo.presence_penalty;
        }
      }
      if (options.tools && options.tools.length > 0 && model.capabilities?.toolCalling) {
        createParams.tools = this.openaiHandler.convertToolsToOpenAI([
          ...options.tools
        ]);
        createParams.tool_choice = "auto";
      }
      const abortController = new AbortController();
      token.onCancellationRequested(() => abortController.abort());
      const stream = client.chat.completions.stream(createParams, {
        signal: abortController.signal
      });
      let currentThinkingId = null;
      let thinkingContentBuffer = "";
      let _hasReceivedContent = false;
      let hasThinkingContent = false;
      const toolCallIds = /* @__PURE__ */ new Map();
      stream.on("chunk", (chunk) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (chunk.choices && chunk.choices.length > 0) {
          for (const choice of chunk.choices) {
            if (choice.delta?.tool_calls) {
              for (const toolCall of choice.delta.tool_calls) {
                if (toolCall.id && toolCall.index !== void 0) {
                  toolCallIds.set(toolCall.index, toolCall.id);
                }
              }
            }
            const delta = choice.delta;
            const reasoningContent = delta?.reasoning ?? delta?.reasoning_content;
            if (reasoningContent && typeof reasoningContent === "string") {
              if (!currentThinkingId) {
                currentThinkingId = `ollama_thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
              }
              thinkingContentBuffer += reasoningContent;
              try {
                progress.report(
                  new vscode46.LanguageModelThinkingPart(
                    thinkingContentBuffer,
                    currentThinkingId
                  )
                );
                thinkingContentBuffer = "";
                hasThinkingContent = true;
              } catch (e) {
                Logger.warn(
                  "[Ollama] Failed to report thinking",
                  e instanceof Error ? e.message : String(e)
                );
              }
            }
          }
        }
      });
      stream.on("content", (delta) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (delta && typeof delta === "string" && delta.trim().length > 0) {
          if (currentThinkingId) {
            try {
              progress.report(
                new vscode46.LanguageModelThinkingPart(
                  "",
                  currentThinkingId
                )
              );
            } catch {
            }
            currentThinkingId = null;
          }
          try {
            progress.report(new vscode46.LanguageModelTextPart(delta));
            _hasReceivedContent = true;
          } catch (e) {
            Logger.warn(
              "[Ollama] Failed to report content",
              e instanceof Error ? e.message : String(e)
            );
          }
        }
      });
      stream.on("tool_calls.function.arguments.done", (event) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (currentThinkingId) {
          try {
            progress.report(
              new vscode46.LanguageModelThinkingPart(
                "",
                currentThinkingId
              )
            );
          } catch {
          }
          currentThinkingId = null;
        }
        const toolCallId = toolCallIds.get(event.index) || `tool_call_${event.index}_${Date.now()}`;
        let parsedArgs = {};
        if (event.parsed_arguments) {
          const result = event.parsed_arguments;
          parsedArgs = typeof result === "object" && result !== null ? result : {};
        } else {
          try {
            parsedArgs = JSON.parse(event.arguments || "{}");
          } catch {
            parsedArgs = { value: event.arguments };
          }
        }
        try {
          progress.report(
            new vscode46.LanguageModelToolCallPart(
              toolCallId,
              event.name,
              parsedArgs
            )
          );
          _hasReceivedContent = true;
        } catch (e) {
          Logger.warn(
            "[Ollama] Failed to report tool call",
            e instanceof Error ? e.message : String(e)
          );
        }
      });
      try {
        await stream.finalChatCompletion();
      } catch (err) {
        if (err instanceof Error && err.message.includes("missing finish_reason")) {
          Logger.debug(
            "[Ollama] Stream completed without finish_reason, ignoring error"
          );
        } else {
          throw err;
        }
      }
      if (currentThinkingId) {
        try {
          progress.report(
            new vscode46.LanguageModelThinkingPart(
              "",
              currentThinkingId
            )
          );
        } catch {
        }
      }
      if (hasThinkingContent && !_hasReceivedContent) {
        progress.report(new vscode46.LanguageModelTextPart("<think/>"));
        Logger.warn(
          "[Ollama] End of message stream has only thinking content and no text content, added <think/> placeholder as output"
        );
      }
    } catch (error2) {
      Logger.error(
        "[Ollama] Chat request failed",
        error2 instanceof Error ? error2.message : String(error2)
      );
      throw error2;
    }
  }
  /**
   * Create OpenAI client for Ollama API
   */
  async createOpenAIClient(apiKey, modelConfig) {
    const baseUrl = modelConfig?.baseUrl || this.providerConfig.baseUrl || "http://localhost:11434/v1";
    const cacheKey = `ollama:${baseUrl}`;
    const cached2 = this.clientCache.get(cacheKey);
    if (cached2) {
      cached2.lastUsed = Date.now();
      return cached2.client;
    }
    const client = new OpenAI({
      apiKey,
      baseURL: baseUrl,
      defaultHeaders: {
        "User-Agent": this.userAgent
      },
      maxRetries: 2,
      timeout: 6e4
    });
    this.clientCache.set(cacheKey, { client, lastUsed: Date.now() });
    return client;
  }
  async provideTokenCount(model, text, _token) {
    return TokenCounter.getInstance().countTokens(model, text);
  }
  async ensureApiKey(silent) {
    let apiKey = await ApiKeyManager.getApiKey(this.providerKey);
    if (!apiKey && !silent) {
      await ApiKeyManager.promptAndSetApiKey(
        this.providerKey,
        this.providerConfig.displayName,
        this.providerConfig.apiKeyTemplate
      );
      apiKey = await ApiKeyManager.getApiKey(this.providerKey);
    }
    return apiKey;
  }
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(`${providerConfig.displayName} provider activated!`);
    const ext = vscode46.extensions.getExtension("OEvortex.better-copilot-chat");
    const extVersion = ext?.packageJSON?.version ?? "unknown";
    const vscodeVersion = vscode46.version;
    const ua = `better-copilot-chat/${extVersion} VSCode/${vscodeVersion}`;
    const provider = new _OllamaProvider(context, providerKey, providerConfig, ua);
    const providerDisposable = vscode46.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const setApiKeyCommand = vscode46.commands.registerCommand(
      `chp.${providerKey}.setApiKey`,
      async () => {
        await ProviderWizard.startWizard({
          providerKey,
          displayName: providerConfig.displayName,
          apiKeyTemplate: providerConfig.apiKeyTemplate,
          supportsApiKey: true,
          supportsBaseUrl: true
        });
        await provider.modelInfoCache?.invalidateCache(providerKey);
        provider._onDidChangeLanguageModelChatInformation.fire(void 0);
      }
    );
    const disposables = [providerDisposable, setApiKeyCommand];
    for (const disposable of disposables) {
      context.subscriptions.push(disposable);
    }
    return { provider, disposables };
  }
};

// src/providers/opencode/opencodeProvider.ts
var fs4 = __toESM(require("node:fs"));
var path6 = __toESM(require("node:path"));
var vscode47 = __toESM(require("vscode"));
init_apiKeyManager();
init_configManager();
init_logger();
var BASE_URL4 = "https://opencode.ai/zen/v1";
var DEFAULT_MAX_OUTPUT_TOKENS5 = 16e3;
var DEFAULT_CONTEXT_LENGTH5 = 128e3;
var OpenCodeProvider = class _OpenCodeProvider extends GenericModelProvider {
  userAgent;
  extensionPath;
  configFilePath;
  clientCache = /* @__PURE__ */ new Map();
  constructor(context, providerKey, providerConfig, userAgent, extensionPath2) {
    super(context, providerKey, providerConfig);
    this.userAgent = userAgent;
    this.extensionPath = extensionPath2;
    this.configFilePath = path6.join(
      this.extensionPath,
      "src",
      "providers",
      "config",
      "opencode.json"
    );
  }
  /**
   * Override refreshHandlers to also clear the OpenAI client cache
   * This ensures that when baseUrl changes, new clients are created with the correct URL
   */
  refreshHandlers() {
    if (this.clientCache && this.clientCache.size > 0) {
      Logger.debug(`[OpenCode] Clearing ${this.clientCache.size} cached OpenAI clients due to config change`);
      this.clientCache.clear();
    }
    super.refreshHandlers();
  }
  estimateMessagesTokens(msgs) {
    let total = 0;
    for (const m of msgs) {
      for (const part of m.content) {
        if (part instanceof vscode47.LanguageModelTextPart) {
          total += Math.ceil(part.value.length / 4);
        }
      }
    }
    return total;
  }
  estimateToolTokens(tools) {
    if (!tools || tools.length === 0) {
      return 0;
    }
    try {
      const json = JSON.stringify(tools);
      return Math.ceil(json.length / 4);
    } catch {
      return 0;
    }
  }
  async prepareLanguageModelChatInformation(options, _token) {
    const apiKey = await this.ensureApiKey(options.silent ?? true);
    if (!apiKey) {
      if (this.providerConfig.models && this.providerConfig.models.length > 0) {
        return this.providerConfig.models.map((m) => this.modelConfigToInfo(m));
      }
      return [];
    }
    let models = [];
    try {
      models = await this.fetchModels(apiKey);
      this.updateConfigFileAsync(models);
    } catch (err) {
      Logger.warn("[OpenCode] Failed to fetch models, using cached config");
      return this.providerConfig.models.map((m) => this.modelConfigToInfo(m));
    }
    const infos = models.map((m) => {
      const modalities = m.input_modalities ?? [];
      const vision = Array.isArray(modalities) && modalities.includes("image");
      const supportsTools = true;
      const contextLen = m.context_length ?? DEFAULT_CONTEXT_LENGTH5;
      let maxOutput = m.max_output_length ?? DEFAULT_MAX_OUTPUT_TOKENS5;
      if (maxOutput >= contextLen) {
        maxOutput = Math.min(contextLen / 2, DEFAULT_MAX_OUTPUT_TOKENS5);
      }
      maxOutput = Math.floor(
        Math.max(1, Math.min(maxOutput, contextLen - 1024))
      );
      const maxInput = Math.max(1, contextLen - maxOutput);
      return {
        id: m.id,
        name: m.id,
        tooltip: `${m.id} by OpenCode`,
        family: m.id,
        version: "1.0.0",
        maxInputTokens: maxInput,
        maxOutputTokens: maxOutput,
        capabilities: {
          toolCalling: supportsTools,
          imageInput: vision
        }
      };
    });
    const dedupedInfos = this.dedupeModelInfos(infos);
    this._chatEndpoints = dedupedInfos.map((info) => ({
      model: info.id,
      modelMaxPromptTokens: info.maxInputTokens + info.maxOutputTokens
    }));
    return dedupedInfos;
  }
  async provideLanguageModelChatInformation(options, _token) {
    return this.prepareLanguageModelChatInformation(
      { silent: options.silent ?? false },
      _token
    );
  }
  async fetchModels(apiKey) {
    const baseUrl = this.providerConfig.baseUrl || BASE_URL4;
    const resp = await fetch(`${baseUrl}/models`, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "User-Agent": this.userAgent
      }
    });
    if (!resp.ok) {
      let text = "";
      try {
        text = await resp.text();
      } catch {
      }
      throw new Error(`Failed to fetch OpenCode models: ${resp.status} ${text}`);
    }
    const parsed = await resp.json();
    return parsed.data ?? [];
  }
  /**
   * Update config file asynchronously in background
   */
  updateConfigFileAsync(models) {
    (async () => {
      try {
        if (!fs4.existsSync(this.configFilePath)) {
          return;
        }
        const modelConfigs = models.map((m) => {
          const modalities = m.input_modalities ?? [];
          const vision = Array.isArray(modalities) && modalities.includes("image");
          const contextLen = m.context_length ?? DEFAULT_CONTEXT_LENGTH5;
          const maxOutput = m.max_output_length ?? DEFAULT_MAX_OUTPUT_TOKENS5;
          const maxInput = Math.max(1, contextLen - maxOutput);
          return {
            id: m.id,
            name: m.id,
            tooltip: `${m.id} by OpenCode`,
            maxInputTokens: maxInput,
            maxOutputTokens: maxOutput,
            model: m.id,
            capabilities: {
              toolCalling: true,
              imageInput: vision
            }
          };
        });
        let existingConfig;
        try {
          const configContent = fs4.readFileSync(this.configFilePath, "utf8");
          existingConfig = JSON.parse(configContent);
        } catch {
          existingConfig = {
            displayName: "OpenCode",
            baseUrl: BASE_URL4,
            apiKeyTemplate: "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            models: []
          };
        }
        const updatedConfig = {
          ...existingConfig,
          models: modelConfigs
        };
        fs4.writeFileSync(
          this.configFilePath,
          JSON.stringify(updatedConfig, null, 4),
          "utf8"
        );
        Logger.info(`[OpenCode] Auto-updated config with ${modelConfigs.length} models`);
      } catch (err) {
        Logger.warn(`[OpenCode] Background config update failed:`, err);
      }
    })();
  }
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    await RateLimiter.getInstance(this.providerKey, 2, 1e3).throttle(
      this.providerConfig.displayName
    );
    try {
      const apiKey = await this.ensureApiKey(true);
      if (!apiKey) {
        throw new Error("OpenCode API key not found");
      }
      validateRequest(
        messages
      );
      if (options.tools && options.tools.length > 128) {
        throw new Error("Cannot have more than 128 tools per request.");
      }
      const inputTokenCount = this.estimateMessagesTokens(messages);
      const toolTokenCount = options.tools ? this.estimateToolTokens(
        this.openaiHandler.convertToolsToOpenAI([...options.tools])
      ) : 0;
      const tokenLimit = Math.max(1, model.maxInputTokens);
      if (inputTokenCount + toolTokenCount > tokenLimit) {
        throw new Error("Message exceeds token limit.");
      }
      const client = await this.createOpenAIClient(apiKey);
      const modelConfig = this.providerConfig.models.find(
        (m) => m.model === model.id || m.id === model.id
      );
      const openaiMessages = this.openaiHandler.convertMessagesToOpenAI(
        messages,
        model.capabilities || void 0,
        modelConfig
      );
      const createParams = {
        model: model.id,
        messages: openaiMessages,
        stream: true,
        stream_options: { include_usage: true },
        max_tokens: Math.min(
          options.modelOptions?.max_tokens || 4096,
          model.maxOutputTokens
        ),
        temperature: options.modelOptions?.temperature ?? ConfigManager.getTemperature(),
        top_p: ConfigManager.getTopP()
      };
      if (options.modelOptions) {
        const mo = options.modelOptions;
        if (typeof mo.stop === "string" || Array.isArray(mo.stop)) {
          createParams.stop = mo.stop;
        }
        if (typeof mo.frequency_penalty === "number") {
          createParams.frequency_penalty = mo.frequency_penalty;
        }
        if (typeof mo.presence_penalty === "number") {
          createParams.presence_penalty = mo.presence_penalty;
        }
      }
      if (options.tools && options.tools.length > 0 && model.capabilities?.toolCalling) {
        createParams.tools = this.openaiHandler.convertToolsToOpenAI([...options.tools]);
        createParams.tool_choice = "auto";
      }
      const abortController = new AbortController();
      token.onCancellationRequested(() => abortController.abort());
      const stream = client.chat.completions.stream(createParams, {
        signal: abortController.signal
      });
      let currentThinkingId = null;
      let thinkingContentBuffer = "";
      let _hasReceivedContent = false;
      let hasThinkingContent = false;
      const toolCallIds = /* @__PURE__ */ new Map();
      const seenToolCalls = /* @__PURE__ */ new Set();
      const toolCallBuffers = /* @__PURE__ */ new Map();
      let legacyFunctionCallBuffer;
      const reportToolCall = (callId, name, args) => {
        const isSyntheticId = callId.startsWith("tool_call_") || callId.startsWith("tool_call_legacy_");
        let argsKey = "";
        if (isSyntheticId) {
          try {
            argsKey = JSON.stringify(args);
          } catch {
            argsKey = "";
          }
        }
        const dedupeKey = isSyntheticId ? `${name}:${argsKey}` : `${callId}:${name}`;
        if (seenToolCalls.has(dedupeKey)) {
          return;
        }
        seenToolCalls.add(dedupeKey);
        if (currentThinkingId) {
          try {
            progress.report(new vscode47.LanguageModelThinkingPart("", currentThinkingId));
          } catch {
          }
          currentThinkingId = null;
        }
        try {
          progress.report(new vscode47.LanguageModelToolCallPart(callId, name, args));
          _hasReceivedContent = true;
        } catch (e) {
          Logger.warn(
            "[OpenCode] Failed to report tool call",
            e instanceof Error ? e.message : String(e)
          );
        }
      };
      const flushBufferedToolCalls = () => {
        for (const [idx, buf] of toolCallBuffers.entries()) {
          if (!buf.name) {
            continue;
          }
          const callId = buf.id || toolCallIds.get(idx) || `tool_call_${idx}_${Date.now()}`;
          let parsedArgs = {};
          try {
            parsedArgs = JSON.parse(buf.arguments || "{}");
          } catch {
            parsedArgs = { value: buf.arguments };
          }
          reportToolCall(callId, buf.name, parsedArgs);
        }
      };
      stream.on("chunk", (chunk) => {
        if (token.isCancellationRequested) return;
        if (chunk.choices && chunk.choices.length > 0) {
          for (const choice of chunk.choices) {
            if (choice.delta?.tool_calls) {
              for (const toolCall of choice.delta.tool_calls) {
                if (toolCall.id && toolCall.index !== void 0) {
                  toolCallIds.set(toolCall.index, toolCall.id);
                }
                const idx = toolCall.index ?? 0;
                const existing = toolCallBuffers.get(idx) ?? { arguments: "" };
                if (toolCall.id) {
                  existing.id = toolCall.id;
                }
                const fn = toolCall.function;
                if (fn?.name) {
                  existing.name = fn.name;
                }
                if (typeof fn?.arguments === "string" && fn.arguments.length > 0) {
                  existing.arguments += fn.arguments;
                }
                toolCallBuffers.set(idx, existing);
              }
            }
            const legacy = choice.delta?.function_call;
            if (legacy) {
              legacyFunctionCallBuffer = legacyFunctionCallBuffer ?? { arguments: "" };
              if (legacy.name) {
                legacyFunctionCallBuffer.name = legacy.name;
              }
              if (typeof legacy.arguments === "string" && legacy.arguments.length > 0) {
                legacyFunctionCallBuffer.arguments += legacy.arguments;
              }
            }
            const delta = choice.delta;
            const reasoningContent = delta?.reasoning ?? delta?.reasoning_content;
            if (reasoningContent && typeof reasoningContent === "string") {
              if (!currentThinkingId) {
                currentThinkingId = `opencode_thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
              }
              thinkingContentBuffer += reasoningContent;
              try {
                progress.report(
                  new vscode47.LanguageModelThinkingPart(
                    thinkingContentBuffer,
                    currentThinkingId
                  )
                );
                thinkingContentBuffer = "";
                hasThinkingContent = true;
              } catch {
              }
            }
            const finishReason = choice?.finish_reason;
            if (finishReason === "tool_calls") {
              flushBufferedToolCalls();
            }
            if (finishReason === "function_call" && legacyFunctionCallBuffer?.name) {
              let parsedArgs = {};
              try {
                parsedArgs = JSON.parse(legacyFunctionCallBuffer.arguments || "{}");
              } catch {
                parsedArgs = { value: legacyFunctionCallBuffer.arguments };
              }
              const callId = `tool_call_legacy_${Date.now()}`;
              reportToolCall(callId, legacyFunctionCallBuffer.name, parsedArgs);
            }
          }
        }
      });
      stream.on("content", (delta) => {
        if (token.isCancellationRequested) return;
        if (delta && typeof delta === "string" && delta.trim().length > 0) {
          if (currentThinkingId) {
            try {
              progress.report(new vscode47.LanguageModelThinkingPart("", currentThinkingId));
            } catch {
            }
            currentThinkingId = null;
          }
          try {
            progress.report(new vscode47.LanguageModelTextPart(delta));
            _hasReceivedContent = true;
          } catch {
          }
        }
      });
      stream.on("tool_calls.function.arguments.done", (event) => {
        if (token.isCancellationRequested) return;
        const toolCallId = toolCallIds.get(event.index) || `tool_call_${event.index}_${Date.now()}`;
        let parsedArgs = {};
        if (event.parsed_arguments) {
          const result = event.parsed_arguments;
          parsedArgs = typeof result === "object" && result !== null ? result : {};
        } else {
          try {
            parsedArgs = JSON.parse(event.arguments || "{}");
          } catch {
            parsedArgs = { value: event.arguments };
          }
        }
        reportToolCall(toolCallId, event.name, parsedArgs);
      });
      await stream.finalChatCompletion();
      flushBufferedToolCalls();
      if (currentThinkingId) {
        try {
          progress.report(new vscode47.LanguageModelThinkingPart("", currentThinkingId));
        } catch {
        }
      }
      if (hasThinkingContent && !_hasReceivedContent) {
        progress.report(new vscode47.LanguageModelTextPart("<think/>"));
      }
    } catch (err) {
      const isAbort = token.isCancellationRequested || err instanceof Error && err.name === "AbortError";
      if (!isAbort) {
        Logger.error(
          "[OpenCode] Chat request failed",
          err instanceof Error ? err.message : String(err)
        );
      }
      throw err;
    } finally {
      this.incrementRequestCount();
    }
  }
  /**
   * Increment global request count and update status bar
   */
  incrementRequestCount() {
    const today = (/* @__PURE__ */ new Date()).toDateString();
    const prefix = this.providerKey;
    let count = this.context?.globalState.get(`${prefix}.requestCount`) || 0;
    const lastReset = this.context?.globalState.get(`${prefix}.lastResetDate`);
    if (lastReset !== today) {
      count = 1;
      this.context?.globalState.update(`${prefix}.lastResetDate`, today);
    } else {
      count++;
    }
    this.context?.globalState.update(`${prefix}.requestCount`, count);
    Logger.debug(`[OpenCode] Global request count: ${count}`);
  }
  async createOpenAIClient(apiKey) {
    const baseUrl = this.providerConfig.baseUrl || BASE_URL4;
    const cacheKey = `opencode:${baseUrl}`;
    const cached2 = this.clientCache.get(cacheKey);
    if (cached2) {
      cached2.lastUsed = Date.now();
      return cached2.client;
    }
    const client = new OpenAI({
      apiKey,
      baseURL: baseUrl,
      defaultHeaders: { "User-Agent": this.userAgent },
      maxRetries: 2,
      timeout: 6e4
    });
    this.clientCache.set(cacheKey, { client, lastUsed: Date.now() });
    return client;
  }
  async provideTokenCount(model, text, _token) {
    return TokenCounter.getInstance().countTokens(model, text);
  }
  async ensureApiKey(silent) {
    let apiKey = await ApiKeyManager.getApiKey(this.providerKey);
    if (!apiKey && !silent) {
      await ApiKeyManager.promptAndSetApiKey(
        this.providerKey,
        this.providerConfig.displayName,
        this.providerConfig.apiKeyTemplate
      );
      apiKey = await ApiKeyManager.getApiKey(this.providerKey);
    }
    return apiKey;
  }
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(`${providerConfig.displayName} provider activated!`);
    const ext = vscode47.extensions.getExtension("OEvortex.better-copilot-chat");
    const extVersion = ext?.packageJSON?.version ?? "unknown";
    const vscodeVersion = vscode47.version;
    const ua = `better-copilot-chat/${extVersion} VSCode/${vscodeVersion}`;
    const provider = new _OpenCodeProvider(
      context,
      providerKey,
      providerConfig,
      ua,
      context.extensionPath
    );
    const providerDisposable = vscode47.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const setApiKeyCommand = vscode47.commands.registerCommand(
      `chp.${providerKey}.setApiKey`,
      async () => {
        await ProviderWizard.startWizard({
          providerKey,
          displayName: providerConfig.displayName,
          apiKeyTemplate: providerConfig.apiKeyTemplate,
          supportsApiKey: true,
          supportsBaseUrl: true
        });
        await provider.modelInfoCache?.invalidateCache(providerKey);
        provider._onDidChangeLanguageModelChatInformation.fire(void 0);
      }
    );
    const disposables = [providerDisposable, setApiKeyCommand];
    for (const d of disposables) {
      context.subscriptions.push(d);
    }
    return { provider, disposables };
  }
};

// src/providers/qwencli/provider.ts
var vscode48 = __toESM(require("vscode"));
init_logger();

// src/providers/qwencli/auth.ts
var fs5 = __toESM(require("node:fs"));
var os2 = __toESM(require("node:os"));
var path7 = __toESM(require("node:path"));
init_logger();

// src/providers/qwencli/types.ts
var QWEN_OAUTH_CLIENT_ID = "f0304373b74a44d2b584a3fb70ca9e56";
var QWEN_OAUTH_TOKEN_ENDPOINT = "https://chat.qwen.ai/api/v1/oauth2/token";
var QWEN_DEFAULT_BASE_URL = "https://dashscope.aliyuncs.com/compatible-mode/v1";
var TOKEN_REFRESH_BUFFER_MS2 = 30 * 1e3;

// src/providers/qwencli/auth.ts
var QwenOAuthManager = class _QwenOAuthManager {
  static instance;
  credentials = null;
  refreshPromise = null;
  refreshTimer = null;
  constructor() {
    this.startProactiveRefresh();
  }
  static getInstance() {
    if (!_QwenOAuthManager.instance) {
      _QwenOAuthManager.instance = new _QwenOAuthManager();
    }
    return _QwenOAuthManager.instance;
  }
  startProactiveRefresh() {
    if (this.refreshTimer) {
      clearInterval(this.refreshTimer);
    }
    this.refreshTimer = setInterval(async () => {
      try {
        if (this.credentials && !this.isTokenValid(this.credentials)) {
          Logger.debug("Qwen CLI: Proactive token refresh triggered");
          await this.refreshAccessToken(this.credentials);
        }
      } catch (error2) {
        Logger.trace(`Qwen CLI: Proactive refresh failed: ${error2}`);
      }
    }, 3e4);
  }
  getCredentialPath() {
    return path7.join(os2.homedir(), ".qwen", "oauth_creds.json");
  }
  loadCachedCredentials() {
    const keyFile = this.getCredentialPath();
    try {
      if (!fs5.existsSync(keyFile)) {
        throw new Error(
          `Qwen OAuth credentials not found at ${keyFile}. Please login using the Qwen Code CLI first: qwen-code auth login`
        );
      }
      const data = JSON.parse(fs5.readFileSync(keyFile, "utf-8"));
      return {
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        token_type: data.token_type || "Bearer",
        expiry_date: data.expiry_date,
        resource_url: data.resource_url
      };
    } catch (error2) {
      if (error2 instanceof Error) {
        throw error2;
      }
      throw new Error("Invalid Qwen OAuth credentials file");
    }
  }
  async refreshAccessToken(credentials) {
    if (this.refreshPromise) {
      return this.refreshPromise;
    }
    this.refreshPromise = (async () => {
      try {
        if (!credentials.refresh_token) {
          throw new Error("No refresh token available in credentials.");
        }
        const bodyData = new URLSearchParams();
        bodyData.set("grant_type", "refresh_token");
        bodyData.set("refresh_token", credentials.refresh_token);
        bodyData.set("client_id", QWEN_OAUTH_CLIENT_ID);
        const response = await fetch(QWEN_OAUTH_TOKEN_ENDPOINT, {
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36"
          },
          body: bodyData.toString()
        });
        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(
            `Token refresh failed: ${response.status} ${response.statusText}. Response: ${errorText}`
          );
        }
        const tokenData = await response.json();
        if (tokenData.error) {
          throw new Error(
            `Token refresh failed: ${tokenData.error} - ${tokenData.error_description || "Unknown error"}`
          );
        }
        const newCredentials = {
          access_token: tokenData.access_token,
          token_type: tokenData.token_type || "Bearer",
          refresh_token: tokenData.refresh_token || credentials.refresh_token,
          expiry_date: Date.now() + tokenData.expires_in * 1e3,
          resource_url: credentials.resource_url
        };
        this.saveCredentials(newCredentials);
        this.credentials = newCredentials;
        return newCredentials;
      } finally {
        this.refreshPromise = null;
      }
    })();
    return this.refreshPromise;
  }
  saveCredentials(credentials) {
    const filePath = this.getCredentialPath();
    try {
      const dir = path7.dirname(filePath);
      if (!fs5.existsSync(dir)) {
        fs5.mkdirSync(dir, { recursive: true });
      }
      fs5.writeFileSync(filePath, JSON.stringify(credentials, null, 2), "utf-8");
    } catch (error2) {
      Logger.warn(`Failed to save refreshed credentials: ${error2}`);
    }
  }
  isTokenValid(credentials) {
    if (!credentials.expiry_date) {
      return false;
    }
    return Date.now() < credentials.expiry_date - TOKEN_REFRESH_BUFFER_MS2;
  }
  async ensureAuthenticated(forceRefresh = false) {
    this.credentials = this.loadCachedCredentials();
    if (forceRefresh || !this.isTokenValid(this.credentials)) {
      this.credentials = await this.refreshAccessToken(this.credentials);
    }
    return {
      accessToken: this.credentials.access_token,
      baseURL: this.getBaseURL(this.credentials)
    };
  }
  invalidateCredentials() {
    this.credentials = null;
  }
  getBaseURL(credentials) {
    let baseURL = credentials.resource_url || QWEN_DEFAULT_BASE_URL;
    if (!baseURL.startsWith("http://") && !baseURL.startsWith("https://")) {
      baseURL = `https://${baseURL}`;
    }
    baseURL = baseURL.replace(/\/$/, "");
    if (!baseURL.endsWith("/v1")) {
      baseURL = `${baseURL}/v1`;
    }
    return baseURL;
  }
  async getAccessToken() {
    const { accessToken } = await this.ensureAuthenticated();
    return accessToken;
  }
  async getBaseURLAsync() {
    const { baseURL } = await this.ensureAuthenticated();
    return baseURL;
  }
};

// src/providers/qwencli/provider.ts
var QwenRateLimitManager = class _QwenRateLimitManager {
  static instance;
  modelStates = /* @__PURE__ */ new Map();
  static getInstance() {
    if (!_QwenRateLimitManager.instance) {
      _QwenRateLimitManager.instance = new _QwenRateLimitManager();
    }
    return _QwenRateLimitManager.instance;
  }
  markRateLimited(modelId, retryAfterMs) {
    const existing = this.modelStates.get(modelId) || {
      isRateLimited: false,
      resetsAt: 0,
      backoffLevel: 0
    };
    let cooldown = 1e3 * 2 ** (existing.backoffLevel || 0);
    const RATE_LIMIT_MAX_DELAY_MS3 = 3e4;
    if (cooldown > RATE_LIMIT_MAX_DELAY_MS3) {
      cooldown = RATE_LIMIT_MAX_DELAY_MS3;
    }
    const actualCooldown = retryAfterMs && retryAfterMs > cooldown ? retryAfterMs : cooldown;
    this.modelStates.set(modelId, {
      isRateLimited: true,
      resetsAt: Date.now() + actualCooldown,
      backoffLevel: (existing.backoffLevel || 0) + 1
    });
    Logger.debug(
      `[qwencli] Rate limit marked for ${modelId}, cooldown: ${actualCooldown}ms, backoff level: ${(existing.backoffLevel || 0) + 1}`
    );
  }
  clearRateLimited(modelId) {
    const existing = this.modelStates.get(modelId);
    if (existing) {
      existing.isRateLimited = false;
      existing.backoffLevel = 0;
    }
  }
  isInCooldown(modelId) {
    const state = this.modelStates.get(modelId);
    if (!state || !state.isRateLimited) {
      return false;
    }
    if (Date.now() >= state.resetsAt) {
      this.clearRateLimited(modelId);
      return false;
    }
    return true;
  }
  getRemainingCooldown(modelId) {
    const state = this.modelStates.get(modelId);
    if (!state || !state.isRateLimited) {
      return 0;
    }
    const remaining = state.resetsAt - Date.now();
    return remaining > 0 ? remaining : 0;
  }
};
var ThinkingBlockParser = class {
  inThinkingBlock = false;
  buffer = "";
  parse(text) {
    let regular = "";
    let thinking = "";
    this.buffer += text;
    while (true) {
      if (this.inThinkingBlock) {
        const endIdx = this.buffer.indexOf("</think>");
        if (endIdx !== -1) {
          thinking += this.buffer.substring(0, endIdx);
          this.buffer = this.buffer.substring(endIdx + 8);
          this.inThinkingBlock = false;
        } else {
          thinking += this.buffer;
          this.buffer = "";
          break;
        }
      } else {
        const startIdx = this.buffer.indexOf("<think>");
        if (startIdx !== -1) {
          regular += this.buffer.substring(0, startIdx);
          this.buffer = this.buffer.substring(startIdx + 7);
          this.inThinkingBlock = true;
        } else {
          regular += this.buffer;
          this.buffer = "";
          break;
        }
      }
    }
    return { regular, thinking };
  }
};
var QwenCliProvider = class _QwenCliProvider extends GenericModelProvider {
  rateLimitManager = QwenRateLimitManager.getInstance();
  isRateLimitError(error2) {
    if (!(error2 instanceof Error)) {
      return false;
    }
    const msg = error2.message;
    return msg.includes("HTTP 429") || msg.includes("Rate limited") || msg.includes("Quota exceeded") || msg.includes("429");
  }
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(`${providerConfig.displayName} provider activated!`);
    const provider = new _QwenCliProvider(context, providerKey, providerConfig);
    const providerDisposable = vscode48.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const loginCommand = vscode48.commands.registerCommand(
      `chp.${providerKey}.login`,
      async () => {
        try {
          const { accessToken, baseURL } = await QwenOAuthManager.getInstance().ensureAuthenticated(true);
          vscode48.window.showInformationMessage(
            `${providerConfig.displayName} login successful!`
          );
          try {
            const accountManager = AccountManager.getInstance();
            const existing = accountManager.getAccountsByProvider("qwencli").find((a) => a.metadata?.source === "cli");
            if (!existing) {
              await accountManager.addOAuthAccount(
                "qwencli",
                "Qwen CLI (Local)",
                "",
                {
                  accessToken: accessToken ?? "",
                  refreshToken: "",
                  expiresAt: "",
                  tokenType: ""
                },
                { source: "cli", baseURL }
              );
            }
          } catch (e) {
            Logger.warn(
              "[qwencli] Failed to register CLI account with AccountManager",
              e
            );
          }
          await provider.modelInfoCache?.invalidateCache(providerKey);
          provider._onDidChangeLanguageModelChatInformation.fire();
        } catch (error2) {
          vscode48.window.showErrorMessage(
            `${providerConfig.displayName} login failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`
          );
        }
      }
    );
    const disposables = [providerDisposable, loginCommand];
    for (const disposable of disposables) {
      context.subscriptions.push(disposable);
    }
    return { provider, disposables };
  }
  async provideLanguageModelChatInformation(_options, _token) {
    return this.providerConfig.models.map(
      (model) => this.modelConfigToInfo(model)
    );
  }
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    const modelConfig = this.providerConfig.models.find(
      (m) => m.id === model.id
    );
    if (!modelConfig) {
      throw new Error(`Model not found: ${model.id}`);
    }
    try {
      if (this.rateLimitManager.isInCooldown(model.id)) {
        const remainingMs = this.rateLimitManager.getRemainingCooldown(model.id);
        const remainingSecs = Math.ceil(remainingMs / 1e3);
        throw new Error(
          `Rate limited: please try again in ${remainingSecs} seconds`
        );
      }
      await RateLimiter.getInstance(this.providerKey, 2, 1e3).throttle(
        this.providerConfig.displayName
      );
      const accountManager = AccountManager.getInstance();
      const accounts = accountManager.getAccountsByProvider("qwencli");
      const loadBalanceEnabled = accountManager.getLoadBalanceEnabled("qwencli");
      const assignedAccountId = accountManager.getAccountIdForModel(
        "qwencli",
        model.id
      );
      const tryAccountRequest = async (account, accountAccessToken) => {
        if (!accountAccessToken) {
          const creds = await accountManager.getCredentials(account.id);
          if (!creds) {
            return { success: false, reason: "no-creds" };
          }
          if ("accessToken" in creds) {
            accountAccessToken = creds.accessToken;
          } else if ("apiKey" in creds) {
            accountAccessToken = creds.apiKey;
          }
          if (!accountAccessToken) {
            return { success: false, reason: "no-token" };
          }
        }
        const configWithAuth2 = {
          ...modelConfig,
          baseUrl: modelConfig.baseUrl || void 0,
          customHeader: {
            ...modelConfig.customHeader || {},
            Authorization: `Bearer ${accountAccessToken}`
          }
        };
        try {
          await this.openaiHandler.handleRequest(
            model,
            configWithAuth2,
            messages,
            options,
            progress,
            token
          );
          return { success: true };
        } catch (err) {
          return { success: false, error: err };
        }
      };
      if (accounts && accounts.length > 0) {
        const usableAccounts = accounts.filter((a) => a.status === "active");
        const candidates = usableAccounts.length > 0 ? usableAccounts : accounts;
        const activeAccount = accountManager.getActiveAccount("qwencli");
        let accountsToTry;
        if (loadBalanceEnabled) {
          if (activeAccount && candidates.some((a) => a.id === activeAccount.id)) {
            accountsToTry = [
              activeAccount,
              ...candidates.filter((a) => a.id !== activeAccount.id)
            ];
          } else {
            accountsToTry = candidates;
          }
        } else {
          const assigned = assignedAccountId ? accounts.find((a) => a.id === assignedAccountId) : activeAccount;
          accountsToTry = assigned ? [assigned] : candidates.length > 0 ? [candidates[0]] : [];
        }
        let lastError;
        let switchedAccount = false;
        for (const account of accountsToTry) {
          const result = await tryAccountRequest(account);
          if (result.success) {
            if (switchedAccount && loadBalanceEnabled) {
              accountManager.setAccountForModel("qwencli", model.id, account.id).catch(() => {
              });
            }
            this.rateLimitManager.clearRateLimited(model.id);
            return;
          }
          lastError = result.error ?? result.reason;
          if (result.error instanceof Error && result.error.message.includes("401")) {
            await accountManager.markAccountExpired(account.id);
            continue;
          }
          if (this.isRateLimitError(result.error) && loadBalanceEnabled) {
            switchedAccount = true;
            continue;
          }
          if (result.error) {
            throw result.error;
          }
        }
        if (lastError) {
          Logger.warn(
            "[qwencli] Managed accounts failed, falling back to CLI credentials",
            lastError
          );
        }
      }
      const { accessToken, baseURL } = await QwenOAuthManager.getInstance().ensureAuthenticated();
      const configWithAuth = {
        ...modelConfig,
        baseUrl: baseURL,
        apiKey: accessToken,
        customHeader: modelConfig.customHeader
      };
      const thinkingParser = new ThinkingBlockParser();
      let currentThinkingId = null;
      let functionCallsBuffer = "";
      const wrappedProgress = {
        report: (part) => {
          if (part instanceof vscode48.LanguageModelTextPart) {
            const { regular, thinking } = thinkingParser.parse(part.value);
            if (thinking) {
              if (!currentThinkingId) {
                currentThinkingId = `qwen_thinking_${Date.now()}`;
              }
              progress.report(
                new vscode48.LanguageModelThinkingPart(
                  thinking,
                  currentThinkingId
                )
              );
            }
            const textToHandle = functionCallsBuffer + (regular || "");
            const funcCallsRegex = /<function_calls>[\s\S]*?<\/function_calls>/g;
            let lastIdx = 0;
            let fm = funcCallsRegex.exec(textToHandle);
            while (fm !== null) {
              const before = textToHandle.slice(lastIdx, fm.index);
              if (before && before.length > 0) {
                if (currentThinkingId) {
                  progress.report(
                    new vscode48.LanguageModelThinkingPart("", currentThinkingId)
                  );
                  currentThinkingId = null;
                }
                progress.report(new vscode48.LanguageModelTextPart(before));
              }
              const block = fm[0];
              const toolCallRegex = /<tool_call\s+name="([^"]+)"\s+arguments='([^']*)'\s*\/>/g;
              let tm = toolCallRegex.exec(block);
              while (tm !== null) {
                const name = tm[1];
                const argsString = tm[2] || "";
                let argsObj = {};
                try {
                  argsObj = JSON.parse(argsString);
                } catch {
                  argsObj = { value: argsString };
                }
                const callId = `qwen_call_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
                if (currentThinkingId) {
                  progress.report(
                    new vscode48.LanguageModelThinkingPart("", currentThinkingId)
                  );
                  currentThinkingId = null;
                }
                progress.report(
                  new vscode48.LanguageModelToolCallPart(callId, name, argsObj)
                );
                tm = toolCallRegex.exec(block);
              }
              lastIdx = funcCallsRegex.lastIndex;
              fm = funcCallsRegex.exec(textToHandle);
            }
            const trailing = textToHandle.slice(lastIdx);
            const openStart = trailing.indexOf("<function_calls>");
            const closeEnd = trailing.indexOf("</function_calls>");
            if (openStart !== -1 && closeEnd === -1) {
              const beforeOpen = trailing.slice(0, openStart);
              if (beforeOpen && beforeOpen.length > 0) {
                if (currentThinkingId) {
                  progress.report(
                    new vscode48.LanguageModelThinkingPart("", currentThinkingId)
                  );
                  currentThinkingId = null;
                }
                progress.report(new vscode48.LanguageModelTextPart(beforeOpen));
              }
              functionCallsBuffer = trailing.slice(openStart);
            } else {
              functionCallsBuffer = "";
              if (trailing && trailing.length > 0) {
                if (currentThinkingId) {
                  progress.report(
                    new vscode48.LanguageModelThinkingPart("", currentThinkingId)
                  );
                  currentThinkingId = null;
                }
                progress.report(new vscode48.LanguageModelTextPart(trailing));
              }
            }
          } else {
            progress.report(part);
          }
        }
      };
      await this.openaiHandler.handleRequest(
        model,
        configWithAuth,
        messages,
        options,
        wrappedProgress,
        token
      );
      this.rateLimitManager.clearRateLimited(model.id);
    } catch (error2) {
      if (error2 instanceof Error && error2.message.includes("401")) {
        QwenOAuthManager.getInstance().invalidateCredentials();
        const { accessToken, baseURL } = await QwenOAuthManager.getInstance().ensureAuthenticated(true);
        const configWithAuth = {
          ...modelConfig,
          baseUrl: baseURL,
          customHeader: {
            ...modelConfig.customHeader,
            Authorization: `Bearer ${accessToken}`
          }
        };
        await this.openaiHandler.handleRequest(
          model,
          configWithAuth,
          messages,
          options,
          progress,
          token
        );
        return;
      }
      if (this.isRateLimitError(error2)) {
        this.rateLimitManager.markRateLimited(model.id, 1e4);
        const remainingMs = this.rateLimitManager.getRemainingCooldown(model.id);
        const remainingSecs = Math.ceil(remainingMs / 1e3);
        throw new Error(
          `Rate limited: please try again in ${remainingSecs} seconds`
        );
      }
      throw error2;
    }
  }
};

// src/providers/zenmux/provider.ts
var fs6 = __toESM(require("node:fs"));
var path8 = __toESM(require("node:path"));
var vscode49 = __toESM(require("vscode"));
init_apiKeyManager();
init_configManager();
init_logger();
var BASE_URL5 = "https://zenmux.ai/api/v1";
var DEFAULT_MAX_OUTPUT_TOKENS6 = 16e3;
var DEFAULT_CONTEXT_LENGTH6 = 128e3;
var ZenmuxProvider = class _ZenmuxProvider extends GenericModelProvider {
  userAgent;
  extensionPath;
  configFilePath;
  clientCache = /* @__PURE__ */ new Map();
  constructor(context, providerKey, providerConfig, userAgent, extensionPath2) {
    super(context, providerKey, providerConfig);
    this.userAgent = userAgent;
    this.extensionPath = extensionPath2;
    this.configFilePath = path8.join(
      this.extensionPath,
      "src",
      "providers",
      "config",
      "zenmux.json"
    );
  }
  /**
   * Override refreshHandlers to also clear the OpenAI client cache
   * This ensures that when baseUrl changes, new clients are created with the correct URL
   */
  refreshHandlers() {
    if (this.clientCache && this.clientCache.size > 0) {
      Logger.debug(`[ZenMux] Clearing ${this.clientCache.size} cached OpenAI clients due to config change`);
      this.clientCache.clear();
    }
    super.refreshHandlers();
  }
  estimateMessagesTokens(msgs) {
    let total = 0;
    for (const m of msgs) {
      for (const part of m.content) {
        if (part instanceof vscode49.LanguageModelTextPart) {
          total += Math.ceil(part.value.length / 4);
        }
      }
    }
    return total;
  }
  estimateToolTokens(tools) {
    if (!tools || tools.length === 0) {
      return 0;
    }
    try {
      const json = JSON.stringify(tools);
      return Math.ceil(json.length / 4);
    } catch {
      return 0;
    }
  }
  async prepareLanguageModelChatInformation(options, _token) {
    const apiKey = await this.ensureApiKey(options.silent ?? true);
    let models = [];
    try {
      const result = await this.fetchModels(apiKey);
      models = result.models;
    } catch (err) {
      Logger.warn("[Zenmux] Failed to fetch models during initialization, using cached config if available");
      if (this.providerConfig.models && this.providerConfig.models.length > 0) {
        return this.providerConfig.models.map((m) => ({
          id: m.model || m.id,
          name: m.name || m.id,
          tooltip: m.tooltip || m.id,
          family: "zenmux",
          version: "1.0.0",
          maxInputTokens: m.maxInputTokens || 128e3,
          maxOutputTokens: m.maxOutputTokens || 16e3,
          capabilities: m.capabilities || { toolCalling: false, imageInput: false }
        }));
      }
      return [];
    }
    this.updateConfigFileAsync(models);
    const infos = models.map((m) => {
      const modalities = m.input_modalities ?? [];
      const vision = Array.isArray(modalities) && modalities.includes("image");
      const supportsReasoning = m.capabilities?.reasoning ?? false;
      const contextLen = m.context_length ?? DEFAULT_CONTEXT_LENGTH6;
      let maxOutput = DEFAULT_MAX_OUTPUT_TOKENS6;
      if (maxOutput >= contextLen) {
        maxOutput = Math.min(contextLen / 2, DEFAULT_MAX_OUTPUT_TOKENS6);
      }
      maxOutput = Math.floor(
        Math.max(1, Math.min(maxOutput, contextLen - 1024))
      );
      const maxInput = Math.max(1, contextLen - maxOutput);
      return {
        id: m.id,
        name: m.display_name || m.id,
        tooltip: `${m.display_name || m.id} by Zenmux`,
        family: "zenmux",
        version: "1.0.0",
        maxInputTokens: maxInput,
        maxOutputTokens: maxOutput,
        capabilities: {
          toolCalling: true,
          // Assuming most Zenmux models support tools as they use OpenAI format
          imageInput: vision
        }
      };
    });
    const dedupedInfos = this.dedupeModelInfos(infos);
    this._chatEndpoints = dedupedInfos.map((info) => ({
      model: info.id,
      modelMaxPromptTokens: info.maxInputTokens + info.maxOutputTokens
    }));
    return dedupedInfos;
  }
  async provideLanguageModelChatInformation(options, _token) {
    return this.prepareLanguageModelChatInformation(
      { silent: options.silent ?? false },
      _token
    );
  }
  async fetchModels(apiKey) {
    const headers = {
      "User-Agent": this.userAgent
    };
    if (apiKey) {
      headers["Authorization"] = `Bearer ${apiKey}`;
    }
    const modelsList = (async () => {
      const baseUrl = this.providerConfig.baseUrl || BASE_URL5;
      const resp = await fetch(`${baseUrl}/models`, {
        method: "GET",
        headers
      });
      if (!resp.ok) {
        let text = "";
        try {
          text = await resp.text();
        } catch (error2) {
          Logger.error(
            "[Zenmux Model Provider] Failed to read response text",
            error2
          );
        }
        const err = new Error(
          `Failed to fetch Zenmux models: ${resp.status} ${resp.statusText}${text ? `
${text}` : ""}`
        );
        Logger.error(
          "[Zenmux Model Provider] Failed to fetch Zenmux models",
          err
        );
        throw err;
      }
      const parsed = await resp.json();
      return parsed.data ?? [];
    })();
    try {
      const models = await modelsList;
      return { models };
    } catch (err) {
      Logger.error(
        "[Zenmux Model Provider] Failed to fetch Zenmux models",
        err
      );
      throw err;
    }
  }
  /**
   * Update config file asynchronously in background
   */
  updateConfigFileAsync(models) {
    (async () => {
      try {
        if (!fs6.existsSync(this.configFilePath)) {
          Logger.debug(
            `[Zenmux] Config file not found at ${this.configFilePath}, skipping auto-update`
          );
          return;
        }
        const modelConfigs = models.map((m) => {
          const modalities = m.input_modalities ?? [];
          const vision = Array.isArray(modalities) && modalities.includes("image");
          const contextLen = m.context_length ?? DEFAULT_CONTEXT_LENGTH6;
          const maxOutput = DEFAULT_MAX_OUTPUT_TOKENS6;
          const maxInput = Math.max(1, contextLen - maxOutput);
          const cleanId = m.id.replace(/[/]/g, "-").replace(/[^a-zA-Z0-9-]/g, "-").toLowerCase();
          return {
            id: cleanId,
            name: m.display_name || m.id,
            tooltip: `${m.display_name || m.id} by Zenmux`,
            maxInputTokens: maxInput,
            maxOutputTokens: maxOutput,
            model: m.id,
            capabilities: {
              toolCalling: true,
              imageInput: vision
            }
          };
        });
        let existingConfig;
        try {
          const configContent = fs6.readFileSync(this.configFilePath, "utf8");
          existingConfig = JSON.parse(configContent);
        } catch (err) {
          Logger.warn(
            `[Zenmux] Failed to read existing config, using defaults:`,
            err instanceof Error ? err.message : String(err)
          );
          existingConfig = {
            displayName: "Zenmux",
            baseUrl: BASE_URL5,
            apiKeyTemplate: "zm-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
            models: []
          };
        }
        const updatedConfig = {
          displayName: existingConfig.displayName || "Zenmux",
          baseUrl: existingConfig.baseUrl || BASE_URL5,
          apiKeyTemplate: existingConfig.apiKeyTemplate || "zm-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx",
          models: modelConfigs
        };
        fs6.writeFileSync(
          this.configFilePath,
          JSON.stringify(updatedConfig, null, 4),
          "utf8"
        );
        Logger.info(
          `[Zenmux] Auto-updated config file with ${modelConfigs.length} models`
        );
      } catch (err) {
        Logger.warn(
          `[Zenmux] Background config update failed:`,
          err instanceof Error ? err.message : String(err)
        );
      }
    })();
  }
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    await RateLimiter.getInstance(this.providerKey, 5, 1e3).throttle(
      this.providerConfig.displayName
    );
    try {
      const apiKey = await this.ensureApiKey(true);
      if (!apiKey) {
        throw new Error("Zenmux API key not found");
      }
      validateRequest(
        messages
      );
      if (options.tools && options.tools.length > 128) {
        throw new Error("Cannot have more than 128 tools per request.");
      }
      const inputTokenCount = this.estimateMessagesTokens(
        messages
      );
      const toolTokenCount = options.tools ? this.estimateToolTokens(
        this.openaiHandler.convertToolsToOpenAI([...options.tools])
      ) : 0;
      const tokenLimit = Math.max(1, model.maxInputTokens);
      if (inputTokenCount + toolTokenCount > tokenLimit) {
        Logger.error("[Zenmux Model Provider] Message exceeds token limit", {
          total: inputTokenCount + toolTokenCount,
          tokenLimit
        });
        throw new Error("Message exceeds token limit.");
      }
      const client = await this.createOpenAIClient(apiKey);
      const modelConfig = this.providerConfig.models.find(
        (m) => m.model === model.id || m.id === model.id
      );
      const openaiMessages = this.openaiHandler.convertMessagesToOpenAI(
        messages,
        model.capabilities || void 0,
        modelConfig
      );
      const createParams = {
        model: model.id,
        messages: openaiMessages,
        stream: true,
        stream_options: { include_usage: true },
        max_tokens: Math.min(
          options.modelOptions?.max_tokens || 4096,
          model.maxOutputTokens
        ),
        temperature: options.modelOptions?.temperature ?? ConfigManager.getTemperature(),
        top_p: ConfigManager.getTopP()
      };
      if (options.modelOptions) {
        const mo = options.modelOptions;
        if (typeof mo.stop === "string" || Array.isArray(mo.stop)) {
          createParams.stop = mo.stop;
        }
        if (typeof mo.frequency_penalty === "number") {
          createParams.frequency_penalty = mo.frequency_penalty;
        }
        if (typeof mo.presence_penalty === "number") {
          createParams.presence_penalty = mo.presence_penalty;
        }
      }
      if (options.tools && options.tools.length > 0 && model.capabilities?.toolCalling) {
        createParams.tools = this.openaiHandler.convertToolsToOpenAI([
          ...options.tools
        ]);
        createParams.tool_choice = "auto";
      }
      const abortController = new AbortController();
      token.onCancellationRequested(() => abortController.abort());
      const stream = client.chat.completions.stream(createParams, {
        signal: abortController.signal
      });
      let currentThinkingId = null;
      let thinkingContentBuffer = "";
      let _hasReceivedContent = false;
      let hasThinkingContent = false;
      const toolCallIds = /* @__PURE__ */ new Map();
      stream.on("chunk", (chunk) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (chunk.choices && chunk.choices.length > 0) {
          for (const choice of chunk.choices) {
            if (choice.delta?.tool_calls) {
              for (const toolCall of choice.delta.tool_calls) {
                if (toolCall.id && toolCall.index !== void 0) {
                  toolCallIds.set(toolCall.index, toolCall.id);
                }
              }
            }
            const delta = choice.delta;
            const reasoningContent = delta?.reasoning ?? delta?.reasoning_content;
            if (reasoningContent && typeof reasoningContent === "string") {
              if (!currentThinkingId) {
                currentThinkingId = `zenmux_thinking_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
              }
              thinkingContentBuffer += reasoningContent;
              try {
                progress.report(
                  new vscode49.LanguageModelThinkingPart(
                    thinkingContentBuffer,
                    currentThinkingId
                  )
                );
                thinkingContentBuffer = "";
                hasThinkingContent = true;
              } catch (e) {
                Logger.warn(
                  "[Zenmux] Failed to report thinking",
                  e instanceof Error ? e.message : String(e)
                );
              }
            }
          }
        }
      });
      stream.on("content", (delta) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (delta && typeof delta === "string" && delta.trim().length > 0) {
          if (currentThinkingId) {
            try {
              progress.report(
                new vscode49.LanguageModelThinkingPart(
                  "",
                  currentThinkingId
                )
              );
            } catch {
            }
            currentThinkingId = null;
          }
          try {
            progress.report(new vscode49.LanguageModelTextPart(delta));
            _hasReceivedContent = true;
          } catch (e) {
            Logger.warn(
              "[Zenmux] Failed to report content",
              e instanceof Error ? e.message : String(e)
            );
          }
        }
      });
      stream.on("tool_calls.function.arguments.done", (event) => {
        if (token.isCancellationRequested) {
          return;
        }
        if (currentThinkingId) {
          try {
            progress.report(
              new vscode49.LanguageModelThinkingPart(
                "",
                currentThinkingId
              )
            );
          } catch {
          }
          currentThinkingId = null;
        }
        const toolCallId = toolCallIds.get(event.index) || `tool_call_${event.index}_${Date.now()}`;
        let parsedArgs = {};
        if (event.parsed_arguments) {
          const result = event.parsed_arguments;
          parsedArgs = typeof result === "object" && result !== null ? result : {};
        } else {
          try {
            parsedArgs = JSON.parse(event.arguments || "{}");
          } catch {
            parsedArgs = { value: event.arguments };
          }
        }
        try {
          progress.report(
            new vscode49.LanguageModelToolCallPart(
              toolCallId,
              event.name,
              parsedArgs
            )
          );
          _hasReceivedContent = true;
        } catch (e) {
          Logger.warn(
            "[Zenmux] Failed to report tool call",
            e instanceof Error ? e.message : String(e)
          );
        }
      });
      await stream.finalChatCompletion();
      if (currentThinkingId) {
        try {
          progress.report(
            new vscode49.LanguageModelThinkingPart(
              "",
              currentThinkingId
            )
          );
        } catch {
        }
      }
      if (hasThinkingContent && !_hasReceivedContent) {
        progress.report(new vscode49.LanguageModelTextPart("<think/>"));
        Logger.warn(
          "[Zenmux] End of message stream has only thinking content and no text content, added <think/> placeholder as output"
        );
      }
    } catch (err) {
      Logger.error("[Zenmux Model Provider] Chat request failed", {
        modelId: model.id,
        messageCount: messages.length,
        error: err instanceof Error ? { name: err.name, message: err.message } : String(err)
      });
      throw err;
    }
  }
  /**
   * Create OpenAI client for Zenmux API
   */
  async createOpenAIClient(apiKey) {
    const baseUrl = this.providerConfig.baseUrl || BASE_URL5;
    const cacheKey = `zenmux:${baseUrl}`;
    const cached2 = this.clientCache.get(cacheKey);
    if (cached2) {
      cached2.lastUsed = Date.now();
      return cached2.client;
    }
    const client = new OpenAI({
      apiKey,
      baseURL: baseUrl,
      defaultHeaders: {
        "User-Agent": this.userAgent
      },
      maxRetries: 2,
      timeout: 6e4
    });
    this.clientCache.set(cacheKey, { client, lastUsed: Date.now() });
    return client;
  }
  async provideTokenCount(model, text, _token) {
    return TokenCounter.getInstance().countTokens(model, text);
  }
  async ensureApiKey(silent) {
    let apiKey = await ApiKeyManager.getApiKey("zenmux");
    if (!apiKey && !silent) {
      await ApiKeyManager.promptAndSetApiKey(
        "zenmux",
        "Zenmux",
        "zm-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
      );
      apiKey = await ApiKeyManager.getApiKey("zenmux");
    }
    return apiKey;
  }
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(`${providerConfig.displayName} provider activated!`);
    const ext = vscode49.extensions.getExtension("OEvortex.better-copilot-chat");
    const extVersion = ext?.packageJSON?.version ?? "unknown";
    const vscodeVersion = vscode49.version;
    const ua = `better-copilot-chat/${extVersion} VSCode/${vscodeVersion}`;
    const extensionPath2 = context.extensionPath;
    const provider = new _ZenmuxProvider(
      context,
      providerKey,
      providerConfig,
      ua,
      extensionPath2
    );
    const providerDisposable = vscode49.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const setApiKeyCommand = vscode49.commands.registerCommand(
      `chp.${providerKey}.setApiKey`,
      async () => {
        await ProviderWizard.startWizard({
          providerKey,
          displayName: providerConfig.displayName,
          apiKeyTemplate: providerConfig.apiKeyTemplate,
          supportsApiKey: true,
          supportsBaseUrl: true
        });
        await provider.modelInfoCache?.invalidateCache(providerKey);
        provider._onDidChangeLanguageModelChatInformation.fire(void 0);
      }
    );
    const disposables = [providerDisposable, setApiKeyCommand];
    for (const d of disposables) {
      context.subscriptions.push(d);
    }
    return { provider, disposables };
  }
};

// src/providers/zhipu/zhipuProvider.ts
var fs7 = __toESM(require("node:fs"));
var path9 = __toESM(require("node:path"));
var vscode50 = __toESM(require("vscode"));
init_configManager();
init_logger();
var DEFAULT_MAX_OUTPUT_TOKENS7 = 16752;
var DEFAULT_CONTEXT_LENGTH7 = 186e3;
var CODING_PLAN_BASE_URL = "https://api.z.ai/api/coding/paas/v4";
var NORMAL_PLAN_BASE_URL = "https://api.z.ai/api/paas/v4";
var HARDCODED_MODELS = [
  {
    id: "glm-4.7-flash",
    object: "model",
    created: 0,
    owned_by: "zhipu"
  },
  {
    id: "glm-4.7-flashx",
    object: "model",
    created: 0,
    owned_by: "zhipu"
  }
];
var ZhipuProvider = class _ZhipuProvider extends GenericModelProvider {
  configFilePath;
  constructor(context, providerKey, providerConfig) {
    super(context, providerKey, providerConfig);
    this.configFilePath = path9.join(
      context.extensionPath,
      "src",
      "providers",
      "config",
      "zhipu.json"
    );
  }
  /**
   * Get base URL based on plan setting
   */
  getBaseUrl() {
    const plan = ConfigManager.getZhipuPlan();
    const customBaseUrl = this.cachedProviderConfig.baseUrl;
    if (customBaseUrl) {
      return customBaseUrl;
    }
    return plan === "coding" ? CODING_PLAN_BASE_URL : NORMAL_PLAN_BASE_URL;
  }
  /**
   * Override refreshHandlers to clear cache when config changes
   */
  refreshHandlers() {
    super.refreshHandlers();
    Logger.debug("[Zhipu] Handlers refreshed due to config change");
  }
  /**
   * Fetch models from Zhipu API
   */
  async fetchModels(apiKey) {
    const baseUrl = this.getBaseUrl();
    Logger.info(`[Zhipu] Fetching models from ${baseUrl}/models`);
    const resp = await fetch(`${baseUrl}/models`, {
      method: "GET",
      headers: {
        Authorization: `Bearer ${apiKey}`
      }
    });
    if (!resp.ok) {
      let text = "";
      try {
        text = await resp.text();
      } catch {
      }
      const err = new Error(
        `Failed to fetch Zhipu models: ${resp.status} ${resp.statusText}${text ? `
${text}` : ""}`
      );
      Logger.error("[Zhipu Model Provider] Failed to fetch Zhipu models", err);
      throw err;
    }
    const parsed = await resp.json();
    return parsed.data ?? [];
  }
  mergeHardcodedModels(models) {
    const seen = new Set(models.map((m) => m.id));
    const merged = [...models];
    for (const hardcoded of HARDCODED_MODELS) {
      if (!seen.has(hardcoded.id)) {
        merged.push(hardcoded);
      }
    }
    return merged;
  }
  supportsThinking(modelId) {
    const normalized = modelId.toLowerCase();
    return /^glm-(5|4\.(5|6|7))(?:[^\d].*)?$/.test(normalized);
  }
  buildThinkingExtraBody(modelId, existingExtraBody) {
    if (!this.supportsThinking(modelId)) {
      return existingExtraBody;
    }
    const thinkingMode = ConfigManager.getZhipuThinking();
    if (thinkingMode === "auto") {
      if (!existingExtraBody) {
        return void 0;
      }
      const next = { ...existingExtraBody };
      delete next.thinking;
      return Object.keys(next).length > 0 ? next : void 0;
    }
    const merged = {
      ...existingExtraBody || {},
      thinking: {
        type: thinkingMode,
        clear_thinking: ConfigManager.getZhipuClearThinking()
      }
    };
    return merged;
  }
  /**
   * Get metadata for known models
   */
  getModelMetadata(modelId) {
    const defaultMeta = {
      name: modelId,
      maxInputTokens: DEFAULT_CONTEXT_LENGTH7,
      maxOutputTokens: DEFAULT_MAX_OUTPUT_TOKENS7,
      toolCalling: true,
      imageInput: false
    };
    const modelMetadata = {
      "glm-5": {
        name: "GLM-5 (Latest)",
        maxInputTokens: 186e3,
        maxOutputTokens: 16752,
        toolCalling: true,
        imageInput: false
      },
      "glm-4.7": {
        name: "GLM-4.7",
        maxInputTokens: 186e3,
        maxOutputTokens: 16752,
        toolCalling: true,
        imageInput: false
      },
      "glm-4.6": {
        name: "GLM-4.6",
        maxInputTokens: 186e3,
        maxOutputTokens: 16752,
        toolCalling: true,
        imageInput: false
      },
      "glm-4.5": {
        name: "GLM-4.5",
        maxInputTokens: 1e5,
        maxOutputTokens: 28e3,
        toolCalling: true,
        imageInput: false
      },
      "glm-4.5-air": {
        name: "GLM-4.5-Air",
        maxInputTokens: 1e5,
        maxOutputTokens: 28e3,
        toolCalling: true,
        imageInput: false
      },
      "glm-4.7-flash": {
        name: "GLM-4.7-Flash (Free, 1 Concurrent)",
        maxInputTokens: 186e3,
        maxOutputTokens: 16752,
        toolCalling: true,
        imageInput: false
      },
      "glm-4.7-flashx": {
        name: "GLM-4.7-FlashX (Paid)",
        maxInputTokens: 186e3,
        maxOutputTokens: 16752,
        toolCalling: true,
        imageInput: false
      }
    };
    return modelMetadata[modelId] || defaultMeta;
  }
  /**
   * Override provideLanguageModelChatInformation to fetch models dynamically
   */
  async provideLanguageModelChatInformation(options, token) {
    const apiKey = await this.getApiKeyFromManager();
    if (!apiKey) {
      return super.provideLanguageModelChatInformation(options, token);
    }
    try {
      const apiModels = await this.fetchModels(apiKey);
      const models = this.mergeHardcodedModels(apiModels);
      this.updateConfigFileAsync(models);
      const infos = models.map((m) => {
        const modelMeta = this.getModelMetadata(m.id);
        return {
          id: m.id,
          name: modelMeta.name,
          tooltip: `${m.id} by ZhipuAI`,
          family: "zhipu",
          version: "1.0.0",
          maxInputTokens: modelMeta.maxInputTokens,
          maxOutputTokens: modelMeta.maxOutputTokens,
          capabilities: {
            toolCalling: modelMeta.toolCalling,
            imageInput: modelMeta.imageInput
          }
        };
      });
      this._chatEndpoints = infos.map((info) => ({
        model: info.id,
        modelMaxPromptTokens: info.maxInputTokens + info.maxOutputTokens
      }));
      return infos;
    } catch (err) {
      Logger.warn(
        "[Zhipu] Failed to fetch models from API, falling back to config:",
        err instanceof Error ? err.message : String(err)
      );
      return super.provideLanguageModelChatInformation(options, token);
    }
  }
  /**
   * Get API key from ApiKeyManager
   */
  async getApiKeyFromManager() {
    try {
      const { ApiKeyManager: ApiKeyManager2 } = await Promise.resolve().then(() => (init_apiKeyManager(), apiKeyManager_exports));
      const key = await ApiKeyManager2.getApiKey(this.providerKey);
      return key === void 0 ? null : key;
    } catch (err) {
      Logger.warn("[Zhipu] Failed to get API key:", err);
      return null;
    }
  }
  /**
   * Update config file asynchronously in background
   */
  updateConfigFileAsync(models) {
    (async () => {
      try {
        if (!fs7.existsSync(this.configFilePath)) {
          Logger.debug(
            `[Zhipu] Config file not found at ${this.configFilePath}, skipping auto-update`
          );
          return;
        }
        const modelConfigs = models.map((m) => {
          const meta = this.getModelMetadata(m.id);
          return {
            id: m.id,
            name: meta.name,
            tooltip: `${m.id} by ZhipuAI`,
            maxInputTokens: meta.maxInputTokens,
            maxOutputTokens: meta.maxOutputTokens,
            model: m.id,
            sdkMode: "openai",
            baseUrl: this.getBaseUrl(),
            extraBody: this.buildThinkingExtraBody(m.id),
            capabilities: {
              toolCalling: meta.toolCalling,
              imageInput: meta.imageInput
            }
          };
        });
        let existingConfig;
        try {
          const configContent = fs7.readFileSync(this.configFilePath, "utf8");
          existingConfig = JSON.parse(configContent);
        } catch {
          existingConfig = {
            displayName: "ZhipuAI",
            baseUrl: this.getBaseUrl(),
            apiKeyTemplate: "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxx",
            models: []
          };
        }
        const updatedConfig = {
          displayName: existingConfig.displayName || "ZhipuAI",
          baseUrl: existingConfig.baseUrl || this.getBaseUrl(),
          apiKeyTemplate: existingConfig.apiKeyTemplate || "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.xxxxxxxxxxxxxxxx",
          models: modelConfigs
        };
        fs7.writeFileSync(
          this.configFilePath,
          JSON.stringify(updatedConfig, null, 4),
          "utf8"
        );
        Logger.info(
          `[Zhipu] Auto-updated config file with ${modelConfigs.length} models`
        );
      } catch (err) {
        Logger.warn(
          `[Zhipu] Background config update failed: ${err instanceof Error ? err.message : String(err)}`
        );
      }
    })();
  }
  /**
   * Static factory method - Create and activate Zhipu provider
   */
  static createAndActivate(context, providerKey, providerConfig) {
    Logger.trace(
      `${providerConfig.displayName} dedicated model extension activated!`
    );
    const provider = new _ZhipuProvider(context, providerKey, providerConfig);
    const providerDisposable = vscode50.lm.registerLanguageModelChatProvider(
      `chp.${providerKey}`,
      provider
    );
    const setApiKeyCommand = vscode50.commands.registerCommand(
      `chp.${providerKey}.setApiKey`,
      async () => {
        await ZhipuWizard.startWizard(
          providerConfig.displayName,
          providerConfig.apiKeyTemplate
        );
        await provider.modelInfoCache?.invalidateCache(providerKey);
        provider._onDidChangeLanguageModelChatInformation.fire();
      }
    );
    const configWizardCommand = vscode50.commands.registerCommand(
      `chp.${providerKey}.configWizard`,
      async () => {
        Logger.info(
          `Starting ${providerConfig.displayName} configuration wizard`
        );
        await ZhipuWizard.startWizard(
          providerConfig.displayName,
          providerConfig.apiKeyTemplate
        );
      }
    );
    const disposables = [
      providerDisposable,
      setApiKeyCommand,
      configWizardCommand
    ];
    for (const disposable of disposables) {
      context.subscriptions.push(disposable);
    }
    return { provider, disposables };
  }
  /**
   * Override provideChatResponse to update status bar after request completion
   */
  async provideLanguageModelChatResponse(model, messages, options, progress, token) {
    await RateLimiter.getInstance(this.providerKey, 2, 1e3).throttle(
      this.providerConfig.displayName
    );
    const modelConfig = this.providerConfig.models.find((m) => m.id === model.id);
    if (modelConfig) {
      modelConfig.sdkMode = "openai";
      modelConfig.baseUrl = modelConfig.baseUrl || this.getBaseUrl();
      modelConfig.extraBody = this.buildThinkingExtraBody(
        model.id,
        modelConfig.extraBody
      );
    }
    await super.provideLanguageModelChatResponse(
      model,
      messages,
      options,
      progress,
      token
    );
  }
};

// src/tools/delegateToAgent.ts
var vscode51 = __toESM(require("vscode"));
var DelegateToAgentTool = class {
  /**
   * Tool invocation handler
   */
  async invoke(request3) {
    try {
      const { agent_name, prompt } = request3.input;
      Logger.info(
        `[Tool Invocation] delegate_to_agent invoked: agent=${agent_name}, prompt="${prompt.substring(0, 50)}..."`
      );
      if (!agent_name) {
        throw new Error("Missing required parameter: agent_name");
      }
      if (!prompt) {
        throw new Error("Missing required parameter: prompt");
      }
      if (agent_name.toLowerCase() === "gemini" || agent_name.toLowerCase() === "geminicli") {
        await vscode51.commands.executeCommand("chp.geminicli.invoke", prompt);
        return new vscode51.LanguageModelToolResult([
          new vscode51.LanguageModelTextPart(
            `Successfully delegated task to ${agent_name}.`
          )
        ]);
      }
      const message = `@${agent_name} ${prompt}`;
      try {
        await vscode51.commands.executeCommand(
          "workbench.panel.chat.view.copilot.focus"
        );
        await vscode51.commands.executeCommand(
          "workbench.action.chat.insertIntoInput",
          message
        );
        const sendCommands = [
          "workbench.action.chat.sendMessage",
          "workbench.action.chat.accept",
          "workbench.action.chat.submit"
        ];
        let sent = false;
        for (const cmd of sendCommands) {
          try {
            await vscode51.commands.executeCommand(cmd);
            sent = true;
            break;
          } catch {
          }
        }
        if (!sent) {
          await vscode51.commands.executeCommand("type", { text: "\n" });
        }
        return new vscode51.LanguageModelToolResult([
          new vscode51.LanguageModelTextPart(
            `Successfully delegated task to ${agent_name}.`
          )
        ]);
      } catch (err) {
        Logger.warn(
          `[Delegate Tool] Failed to delegate to ${agent_name}:`,
          err
        );
        throw new Error(
          `Failed to delegate to ${agent_name}. Make sure the agent is available.`
        );
      }
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      Logger.error(
        "[Tool Invocation] delegate_to_agent failed",
        error2 instanceof Error ? error2 : void 0
      );
      throw new vscode51.LanguageModelError(`Delegation failed: ${errorMessage}`);
    }
  }
};

// src/tools/minimaxSearch.ts
var https = __toESM(require("node:https"));
var vscode52 = __toESM(require("vscode"));
init_apiKeyManager();
var MiniMaxSearchTool = class {
  baseURL = "https://api.minimax.chat/v1/coding_plan/search";
  /**
   * Execute search
   */
  async search(params) {
    const apiKey = await ApiKeyManager.getApiKey("minimax-coding");
    if (!apiKey) {
      throw new Error(
        'MiniMax Coding Plan API key not set, please run command "Copilot ++: Set MiniMax Coding Plan API Key" first'
      );
    }
    const requestData = JSON.stringify({
      q: params.q
    });
    const options = {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${apiKey}`,
        "Content-Length": Buffer.byteLength(requestData),
        "User-Agent": VersionManager.getUserAgent("MiniMaxSearch")
      }
    };
    Logger.info(`[MiniMax Search] Starting search: "${params.q}"`);
    Logger.debug(`[MiniMax Search] Request data: ${requestData}`);
    let requestUrl = this.baseURL;
    if (ConfigManager.getMinimaxEndpoint() === "minimax.io") {
      requestUrl = requestUrl.replace("api.minimax.chat", "api.minimax.io");
    }
    return new Promise((resolve, reject) => {
      const req = https.request(requestUrl, options, (res) => {
        let data = "";
        res.on("data", (chunk) => {
          data += chunk;
        });
        res.on("end", () => {
          try {
            Logger.debug(
              `[MiniMax Search] Response status code: ${res.statusCode}`
            );
            Logger.debug(`[MiniMax Search] Response data: ${data}`);
            if (res.statusCode !== 200) {
              let errorMessage = `MiniMax search API error ${res.statusCode}`;
              try {
                const errorData = JSON.parse(data);
                errorMessage += `: ${errorData.error?.message || JSON.stringify(errorData)}`;
              } catch {
                errorMessage += `: ${data}`;
              }
              Logger.error(
                "[MiniMax Search] API returned error",
                new Error(errorMessage)
              );
              reject(new Error(errorMessage));
              return;
            }
            const response = JSON.parse(data);
            Logger.info(
              `[MiniMax Search] Search complete: found ${response.organic?.length || 0} results`
            );
            resolve(response);
          } catch (error2) {
            Logger.error(
              "[MiniMax Search] Failed to parse response",
              error2 instanceof Error ? error2 : void 0
            );
            reject(
              new Error(
                `Failed to parse MiniMax search response: ${error2 instanceof Error ? error2.message : "Unknown error"}`
              )
            );
          }
        });
      });
      req.on("error", (error2) => {
        Logger.error("[MiniMax Search] Request failed", error2);
        reject(new Error(`MiniMax search request failed: ${error2.message}`));
      });
      req.write(requestData);
      req.end();
    });
  }
  /**
   * Tool invocation handler
   */
  async invoke(request3) {
    try {
      Logger.info(
        `[Tool Invocation] MiniMax web search tool invoked: ${JSON.stringify(request3.input)}`
      );
      const params = request3.input;
      if (!params.q) {
        throw new Error("Missing required parameter: q");
      }
      const response = await this.search(params);
      const searchResults = response.organic || [];
      Logger.info(
        "[Tool Invocation] MiniMax web search tool invocation successful"
      );
      const parts = [];
      if (searchResults.length > 0) {
        parts.push(
          new vscode52.LanguageModelTextPart(
            `## Search Results (${searchResults.length})`
          )
        );
        searchResults.forEach((result, index) => {
          const formattedResult = `**${index + 1}. ${result.title}**

${result.snippet}

${result.date}

[View Original](${result.link})

---
`;
          parts.push(new vscode52.LanguageModelTextPart(formattedResult));
        });
      } else {
        if (response.base_resp?.status_code !== 0 && response.base_resp?.status_msg) {
          throw new vscode52.LanguageModelError(response.base_resp.status_msg);
        } else {
          parts.push(
            new vscode52.LanguageModelTextPart(
              "No relevant search results found."
            )
          );
        }
      }
      return new vscode52.LanguageModelToolResult(parts);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      Logger.error(
        "[Tool Invocation] MiniMax web search tool invocation failed",
        error2 instanceof Error ? error2 : void 0
      );
      throw new vscode52.LanguageModelError(
        `MiniMax search failed: ${errorMessage}`
      );
    }
  }
  /**
   * Clean up tool resources
   */
  async cleanup() {
    try {
      Logger.info("[MiniMax Search] Tool resources cleaned up");
    } catch (error2) {
      Logger.error(
        "[MiniMax Search] Resource cleanup failed",
        error2 instanceof Error ? error2 : void 0
      );
    }
  }
};

// src/tools/registry.ts
var vscode54 = __toESM(require("vscode"));

// src/tools/zhipuSearch.ts
var https2 = __toESM(require("node:https"));
var vscode53 = __toESM(require("vscode"));
init_apiKeyManager();
init_configManager();
var ZhipuSearchTool = class {
  baseURL = "https://open.bigmodel.cn/api/paas/v4";
  // MCP client uses singleton pattern, not instantiated directly here
  /**
   * Check if MCP mode is enabled
   */
  isMCPEnabled() {
    const config2 = ConfigManager.getZhipuSearchConfig();
    return config2.enableMCP;
  }
  /**
   * Search via MCP
   */
  async searchViaMCP(params) {
    Logger.info(
      `[Zhipu Search] Using MCP mode search: "${params.search_query}"`
    );
    const mcpClient = await MCPWebSearchClient.getInstance();
    const searchRequest = {
      search_query: params.search_query,
      search_engine: params.search_engine,
      search_intent: params.search_intent,
      count: params.count,
      search_domain_filter: params.search_domain_filter,
      search_recency_filter: params.search_recency_filter,
      content_size: params.content_size
    };
    return await mcpClient.search(searchRequest);
  }
  /**
   * Execute search (standard billing interface)
   */
  async search(params) {
    const apiKey = await ApiKeyManager.getApiKey("zhipu");
    if (!apiKey) {
      throw new Error(
        'ZhipuAI API key not set, please run command "Copilot ++: Set ZhipuAI API Key" first'
      );
    }
    let baseURL = this.baseURL;
    const endpoint = ConfigManager.getZhipuEndpoint();
    if (endpoint === "api.z.ai") {
      baseURL = baseURL.replace("open.bigmodel.cn", "api.z.ai");
    }
    const url2 = `${baseURL}/web_search`;
    const requestData = JSON.stringify({
      search_query: params.search_query,
      search_engine: params.search_engine || "search_std",
      search_intent: params.search_intent !== void 0 ? params.search_intent : false,
      count: params.count || 10,
      search_domain_filter: params.search_domain_filter,
      search_recency_filter: params.search_recency_filter || "noLimit",
      content_size: params.content_size || "medium",
      request_id: params.request_id,
      user_id: params.user_id
    });
    const options = {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${apiKey}`,
        "Content-Length": Buffer.byteLength(requestData),
        "User-Agent": VersionManager.getUserAgent("ZhipuSearch")
      }
    };
    Logger.info(
      `[Zhipu Search] Starting search: "${params.search_query}" using engine ${params.search_engine || "search_std"}`
    );
    Logger.debug(`[Zhipu Search] Request data: ${requestData}`);
    return new Promise((resolve, reject) => {
      const req = https2.request(url2, options, (res) => {
        let data = "";
        res.on("data", (chunk) => {
          data += chunk;
        });
        res.on("end", () => {
          try {
            Logger.debug(
              `[Zhipu Search] Response status code: ${res.statusCode}`
            );
            Logger.debug(`[Zhipu Search] Response data: ${data}`);
            if (res.statusCode !== 200) {
              let errorMessage = `ZhipuAI search API error ${res.statusCode}`;
              try {
                const errorData = JSON.parse(data);
                errorMessage += `: ${errorData.error?.message || JSON.stringify(errorData)}`;
              } catch {
                errorMessage += `: ${data}`;
              }
              Logger.error(
                "[Zhipu Search] API returned error",
                new Error(errorMessage)
              );
              reject(new Error(errorMessage));
              return;
            }
            const response = JSON.parse(data);
            Logger.info(
              `[Zhipu Search] Search complete: found ${response.search_result?.length || 0} results`
            );
            resolve(response);
          } catch (error2) {
            Logger.error(
              "[Zhipu Search] Failed to parse response",
              error2 instanceof Error ? error2 : void 0
            );
            reject(
              new Error(
                `Failed to parse ZhipuAI search response: ${error2 instanceof Error ? error2.message : "Unknown error"}`
              )
            );
          }
        });
      });
      req.on("error", (error2) => {
        Logger.error("[Zhipu Search] Request failed", error2);
        reject(new Error(`ZhipuAI search request failed: ${error2.message}`));
      });
      req.write(requestData);
      req.end();
    });
  }
  /**
   * Tool invocation handler
   */
  async invoke(request3) {
    try {
      Logger.info(
        `[Tool Invocation] ZhipuAI web search tool invoked: ${JSON.stringify(request3.input)}`
      );
      const params = request3.input;
      if (!params.search_query) {
        throw new Error("Missing required parameter: search_query");
      }
      let searchResults;
      if (this.isMCPEnabled()) {
        Logger.info("[Zhipu Search] Using MCP mode search");
        searchResults = await this.searchViaMCP(params);
      } else {
        Logger.info(
          "[Zhipu Search] Using standard billing interface search (pay-per-use)"
        );
        const response = await this.search(params);
        searchResults = response.search_result || [];
      }
      Logger.info(
        "[Tool Invocation] ZhipuAI web search tool invocation successful"
      );
      return new vscode53.LanguageModelToolResult([
        new vscode53.LanguageModelTextPart(JSON.stringify(searchResults))
      ]);
    } catch (error2) {
      const errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
      Logger.error(
        "[Tool Invocation] ZhipuAI web search tool invocation failed",
        error2 instanceof Error ? error2 : void 0
      );
      throw new vscode53.LanguageModelError(
        `ZhipuAI search failed: ${errorMessage}`
      );
    }
  }
  /**
   * Get search mode status
   */
  getSearchModeStatus() {
    const isMCP = this.isMCPEnabled();
    return {
      mode: isMCP ? "MCP" : "Standard",
      description: isMCP ? "MCP mode (Coding Plan exclusive)" : "Standard billing interface mode (pay-per-use)"
    };
  }
  /**
   * Clean up tool resources
   */
  async cleanup() {
    try {
      Logger.info("[Zhipu Search] Tool resources cleaned up");
    } catch (error2) {
      Logger.error(
        "[Zhipu Search] Resource cleanup failed",
        error2 instanceof Error ? error2 : void 0
      );
    }
  }
  /**
   * Get MCP client cache statistics
   */
  getMCPCacheStats() {
    return MCPWebSearchClient.getCacheStats();
  }
  /**
   * Clear MCP client cache
   */
  async clearMCPCache(apiKey) {
    await MCPWebSearchClient.clearCache(apiKey);
  }
};

// src/tools/registry.ts
var zhipuSearchTool;
var minimaxSearchTool;
var delegateToAgentTool;
function registerAllTools(context) {
  try {
    zhipuSearchTool = new ZhipuSearchTool();
    const zhipuToolDisposable = vscode54.lm.registerTool("chp_zhipuWebSearch", {
      invoke: zhipuSearchTool.invoke.bind(zhipuSearchTool)
    });
    context.subscriptions.push(zhipuToolDisposable);
    minimaxSearchTool = new MiniMaxSearchTool();
    const minimaxToolDisposable = vscode54.lm.registerTool(
      "chp_minimaxWebSearch",
      {
        invoke: minimaxSearchTool.invoke.bind(minimaxSearchTool)
      }
    );
    context.subscriptions.push(minimaxToolDisposable);
    delegateToAgentTool = new DelegateToAgentTool();
    const delegateToolDisposable = vscode54.lm.registerTool(
      "chp_delegateToAgent",
      {
        invoke: delegateToAgentTool.invoke.bind(delegateToAgentTool)
      }
    );
    context.subscriptions.push(delegateToolDisposable);
    context.subscriptions.push({
      dispose: async () => {
        await cleanupAllTools();
      }
    });
    Logger.info("Zhipu AI web search tool registered: chp_zhipuWebSearch");
    Logger.info("MiniMax web search tool registered: chp_minimaxWebSearch");
    Logger.info("Delegate to agent tool registered: chp_delegateToAgent");
  } catch (error2) {
    Logger.error(
      "Tool registration failed",
      error2 instanceof Error ? error2 : void 0
    );
    throw error2;
  }
}
async function cleanupAllTools() {
  try {
    if (zhipuSearchTool) {
      await zhipuSearchTool.cleanup();
      zhipuSearchTool = void 0;
      Logger.info("ZhipuAI web search tool resources cleaned up");
    }
    if (minimaxSearchTool) {
      await minimaxSearchTool.cleanup();
      minimaxSearchTool = void 0;
      Logger.info("MiniMax web search tool resources cleaned up");
    }
    if (delegateToAgentTool) {
      delegateToAgentTool = void 0;
      Logger.info("Delegate to agent tool resources cleaned up");
    }
  } catch (error2) {
    Logger.error(
      "Tool cleanup failed",
      error2 instanceof Error ? error2 : void 0
    );
  }
}

// src/extension.ts
init_providerKeys();

// src/ui/copilotOverview.ts
var vscode55 = __toESM(require("vscode"));
init_apiKeyManager();

// raw-file:./copilotOverview.css
var copilotOverview_default = 'body {\n	font-family:\n		-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue",\n		Arial, sans-serif;\n	color: #ddd;\n	background: transparent;\n}\n.container {\n	width: 420px;\n	padding: 12px;\n}\n.header {\n	display: flex;\n	justify-content: space-between;\n	align-items: center;\n}\n.header h2 {\n	margin: 0;\n	font-size: 14px;\n}\n.section {\n	margin-top: 12px;\n}\n.label-row {\n	display: flex;\n	justify-content: space-between;\n	align-items: center;\n	font-size: 12px;\n}\n.progress {\n	width: 100%;\n	height: 8px;\n	background: #2b2b2b;\n	border-radius: 6px;\n	margin-top: 8px;\n}\n.progress > .bar {\n	height: 100%;\n	background: linear-gradient(90deg, #3b82f6, #7c3aed);\n	border-radius: 6px;\n	width: 0%;\n}\n.button {\n	margin-top: 10px;\n	background: #2d2d2d;\n	border: 1px solid #444;\n	color: #fff;\n	padding: 8px 10px;\n	border-radius: 6px;\n	cursor: pointer;\n}\n.providers {\n	margin-top: 12px;\n}\n.provider-item {\n	padding: 6px 0;\n	border-bottom: 1px solid rgba(255, 255, 255, 0.03);\n	display: flex;\n	justify-content: space-between;\n	align-items: center;\n	font-size: 12px;\n}\n.toggle {\n	display: inline-flex;\n	align-items: center;\n	gap: 8px;\n}\n.small {\n	font-size: 11px;\n	color: #aaa;\n}\n.footer {\n	margin-top: 10px;\n	font-size: 11px;\n	color: #aaa;\n}\nhr {\n	border: 0;\n	border-top: 1px solid rgba(255, 255, 255, 0.03);\n	margin: 10px 0;\n}\n';

// raw-file:./copilotOverview.js
var copilotOverview_default2 = '(() => {\n    // Minimal client-side logic\n    function $(id) {\n        return document.getElementById(id);\n    }\n    window.addEventListener("message", (event) => {\n        const msg = event.data;\n        if (msg.command === "updateState") {\n            updateState(msg.data);\n        } else if (msg.command === "tokenUpdate") {\n            applyToken(msg.data);\n        }\n    });\n\n    function updateState(state) {\n        // Token\n        if (state.tokenUsage && state.tokenUsage.percentage != null) {\n            applyToken(state.tokenUsage);\n        } else {\n            $("token-model").textContent = "No requests yet";\n            setProgress(0);\n        }\n\n        // Inline/FIM/NES\n        $("inline-val").textContent = state.inlineEnabled ? "Included" : "Disabled";\n        $("fim-val").textContent = state.fimEnabled ? "Enabled" : "Disabled";\n        $("nes-val").textContent = state.nesEnabled ? "Enabled" : "Disabled";\n\n        // Providers\n        const list = $("providers-list");\n        list.innerHTML = "";\n        if (state.providers) {\n            for (const [k, v] of Object.entries(state.providers)) {\n                const div = document.createElement("div");\n                div.className = "provider-item";\n                div.innerHTML = `<div>${capitalize(k)}</div><div class="small">${v}</div>`;\n                list.appendChild(div);\n            }\n        }\n    }\n\n    function applyToken(data) {\n        const modelName = data.modelName || "Model";\n        const percent = Number.isFinite(data.percentage)\n            ? data.percentage\n            : 0;\n        const promptTokens =\n            typeof data.promptTokens === "number" ? data.promptTokens : 0;\n        const maxInputTokens =\n            typeof data.maxInputTokens === "number" ? data.maxInputTokens : 0;\n        const suffix = maxInputTokens\n            ? ` (${promptTokens}/${maxInputTokens})`\n            : promptTokens\n                ? ` (${promptTokens})`\n                : "";\n        $("token-model").textContent =\n            `${modelName} \u2014 ${percent.toFixed(1)}%${suffix}`;\n        setProgress(Math.max(0, Math.min(100, percent)));\n    }\n\n    function setProgress(pct) {\n        const bar = $("bar");\n        bar.style.width = `${pct}%`;\n    }\n\n    function capitalize(s) {\n        return s.charAt(0).toUpperCase() + s.slice(1);\n    }\n\n    // Buttons\n    window.managePaid = () => {\n        vscode.postMessage({ command: "managePaidRequests" });\n    };\n    window.refresh = () => {\n        vscode.postMessage({ command: "refresh" });\n    };\n\n    // Post init ready\n    const vscode = acquireVsCodeApi\n        ? acquireVsCodeApi()\n        : { postMessage: () => { } };\n    // Request initial state\n    setTimeout(() => {\n        vscode.postMessage({ command: "ready" });\n    }, 50);\n})();\n';

// src/ui/copilotOverview.ts
var CopilotOverview = class _CopilotOverview {
  static currentPanel;
  static context;
  static async show(context) {
    _CopilotOverview.context = context;
    if (_CopilotOverview.currentPanel) {
      _CopilotOverview.currentPanel.reveal(vscode55.ViewColumn.Active);
      return;
    }
    const panel = vscode55.window.createWebviewPanel(
      "chpCopilotOverview",
      "Copilot ++ Overview",
      vscode55.ViewColumn.Active,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [
          vscode55.Uri.joinPath(context.extensionUri, "src", "ui")
        ]
      }
    );
    _CopilotOverview.currentPanel = panel;
    panel.webview.html = _CopilotOverview.generateHTML(panel.webview);
    const disp = panel.webview.onDidReceiveMessage(async (message) => {
      switch (message.command) {
        case "ready":
          await _CopilotOverview.sendStateUpdate(panel.webview);
          break;
        case "managePaidRequests":
          await vscode55.commands.executeCommand(
            "workbench.action.openSettings",
            "chp"
          );
          break;
        case "refresh":
          await _CopilotOverview.sendStateUpdate(panel.webview);
          break;
      }
    });
    panel.onDidDispose(() => {
      disp.dispose();
      _CopilotOverview.currentPanel = void 0;
      _CopilotOverview.detachTokenListener();
    });
    _CopilotOverview.attachTokenListener(panel.webview);
    await _CopilotOverview.sendStateUpdate(panel.webview);
  }
  static generateHTML(webview) {
    const csp = webview.cspSource;
    return `<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline' ${csp}; script-src 'unsafe-inline' ${csp};" /><style>${copilotOverview_default}</style></head><body><div class="container"><div class="header"><h2>Copilot Usage</h2><button class="button" onclick="refresh()">Refresh</button></div><div class="section"><div class="label-row"><div class="small">Inline Suggestions</div><div id="inline-val">Included</div></div></div><div class="section"><div class="label-row"><div class="small">Chat messages</div><div id="token-model">No requests yet</div></div><div class="progress"><div id="bar" class="bar"></div></div></div><div class="section"><button class="button" onclick="managePaid()">Manage paid premium requests</button></div><hr/><div class="providers"><h3 style="margin:0;">Providers</h3><div id="providers-list"></div></div><div class="footer">Allowance resets TBD</div></div><script>${copilotOverview_default2}</script></body></html>`;
  }
  static async sendStateUpdate(webview) {
    try {
      const providers2 = [
        "deepseek",
        "deepinfra",
        "chutes",
        "opencode",
        "lightningai",
        "zenmux",
        "huggingface",
        "minimax",
        "zhipu",
        "antigravity",
        "codex",
        "compatible"
      ];
      const providerStatuses = {};
      await Promise.all(
        providers2.map(async (p) => {
          try {
            const has2 = await ApiKeyManager.hasValidApiKey(p);
            providerStatuses[p] = has2 ? "Configured" : "Not configured";
          } catch {
            providerStatuses[p] = "Unknown";
          }
        })
      );
      const inlineEnabled = vscode55.workspace.getConfiguration("editor").get("inlineSuggest.enabled", true);
      const fimEnabled = vscode55.workspace.getConfiguration("chp").get("fimCompletion.enabled", false);
      const nesEnabled = vscode55.workspace.getConfiguration("chp").get("nesCompletion.enabled", false);
      webview.postMessage({
        command: "updateState",
        data: {
          providers: providerStatuses,
          tokenUsage: TokenTelemetryTracker.getInstance().getLastUsageSummary(),
          inlineEnabled,
          fimEnabled,
          nesEnabled
        }
      });
    } catch (e) {
      console.error("sendStateUpdate failed", e);
    }
  }
  static tokenListener;
  static attachTokenListener(webview) {
    const tracker = TokenTelemetryTracker.getInstance();
    const handleEvent = () => {
      const summary = tracker.getLastUsageSummary();
      if (summary) {
        webview.postMessage({
          command: "tokenUpdate",
          data: summary
        });
      }
    };
    _CopilotOverview.tokenListener = tracker.onEvent((event) => {
      if (event.status === "success" && event.responseMetrics) {
        handleEvent();
      }
    });
    handleEvent();
  }
  static detachTokenListener() {
    if (_CopilotOverview.tokenListener) {
      _CopilotOverview.tokenListener.dispose();
      _CopilotOverview.tokenListener = void 0;
    }
  }
};
function registerCopilotOverviewCommand(context) {
  return vscode55.commands.registerCommand(
    "chp.copilot.openOverview",
    async () => {
      await CopilotOverview.show(context);
    }
  );
}

// src/ui/index.ts
init_modelEditor3();

// src/ui/settingsPage.ts
var vscode56 = __toESM(require("vscode"));
init_accountManager();

// raw-file:./settingsPage.css
var settingsPage_default = '/* GCMP Settings Page - Modern & Simple UI */\n\n:root {\n	--card-bg: var(--vscode-editor-background);\n	--card-border: var(--vscode-panel-border);\n	--card-hover: var(--vscode-list-hoverBackground);\n	--accent-color: var(--vscode-button-background);\n	--accent-hover: var(--vscode-button-hoverBackground);\n	--success-color: #4caf50;\n	--warning-color: #ff9800;\n	--danger-color: #f44336;\n}\n\n* {\n	box-sizing: border-box;\n}\n\nbody {\n	font-family: var(--vscode-font-family);\n	font-size: var(--vscode-font-size);\n	color: var(--vscode-foreground);\n	background-color: var(--vscode-editor-background);\n	padding: 0;\n	margin: 0;\n	line-height: 1.5;\n}\n\n.settings-container {\n	max-width: 800px;\n	margin: 0 auto;\n	padding: 24px;\n}\n\n/* Header */\n.settings-header {\n	margin-bottom: 32px;\n	padding-bottom: 16px;\n	border-bottom: 1px solid var(--card-border);\n}\n\n.settings-header h1 {\n	margin: 0 0 8px 0;\n	font-size: 1.8em;\n	font-weight: 600;\n	color: var(--vscode-foreground);\n	display: flex;\n	align-items: center;\n	gap: 12px;\n}\n\n.settings-header h1 .icon {\n	font-size: 1.2em;\n}\n\n.settings-header p {\n	margin: 0;\n	color: var(--vscode-descriptionForeground);\n	font-size: 1em;\n}\n\n/* Section */\n.settings-section {\n	margin-bottom: 28px;\n}\n\n.section-title {\n	font-size: 1.2em;\n	font-weight: 600;\n	margin: 0 0 16px 0;\n	color: var(--vscode-foreground);\n	display: flex;\n	align-items: center;\n	gap: 8px;\n}\n\n.section-title .badge {\n	font-size: 0.7em;\n	padding: 2px 8px;\n	border-radius: 12px;\n	background-color: var(--accent-color);\n	color: var(--vscode-button-foreground);\n	font-weight: 500;\n}\n\n/* Card Grid */\n.card-grid {\n	display: grid;\n	grid-template-columns: repeat(auto-fill, minmax(320px, 1fr));\n	gap: 16px;\n}\n\n/* Settings Card */\n.settings-card {\n	background-color: var(--card-bg);\n	border: 1px solid var(--card-border);\n	border-radius: 8px;\n	padding: 16px;\n	transition: all 0.2s ease;\n}\n\n.settings-card:hover {\n	border-color: var(--accent-color);\n	box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);\n}\n\n.card-header {\n	display: flex;\n	align-items: center;\n	justify-content: space-between;\n	margin-bottom: 12px;\n}\n\n.card-title {\n	display: flex;\n	align-items: center;\n	gap: 10px;\n}\n\n.card-title .provider-icon {\n	width: 32px;\n	height: 32px;\n	border-radius: 6px;\n	display: flex;\n	align-items: center;\n	justify-content: center;\n	font-size: 1.2em;\n	background: linear-gradient(135deg, var(--accent-color), var(--accent-hover));\n	color: var(--vscode-button-foreground);\n}\n\n.card-title h3 {\n	margin: 0;\n	font-size: 1.1em;\n	font-weight: 600;\n}\n\n.card-description {\n	color: var(--vscode-descriptionForeground);\n	font-size: 0.95em;\n	margin-bottom: 16px;\n	line-height: 1.5;\n}\n\n/* Toggle Switch */\n.toggle-container {\n	display: flex;\n	align-items: center;\n	justify-content: space-between;\n	padding: 12px 0;\n	border-top: 1px solid var(--card-border);\n}\n\n.toggle-label {\n	display: flex;\n	flex-direction: column;\n	gap: 2px;\n}\n\n.toggle-label .label-text {\n	font-weight: 500;\n	font-size: 0.95em;\n}\n\n.toggle-label .label-hint {\n	font-size: 0.85em;\n	color: var(--vscode-descriptionForeground);\n}\n\n/* Modern Toggle Switch */\n.toggle-switch {\n	position: relative;\n	width: 48px;\n	height: 26px;\n	flex-shrink: 0;\n}\n\n.toggle-switch input {\n	opacity: 0;\n	width: 0;\n	height: 0;\n}\n\n.toggle-slider {\n	position: absolute;\n	cursor: pointer;\n	top: 0;\n	left: 0;\n	right: 0;\n	bottom: 0;\n	background-color: var(--vscode-input-background);\n	border: 1px solid var(--vscode-input-border);\n	transition: all 0.3s ease;\n	border-radius: 26px;\n}\n\n.toggle-slider:before {\n	position: absolute;\n	content: "";\n	height: 20px;\n	width: 20px;\n	left: 2px;\n	bottom: 2px;\n	background-color: var(--vscode-foreground);\n	transition: all 0.3s ease;\n	border-radius: 50%;\n}\n\n.toggle-switch input:checked + .toggle-slider {\n	background-color: var(--success-color);\n	border-color: var(--success-color);\n}\n\n.toggle-switch input:checked + .toggle-slider:before {\n	transform: translateX(22px);\n	background-color: white;\n}\n\n.toggle-switch input:focus + .toggle-slider {\n	box-shadow: 0 0 0 2px var(--vscode-focusBorder);\n}\n\n.toggle-switch input:disabled + .toggle-slider {\n	opacity: 0.5;\n	cursor: not-allowed;\n}\n\n/* Status Indicator */\n.status-indicator {\n	display: inline-flex;\n	align-items: center;\n	gap: 6px;\n	padding: 4px 10px;\n	border-radius: 12px;\n	font-size: 0.85em;\n	font-weight: 500;\n}\n\n.status-indicator.enabled {\n	background-color: rgba(76, 175, 80, 0.15);\n	color: var(--success-color);\n}\n\n.status-indicator.disabled {\n	background-color: rgba(158, 158, 158, 0.15);\n	color: var(--vscode-descriptionForeground);\n}\n\n.status-dot {\n	width: 8px;\n	height: 8px;\n	border-radius: 50%;\n	background-color: currentColor;\n}\n\n/* Account Count Badge */\n.account-badge {\n	display: inline-flex;\n	align-items: center;\n	gap: 4px;\n	padding: 2px 8px;\n	border-radius: 10px;\n	font-size: 0.8em;\n	background-color: var(--vscode-badge-background);\n	color: var(--vscode-badge-foreground);\n}\n\n.account-badge.success {\n	background-color: rgba(76, 175, 80, 0.15);\n	color: var(--success-color);\n}\n\n.account-badge.warning {\n	background-color: rgba(255, 152, 0, 0.15);\n	color: var(--warning-color);\n}\n\n.account-info {\n	display: flex;\n	gap: 8px;\n	flex-wrap: wrap;\n	margin-bottom: 12px;\n}\n\n/* Strategy Selector */\n.strategy-container {\n	margin-top: 16px;\n	padding-top: 16px;\n	border-top: 1px solid var(--card-border);\n}\n\n.strategy-label {\n	margin-bottom: 12px;\n}\n\n.strategy-label .label-text {\n	font-weight: 500;\n	font-size: 0.95em;\n}\n\n.strategy-options {\n	display: flex;\n	flex-direction: column;\n	gap: 8px;\n}\n\n.strategy-option {\n	display: flex;\n	align-items: flex-start;\n	gap: 10px;\n	padding: 10px 12px;\n	border: 1px solid var(--card-border);\n	border-radius: 6px;\n	cursor: pointer;\n	transition: all 0.2s ease;\n	background-color: transparent;\n}\n\n.strategy-option:hover {\n	border-color: var(--accent-color);\n	background-color: var(--card-hover);\n}\n\n.strategy-option.selected {\n	border-color: var(--success-color);\n	background-color: rgba(76, 175, 80, 0.08);\n}\n\n.strategy-option input[type="radio"] {\n	margin-top: 2px;\n	accent-color: var(--success-color);\n}\n\n.strategy-content {\n	display: flex;\n	flex-direction: column;\n	gap: 2px;\n}\n\n.strategy-name {\n	font-weight: 500;\n	font-size: 0.95em;\n}\n\n.strategy-desc {\n	font-size: 0.85em;\n	color: var(--vscode-descriptionForeground);\n}\n\n/* Action Buttons Container */\n.action-buttons {\n	display: flex;\n	gap: 12px;\n	flex-wrap: wrap;\n}\n\n/* Info Box */\n.info-box {\n	display: flex;\n	align-items: flex-start;\n	gap: 12px;\n	padding: 14px;\n	background-color: var(--vscode-textBlockQuote-background);\n	border-left: 3px solid var(--accent-color);\n	border-radius: 0 6px 6px 0;\n	margin-top: 16px;\n}\n\n.info-box .info-icon {\n	font-size: 1.2em;\n	flex-shrink: 0;\n}\n\n.info-box .info-content {\n	flex: 1;\n}\n\n.info-box .info-content p {\n	margin: 0;\n	font-size: 0.95em;\n	line-height: 1.5;\n}\n\n/* Empty State */\n.empty-state {\n	text-align: center;\n	padding: 40px 20px;\n	color: var(--vscode-descriptionForeground);\n}\n\n.empty-state .empty-icon {\n	font-size: 3em;\n	margin-bottom: 16px;\n	opacity: 0.5;\n}\n\n.empty-state h3 {\n	margin: 0 0 8px 0;\n	color: var(--vscode-foreground);\n}\n\n.empty-state p {\n	margin: 0;\n	font-size: 0.95em;\n}\n\n/* Action Button */\n.action-button {\n	display: inline-flex;\n	align-items: center;\n	gap: 6px;\n	padding: 8px 16px;\n	border: none;\n	border-radius: 6px;\n	font-size: 0.95em;\n	font-weight: 500;\n	cursor: pointer;\n	transition: all 0.2s ease;\n	background-color: var(--vscode-button-background);\n	color: var(--vscode-button-foreground);\n}\n\n.action-button:hover {\n	background-color: var(--vscode-button-hoverBackground);\n}\n\n.action-button.secondary {\n	background-color: var(--vscode-button-secondaryBackground);\n	color: var(--vscode-button-secondaryForeground);\n}\n\n.action-button.secondary:hover {\n	background-color: var(--vscode-button-secondaryHoverBackground);\n}\n\n/* Divider */\n.divider {\n	height: 1px;\n	background-color: var(--card-border);\n	margin: 24px 0;\n}\n\n/* Loading Spinner */\n.loading-spinner {\n	display: inline-block;\n	width: 16px;\n	height: 16px;\n	border: 2px solid var(--vscode-foreground);\n	border-radius: 50%;\n	border-top-color: transparent;\n	animation: spin 0.8s linear infinite;\n}\n\n@keyframes spin {\n	to {\n		transform: rotate(360deg);\n	}\n}\n\n/* Toast Notification */\n.toast {\n	position: fixed;\n	bottom: 24px;\n	right: 24px;\n	padding: 12px 20px;\n	background-color: var(--vscode-notifications-background);\n	border: 1px solid var(--vscode-notifications-border);\n	border-radius: 8px;\n	box-shadow: 0 4px 12px rgba(0, 0, 0, 0.25);\n	display: flex;\n	align-items: center;\n	gap: 10px;\n	z-index: 1000;\n	animation: slideIn 0.3s ease;\n}\n\n.toast.success {\n	border-left: 3px solid var(--success-color);\n}\n\n.toast.error {\n	border-left: 3px solid var(--danger-color);\n}\n\n@keyframes slideIn {\n	from {\n		opacity: 0;\n		transform: translateY(20px);\n	}\n	to {\n		opacity: 1;\n		transform: translateY(0);\n	}\n}\n\n/* Responsive */\n@media (max-width: 600px) {\n	.settings-container {\n		padding: 16px;\n	}\n\n	.card-grid {\n		grid-template-columns: 1fr;\n	}\n\n	.settings-header h1 {\n		font-size: 1.5em;\n	}\n}\n\n/* Scrollbar */\n::-webkit-scrollbar {\n	width: 8px;\n}\n\n::-webkit-scrollbar-track {\n	background: transparent;\n}\n\n::-webkit-scrollbar-thumb {\n	background-color: var(--vscode-scrollbarSlider-background);\n	border-radius: 4px;\n}\n\n::-webkit-scrollbar-thumb:hover {\n	background-color: var(--vscode-scrollbarSlider-hoverBackground);\n}\n';

// raw-file:./settingsPage.js
var settingsPage_default2 = '/* GCMP Settings Page - JavaScript */\n\n// VS Code API\nconst vscode = acquireVsCodeApi();\n\n// State management\nlet settingsState = {\n	providers: [],\n	loadBalanceSettings: {},\n	loadBalanceStrategies: {},\n	loading: true,\n};\n\n// Available load balance strategies\nconst LOAD_BALANCE_STRATEGIES = [\n	{\n		id: "round-robin",\n		name: "Round Robin",\n		description: "Distribute requests evenly across accounts",\n	},\n	{\n		id: "quota-aware",\n		name: "Quota Aware",\n		description: "Prioritize accounts with more remaining quota",\n	},\n	{\n		id: "failover",\n		name: "Failover Only",\n		description: "Use primary account, switch on errors",\n	},\n];\n\n/**\n * Initialize the settings page\n */\nfunction _initializeSettingsPage(initialData) {\n	settingsState = {\n		...settingsState,\n		...initialData,\n		loading: false,\n	};\n	renderPage();\n}\n\n/**\n * Render the entire page\n */\nfunction renderPage() {\n	const app = document.getElementById("app");\n	if (!app) return;\n\n	app.innerHTML = `\n        ${renderHeader()}\n        ${renderLoadBalanceSection()}\n        ${renderAdvancedSection()}\n        ${renderInfoSection()}\n    `;\n\n	attachEventListeners();\n}\n\n/**\n * Render header section\n */\nfunction renderHeader() {\n	return `\n        <div class="settings-header">\n            <h1>\n                <span class="icon"></span>\n                GCMP Settings\n            </h1>\n            <p>Configure load balancing and advanced settings for AI Chat Models</p>\n        </div>\n    `;\n}\n\n/**\n * Render load balance section\n */\nfunction renderLoadBalanceSection() {\n	const providers = settingsState.providers || [];\n\n	// Filter providers that have accounts\n	const providersWithAccounts = providers.filter((p) => p.accountCount > 0);\n\n	if (providersWithAccounts.length === 0) {\n		return `\n            <div class="settings-section">\n                <h2 class="section-title">\n                    \u2696\uFE0F Load Balance Settings\n                    <span class="badge">Multi-Account</span>\n                </h2>\n                <div class="empty-state">\n                    <div class="empty-icon">\u{1F4ED}</div>\n                    <h3>No Accounts Configured</h3>\n                    <p>Add accounts to providers to enable load balancing features</p>\n                    <button class="action-button" onclick="openAccountManager()">\n                        \u{1F464} Manage Accounts\n                    </button>\n                </div>\n            </div>\n        `;\n	}\n\n	return `\n        <div class="settings-section">\n            <h2 class="section-title">\n                \u2696\uFE0F Load Balance Settings\n                <span class="badge">Multi-Account</span>\n            </h2>\n            <div class="card-grid">\n                ${providersWithAccounts.map((provider) => renderProviderCard(provider)).join("")}\n            </div>\n        </div>\n    `;\n}\n\n/**\n * Render a provider card\n */\nfunction renderProviderCard(provider) {\n	const isEnabled = settingsState.loadBalanceSettings[provider.id] || false;\n	const currentStrategy =\n		settingsState.loadBalanceStrategies[provider.id] || "round-robin";\n	const accountCount = provider.accountCount || 0;\n	const statusClass = isEnabled ? "enabled" : "disabled";\n	const statusText = isEnabled ? "Enabled" : "Disabled";\n	const canEnable = accountCount >= 2;\n\n	return `\n        <div class="settings-card" data-provider="${provider.id}">\n            <div class="card-header">\n                <div class="card-title">\n                    <div class="provider-icon">${getProviderIcon(provider.id)}</div>\n                    <h3>${escapeHtml(provider.displayName)}</h3>\n                </div>\n                <span class="status-indicator ${statusClass}">\n                    <span class="status-dot"></span>\n                    ${statusText}\n                </span>\n            </div>\n            <div class="card-description">\n                ${getProviderDescription(provider.id)}\n            </div>\n            <div class="account-info">\n                <span class="account-badge">\n                    \u{1F464} ${accountCount} account${accountCount !== 1 ? "s" : ""}\n                </span>\n                ${accountCount >= 2 ? \'<span class="account-badge success">Ready for LB</span>\' : \'<span class="account-badge warning">Need 2+ accounts</span>\'}\n            </div>\n            <div class="toggle-container">\n                <div class="toggle-label">\n                    <span class="label-text">Enable Load Balancing</span>\n                    <span class="label-hint">${canEnable ? "Distribute requests across accounts" : "Requires 2+ accounts"}</span>\n                </div>\n                <label class="toggle-switch">\n                    <input type="checkbox" \n                           id="toggle-${provider.id}" \n                           ${isEnabled ? "checked" : ""} \n                           ${!canEnable ? "disabled" : ""}\n                           onchange="handleToggleChange(\'${provider.id}\', this.checked)">\n                    <span class="toggle-slider"></span>\n                </label>\n            </div>\n            ${isEnabled && canEnable ? renderStrategySelector(provider.id, currentStrategy) : ""}\n        </div>\n    `;\n}\n\n/**\n * Render strategy selector\n */\nfunction renderStrategySelector(providerId, currentStrategy) {\n	return `\n        <div class="strategy-container">\n            <div class="strategy-label">\n                <span class="label-text">Load Balance Strategy</span>\n            </div>\n            <div class="strategy-options">\n                ${LOAD_BALANCE_STRATEGIES.map(\n									(strategy) => `\n                    <label class="strategy-option ${currentStrategy === strategy.id ? "selected" : ""}">\n                        <input type="radio" \n                               name="strategy-${providerId}" \n                               value="${strategy.id}"\n                               ${currentStrategy === strategy.id ? "checked" : ""}\n                               onchange="handleStrategyChange(\'${providerId}\', \'${strategy.id}\')">\n                        <div class="strategy-content">\n                            <span class="strategy-name">${strategy.name}</span>\n                            <span class="strategy-desc">${strategy.description}</span>\n                        </div>\n                    </label>\n                `,\n								).join("")}\n            </div>\n        </div>\n    `;\n}\n\n/**\n * Render advanced section\n */\nfunction renderAdvancedSection() {\n	return `\n        <div class="settings-section">\n            <h2 class="section-title">\n                Quick Actions\n            </h2>\n            <div class="action-buttons">\n                <button class="action-button" onclick="openAccountManager()">\n                    \u{1F464} Manage Accounts\n                </button>\n                <button class="action-button secondary" onclick="refreshSettings()">\n                    Refresh\n                </button>\n            </div>\n        </div>\n    `;\n}\n\n/**\n * Render info section\n */\nfunction renderInfoSection() {\n	return `\n        <div class="divider"></div>\n        <div class="info-box">\n            <span class="info-icon"></span>\n            <div class="info-content">\n                <p><strong>About Load Balancing:</strong></p>\n                <p>When enabled, requests will be distributed across multiple accounts to optimize quota usage and improve reliability. \n                If one account hits its quota limit, the system will automatically switch to another available account.</p>\n            </div>\n        </div>\n        <div class="info-box" style="margin-top: 12px;">\n            <span class="info-icon"></span>\n            <div class="info-content">\n                <p><strong>Load Balance Strategies:</strong></p>\n                <p>\u2022 <strong>Round Robin:</strong> Requests are distributed evenly across accounts<br>\n                \u2022 <strong>Quota Aware:</strong> Prioritizes accounts with more remaining quota<br>\n                \u2022 <strong>Failover Only:</strong> Uses primary account, switches only on errors</p>\n            </div>\n        </div>\n    `;\n}\n\n/**\n * Get provider icon\n */\nfunction getProviderIcon(providerId) {\n	const icons = {\n		antigravity: "",\n		codex: "\u{1F916}",\n		zhipu: "\u{1F9E0}",\n		moonshot: "\u{1F319}",\n		minimax: "",\n		deepseek: "",\n		compatible: "",\n	};\n	return icons[providerId] || "\u{1F916}";\n}\n\n/**\n * Get provider description\n */\nfunction getProviderDescription(providerId) {\n	const descriptions = {\n		antigravity:\n			"Google Cloud Code powered AI models with OAuth authentication",\n		codex: "OpenAI Codex models with OAuth authentication",\n		zhipu: "ZhipuAI GLM models with Coding Plan support",\n		moonshot: "MoonshotAI Kimi models for coding assistance",\n		minimax: "MiniMax models with Coding Plan features",\n		deepseek: "DeepSeek AI models for code generation",\n		compatible: "OpenAI/Anthropic compatible custom models",\n	};\n	return descriptions[providerId] || "AI model provider";\n}\n\n/**\n * Handle toggle change\n */\nfunction _handleToggleChange(providerId, enabled) {\n	// Update local state\n	settingsState.loadBalanceSettings[providerId] = enabled;\n\n	// Send message to extension\n	vscode.postMessage({\n		command: "setLoadBalance",\n		providerId: providerId,\n		enabled: enabled,\n	});\n\n	// Re-render to show/hide strategy selector\n	renderPage();\n	showToast(\n		enabled ? "Load balancing enabled" : "Load balancing disabled",\n		"success",\n	);\n}\n\n/**\n * Handle strategy change\n */\nfunction _handleStrategyChange(providerId, strategy) {\n	// Update local state\n	settingsState.loadBalanceStrategies[providerId] = strategy;\n\n	// Send message to extension\n	vscode.postMessage({\n		command: "setLoadBalanceStrategy",\n		providerId: providerId,\n		strategy: strategy,\n	});\n\n	// Update UI\n	renderPage();\n	showToast(`Strategy changed to ${strategy}`, "success");\n}\n\n/**\n * Open account manager\n */\nfunction _openAccountManager() {\n	vscode.postMessage({\n		command: "openAccountManager",\n	});\n}\n\n/**\n * Refresh settings\n */\nfunction _refreshSettings() {\n	vscode.postMessage({\n		command: "refresh",\n	});\n	showToast("Refreshing settings...", "success");\n}\n\n/**\n * Update card status indicator\n */\nfunction _updateCardStatus(providerId, enabled) {\n	const card = document.querySelector(`[data-provider="${providerId}"]`);\n	if (!card) return;\n\n	const statusIndicator = card.querySelector(".status-indicator");\n	if (statusIndicator) {\n		statusIndicator.className = `status-indicator ${enabled ? "enabled" : "disabled"}`;\n		statusIndicator.innerHTML = `\n            <span class="status-dot"></span>\n            ${enabled ? "Enabled" : "Disabled"}\n        `;\n	}\n}\n\n/**\n * Show toast notification\n */\nfunction showToast(message, type = "success") {\n	// Remove existing toast\n	const existingToast = document.querySelector(".toast");\n	if (existingToast) {\n		existingToast.remove();\n	}\n\n	const toast = document.createElement("div");\n	toast.className = `toast ${type}`;\n	toast.innerHTML = `\n        <span>${type === "success" ? "OK" : "NO"}</span>\n        <span>${escapeHtml(message)}</span>\n    `;\n	document.body.appendChild(toast);\n\n	// Auto remove after 3 seconds\n	setTimeout(() => {\n		toast.style.animation = "slideIn 0.3s ease reverse";\n		setTimeout(() => toast.remove(), 300);\n	}, 3000);\n}\n\n/**\n * Attach event listeners\n */\nfunction attachEventListeners() {\n	// Add any additional event listeners here\n}\n\n/**\n * Escape HTML to prevent XSS\n */\nfunction escapeHtml(text) {\n	if (!text) return "";\n	const map = {\n		"&": "&amp;",\n		"<": "&lt;",\n		">": "&gt;",\n		\'"\': "&quot;",\n		"\'": "&#039;",\n	};\n	return String(text).replace(/[&<>"\']/g, (char) => map[char]);\n}\n\n/**\n * Handle messages from extension\n */\nwindow.addEventListener("message", (event) => {\n	const message = event.data;\n	switch (message.command) {\n		case "updateState":\n			settingsState = {\n				...settingsState,\n				...message.data,\n			};\n			renderPage();\n			break;\n		case "showToast":\n			showToast(message.message, message.type);\n			break;\n	}\n});\n';

// src/ui/settingsPage.ts
var SettingsPage = class _SettingsPage {
  static currentPanel;
  static accountManager;
  // Store strategies in memory (can be extended to persist)
  static loadBalanceStrategies = {};
  /**
   * Hin th trang settings
   */
  static async show(context) {
    _SettingsPage.context = context;
    if (_SettingsPage.currentPanel) {
      _SettingsPage.currentPanel.reveal(vscode56.ViewColumn.One);
      return;
    }
    try {
      _SettingsPage.accountManager = AccountManager.getInstance();
    } catch {
      vscode56.window.showErrorMessage("Account Manager not initialized");
      return;
    }
    const panel = vscode56.window.createWebviewPanel(
      "chpSettings",
      "Copilot ++ Settings",
      vscode56.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [
          vscode56.Uri.joinPath(context.extensionUri, "src", "ui")
        ]
      }
    );
    _SettingsPage.currentPanel = panel;
    panel.webview.html = _SettingsPage.generateHTML(panel.webview);
    const messageDisposable = panel.webview.onDidReceiveMessage(
      async (message) => {
        switch (message.command) {
          case "setLoadBalance":
            await _SettingsPage.handleSetLoadBalance(
              message.providerId,
              message.enabled,
              panel.webview
            );
            break;
          case "setLoadBalanceStrategy":
            await _SettingsPage.handleSetLoadBalanceStrategy(
              message.providerId,
              message.strategy,
              panel.webview
            );
            break;
          case "openAccountManager":
            await vscode56.commands.executeCommand("chp.accounts.openManager");
            break;
          case "refresh":
            await _SettingsPage.sendStateUpdate(panel.webview);
            break;
        }
      }
    );
    panel.onDidDispose(() => {
      _SettingsPage.currentPanel = void 0;
      messageDisposable.dispose();
    });
    await _SettingsPage.sendStateUpdate(panel.webview);
  }
  /**
   * Generate HTML for the settings page
   */
  static generateHTML(webview) {
    const cspSource = webview.cspSource || "";
    return `<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Copilot ++ Settings</title>
        <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src 'unsafe-inline' ${cspSource}; script-src 'unsafe-inline' ${cspSource};" />
        <style>
            ${settingsPage_default}
        </style>
    </head>
    <body>
        <div class="settings-container">
            <div id="app">
                <div class="settings-header">
                    <h1>
                        <span class="icon"></span>
                        Copilot ++ Settings
                    </h1>
                    <p>Loading settings...</p>
                </div>
                <div style="text-align: center; padding: 40px;">
                    <div class="loading-spinner"></div>
                </div>
            </div>
        </div>
        <script>
            ${settingsPage_default2}
        </script>
    </body>
</html>`;
  }
  /**
   * Send state update to webview
   */
  static async sendStateUpdate(webview) {
    const providers2 = _SettingsPage.getProvidersInfo();
    const loadBalanceSettings = {};
    const loadBalanceStrategies = {};
    for (const provider of providers2) {
      loadBalanceSettings[provider.id] = _SettingsPage.accountManager.getLoadBalanceEnabled(provider.id);
      loadBalanceStrategies[provider.id] = _SettingsPage.loadBalanceStrategies[provider.id] || "round-robin";
    }
    webview.postMessage({
      command: "updateState",
      data: {
        providers: providers2,
        loadBalanceSettings,
        loadBalanceStrategies
      }
    });
    const _initScript = `
            if (typeof initializeSettingsPage === 'function') {
                initializeSettingsPage({
                    providers: ${JSON.stringify(providers2)},
                    loadBalanceSettings: ${JSON.stringify(loadBalanceSettings)},
                    loadBalanceStrategies: ${JSON.stringify(loadBalanceStrategies)}
                });
            }
        `;
    setTimeout(() => {
      webview.postMessage({
        command: "updateState",
        data: {
          providers: providers2,
          loadBalanceSettings,
          loadBalanceStrategies
        }
      });
    }, 100);
  }
  /**
   * Get providers info for display
   */
  static getProvidersInfo() {
    const providerConfigs = [
      { id: "antigravity", displayName: "Antigravity (Google Cloud Code)" },
      { id: "codex", displayName: "Codex (OpenAI Codex)" },
      { id: "zhipu", displayName: "ZhipuAI (GLM)" },
      { id: "moonshot", displayName: "MoonshotAI (Kimi)" },
      { id: "minimax", displayName: "MiniMax" },
      { id: "deepseek", displayName: "DeepSeek" },
      { id: "deepinfra", displayName: "DeepInfra" },
      { id: "compatible", displayName: "OpenAI/Anthropic Compatible" }
    ];
    return providerConfigs.map((config2) => {
      const accounts = _SettingsPage.accountManager.getAccountsByProvider(
        config2.id
      );
      return {
        id: config2.id,
        displayName: config2.displayName,
        accountCount: accounts.length,
        supportsLoadBalance: AccountManager.supportsMultiAccount(config2.id)
      };
    });
  }
  /**
   * Handle set load balance request
   */
  static async handleSetLoadBalance(providerId, enabled, webview) {
    try {
      await _SettingsPage.accountManager.setLoadBalanceEnabled(
        providerId,
        enabled
      );
      webview.postMessage({
        command: "showToast",
        message: `Load balancing ${enabled ? "enabled" : "disabled"} for ${providerId}`,
        type: "success"
      });
    } catch (error2) {
      webview.postMessage({
        command: "showToast",
        message: `Failed to update load balance setting: ${error2}`,
        type: "error"
      });
    }
  }
  /**
   * Handle set load balance strategy request
   */
  static async handleSetLoadBalanceStrategy(providerId, strategy, webview) {
    try {
      _SettingsPage.loadBalanceStrategies[providerId] = strategy;
      webview.postMessage({
        command: "showToast",
        message: `Strategy changed to ${strategy} for ${providerId}`,
        type: "success"
      });
    } catch (error2) {
      webview.postMessage({
        command: "showToast",
        message: `Failed to update strategy: ${error2}`,
        type: "error"
      });
    }
  }
  /**
   * Dispose the current panel
   */
  static dispose() {
    if (_SettingsPage.currentPanel) {
      _SettingsPage.currentPanel.dispose();
      _SettingsPage.currentPanel = void 0;
    }
  }
};
function registerSettingsPageCommand(context) {
  return vscode56.commands.registerCommand("chp.openSettings", async () => {
    await SettingsPage.show(context);
  });
}

// src/extension.ts
init_compatibleModelManager();
var registeredProviders = {};
var registeredDisposables = [];
var inlineCompletionProvider;
async function activateProviders(context) {
  const startTime = Date.now();
  const configProvider = ConfigManager.getConfigProvider();
  if (!configProvider) {
    Logger.warn(
      "Provider configuration not found, skipping provider registration"
    );
    return;
  }
  TokenCounter.setExtensionPath(context.extensionPath);
  const providerEntries = Object.entries(configProvider);
  Logger.info(
    `\u23F1\uFE0F Starting parallel registration of ${providerEntries.length} providers...`
  );
  const registrationPromises = providerEntries.map(
    async ([providerKey, providerConfig]) => {
      try {
        Logger.trace(
          `Registering provider: ${providerConfig.displayName} (${providerKey})`
        );
        const providerStartTime = Date.now();
        let provider;
        let disposables;
        if (providerKey === "zhipu") {
          const result = ZhipuProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        } else if (providerKey === "minimax") {
          const result = MiniMaxProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        } else if (providerKey === "chutes") {
          const result = ChutesProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        } else if (providerKey === "zenmux") {
          const result = ZenmuxProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        } else if (providerKey === "lightningai") {
          const result = LightningAIProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        } else if (providerKey === "opencode") {
          const result = OpenCodeProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        } else if (providerKey === "qwencli") {
          const result = QwenCliProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        } else if (providerKey === "geminicli") {
          const result = GeminiCliProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        } else if (providerKey === "huggingface") {
          const result = HuggingfaceProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        } else if (providerKey === "deepinfra") {
          const result = DeepInfraProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        } else if (providerKey === "mistral") {
          const result = MistralProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        } else if (providerKey === "ollama") {
          const result = OllamaProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        } else {
          const result = GenericModelProvider.createAndActivate(
            context,
            providerKey,
            providerConfig
          );
          provider = result.provider;
          disposables = result.disposables;
        }
        const providerTime = Date.now() - providerStartTime;
        Logger.info(
          `${providerConfig.displayName} provider registered successfully (time: ${providerTime}ms)`
        );
        return { providerKey, provider, disposables };
      } catch (error2) {
        Logger.error(`Failed to register provider ${providerKey}:`, error2);
        return null;
      }
    }
  );
  const results = await Promise.all(registrationPromises);
  for (const result of results) {
    if (result) {
      registeredProviders[result.providerKey] = result.provider;
      registeredDisposables.push(...result.disposables);
    }
  }
  const totalTime = Date.now() - startTime;
  const successCount = results.filter((r) => r !== null).length;
  Logger.info(
    `\u23F1\uFE0F Provider registration completed: ${successCount}/${providerEntries.length} successful (total time: ${totalTime}ms)`
  );
}
async function activateCompatibleProvider(context) {
  try {
    Logger.trace("Registering compatible provider...");
    const providerStartTime = Date.now();
    const result = CompatibleProvider.createAndActivate(context);
    const provider = result.provider;
    const disposables = result.disposables;
    registeredProviders.compatible = provider;
    registeredDisposables.push(...disposables);
    const providerTime = Date.now() - providerStartTime;
    Logger.info(
      `Compatible Provider registered successfully (time: ${providerTime}ms)`
    );
  } catch (error2) {
    Logger.error("Failed to register compatible provider:", error2);
  }
  try {
    const copilotOverviewCmd = registerCopilotOverviewCommand(context);
    registeredDisposables.push(copilotOverviewCmd);
  } catch (e) {
    Logger.warn("Failed to register Copilot Overview command", e);
  }
}
async function activateInlineCompletionProvider(context) {
  try {
    Logger.trace("Registering inline completion provider (Shim mode)...");
    const providerStartTime = Date.now();
    const result = InlineCompletionShim.createAndActivate(context);
    inlineCompletionProvider = result.provider;
    registeredDisposables.push(...result.disposables);
    const providerTime = Date.now() - providerStartTime;
    Logger.info(
      `Inline completion provider registered successfully - Shim mode (time: ${providerTime}ms)`
    );
  } catch (error2) {
    Logger.error("Failed to register inline completion provider:", error2);
  }
}
async function activate(context) {
  globalThis.__chp_singletons = {
    CompletionLogger,
    ApiKeyManager,
    ConfigManager
  };
  const activationStartTime = Date.now();
  try {
    Logger.initialize("Copilot ++");
    StatusLogger.initialize("GitHub Copilot Models Provider Status");
    CompletionLogger.initialize("Copilot ++Inline Completion");
    const isDevelopment = context.extensionMode === vscode57.ExtensionMode.Development;
    Logger.info(
      `Copilot ++Extension Mode: ${isDevelopment ? "Development" : "Production"}`
    );
    if (isDevelopment) {
      Logger.checkAndPromptLogLevel();
    }
    Logger.info("\u23F1\uFE0F Starting Copilot ++extension activation...");
    let stepStartTime = Date.now();
    ApiKeyManager.initialize(context);
    Logger.trace(
      `\u23F1\uFE0F API key manager initialization complete (time: ${Date.now() - stepStartTime}ms)`
    );
    stepStartTime = Date.now();
    AccountManager.initialize(context);
    AccountQuotaCache.initialize(context);
    const accountDisposables = registerAccountCommands(context);
    context.subscriptions.push(...accountDisposables);
    const accountSyncAdapter = AccountSyncAdapter.initialize();
    context.subscriptions.push({ dispose: () => accountSyncAdapter.dispose() });
    accountSyncAdapter.syncAllAccounts().catch((err) => Logger.warn("Account sync failed:", err));
    const accountManager = AccountManager.getInstance();
    const updateAntigravityConfig = async () => {
      const activeAccount = accountManager.getActiveAccount(
        "antigravity" /* Antigravity */
      );
      if (!activeAccount) {
        return;
      }
      const credentials = await accountManager.getCredentials(activeAccount.id);
      if (!credentials) {
        return;
      }
      const token = credentials.accessToken ?? credentials.apiKey;
      if (token) {
        const config2 = vscode57.workspace.getConfiguration(
          "antigravityQuotaWatcher"
        );
        if (config2.get("apiKey") !== token) {
          await config2.update(
            "apiKey",
            token,
            vscode57.ConfigurationTarget.Global
          );
        }
      }
    };
    updateAntigravityConfig();
    context.subscriptions.push(
      accountManager.onAccountChange(async (event) => {
        if (event.provider === "antigravity" /* Antigravity */ && (event.type === "switched" || event.type === "updated" || event.type === "added")) {
          await updateAntigravityConfig();
        }
      })
    );
    Logger.trace(
      `\u23F1\uFE0F Multi-account manager initialization complete (time: ${Date.now() - stepStartTime}ms)`
    );
    stepStartTime = Date.now();
    const settingsPageDisposable = registerSettingsPageCommand(context);
    context.subscriptions.push(settingsPageDisposable);
    Logger.trace(
      `\u23F1\uFE0F Settings page command registered (time: ${Date.now() - stepStartTime}ms)`
    );
    stepStartTime = Date.now();
    const configDisposable = ConfigManager.initialize();
    context.subscriptions.push(configDisposable);
    Logger.trace(
      `\u23F1\uFE0F Configuration manager initialized (time: ${Date.now() - stepStartTime}ms)`
    );
    stepStartTime = Date.now();
    JsonSchemaProvider.initialize();
    context.subscriptions.push({ dispose: () => JsonSchemaProvider.dispose() });
    Logger.trace(
      `\u23F1\uFE0F JSON Schema provider initialized (time: ${Date.now() - stepStartTime}ms)`
    );
    stepStartTime = Date.now();
    CompatibleModelManager.initialize();
    Logger.trace(
      `\u23F1\uFE0F Compatible model manager initialized (time: ${Date.now() - stepStartTime}ms)`
    );
    stepStartTime = Date.now();
    await activateProviders(context);
    Logger.trace(
      `\u23F1\uFE0F Model provider registration complete (time: ${Date.now() - stepStartTime}ms)`
    );
    stepStartTime = Date.now();
    await activateCompatibleProvider(context);
    Logger.trace(
      `\u23F1\uFE0F Compatible provider registration complete (time: ${Date.now() - stepStartTime}ms)`
    );
    stepStartTime = Date.now();
    registerAllTools(context);
    Logger.trace(`\u23F1\uFE0F Tools registered (time: ${Date.now() - stepStartTime}ms)`);
    stepStartTime = Date.now();
    const antigravityResult = AntigravityProvider.createAndActivate(context);
    registeredProviders["antigravity" /* Antigravity */] = antigravityResult.provider;
    registeredDisposables.push(...antigravityResult.disposables);
    Logger.trace(
      `\u23F1\uFE0F Antigravity Provider registered (time: ${Date.now() - stepStartTime}ms)`
    );
    stepStartTime = Date.now();
    await activateInlineCompletionProvider(context);
    Logger.trace(
      `\u23F1\uFE0F NES inline completion provider registered (time: ${Date.now() - stepStartTime}ms)`
    );
    stepStartTime = Date.now();
    const copilotAttachSelectionCmd = vscode57.commands.registerCommand(
      "chp.copilot.attachSelection",
      async () => {
        try {
          const editor = vscode57.window.activeTextEditor;
          if (!editor) {
            vscode57.window.showWarningMessage("No active editor found.");
            return;
          }
          const selection = editor.selection;
          const document = editor.document;
          const fileName = document.fileName.split("/").pop() || document.fileName;
          let lineRange;
          if (selection.start.line === selection.end.line) {
            lineRange = `${selection.start.line + 1}`;
          } else {
            lineRange = `${selection.start.line + 1}-${selection.end.line + 1}`;
          }
          const referenceText = `@${fileName}:${lineRange} `;
          await vscode57.commands.executeCommand(
            "workbench.panel.chat.view.copilot.focus"
          );
          await vscode57.commands.executeCommand(
            "workbench.action.chat.insertIntoInput",
            referenceText
          );
        } catch (error2) {
          Logger.warn("Unable to execute Copilot attach selection:", error2);
          vscode57.window.showWarningMessage(
            "Failed to insert reference to Copilot Chat. Make sure GitHub Copilot Chat is installed."
          );
        }
      }
    );
    context.subscriptions.push(copilotAttachSelectionCmd);
    const copilotInsertHandleCmd = vscode57.commands.registerCommand(
      "chp.copilot.insertHandle",
      async () => {
        try {
          const editor = vscode57.window.activeTextEditor;
          if (!editor) {
            vscode57.window.showWarningMessage("No active editor found.");
            return;
          }
          const selection = editor.selection;
          const document = editor.document;
          const fileName = document.fileName.split("/").pop() || document.fileName;
          let lineRange;
          if (selection.isEmpty) {
            lineRange = `L${selection.start.line + 1}`;
          } else if (selection.start.line === selection.end.line) {
            lineRange = `L${selection.start.line + 1}`;
          } else {
            lineRange = `L${selection.start.line + 1}-L${selection.end.line + 1}`;
          }
          const handleText = `#file:${fileName}:${lineRange} `;
          await vscode57.commands.executeCommand(
            "workbench.panel.chat.view.copilot.focus"
          );
          await vscode57.commands.executeCommand("type", { text: handleText });
          Logger.trace(`Inserted handle reference: ${handleText}`);
        } catch (error2) {
          Logger.warn("Unable to insert handle reference:", error2);
          vscode57.window.showWarningMessage(
            "Failed to insert handle reference to Copilot Chat. Make sure GitHub Copilot Chat is installed."
          );
        }
      }
    );
    context.subscriptions.push(copilotInsertHandleCmd);
    const copilotInsertHandleFullPathCmd = vscode57.commands.registerCommand(
      "chp.copilot.insertHandleFullPath",
      async () => {
        try {
          const editor = vscode57.window.activeTextEditor;
          if (!editor) {
            vscode57.window.showWarningMessage("No active editor found.");
            return;
          }
          const selection = editor.selection;
          const document = editor.document;
          const workspaceFolder = vscode57.workspace.getWorkspaceFolder(
            document.uri
          );
          let relativePath;
          if (workspaceFolder) {
            relativePath = vscode57.workspace.asRelativePath(document.uri, false);
          } else {
            relativePath = document.fileName.split("/").pop() || document.fileName;
          }
          let lineRange;
          if (selection.isEmpty) {
            lineRange = `L${selection.start.line + 1}`;
          } else if (selection.start.line === selection.end.line) {
            lineRange = `L${selection.start.line + 1}`;
          } else {
            lineRange = `L${selection.start.line + 1}-L${selection.end.line + 1}`;
          }
          const handleText = `#handle:${relativePath}:${lineRange} `;
          await vscode57.commands.executeCommand(
            "workbench.panel.chat.view.copilot.focus"
          );
          await vscode57.commands.executeCommand("type", { text: handleText });
        } catch (error2) {
          Logger.warn(
            "Unable to insert handle reference with full path:",
            error2
          );
          vscode57.window.showWarningMessage(
            "Failed to insert handle reference to Copilot Chat."
          );
        }
      }
    );
    context.subscriptions.push(copilotInsertHandleFullPathCmd);
    Logger.trace(
      `\u23F1\uFE0F Copilot helper commands registered (time: ${Date.now() - stepStartTime}ms)`
    );
    const totalActivationTime = Date.now() - activationStartTime;
    Logger.info(
      `Copilot ++extension activation completed (total time: ${totalActivationTime}ms)`
    );
  } catch (error2) {
    const errorMessage = `Copilot ++extension activation failed: ${error2 instanceof Error ? error2.message : "Unknown error"}`;
    Logger.error(errorMessage, error2 instanceof Error ? error2 : void 0);
    vscode57.window.showErrorMessage(
      "Copilot ++extension startup failed. Please check the output window for details."
    );
    throw error2;
  }
}
function deactivate() {
  try {
    for (const [providerKey, provider] of Object.entries(registeredProviders)) {
      try {
        if (typeof provider.dispose === "function") {
          provider.dispose();
          Logger.trace(`Provider ${providerKey} resources cleaned up`);
        }
      } catch (error2) {
        Logger.warn(
          `Error cleaning up provider ${providerKey} resources:`,
          error2
        );
      }
    }
    if (inlineCompletionProvider) {
      inlineCompletionProvider.dispose();
      Logger.trace("Inline completion provider cleaned up");
    }
    try {
      AccountManager.getInstance().dispose();
      Logger.trace("Multi-account manager cleaned up");
    } catch {
    }
    ConfigManager.dispose();
    StatusLogger.dispose();
    CompletionLogger.dispose();
    Logger.dispose();
  } catch (error2) {
    Logger.error("Error during Copilot ++extension deactivation:", error2);
  }
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
//# sourceMappingURL=extension.js.map
